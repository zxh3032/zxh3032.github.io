<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>MySQL实战总结 | 随便寻个地方'Blog</title><meta name="author" content="随便寻个地方"><meta name="copyright" content="随便寻个地方"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。 主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。 从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。 B+树有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。 学习MySQL的索引">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL实战总结">
<meta property="og:url" content="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="随便寻个地方&#39;Blog">
<meta property="og:description" content="本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。 主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。 从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。 B+树有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。 学习MySQL的索引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.png">
<meta property="article:published_time" content="2024-06-01T10:02:00.000Z">
<meta property="article:modified_time" content="2024-06-11T15:53:43.232Z">
<meta property="article:author" content="随便寻个地方">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL实战总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-11 23:53:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="随便寻个地方'Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="随便寻个地方'Blog"><span class="site-name">随便寻个地方'Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL实战总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-01T10:02:00.000Z" title="发表于 2024-06-01 18:02:00">2024-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-11T15:53:43.232Z" title="更新于 2024-06-11 23:53:43">2024-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL实战总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。</p>
<p>主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。</p>
<p>从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。</p>
<p>学习MySQL的索引，就避不开要了解 B+ 树，在 MySQL 里 InnoDB 存储引擎就是采用 B+ 树来组织数据的，这是我们在背八股文时一定要记住的东西。那么在 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？为什么要选择 B+ 树来组织数据呢？下面我们来深入学习一下。</p>
<h2 id="从数据页的角度看-B-树"><a href="#从数据页的角度看-B-树" class="headerlink" title="从数据页的角度看 B+ 树"></a>从数据页的角度看 B+ 树</h2><p>这次，我们<strong>从数据页的角度看 B+ 树</strong>，看看每个节点长啥样。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f7696506a3c1c94621fcbad10341f1a8.png" alt="图片"></p>
<h3 id="InnoDB-是如何进行存储数据的？"><a href="#InnoDB-是如何进行存储数据的？" class="headerlink" title="InnoDB 是如何进行存储数据的？"></a>InnoDB 是如何进行存储数据的？</h3><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同，我们最常用的就是 InnoDB 存储引擎。</p>
<p>记录时按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，InnoDB 的数据时按<strong>「数据页」</strong>为单位来读写的，也就是说，当需要读一条数据的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>InnoDB 数据页的默认大小是 16KB</strong>，数据页包括七个部分，结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p>
<p>这 7 个部分的作用如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p>
<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向的链表</strong>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/557d17e05ce90f18591c2305871af665.png" alt="图片"></p>
<p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p>
<hr>
<p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p>
<p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p>
<p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li>
</ol>
<p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p>
<p>如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p>
<p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ul>
<h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p>
<p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p>
<p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p>
<p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p>
<p>通过上图，我们看出 B+ 树的特点：</p>
<ul>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<p>可以得出，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p>
<h3 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h3><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p>
<ul>
<li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li>
<li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p>
<p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p>
<p>二级索引的 B+ 树如下图，数据部分为主键值：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p>
<p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p>
<hr>
<p>看了这么多关于 B+ 树和数据库索引的内容，我们对其也有了基本的了解，那就来再解决一个问题吧，为什么要用 B+ 树，而不是其他的数据结构，也顺便了解一下其他的树相关的知识。</p>
<h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的。</p>
<h3 id="怎样的索引的数据结构是好的？"><a href="#怎样的索引的数据结构是好的？" class="headerlink" title="怎样的索引的数据结构是好的？"></a>怎样的索引的数据结构是好的？</h3><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存在磁盘上的，因为这样及时设备断电了，数据也不会丢失。</p>
<p>这样就带来了一个新的问题，速度太慢，因为磁盘是一个慢的离谱的存储设备。磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p>
<p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p>
<p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p>
<p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p>
<p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<blockquote>
<p>索引的数据最好是按顺序排列的，这样才能使用<strong>「二分查找法」</strong>高效定位数据。</p>
</blockquote>
<h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p>
<p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p>
<p>那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？</p>
<p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/49cb4df3fb7d4accbc75f6970ff1d0ea.gif" alt="请添加图片描述"></p>
<p>这样这个数组就变成了一个二叉查找树。</p>
<p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p>
<p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p>
<p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p>
<p>那么既然已经解决了所有问题，是不是就可以直接用二叉查找树来组织索引了。</p>
<p>不行，因为二叉查找树有一个致命的问题，那就是当新插入的数据全都比已有数据大或者小，那这个二叉查找树就变成了一个链表了，也就失去了现有的优势。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/320c5c2653e74f9e9ebfcd8ca9681905.gif" alt="请添加图片描述"></p>
<h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p>
<p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树。</p>
<p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，由于也被面试官提到过类似的问题，后面会单独写一篇博客来记录。</p>
<p>现在，平衡二叉树退化成为链表的情况被解决了，但是随着数据的插入，树会变得越来越高，查询次数也就越来越多。</p>
<p>下面我们来看一下二叉树和三叉树在有相同节点个数的情况下高度的差别。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2d26d30c953cd47c6ab637ad0eba2f99.png" alt="图片"></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00fb73de7014a87958f1597345e9ef2f.png" alt="图片"></p>
<p><strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B 树"></a>B 树</h3><p>对于上一节中提到的问题，一个新的数据结构被提出——B 树，它不在限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p>
<p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，特点就是每个节点最多有 M-1个数据，超过这些要求的话，就会分裂节点。</p>
<p>这么看来，B 树好像又解决了所有已经出现的问题，还有新的吗，当然。毕竟我们的主角是 B+ 树。</p>
<p>正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？</p>
<p>在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p>
<p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p>
<h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>好了好了，没想到设计一个索引需要的数据结构能遇到这么多困难，现在我们的救世主——B+ 树他终于来了。</p>
<p>B+ 树就是对 B 树做了一个升级，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mysql-20240322142950.png" alt="用户1260737：B+树"></p>
<p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了。</p>
<p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p>
<p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p>
<hr>
<p>至此，所有出现的问题都得到了解决，当然也并不是在所有的数据库中都使用 B+ 树来存储索引。比如在 MongoDB 中存储索引的数据结构就是 B 树。详细原因还是在后面的博客中记录吧，挖个坑先……</p>
<h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>腾讯第二次面试时提的问题，我回答的不知道，后来美团面试也问了，我答了几种情况，当时就只是背下来了，也不知道为什么，面试官想要更深入地问，我就又不会了。</p>
<p>那在本文中就详细解释一下这个问题吧。</p>
<p>在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。</p>
<p>但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。</p>
<p>稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低（之前我甚至以为索引失效是索引直接被删除了，脑子坏了）。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9e6a9708a6dbbcc65906d1338d2ae70.png" alt=""></p>
<h2 id="索引长什么样？"><a href="#索引长什么样？" class="headerlink" title="索引长什么样？"></a>索引长什么样？</h2><p>我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。</p>
<p>索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。</p>
<p>MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构。在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p>
<p>MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。</p>
<p>虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：</p>
<ul>
<li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；</li>
<li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；</li>
</ul>
<p>举个栗子：</p>
<p>这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00730eac527c21a4034f0f9ba0218aba.png" alt="图片"></p>
<p>如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f287701eba9bf6f32a2d09b013bb451b.png" alt="图片"></p>
<p>如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（图中叶子节点之间是双向链表）。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ef726d7287b854ea4862f7442d8012ec.png" alt="图片"></p>
<p>InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p>
<p>如果将 name 字段设置为普通索引，那么这个二级索引长下图这样（图中叶子节点之间是双向链表）</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7dd91be9fe584d94a4d71572ae7214d0.png" alt="图片"></p>
<p>在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 字段为主键索引</span><br><span class="line">select * from t_user where id=1;</span><br></pre></td></tr></table></figure>
<p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：</p>
<ul>
<li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li>
<li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li>
</ul>
<p>上面这个过程叫做<strong>回表</strong>，如下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select * from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure>
<p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做<strong>覆盖索引</strong>。如下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select id from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="什么情况会导致索引失效？"><a href="#什么情况会导致索引失效？" class="headerlink" title="什么情况会导致索引失效？"></a>什么情况会导致索引失效？</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p>
<blockquote>
<p>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</p>
</blockquote>
<p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b161c1d88f978e42077f8c14e10972a7.png" alt="图片"></p>
<p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p>
<ul>
<li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li>
<li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li>
<li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li>
</ul>
<p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p>
<h3 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h3><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<blockquote>
<p>为什么对索引使用函数，就无法走索引了呢？</p>
</blockquote>
<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<h3 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h3><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<blockquote>
<p>为什么对索引进行表达式计算，就无法走索引了呢？</p>
</blockquote>
<p>原因跟对索引使用函数差不多。</p>
<p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p>
<h3 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h3><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p>
<p>MySQL 的数据类型转换规则是什么？是会将字符串转成数字处理，还是将数字转换成字符串处理。</p>
<p>《MySQL45讲》里有一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p>
<ul>
<li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li>
<li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li>
</ul>
<p>在 MySQL 中，执行的结果如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/25316fd06cadff4434f02391ef0b5c55.png" alt="图片"></p>
<p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p>
<p>所以，在索引字段为字符串类型，比较字段为数字类型时，MySQL会对索引使用函数实现隐式类型转换，从而导致索引失效。</p>
<h3 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>
<p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>
<p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a=1；</li>
<li>where a=1 and b=2 and c=3；</li>
<li>where a=1 and b=2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b=2；</li>
<li>where c=3；</li>
<li>where b=2 and c=3；</li>
</ul>
<blockquote>
<p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？</p>
<p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p>
<p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p>
<p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p>
<p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p>
<p>为什么联合索引不遵循最左匹配原则就会失效？</p>
</blockquote>
<p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>
<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p>
<h3 id="WHERE-字句中地-OR"><a href="#WHERE-字句中地-OR" class="headerlink" title="WHERE 字句中地 OR"></a>WHERE 字句中地 OR</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
<h2 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h2><ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<h1 id="百万-千万级数据库如何优化？"><a href="#百万-千万级数据库如何优化？" class="headerlink" title="百万/千万级数据库如何优化？"></a>百万/千万级数据库如何优化？</h1><p>百万级、千万级数据处理，个人认为核心关键在于数据存储方案设计，存储方案设计的是否合理，直接影响到数据CRUD操作。总体设计可以考虑一下几个方面进行设计考虑：</p>
<ul>
<li>数据存储结构设计</li>
<li>索引设计</li>
<li>数据主键设计</li>
<li>查询方案设计</li>
</ul>
<p>由于本人也没有这个实力去真正实操百万千万级别地数据库，所以更到还是纸上谈兵，图个乐就行了。</p>
<h2 id="百万级"><a href="#百万级" class="headerlink" title="百万级"></a>百万级</h2><h3 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><ul>
<li>表字段 not null，因为 null 值很难查询优化且占用额外的索引空间，推荐默认数字 0。</li>
<li>数据状态类型的字段，比如 status, type 等等，尽量不要定义负数，如 -1。因为这样可以加上 UNSIGNED，数值容量就会扩大一倍。</li>
<li>可以的话用 TINYINT、SMALLINT 等代替 INT，尽量不使用 BIGINT，因为占的空间更小。</li>
<li>字符串类型的字段会比数字类型占的空间更大，所以尽量用整型代替字符串，很多场景是可以通过编码逻辑来实现用整型代替的。</li>
<li>字符串类型长度不要随意设置，保证满足业务的前提下尽量小。</li>
<li>用整型来存 IP。</li>
<li>单表不要有太多字段，建议在20以内。</li>
<li>为能预见的字段提前预留，因为数据量越大，修改数据结构越耗时。</li>
</ul>
<h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul>
<li>索引，空间换时间的优化策略，基本上根据业务需求设计好索引，足以应付百万级的数据量，养成使用 explain 的习惯，关于 explain 也可以访问：explain 让你的 sql 写的更踏实了解更多。</li>
<li>一个常识：索引并不是越多越好，索引是会降低数据写入性能的。</li>
<li>索引字段长度尽量短，这样能够节省大量索引空间；</li>
<li>取消外键，可交由程序来约束，性能更好。</li>
<li>复合索引的匹配最左列规则，索引的顺序和查询条件保持一致，尽量去除没必要的单列索引。</li>
<li>值分布较少的字段（不重复的较少）不适合建索引，比如像性别这种只有两三个值的情况字段建立索引意义不大。</li>
<li>需要排序的字段建议加上索引，因为索引是会排序的，能提高查询性能。</li>
<li>字符串字段使用前缀索引，不使用全字段索引，可大幅减小索引空间。</li>
</ul>
<h3 id="查询语句优化"><a href="#查询语句优化" class="headerlink" title="查询语句优化"></a>查询语句优化</h3><ul>
<li>尽量使用短查询替代复杂的内联查询。</li>
<li>查询不使用 select *，尽量查询带索引的字段，避免回表。</li>
<li>尽量使用 limit 对查询数量进行限制。</li>
<li>查询字段尽量落在索引上，尤其是复合索引，更需要注意最左前缀匹配。</li>
<li>拆分大的 delete / insert 操作，一方面会锁表，影响其他业务操作，还有一方面是 MySQL 对 sql 长度也是有限制的。</li>
<li>不建议使用 MySQL 的函数，计算等，可先由程序处理，从上面提的一些点会发现，能交由程序处理的尽量不要把压力转至数据库上。因为多数的服务器性能瓶颈都在数据库上。</li>
<li>查询 count，性能：count(1) = count(*) &gt; count(主键) &gt; count(其他字段)。</li>
<li>查询操作符能用 between 则不用 in，能用 in 则不用 or。</li>
<li>避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符，因为这些查询无法使用索引。</li>
<li>sql 尽量简单，少用 join，不建议两个 join 以上。</li>
</ul>
<h2 id="千万级"><a href="#千万级" class="headerlink" title="千万级"></a>千万级</h2><h3 id="数据存储结构设计-1"><a href="#数据存储结构设计-1" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><p>到了这个阶段的数据量，数据本身已经有很大的价值了，数据除了满足常规业务需求外，还会有一些数据分析的需求。而这个时候数据可变动性不高，基本上不会考虑修改原有结构，一般会考虑从分区，分表，分库三方面做优化：<br><strong>分区</strong><br>分区是根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分，是一种水平划分。对应用来说是完全透明的，不影响应用的业务逻辑，即不用修改代码。因此能存更多的数据，查询，删除也支持按分区来操作，从而达到优化的目的。如果有考虑分区，可以提前做准备，避免下列一些限制：</p>
<ul>
<li>一个表最多只能有1024个分区（6之后支持8192个分区）。但你实际操作的时候，最好不要一次性打开超过100 个分区，因为打开分区也是有时间损耗的。</li>
<li>如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。</li>
<li>分区表中无法使用外键约束。</li>
<li>NULL值会使分区过滤无效，这样会被放入默认的分区里，请千万不要让分区字段出现NULL。</li>
<li>所有分区必须使用相同的存储引擎。</li>
</ul>
<p><strong>分表</strong><br>分表分水平分表和垂直分表。<br>水平分表即拆分成数据结构相同的各个小表，如拆分成 table1, table2…，从而缓解数据库读写压力。<br>垂直分表即将一些字段分出去形成一个新表，各个表数据结构不相同，可以优化高并发下锁表的情况。<br>可想而知，分表的话，程序的逻辑是需要做修改的，所以，一般是在项目初期时，预见到大数据量的情况，才会考虑分表。后期阶段不建议分表，成本很大。<br><strong>分库</strong><br>分库一般是主从模式，一个数据库服务器主节点复制到一个或多个从节点多个数据库，主库负责写操作，从库负责读操作，从而达到主从分离，高可用，数据备份等优化目的。<br>当然，主从模式也会有一些缺陷，主从同步延迟，binlog 文件太大导致的问题等等，这里不细讲（笔者也学不动了）。<br><strong>其他</strong><br>冷热表隔离。对于历史的数据，查询和使用的人数少的情况，可以移入另一个冷数据库里，只提供查询用，来缓解热表数据量大的情况。</p>
<h3 id="数据库表主键设计"><a href="#数据库表主键设计" class="headerlink" title="数据库表主键设计"></a><strong>数据库表主键设计</strong></h3><p>数据库主键设计，个人推荐带有时间属性的自增长数字ID。（分布式自增长ID生成算法）<br>雪花算法<br>百度分布式ID算法<br>美团分布式ID算法<br>为什么要使用这些算法呢，这个与MySQL数据存储结构有关</p>
<p><strong>从业务上来说</strong></p>
<p>   在设计数据库时不需要费尽心思去考虑设置哪个字段为主键。然后是这些字段只是理论上是唯一的，例如使用图书编号为主键，这个图书编号只是理论上来说是唯一的，但实践中可能会出现重复的情况。所以还是设置一个与业务无关的自增ID作为主键，然后增加一个图书编号的唯一性约束。</p>
<p><strong>从技术上来说</strong></p>
<ol>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。</li>
<li>对InnoDB来说主键索引既存储索引值，又在叶子节点中存储行的数据，也就是说数据文件本身就是按照b+树方式存放数据的。</li>
<li>如果没有定义主键，则会使用非空的UNIQUE键做主键 ; 如果没有非空的UNIQUE键，则系统生成一个6字节的rowid做主键;聚簇索引中，N行形成一个页（一页通常大小为16K)。如果碰到不规则数据插入时，为了保持B+树的平衡，会造成频繁的页分裂和页旋转，插入速度比较慢。所以聚簇索引的主键值应尽量是连续增长的值，而不是随机值(不要用随机字符串或UUID)。</li>
<li>故对于InnoDB的主键，尽量用整型，而且是递增的整型。这样在存储/查询上都是非常高效的。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又到了我最爱的总结环节了，就能想写什么就写什么了。本来这篇文章要写四大部份的，还有一个sql注入的问题，之前看的文章就讲了一点例子，我以为就只有那么一点呢，今天仔细一查才发现还有那么多没有看过，下次再写吧。</p>
<p>昨天为什么破防，因为还是没有找到实习，一直都没有公司跟我约面试，我也不知道是那个环节出现问题了，可能还是因为学的东西太少了吧，所以我决定不找实习了，沉淀三个月，把MongoDO、kafka、docker、k8s还有Linux这些东西学一下。</p>
<p>之前一直觉得边找边学挺好的，找着找着发现面试太少了，不能从面试里面学到什么东西，又要因为准备面试耽误时间。我还是得练练表达能力，老是紧张也不是个事啊。加油吧，祝我自己秋招顺利，也祝我的朋友们考研成功、秋招顺利。还有两个有实习的，那就祝他们实习顺利吧（呜呜呜……，留下了羡慕的泪水）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/index/index_interview.html">小林coding 图解MySQL 索引篇</a></p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/sidebar/sanfene/mysql.html">MySQL八股文</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/222183">数据库优化</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">随便寻个地方</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/">http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">随便寻个地方'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/" title="了解MongoDB——你想知道的都在这"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">了解MongoDB——你想知道的都在这</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/" title="解锁灵活与高效——Casbin"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">解锁灵活与高效——Casbin</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/" title="了解MongoDB——你想知道的都在这"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">了解MongoDB——你想知道的都在这</div></div></a></div><div><a href="/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/" title="Redis执行流程大揭秘：从命令到结果的奇幻之旅"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-04</div><div class="title">Redis执行流程大揭秘：从命令到结果的奇幻之旅</div></div></a></div><div><a href="/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/" title="Redis持久化：让你的数据不再“无疾而终”"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-04</div><div class="title">Redis持久化：让你的数据不再“无疾而终”</div></div></a></div><div><a href="/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/" title="Redis数据结构五兄弟：数据江湖的武林盟主"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-05</div><div class="title">Redis数据结构五兄弟：数据江湖的武林盟主</div></div></a></div><div><a href="/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/" title="Redis事务的深潜之旅：像个老司机一样操作数据！"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">Redis事务的深潜之旅：像个老司机一样操作数据！</div></div></a></div><div><a href="/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/" title="Redis的键值过期和内存淘汰机制：内存的游戏"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">Redis的键值过期和内存淘汰机制：内存的游戏</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">随便寻个地方</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B-B-%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">从数据页的角度看 B+ 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">InnoDB 是如何进行存储数据的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">B+ 树是如何进行查询的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">聚簇索引和二级索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-%E9%87%87%E7%94%A8-B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么 MySQL 采用 B+ 树作为索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E5%A5%BD%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">怎样的索引的数据结构是好的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.2.2.</span> <span class="toc-text">二分查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">自平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">B 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-2"><span class="toc-number">1.2.5.</span> <span class="toc-text">B+ 树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">2.</span> <span class="toc-text">索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">索引长什么样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">什么情况会导致索引失效？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B7%A6%E6%88%96%E8%80%85%E5%B7%A6%E5%8F%B3%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.1.</span> <span class="toc-text">对索引使用左或者左右模糊匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">对索引使用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.3.</span> <span class="toc-text">对索引进行表达式计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.4.</span> <span class="toc-text">对索引隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E9%9D%9E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.5.</span> <span class="toc-text">联合索引非最左匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WHERE-%E5%AD%97%E5%8F%A5%E4%B8%AD%E5%9C%B0-OR"><span class="toc-number">2.2.6.</span> <span class="toc-text">WHERE 字句中地 OR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E7%89%88"><span class="toc-number">2.3.</span> <span class="toc-text">精简版</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%99%BE%E4%B8%87-%E5%8D%83%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">百万&#x2F;千万级数据库如何优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7"><span class="toc-number">3.1.</span> <span class="toc-text">百万级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">数据存储结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">索引设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">查询语句优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%83%E4%B8%87%E7%BA%A7"><span class="toc-number">3.2.</span> <span class="toc-text">千万级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据存储结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">数据库表主键设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Tokenb%E5%92%8CJWT/" title="傻傻分不清之Cookie、Session、Tokenb和JWT">傻傻分不清之Cookie、Session、Tokenb和JWT</a><time datetime="2024-10-21T13:08:06.000Z" title="发表于 2024-10-21 21:08:06">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/21/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/" title="声明、类型、语句与控制与控制结构">声明、类型、语句与控制与控制结构</a><time datetime="2024-10-21T12:55:35.000Z" title="发表于 2024-10-21 20:55:35">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/" title="Go语言创世纪">Go语言创世纪</a><time datetime="2024-10-19T07:02:08.000Z" title="发表于 2024-10-19 15:02:08">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E3%80%8B/" title="《深入理解Go语言》">《深入理解Go语言》</a><time datetime="2024-10-19T06:34:30.000Z" title="发表于 2024-10-19 14:34:30">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/05/gRPC%E5%85%A5%E9%97%A8/" title="gRPC入门">gRPC入门</a><time datetime="2024-07-05T13:12:05.000Z" title="发表于 2024-07-05 21:12:05">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 随便寻个地方</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>