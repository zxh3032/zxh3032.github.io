<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>了解MongoDB——你想知道的都在这 | 随便寻个地方'Blog</title><meta name="author" content="随便寻个地方"><meta name="copyright" content="随便寻个地方"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。 本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。 什么是 NoSQL？在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQ">
<meta property="og:type" content="article">
<meta property="og:title" content="了解MongoDB——你想知道的都在这">
<meta property="og:url" content="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/index.html">
<meta property="og:site_name" content="随便寻个地方&#39;Blog">
<meta property="og:description" content="数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。 本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。 什么是 NoSQL？在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.png">
<meta property="article:published_time" content="2024-06-02T12:11:30.000Z">
<meta property="article:modified_time" content="2024-06-11T15:54:01.684Z">
<meta property="article:author" content="随便寻个地方">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '了解MongoDB——你想知道的都在这',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-11 23:54:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="随便寻个地方'Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="随便寻个地方'Blog"><span class="site-name">随便寻个地方'Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">了解MongoDB——你想知道的都在这</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-02T12:11:30.000Z" title="发表于 2024-06-02 20:11:30">2024-06-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-11T15:54:01.684Z" title="更新于 2024-06-11 23:54:01">2024-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MongoDB/">MongoDB</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="了解MongoDB——你想知道的都在这"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。</p>
<p>本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。</p>
<h1 id="什么是-NoSQL？"><a href="#什么是-NoSQL？" class="headerlink" title="什么是 NoSQL？"></a>什么是 NoSQL？</h1><p>在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQL 以外，还了解什么数据库。我回答，不知道。结束后，我机智的舍友问我为什么不回答 NoSQL，我以为这是不知道其他数据库的英文表达（离谱）。</p>
<p>NoSQL 也被称为 “not only SQL” 或 “non-SQL”，它是一种数据库设计方法，可以在关系数据库中的传统结构之外存储和查询数据。</p>
<p>虽然 NoSQL 仍然可以存储关系数据库管理系统 (RDBMS) 中的数据，但与 RDBMS 相比，数据存储方式有所不同。决定使用关系数据库还是非关系数据库在很大程度上取决于上下文，并且因用例而异。</p>
<p>NoSQL 数据库并非采用关系数据库的典型表结构，而是将数据存储在一个数据结构中，例如 JSON 文档。由于这种非关系数据库设计不需要使用架构，因此，它提供快速可扩展性以管理通常为非结构化的大型数据集。</p>
<p>NoSQL 也是一种分布式数据库类型，这意味着将信息复制并存储在不同的服务器上，这些服务器可能是远程服务器或本地服务器。这确保了数据的可用性和可靠性。如果一些数据脱机，数据库的其他部分可以继续运行。</p>
<p><strong>特点</strong></p>
<ol>
<li><strong>灵活的数据模型</strong>：NoSQL数据库支持多种数据模型，如键值对、文档、列族和图形模型，适应各种应用场景。</li>
<li><strong>高可扩展性</strong>：通过分布式架构实现水平扩展，可以轻松添加更多的服务器来处理增加的数据量和流量。</li>
<li><strong>高性能</strong>：NoSQL数据库设计优化了读写操作，能提供高性能的查询速度。</li>
<li><strong>可用性和可靠性</strong>：通常具备内置的故障转移和数据复制机制，保证数据的高可用性和可靠性。</li>
</ol>
<p><strong>类型</strong></p>
<ol>
<li><p>键值存储（Key-Value Store）</p>
<p>：数据以键值对的形式存储，适合简单查询和高速读写操作。</p>
<ul>
<li>示例：Redis, DynamoDB</li>
</ul>
</li>
<li><p>文档存储（Document Store）</p>
<p>：数据以文档的形式存储，每个文档可以有不同的结构，适合存储复杂的嵌套数据。</p>
<ul>
<li>示例：MongoDB, CouchDB</li>
</ul>
</li>
<li><p>列族存储（Column-Family Store）</p>
<p>：数据以列的形式存储，每一列可以独立查询，适合大规模数据分析。</p>
<ul>
<li>示例：Cassandra, HBase</li>
</ul>
</li>
<li><p>图形数据库（Graph Database）</p>
<p>：数据以节点和边的形式存储，适合处理复杂关系和网络图。</p>
<ul>
<li>示例：Neo4j, ArangoDB</li>
</ul>
</li>
</ol>
<h2 id="常见的-NoSQL"><a href="#常见的-NoSQL" class="headerlink" title="常见的 NoSQL"></a>常见的 NoSQL</h2><p>以下是几个常用的NoSQL数据库及其主要特点：</p>
<ol>
<li>MongoDB</li>
</ol>
<ul>
<li><strong>类型</strong>：文档存储（Document Store）</li>
<li><strong>特点</strong>：<ul>
<li>使用JSON格式（BSON）存储数据，文档具有灵活的结构。</li>
<li>强大的查询和索引功能，支持复杂的查询操作。</li>
<li>支持水平扩展，通过分片实现高可扩展性。</li>
<li>提供复制集功能，保证数据的高可用性和自动故障转移。</li>
</ul>
</li>
</ul>
<ol>
<li>Cassandra</li>
</ol>
<ul>
<li><strong>类型</strong>：列族存储（Column-Family Store）</li>
<li><strong>特点</strong>：<ul>
<li>采用分布式架构，无单点故障，提供高可用性和高容错性。</li>
<li>高写入和读取性能，适用于大规模数据处理。</li>
<li>支持多数据中心的复制，保证数据的高可用性和一致性。</li>
<li>灵活的Schema设计，适合时间序列数据和大数据分析。</li>
</ul>
</li>
</ul>
<ol>
<li>Redis</li>
</ol>
<ul>
<li><strong>类型</strong>：键值存储（Key-Value Store）</li>
<li><strong>特点</strong>：<ul>
<li>数据存储在内存中，提供极高的读写性能，适用于实时应用。</li>
<li>支持多种数据结构，如字符串、哈希、列表、集合和有序集合。</li>
<li>提供丰富的操作和事务功能，支持发布/订阅、Lua脚本等。</li>
<li>具有持久化机制，数据可以持久化到磁盘。</li>
</ul>
</li>
</ul>
<ol>
<li>Neo4j</li>
</ol>
<ul>
<li><strong>类型</strong>：图形数据库（Graph Database）</li>
<li><strong>特点</strong>：<ul>
<li>以节点和关系（边）的形式存储数据，适合处理复杂关系和网络图。</li>
<li>提供强大的图形查询语言Cypher，支持高效的图遍历和查询操作。</li>
<li>广泛应用于社交网络、推荐系统和网络分析等场景。</li>
<li>提供ACID事务保证，确保数据一致性和可靠性。</li>
</ul>
</li>
</ul>
<ol>
<li>CouchDB</li>
</ol>
<ul>
<li><strong>类型</strong>：文档存储（Document Store）</li>
<li><strong>特点</strong>：<ul>
<li>使用JSON格式存储数据，每个文档可以有不同的结构。</li>
<li>提供RESTful API接口，便于集成和访问数据。</li>
<li>支持多主复制，允许在不同节点之间同步数据。</li>
<li>具备内置的冲突解决机制，适用于分布式环境。</li>
</ul>
</li>
</ul>
<ol>
<li>HBase</li>
</ol>
<ul>
<li><strong>类型</strong>：列族存储（Column-Family Store）</li>
<li><strong>特点</strong>：<ul>
<li>基于Hadoop HDFS构建，适用于处理大规模结构化数据。</li>
<li>提供强一致性的读写操作，适合需要高可靠性的应用。</li>
<li>支持随机读写和实时查询，适合大数据分析和实时应用。</li>
<li>与Hadoop生态系统紧密集成，支持MapReduce等大数据处理框架。</li>
</ul>
</li>
</ul>
<p>这些NoSQL数据库在不同的应用场景中发挥着重要作用，根据具体需求选择合适的数据库可以显著提升系统的性能和可扩展性。</p>
<h1 id="MongoDB-出现的原因"><a href="#MongoDB-出现的原因" class="headerlink" title="MongoDB 出现的原因"></a>MongoDB 出现的原因</h1><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。而MongoDB可应对“三高”需求。“三高”需求：</p>
<p>（1）High performance - 对数据库高并发读写的需求。</p>
<p>（2）Huge Storage - 对海量数据的高效率存储和访问的需求。</p>
<p>（3）High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对“三高”需求。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从它的命名也可以看出来，设计者是有一定野心的。MongoDB 的原名一开始<strong>来自于 英文单词”Humongous”, 中文含义是指”庞大”</strong>，即命名者的意图是可以处理大规模的数据。</p>
<p>在使用 MongoDB 我会有两种感觉：</p>
<ul>
<li>第一层感受是”爽”，使用这个文档数据库的特点是几乎不受什么限制，一方面Json文档式的结构更容易理解，而无Schema约束也让DDL管理更加简单，一切都可以很快速的进行。</li>
<li>第二层感受是”酸爽”，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验”太过于友好”，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。</li>
</ul>
<p>所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的RDBMS数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的话，会遇到更多的坑。</p>
<p>尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-aedbdb7187c091f3b2e091baea945806_720w.webp" alt="img"></p>
<p>在全部的排名中，MongoDB 长期排在第5位(文档数据库排名第1位)，同时也是最受欢迎的 NoSQL 数据库。</p>
<p>MongoDB 数据库的一些特性：</p>
<ul>
<li>面向文档存储，基于JSON/BSON 可表示灵活的数据结构</li>
<li>动态 DDL能力，没有强Schema约束，支持快速迭代</li>
<li>高性能计算，提供基于内存的快速数据查询</li>
<li>容易扩展，利用数据分片可以支持海量数据存储</li>
<li>丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。</li>
<li>跨平台版本、支持多语言SDK..</li>
</ul>
<h1 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h1><p>数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。</p>
<blockquote>
<p>关于这点，也有人说，MongoDB 是 NoSQL中最像SQL的数据库..</p>
</blockquote>
<p>我们来看与MySQL的对比，通过对比来学习其基本模型。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428161048312-2056386348.png" alt="img"></p>
<ul>
<li>database 数据库，与SQL的数据库(database)概念相同，一个数据库包含多个集合(表)</li>
<li>collection 集合，相当于SQL中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是<strong>动态的</strong>，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema的校验。</li>
<li>document 文档，相当于SQL中的行(row)，一个文档由多个字段(列)组成，并采用<code>bson(json)</code>格式表示。</li>
<li>field 字段，相当于SQL中的列(column)，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。</li>
</ul>
<p>此外，MongoDB中字段的类型是<strong>固定的</strong>、<strong>区分大小写</strong>、并且文档中的字段也是<strong>有序的</strong>。</p>
<p>另外，SQL 还有一些其他的概念，对应关系如下：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a4ce8ff9c69d5402f70baa1b050ad0d_720w.webp" alt="img"></p>
<ul>
<li>_id 主键，MongoDB 默认使用一个 _id 字段来保证文档的<strong>唯一性</strong>。</li>
<li>reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。</li>
<li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。</li>
<li>index 索引，与SQL 的索引相同。</li>
<li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li>
<li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li>
<li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li>
</ul>
<h2 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a><code>BSON</code> 数据类型</h2><p> MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以 <code>BSON（Binary-JSON）</code>文档的格式存储在磁盘上。</p>
<p><code>BSON（Binary Serialized Document Format）</code>是一种类 <code>json</code> 的一种二进制形式的存储格式，简称<code>Binary JSON</code>。<code>BSON</code>和<code>JSON</code>一样，支持 内嵌的文档对象和数组对象，但是<code>BSON</code>有<code>JSON</code>没有的一些数据类型，如Date和BinData类型。</p>
<p><code>BSON</code>采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p>
<p><code>BSON</code>中，除了基本的JSON类型：string, integer, boolean, double, null, array 和 object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详 细信息。</p>
<p>BSON数据类型参考列表：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428163656218-1316936233.png" alt="img"></p>
<p> 提示： shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符 号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p>
<h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><p>面试问题：在进行数据库分表或者将同一个数据库部署到不同的服务器上，如何保证主键不重复。</p>
<p>当然，方法有很多，不同公司会有自己的处理方式，具体的后续会写文章来分析。我们先看在 MongoDB 中是如何保证主键不重复的。</p>
<p>在单机时代，大多数应用可以使用数据可自增式 ID 来作为主键。传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。</p>
<p>为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。</p>
<p>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-227bd6ae2f8a3c05546f51cfd4a0b7a8_720w.webp" alt="img"></p>
<p>其中包括：</p>
<ul>
<li>4-byte Unix 时间戳</li>
<li>3-byte 机器 ID</li>
<li>2-byte 进程 ID</li>
<li>3-byte 计数器(初始化随机)</li>
</ul>
<p>值得一提的是 _id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。<br>当然服务端也会检测写入的文档是否包含 _id 字段，如果没有就生成一个。</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>除了文档模型本身，对于数据的操作命令也是基于JSON/BSON 格式的语法。</p>
<p>详细的语法操作，可以去看<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/reference/sql-comparison/">官方的文档</a>，下面简单介绍一下基础使用语法。</p>
<p>比如插入文档的操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.book.insert(</span><br><span class="line">&#123;</span><br><span class="line">  title: &quot;My first blog post&quot;,</span><br><span class="line">  published: <span class="keyword">new</span> <span class="type">Date</span>(),</span><br><span class="line">  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],</span><br><span class="line">  type: &quot;Work&quot;,</span><br><span class="line">  author : &quot;James&quot;,</span><br><span class="line">  viewCount: <span class="number">25</span>,</span><br><span class="line">  commentCount: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>执行文档查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;author : &quot;James&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>更新文档的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.book.update(</span><br><span class="line">   &#123;&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)&#125;,</span><br><span class="line">   &#123;&quot;$inc&quot;: &#123;&quot;viewCount&quot;: <span class="number">3</span>&#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>删除文档的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.remove(&#123;&quot;_id&quot;:</span><br><span class="line">     ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)&#125;)</span><br></pre></td></tr></table></figure>
<p>在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&quot;author&quot;: &quot;James&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;: <span class="number">1</span>, &quot;title&quot;: <span class="number">1</span>, &quot;author&quot;: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>实现简单的分页查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&#125;)</span><br><span class="line">    .sort(&#123;&quot;viewCount&quot; : <span class="number">-1</span>&#125;)</span><br><span class="line">    .<span class="keyword">skip</span>(<span class="number">10</span>).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。<br>与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。</p>
<p>那么，一个有趣的问题是 MongoDB 能不能用 SQL进行查询？</p>
<p>当然是可以！</p>
<p>但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：</p>
<ul>
<li>客户端使用SQL，可以使用 mongobooster、studio3t 这样的工具</li>
<li>服务端的话，可以看看 presto 之类的一些平台..</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。</p>
<p>索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。在索引的实现上使用了 B 树，MySQL 则是采用 B+ 树来实现索引的。</p>
<p>使用 <code>ensureIndexes</code> 可以为集合声明一个普通的索引：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;author: 1&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>author后面的数字 1 代表升序，如果是降序则是 -1</p>
</blockquote>
<p>实现复合式(compound)的索引，如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;type: 1, published: 1&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有对于复合式索引时，索引键的顺序才变得有意义</p>
</blockquote>
<p>如果索引的字段是数组类型，该索引就自动成为数组(multikey)索引：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;tags: 1&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个</p>
</blockquote>
<h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a><strong>索引特性</strong></h2><p>在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：</p>
<ul>
<li>unique=true，表示一个唯一性索引</li>
<li>expireAfterSeconds=3600，表示这是一个TTL索引，并且数据将在1小时后老化</li>
<li>sparse=true，表示稀疏的索引，仅索引非空(non-null)字段的文档</li>
<li>partialFilterExpression: { rating: { $gt: 5 }，条件式索引，即满足计算条件的文档才进行索引</li>
</ul>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h2><p>除了普通索引之外，MongoDB 支持的类型还包括：</p>
<ul>
<li>哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。</li>
<li>地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。</li>
<li>文本索引，用于支持快速的全文检索</li>
<li>模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。</li>
</ul>
<h2 id="索引评估、调优"><a href="#索引评估、调优" class="headerlink" title="索引评估、调优"></a><strong>索引评估、调优</strong></h2><p>使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。<br>如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.explain().find( &#123; a : 5 &#125; )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;queryPlanner&quot; : &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;winningPlan&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">      &quot;inputStage&quot; : &#123;</span><br><span class="line">        &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">        &quot;keyPattern&quot; : &#123;</span><br><span class="line">            &quot;a&quot; : 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;indexName&quot; : &quot;a_1&quot;,</span><br><span class="line">        &quot;isMultiKey&quot; : false,</span><br><span class="line">        &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">        &quot;indexBounds&quot; : &#123;&quot;a&quot; : [&quot;[5.0, 5.0]&quot;]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从结果 winningPlan 中可以看出执行计划是否高效，比如：</p>
<ul>
<li>未能命中索引的结果，会显示COLLSCAN</li>
<li>命中索引的结果，使用IXSCAN</li>
<li>出现了内存排序，显示为 SORT</li>
</ul>
<p>更加详细的内容，请移步到<a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/indexes/">官方文档</a>。</p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>在大数据领域常常提到的4V特征中，Volume(数据量大)是首当其冲被提及的。<br>由于单机垂直扩展能力的局限，<strong>水平扩展</strong>的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。<br>此外，同时为了保证数据的高可用，MongoDB 采用<strong>副本集</strong>的方式来实现数据复制。</p>
<p>一个典型的MongoDB集群架构会同时采用分片+副本集的方式，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6f849c75bffb439f06e9ceafe6263377_720w.webp" alt="img"></p>
<p><strong>架构说明</strong></p>
<ul>
<li>数据分片（Shards）<br>分片用于存储真正的集群数据，可以是一个单独的 Mongod实例，也可以是一个副本集。 生产环境下Shard一般是一个 Replica Set，以防止该数据片的单点故障。<br>对于分片集合(sharded collection)来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard中。</li>
<li>配置服务器（Config Servers）<br>保存集群的元数据（metadata），包含各个Shard的路由规则，配置服务器由一个副本集(ReplicaSet)组成。</li>
<li>查询路由（Query Routers）<br>Mongos是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的Shard。<br>Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。</li>
</ul>
<h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><p>基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片(Shard) 则记录在 Config Server(配置服务器)上。<br>Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。</p>
<p><strong>数据是根据分片策略来进行切分的，而分片策略则由 分片键(ShardKey)+分片算法(ShardStrategy)组成。</strong></p>
<p>MongoDB 支持两种分片算法：</p>
<h3 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a9c8b977f026d13650d5fd70818d280_720w.webp" alt="img"></p>
<p>假设集合根据x字段来分片，x的取值范围为[minKey, maxKey]（x为整型，这里的minKey、maxKey为整型的最小值和最大值），将整个取值范围划分为多个chunk，每个chunk（默认配置为64MB）包含其中一小段的数据：<br>如Chunk1包含x的取值在[minKey, -75)的所有文档，而Chunk2包含x取值在[-75, 25)之间的所有文档…</p>
<p>范围分片能很好的满足<strong>范围查询</strong>的需求，比如想查询x的值在[-30, 10]之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力，比如使用_id作为 ShardKey，而MongoDB自动生成的id高位是时间戳，是持续递增的。</p>
<h3 id="哈希分片"><a href="#哈希分片" class="headerlink" title="哈希分片"></a>哈希分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6beb0f8fd6e84d4ffa847d7a579bf1e7_720w.webp" alt="img"></p>
<p>Hash分片是根据用户的 ShardKey 先计算出hash值（64bit整型），再根据hash值按照<strong>范围分片</strong>的策略将文档分布到不同的 chunk。<br>由于 hash值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。</p>
<h2 id="如何保证均衡"><a href="#如何保证均衡" class="headerlink" title="如何保证均衡"></a>如何保证均衡</h2><p>既然数据是分布在不同的 chunk 上的，而不同的 chunk 会被分配到不同的分片上，那么就会出现一个问题，如何保证分片上的数据（chunk）是均衡的。</p>
<p>一般会有以下两种情况：</p>
<ul>
<li>全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10个shard，存储1000个chunk，那么每个shard 分别拥有100个chunk。</li>
<li>非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂(split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk数据的搬迁达到均衡。</li>
</ul>
<p>MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点)上，而该节点也同时会控制 Chunk 数据的搬迁流程。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-ecb42a8acff963eacb2463f56d51465b_720w.webp" alt="img"></p>
<p>对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-a4afc0f479a98f4d8fa6302159dd5d4b_720w.webp" alt="img"></p>
<p>MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将<a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/%23sharding-schedule-balancing-window">均衡窗口</a>对齐到业务闲时段。</p>
<h2 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h2><p>应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-02b6729e1ae7d867e243c30524278a29_720w.webp" alt=""></p>
<p>当然，连接高可用的功能是由 Driver 实现的。</p>
<h3 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h3><p>副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个Shard(片)之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。<br>MongoDB 的副本集采取了一主多从的结构，即一个Primary Node + N* Secondary Node的方式，数据从主节点写入，并复制到多个备节点。</p>
<p>典型的架构如下：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-69646e694e88aafce80498990307df9b_720w.webp" alt="img"></p>
<p>利用副本集，我们可以实现：：</p>
<ul>
<li>数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；</li>
<li>读写分离，读请求可以分流到备节点，减轻主节点的单点压力。</li>
</ul>
<p>请注意，读写分离只能增加集群”读”的能力，对于写负载非常高的情况却无能为力。<br>对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘IO、CPU能力可以取得一定效果。</p>
<h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config <span class="operator">=</span> &#123;</span><br><span class="line">    _id : &quot;my_replica_set&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : <span class="number">0</span>, host : &quot;rs1.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">1</span>, host : &quot;rs2.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">2</span>, host : &quot;rs3.example.net:27017&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure>
<p>initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster()命令就可以看到选举的结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.isMaster()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;hosts&quot; : [</span><br><span class="line">    &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;192.168.100.2:27030&quot;,</span><br><span class="line">    &quot;192.168.100.3:27030&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;setName&quot; : &quot;myReplSet&quot;,</span><br><span class="line">    &quot;setVersion&quot; : <span class="number">1</span>,</span><br><span class="line">    &quot;ismaster&quot; : <span class="literal">true</span>,</span><br><span class="line">    &quot;secondary&quot; : <span class="literal">false</span>,</span><br><span class="line">    &quot;primary&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;me&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;electionId&quot; : ObjectId(&quot;7fffffff0000000000000001&quot;),</span><br><span class="line">    &quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>受 Raft算法的影响，主节点的选举需要满足”大多数”原则，可以参考下表：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-099f568819dbb05978634934e3aa585e_720w.webp" alt="img"></p>
<p>因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如3个，正所谓三人行必有我师..</p>
<h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a><strong>心跳</strong></h4><p>在高可用的实现机制中，心跳(heartbeat)是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。<br>副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。<br>利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-81382e5544264faae3d6954584fe9254_720w.webp" alt="img"></p>
<p>默认情况下，节点会每2秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在10秒内没有收到主节点的响应就会主动发起选举。<br>此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。<br>如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>主节点和备节点的数据是通过日志(oplog)复制来实现的，这很类似于 mysql 的 binlog。<br>在每一个副本集的节点中，都会存在一个名为local.oplog.rs的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条oplog，<br>而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。</p>
<p>下面，看看一条 oplog 的具体形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ts&quot; : <span class="type">Timestamp</span>(<span class="number">1446011584</span>, <span class="number">2</span>),</span><br><span class="line">&quot;h&quot; : NumberLong(&quot;1687359108795812092&quot;),</span><br><span class="line">&quot;v&quot; : <span class="number">2</span>,</span><br><span class="line">&quot;op&quot; : &quot;i&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.nosql&quot;,</span><br><span class="line">&quot;o&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;563062c0b085733f34ab4129&quot;), &quot;name&quot; : &quot;mongodb&quot;, &quot;score&quot; : &quot;100&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的一些关键字段有：</p>
<ul>
<li>ts 操作的 optime，该字段不仅仅包含了操作的时间戳(timestamp)，还包含一个自增的计数器值。</li>
<li>h 操作的全局唯一表示</li>
<li>v oplog 的版本信息</li>
<li>op 操作类型，比如 i=insert,u=update..</li>
<li>ns 操作集合，形式为 database.collection</li>
<li>o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容</li>
</ul>
<p>MongoDB 对于 oplog 的设计是比较仔细的，比如：</p>
<ul>
<li>oplog 必须保证有序，通过 optime 来保证。</li>
<li>oplog 必须包含能够进行数据回放的完整信息。</li>
<li>oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。</li>
<li>oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。</li>
</ul>
<h1 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h1><p>一直以来，”不支持事务” 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡(放弃事务，追求高性能、高可扩展)<br>但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。<br>在4.0 版本之后，MongoDB 开始支持多文档的事务：</p>
<ul>
<li>4.0 版本支持副本集范围的多文档事务。</li>
<li>4.2 版本支持跨分片的多文档事务(基于两阶段提交)。</li>
</ul>
<p>在事务的隔离性上，MongoDB 支持快照(snapshot)的隔离级别，可以避免脏读、不可重复读和幻读。<br>尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向系统写入一条数据，应该能够马上读到写入的这个数据。</span><br></pre></td></tr></table></figure>
<p>在分布式架构的CAP理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-12e5c64d1e1df25b325af95055a7012c_720w.webp" alt="img"></p>
<p>在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：</p>
<ul>
<li>read preference<br>读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点</li>
<li>write concern<br>写关注，指定写入结果达到什么状态时才返回，可以为无应答(none)、应答(ack)，或者是大多数节点完成了数据复制等等</li>
<li>read concern<br>读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读(linearizable)等等。</li>
</ul>
<p>使用不同的设定将会产生对于C(一致性)、A(可用性)的不同的抉择，比如：</p>
<ul>
<li>将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败(可用性降低)</li>
<li>将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟(出现不一致)</li>
<li>将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了(节点失效会导致大多数写失败)</li>
</ul>
<p>关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动failover等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>行文至此，笔者对 MongoDB 也有了基本的了解，那么在什么样的情况下才需要使用 MongoDB 呢？换句话说就是 MongoDB 的应用场景是什么。</p>
<p>以下是几个实际的应用案例。</p>
<ul>
<li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li>
<li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。</li>
<li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li>
<li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li>
<li>视频直播，使用 MongoDB 存储用户信息、礼物信息等。</li>
</ul>
<p>这些应用场景中，数据操作方面的共同特点是：</p>
<p>（1）数据量大</p>
<p>（2）写入操作频繁（读写都很频繁）</p>
<p>（3）价值较低的数据，对事务性要求不高 对于这样的数据，我们更适合使用MongoDB来实现数据的存储。</p>
<h2 id="辅助决策"><a href="#辅助决策" class="headerlink" title="辅助决策"></a>辅助决策</h2><p>如果你还在为是否应该使用 MongoDB，不如来做几个选择题来辅助决策</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428154322305-1499789968.png" alt="img"></p>
<p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择MongoDB绝不会后悔。</p>
<h1 id="优势和局限性"><a href="#优势和局限性" class="headerlink" title="优势和局限性"></a>优势和局限性</h1><p>MongoDB 为需要可靠数据库的公司提供了众多优势。以下是使用 MongoDB 的一些好处：</p>
<ul>
<li>速度：MongoDB比一般的关系数据库快 100 倍。作为一个面向文档的数据库，MongoDB 通过索引使访问文档变得容易。这有助于快速查询响应，从而节省用户宝贵的时间。</li>
<li>分片：MongoDB 提供的另一个好处是它允许用户存储大量数据。这是通过将数据分发到连接到应用程序的多个服务器来完成的。如果一台服务器无法处理数据的大小，则通过称为自动分片的过程将其共享给另一台服务器。</li>
<li>灵活的数据库：MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由。</li>
<li>水平可扩展性：MongoDB 是一个可水平扩展的数据库，这是它的基本优势之一。它允许用户有效地将大量数据分发到多台机器。</li>
<li>事务可行性：一些 MongoDB 功能包括gridFS 和 Replication。这些功能支持在使用 MongoDB 时提高数据可用性。这确保了应用程序的性能非常高。</li>
<li>缺少模式：MongoDB 是 NoSQL，这意味着它不需要模式。因此，在使用 MongoDB 时无需概述数据库模式。这减少了数据库处理信息所需的时间。因此，您的架构将由您编写的算法定义。</li>
</ul>
<p>尽管 MongoDB 提供了优于其他数据库的显着优势，但它并不完美。它有一些需要改进的限制。以下是 MongoDB 的一些缺点。 </p>
<ul>
<li>不支持连接：与支持连接的理性数据库不同，MongoDB 不支持。虽然可以通过手动编码添加连接功能，但执行速度可能会很慢并影响性能。</li>
<li>高内存使用率：MongoDB 旨在为每个值对存储键名称。它还受到数据冗余的影响，因为它缺少连接功能。这会导致高内存使用率。</li>
<li>有限数据大小：MongoDB 允许的最大文档大小为16MB。这是一个需要纠正的严峻挑战。</li>
<li>有限嵌套：MongoDB 提供有限的嵌套访问，因为用户不能执行超过100 级的文档嵌套。</li>
</ul>
<h1 id="ChatGPT-怎么看"><a href="#ChatGPT-怎么看" class="headerlink" title="ChatGPT 怎么看"></a>ChatGPT 怎么看</h1><p>问：怎么理解MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由？</p>
<p>答：MongoDB 作为无模式（schema-less）的文档存储数据库，其设计允许在同一个集合（相当于关系数据库中的表）中的不同文档（相当于关系数据库中的行）具有不同的结构和类型。以下是对这一特性的详细解释：</p>
<h3 id="1-无模式（Schema-less）特性"><a href="#1-无模式（Schema-less）特性" class="headerlink" title="1. 无模式（Schema-less）特性"></a>1. 无模式（Schema-less）特性</h3><p>在传统的关系数据库中，所有行必须符合预定义的表结构（schema），即每一列的数据类型和属性在创建表时就已经固定下来。这意味着每一行的数据必须遵循相同的格式。</p>
<p>相比之下，MongoDB 不强制要求文档具有相同的结构。每个文档可以有不同的字段和数据类型。这种灵活性源于 MongoDB 使用 BSON（一种二进制的 JSON 格式）来存储数据。</p>
<h3 id="2-灵活的数据模型"><a href="#2-灵活的数据模型" class="headerlink" title="2. 灵活的数据模型"></a>2. 灵活的数据模型</h3><ul>
<li><strong>不同文档的结构可以不同</strong>：在同一个集合中，一个文档可以包含某些字段，而另一个文档可以不包含这些字段，或者包含不同的字段。例如，在一个用户集合中，一个文档可以包含 <code>name</code> 和 <code>email</code> 字段，而另一个文档可以包含 <code>name</code>、<code>email</code> 和 <code>phone</code> 字段。</li>
<li><strong>字段的数据类型可以不同</strong>：即使是相同字段，在不同文档中也可以具有不同的数据类型。例如，一个文档中的 <code>age</code> 字段可以是整数类型，而在另一个文档中，<code>age</code> 字段可以是字符串类型。</li>
</ul>
<h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul>
<li><strong>灵活性</strong>：开发者可以根据需要随时添加或修改文档中的字段，而无需修改整个集合的结构。这使得开发迭代更快，特别是在需求频繁变化的项目中。</li>
<li><strong>适应性</strong>：能够轻松存储和处理复杂和多变的数据结构，如嵌套文档和数组。适用于需要处理异构数据（heterogeneous data）的应用场景。</li>
<li><strong>快速开发和原型设计</strong>：无需提前定义和维护模式，能够快速启动项目和进行原型设计。</li>
</ul>
<h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>考虑一个用户集合，其中的文档结构如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123-456-7890&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上述例子中：</p>
<ul>
<li>文档1 和 文档2 具有不同的字段，文档2 比文档1 多了 <code>phone</code> 字段。</li>
<li>文档3 没有 <code>email</code> 字段，但有 <code>age</code> 字段，并且 <code>age</code> 字段的数据类型为整数。</li>
</ul>
<h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul>
<li><strong>内容管理系统（CMS）</strong>：需要存储不同类型的内容，如文章、评论、用户信息等，每种内容的结构可能不同。</li>
<li><strong>物联网（IoT）</strong>：不同的传感器设备产生的数据格式可能不同，需要灵活存储和处理。</li>
<li><strong>快速原型设计</strong>：在产品开发初期，需求可能频繁变化，无模式数据库可以快速适应这些变化。</li>
</ul>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><strong>数据一致性和验证</strong>：由于没有固定模式，可能会引入不一致的数据，需要在应用层进行数据验证和清理。</li>
<li><strong>查询优化</strong>：灵活的结构可能会影响查询性能，需要通过索引和查询优化来提高效率。</li>
</ul>
<p>总之，MongoDB 的无模式特性为开发者提供了极大的灵活性，允许存储和处理多种类型和结构的数据，适应快速变化的需求和复杂的应用场景。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通读全文，好像感觉这篇文章在哪看过。对，没错，这就是笔者对几篇文章的缝合。边学习边记录吗，不错的学习模式。</p>
<p>总之，MongoDB 以其高并发、高扩展性、高可用性和无模式特性取得了不错的成绩。也逐渐变成了找工作必须要会的一项技能。情到深处，不得不搞个一首，“都是内卷惹的祸……”。</p>
<p>关于 MongoDB 的学习绝不仅于此，后续会记录深入的内容。</p>
<p>一位同志在第三次考ccf通过后突然顿悟，决定不考研了，乐。猜一下他学 Java 能学多久，刚好我也要学。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/littleatp/p/11675233.html">了解 MongoDB 看这一篇就够了</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liaowenhui/p/17362409.html">MongoDB 的简介及应用场景</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/64352">什么场景下该用 MongoDB</a></p>
<p><a target="_blank" rel="noopener" href="https://www.mongodb.com/docs/manual/">MongoDB 官网</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">随便寻个地方</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/">http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">随便寻个地方'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/" title="细说空结构体：Go语言中的奇妙用途"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">细说空结构体：Go语言中的奇妙用途</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/" title="MySQL实战总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL实战总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/" title="MySQL实战总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="title">MySQL实战总结</div></div></a></div><div><a href="/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/" title="Redis执行流程大揭秘：从命令到结果的奇幻之旅"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-04</div><div class="title">Redis执行流程大揭秘：从命令到结果的奇幻之旅</div></div></a></div><div><a href="/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/" title="Redis持久化：让你的数据不再“无疾而终”"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-04</div><div class="title">Redis持久化：让你的数据不再“无疾而终”</div></div></a></div><div><a href="/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/" title="Redis数据结构五兄弟：数据江湖的武林盟主"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-05</div><div class="title">Redis数据结构五兄弟：数据江湖的武林盟主</div></div></a></div><div><a href="/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/" title="Redis事务的深潜之旅：像个老司机一样操作数据！"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">Redis事务的深潜之旅：像个老司机一样操作数据！</div></div></a></div><div><a href="/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/" title="Redis的键值过期和内存淘汰机制：内存的游戏"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">Redis的键值过期和内存淘汰机制：内存的游戏</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">随便寻个地方</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-NoSQL%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 NoSQL？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-NoSQL"><span class="toc-number">1.1.</span> <span class="toc-text">常见的 NoSQL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MongoDB-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.</span> <span class="toc-text">MongoDB 出现的原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基本模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BSON-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">BSON 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-ID"><span class="toc-number">4.2.</span> <span class="toc-text">分布式 ID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">基础语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">索引特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%84%E4%BC%B0%E3%80%81%E8%B0%83%E4%BC%98"><span class="toc-number">6.3.</span> <span class="toc-text">索引评估、调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">7.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6"><span class="toc-number">7.1.</span> <span class="toc-text">分片机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E7%89%87"><span class="toc-number">7.1.1.</span> <span class="toc-text">范围分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%88%86%E7%89%87"><span class="toc-number">7.1.2.</span> <span class="toc-text">哈希分片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%9D%87%E8%A1%A1"><span class="toc-number">7.2.</span> <span class="toc-text">如何保证均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">应用高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E9%9B%86"><span class="toc-number">7.3.1.</span> <span class="toc-text">副本集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">心跳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">复制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">8.</span> <span class="toc-text">事务一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">一致性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%86%B3%E7%AD%96"><span class="toc-number">9.1.</span> <span class="toc-text">辅助决策</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">10.</span> <span class="toc-text">优势和局限性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChatGPT-%E6%80%8E%E4%B9%88%E7%9C%8B"><span class="toc-number">11.</span> <span class="toc-text">ChatGPT 怎么看</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A0%E6%A8%A1%E5%BC%8F%EF%BC%88Schema-less%EF%BC%89%E7%89%B9%E6%80%A7"><span class="toc-number">11.0.1.</span> <span class="toc-text">1. 无模式（Schema-less）特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%81%B5%E6%B4%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.0.2.</span> <span class="toc-text">2. 灵活的数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E7%82%B9"><span class="toc-number">11.0.3.</span> <span class="toc-text">3. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.0.4.</span> <span class="toc-text">4. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.0.5.</span> <span class="toc-text">5. 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.0.6.</span> <span class="toc-text">6. 注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">12.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Tokenb%E5%92%8CJWT/" title="傻傻分不清之Cookie、Session、Tokenb和JWT">傻傻分不清之Cookie、Session、Tokenb和JWT</a><time datetime="2024-10-21T13:08:06.000Z" title="发表于 2024-10-21 21:08:06">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/21/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/" title="声明、类型、语句与控制与控制结构">声明、类型、语句与控制与控制结构</a><time datetime="2024-10-21T12:55:35.000Z" title="发表于 2024-10-21 20:55:35">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/" title="Go语言创世纪">Go语言创世纪</a><time datetime="2024-10-19T07:02:08.000Z" title="发表于 2024-10-19 15:02:08">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E3%80%8B/" title="《深入理解Go语言》">《深入理解Go语言》</a><time datetime="2024-10-19T06:34:30.000Z" title="发表于 2024-10-19 14:34:30">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/05/gRPC%E5%85%A5%E9%97%A8/" title="gRPC入门">gRPC入门</a><time datetime="2024-07-05T13:12:05.000Z" title="发表于 2024-07-05 21:12:05">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 随便寻个地方</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>