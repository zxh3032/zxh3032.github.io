<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>十大经典排序算法大揭秘 | 随便寻个地方'Blog</title><meta name="author" content="随便寻个地方"><meta name="copyright" content="随便寻个地方"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。 学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之前一直拖着没总结的东西重新学习并总结一下。 排序算法排序算法（sorting algorithm）用于对一组数据按照特定的顺序进行排序。排序">
<meta property="og:type" content="article">
<meta property="og:title" content="十大经典排序算法大揭秘">
<meta property="og:url" content="http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/index.html">
<meta property="og:site_name" content="随便寻个地方&#39;Blog">
<meta property="og:description" content="从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。 学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之前一直拖着没总结的东西重新学习并总结一下。 排序算法排序算法（sorting algorithm）用于对一组数据按照特定的顺序进行排序。排序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.png">
<meta property="article:published_time" content="2024-06-20T08:17:28.000Z">
<meta property="article:modified_time" content="2024-06-20T12:54:00.350Z">
<meta property="article:author" content="随便寻个地方">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '十大经典排序算法大揭秘',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-20 20:54:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="随便寻个地方'Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="随便寻个地方'Blog"><span class="site-name">随便寻个地方'Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">十大经典排序算法大揭秘</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-20T08:17:28.000Z" title="发表于 2024-06-20 16:17:28">2024-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-20T12:54:00.350Z" title="更新于 2024-06-20 20:54:00">2024-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Hello-%E7%AE%97%E6%B3%95%EF%BC%81/">Hello,算法！</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="十大经典排序算法大揭秘"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。</p>
<p>学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之前一直拖着没总结的东西重新学习并总结一下。</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法（sorting algorithm）用于对一组数据按照特定的顺序进行排序。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。</p>
<p>排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620163619694.png" alt="image-20240620163619694"></p>
<h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p>
<p><strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p>
<p><strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。</p>
<p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure>
<p><strong>自适应性</strong>：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。</p>
<p>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。</p>
<p><strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $𝑂(𝑛 log⁡𝑛)$ 。而非比较排序不使用比较运算符，时间复杂度可达 $𝑂(𝑛)$ ，但其通用性相对较差。</p>
<h2 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h2><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</p>
<p>接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。先看看各种算法的比较：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="image"></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>选择排序（selection sort）</strong>的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ol>
<p><strong>动画演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1c7e20f306ddc02eb4e3a50fa7817ff4.gif" alt="img"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 外循环：未排序区间为[i, n-1]</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 内循环：找到未排序区间内最小（大）的元素</span></span><br><span class="line">		k := i</span><br><span class="line">		<span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &lt; nums[k] &#123;</span><br><span class="line">				<span class="comment">// 记录最小元素的值</span></span><br><span class="line">				k = j;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 𝑂(𝑛2)、非自适应排序</strong>：外循环共 𝑛−1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛−1、…、3、2 轮内循环，求和为 $(𝑛−1)(𝑛+2)/2$ 。</li>
<li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li>
<li><strong>非稳定排序</strong>：如图 11-3 所示，元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620170153391.png" alt="image-20240620170153391"></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>冒泡排序（bubble sort）</strong>通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/33a947c71ad62b254cab62e5364d2813.gif" alt="img"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为[0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回。</p>
<p>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 $𝑂(𝑛^2) $；但当输入数组完全有序时，可达到最佳时间复杂度 $𝑂(𝑛) $。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortWithFlag</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        flag := <span class="literal">false</span> <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">false</span> &#123; <span class="comment">// 此轮“冒泡”未交换任何元素，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 $𝑂(n^2)$、自适应排序</strong>：各轮“冒泡”遍历的数组长度依次为 𝑛−1、𝑛−2、…、2、1 ，总和为$ (𝑛−1)𝑛/2 $。在引入 <code>flag</code> 优化后，最佳时间复杂度可达到 $𝑂(𝑛)$ 。</li>
<li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li>
<li><strong>稳定排序</strong>：由于在“冒泡”中遇到相等元素不交换。</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>插入排序（insertion sort）</strong>是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p>
<p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p>
<p><strong>算法步骤：</strong></p>
<p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/91b76e8e4dab9b0cad9a017d7dd431e2.gif" alt="img"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        base := nums[i]</span><br><span class="line">        j := i<span class="number">-1</span></span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 $𝑂(𝑛2)$、自适应排序</strong>：在最差情况下，每次插入操作分别需要循环 𝑛−1、𝑛−2、…、2、1 次，求和得到 $(𝑛−1)𝑛/2 $，因此时间复杂度为 $𝑂(𝑛2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li>
<li><strong>稳定排序</strong>：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>插入排序的时间复杂度为$ 𝑂(𝑛^2) $，而我们即将学习的快速排序的时间复杂度为$ 𝑂(𝑛log⁡𝑛) $。尽管插入排序的时间复杂度更高，<strong>但在数据量较小的情况下，插入排序通常更快</strong>。</p>
<p>这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 𝑂(𝑛log⁡𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，𝑛2 和 𝑛log⁡𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。</p>
<p>实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。</p>
<p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $𝑂(𝑛^2) $，但在实际情况中，<strong>插入排序的使用频率显著高于冒泡排序和选择排序</strong>，主要有以下原因。</p>
<ul>
<li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，<strong>冒泡排序的计算开销通常比插入排序更高</strong>。</li>
<li>选择排序在任何情况下的时间复杂度都为 $𝑂(𝑛^2)$ 。<strong>如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</strong>。</li>
<li>选择排序不稳定，无法应用于多级排序。</li>
</ul>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>希尔排序（Shell Sort）</strong>通过将待排序数组分割成若干子序列，使得每个子序列分别进行插入排序，随着算法的进行逐渐减小子序列的间隔，最终使整个数组变得有序。希尔排序在最后一步中使用一个间隔为 1 的插入排序，这一步能够高效地将几乎有序的数组进行完全排序。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><strong>选择初始增量（gap）</strong>：选择一个初始的增量序列，可以是数组长度的一半或者其他一些预定义的序列。</li>
<li><strong>分割子序列</strong>：根据当前的增量将数组分割成若干子序列，每个子序列由相隔增量距离的元素组成。</li>
<li><strong>对子序列进行插入排序</strong>：对每个子序列分别进行插入排序。</li>
<li><strong>缩小增量</strong>：减少增量的值，通常减小为原来的一半或者按照其他规则减小。</li>
<li><strong>重复上述步骤</strong>：重复分割子序列和排序的过程，直到增量缩小到 1，此时对整个数组进行一次插入排序。</li>
</ol>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="image"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 初始增量，通常取数组长度的一半</span></span><br><span class="line">    <span class="keyword">for</span> gap := n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := gap; i &lt; n; i++ &#123;</span><br><span class="line">            temp := nums[i]</span><br><span class="line">            j := i</span><br><span class="line">            <span class="keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-3"><a href="#算法特性-3" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度</strong>：希尔排序的时间复杂度依赖于增量序列的选择，最坏情况下为 $O(n^2)$，但在实际应用中通常表现优于插入排序和冒泡排序。</li>
<li><strong>空间复杂度</strong>：希尔排序是原地排序算法，空间复杂度为$ O(1)$。</li>
<li><strong>稳定性</strong>：希尔排序不是稳定排序，因为相同元素在不同子序列中的相对位置可能会发生变化。</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。</p>
<ol>
<li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li>
<li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li>
</ol>
<p><strong>算法步骤：</strong></p>
<p><strong>“划分阶段”</strong>从顶至底递归地将数组从中点切分为两个子数组。</p>
<ol>
<li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li>
<li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时终止。</li>
</ol>
<p><strong>“合并阶段”</strong>从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。</p>
<p><strong>动图演示：</strong></p>
<p><img src="https://static001.geekbang.org/infoq/cd/cdda3f11c6efbc01577f5c29a9066772.gif" alt="img"></p>
<p>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。</p>
<ul>
<li><strong>后序遍历</strong>：先递归左子树，再递归右子树，最后处理根节点。</li>
<li><strong>归并排序</strong>：先递归左子数组，再递归右子数组，最后处理合并。</li>
</ul>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 合并左子树组和右子数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span></span><br><span class="line">    <span class="comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化左子树组和右子数组的起始索引</span></span><br><span class="line">    i, j, k := left, mid+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= right &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j] &#123;</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将左子树组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &#123;</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j &lt;= right &#123;</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(tmp); k++ &#123;</span><br><span class="line">        nums[left+k] = tmp[k]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 划分阶段</span></span><br><span class="line">    mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">    mergeSort(nums, left, mid)</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-4"><a href="#算法特性-4" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：划分产生高度为 log⁡𝑛 的递归树，每层合并的总操作数量为 𝑛 ，因此总体时间复杂度为 𝑂(𝑛log⁡𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(𝑛)、非原地排序</strong>：递归深度为 log⁡𝑛 ，使用 𝑂(log⁡𝑛) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 𝑂(𝑛) 大小的额外空间。</li>
<li><strong>稳定排序</strong>：在合并过程中，相等元素的次序保持不变。</li>
</ul>
<h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>对于链表，归并排序相较于其他排序算法具有显著优势，<strong>可以将链表排序任务的空间复杂度优化至 𝑂(1)</strong> 。</p>
<ul>
<li><strong>划分阶段</strong>：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。</li>
<li><strong>合并阶段</strong>：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p><strong>快速排序（quick sort）</strong>是一种基于分治策略的排序算法，运行高效，应用广泛。</p>
<p>快速排序的核心操作是 “哨兵划分”，其目标是：选择数组中某个元素作为 “基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 <code>2</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ol>
<p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c411339b79f92499dcb7b5f304c826f4.gif" alt="img"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>哨兵划分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归版：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哨兵划分</span></span><br><span class="line">    pivot := q.partition(nums, left, right)</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    q.quickSort(nums, left, pivot<span class="number">-1</span>)</span><br><span class="line">    q.quickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归版：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuickSort 非递归快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        high := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        low := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        p := Partition(arr, low, high)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p<span class="number">-1</span> &gt; low &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, low, p<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p+<span class="number">1</span> &lt; high &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, p+<span class="number">1</span>, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-5"><a href="#算法特性-5" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、自适应排序</strong>：在平均情况下，哨兵划分的递归层数为 log⁡𝑛 ，每层中的总循环数为 𝑛 ，总体使用 𝑂(𝑛log⁡𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 $𝑂(𝑛^2) $时间。</li>
<li><strong>空间复杂度为 𝑂(𝑛)、原地排序</strong>：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。</li>
<li><strong>非稳定排序</strong>：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</li>
</ul>
<h2 id="快速排序为什么快？"><a href="#快速排序为什么快？" class="headerlink" title="快速排序为什么快？"></a>快速排序为什么快？</h2><p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。</p>
<ul>
<li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 $𝑂(𝑛^2) $，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛log⁡𝑛) 的时间复杂度下运行。</li>
<li><strong>缓存使用效率高</strong>：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。</li>
<li><strong>复杂度的常数系数小</strong>：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。</li>
</ul>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="基准数优化"><a href="#基准数优化" class="headerlink" title="基准数优化"></a>基准数优化</h3><p><strong>快速排序在某些输入下的时间效率可能降低</strong>。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。</p>
<p>为了尽量避免这种情况发生，<strong>我们可以优化哨兵划分中的基准数的选取策略</strong>。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。</p>
<p>需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。</p>
<p>为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），<strong>并将这三个候选元素的中位数作为基准数</strong>。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 $𝑂(𝑛^2) $的概率大大降低。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选取三个候选元素的中位数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> medianThree(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    l, m, r := nums[left], nums[mid], nums[right]</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid <span class="comment">// m 在 l 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">return</span> left <span class="comment">// l 在 m 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哨兵划分（三数取中值）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    med := q.medianThree(nums, left, (left+right)/<span class="number">2</span>, right)</span><br><span class="line">    <span class="comment">// 将中位数交换至数组最左端</span></span><br><span class="line">    nums[left], nums[med] = nums[med], nums[left]</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">//从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">//从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">//返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。</p>
<p>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过 𝑛/2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序（尾递归优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortTailCall)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        pivot := q.partition(nums, left, right)</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> pivot-left &lt; right-pivot &#123;</span><br><span class="line">            q.quickSort(nums, left, pivot<span class="number">-1</span>) <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q.quickSort(nums, pivot+<span class="number">1</span>, right) <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 𝑂(𝑛log⁡𝑛) 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</p>
<h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。</p>
<ol>
<li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li>
<li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li>
</ol>
<p>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。</p>
<p><strong>算法步骤：</strong></p>
<p>设数组的长度为 𝑛 </p>
<ol>
<li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li>
<li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。</li>
<li>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。</li>
<li>循环执行第 <code>2.</code> 步和第 <code>3.</code> 步。循环 𝑛−1 轮后，即可完成数组排序。</li>
</ol>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7073c729230e1a2c3c3c9207b25f6b43.gif" alt="img"></p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(nums *[]<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        r := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">        ma := i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = r</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        siftDown(nums, <span class="built_in">len</span>(*nums), i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span></span><br><span class="line">        (*nums)[<span class="number">0</span>], (*nums)[i] = (*nums)[i], (*nums)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        siftDown(nums, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-6"><a href="#算法特性-6" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：建堆操作使用 𝑂(𝑛) 时间。从堆中提取最大元素的时间复杂度为 𝑂(log⁡𝑛) ，共循环 𝑛−1 轮。</li>
<li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：几个指针变量使用 𝑂(1) 空间。元素交换和堆化操作都是在原数组上进行的。</li>
<li><strong>非稳定排序</strong>：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li>
</ul>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>计数排序（counting sort）不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3c7ddb59df2d21b287e42a7b908409cb.gif" alt="img"></p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>给定一个长度为 𝑛 的数组 <code>nums</code> ，其中的元素都是“非负整数”。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>遍历数组，找出其中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚+1 的辅助数组 <code>counter</code> 。</li>
<li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加 1 即可。</li>
<li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字出现次数从小到大的顺序填入 <code>nums</code> 即可。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620202353083.png" alt="image-20240620202353083"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 简单实现，无法用于排序对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortNaive</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="number">0</span>, <span class="number">0</span>; num &lt; m+<span class="number">1</span>; num++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; counter[num]; j++ &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>计数排序与桶排序的联系</p>
<p>从桶排序的角度看，我们可以将计数排序中的计数数组 <code>counter</code> 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。</p>
</blockquote>
<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>细心的同学可能已经发现了，<strong>如果输入数据是对象，上述步骤 <code>3.</code> 就失效了</strong>。假设输入数据是商品对象，我们想按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。</p>
<p>那么如何才能得到原数据的排序结果呢？我们首先计算 <code>counter</code> 的“前缀和”。顾名思义，索引 <code>i</code> 处的前缀和 <code>prefix[i]</code> 等于数组前 <code>i</code> 个元素之和：</p>
<script type="math/tex; mode=display">
prefix[𝑖]=∑_{𝑗=0}^𝑖counter[j]</script><p><strong>前缀和具有明确的意义，<code>prefix[num] - 1</code> 代表元素 <code>num</code> 在结果数组 <code>res</code> 中最后一次出现的索引</strong>。这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 <code>nums</code> 的每个元素 <code>num</code> ，在每轮迭代中执行以下两步。</p>
<ol>
<li>将 <code>num</code> 填入数组 <code>res</code> 的索引 <code>prefix[num] - 1</code> 处。</li>
<li>令前缀和 <code>prefix[num]</code> 减小 1 ，从而得到下次放置 <code>num</code> 的索引。</li>
</ol>
<p>遍历完成后，数组 <code>res</code> 中就是排序好的结果，最后使用 <code>res</code> 覆盖原数组 <code>nums</code> 即可。</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        counter[i+<span class="number">1</span>] += counter[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment">// 初始化数组 res 用于记录结果</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        num := nums[i]</span><br><span class="line">        <span class="comment">// 将 num 放置到对应索引处</span></span><br><span class="line">        res[counter[num]<span class="number">-1</span>] = num</span><br><span class="line">        <span class="comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">        counter[num]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="built_in">copy</span>(nums, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-7"><a href="#算法特性-7" class="headerlink" title="算法特性"></a>算法特性</h2><ul>
<li><strong>时间复杂度为 𝑂(𝑛+𝑚)、非自适应排序</strong> ：涉及遍历 <code>nums</code> 和遍历 <code>counter</code> ，都使用线性时间。一般情况下 𝑛≫𝑚 ，时间复杂度趋于 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(𝑛+𝑚)、非原地排序</strong>：借助了长度分别为 𝑛 和 𝑚 的数组 <code>res</code> 和 <code>counter</code> 。</li>
<li><strong>稳定排序</strong>：由于向 <code>res</code> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <code>nums</code> 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <code>nums</code> 也可以得到正确的排序结果，但结果是非稳定的。</li>
</ul>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>看到这里，你也许会觉得计数排序非常巧妙，仅通过统计数量就可以实现高效的排序。然而，使用计数排序的前置条件相对较为严格。</p>
<p><strong>计数排序只适用于非负整数</strong>。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去。</p>
<p><strong>计数排序适用于数据量大但数据范围较小的情况</strong>。比如，在上述示例中 𝑚 不能太大，否则会占用过多空间。而当 𝑛≪𝑚 时，计数排序使用 𝑂(𝑚) 时间，可能比 𝑂(𝑛log⁡𝑛) 的排序算法还要慢。</p>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p><strong>桶排序（bucket sort）</strong>是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p>
<p><strong>算法步骤：</strong></p>
<p>考虑一个长度为 𝑛 的数组，其元素是范围 [0,1) 内的浮点数。</p>
<ol>
<li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li>
<li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li>
<li>按照桶从小到大的顺序合并结果。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620203439496.png" alt="image-20240620203439496"></p>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b29c1a8ee42595e7992b6d2eb1030f76.gif" alt="img"></p>
<h2 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(nums []<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="type">float64</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        buckets[i] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i := <span class="type">int</span>(num * <span class="type">float64</span>(k))</span><br><span class="line">        <span class="comment">// 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i] = <span class="built_in">append</span>(buckets[i], num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="comment">// 使用内置切片排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        sort.Float64s(buckets[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-8"><a href="#算法特性-8" class="headerlink" title="算法特性"></a>算法特性</h2><p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛+𝑘)</strong> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 𝑛𝑘 。假设排序单个桶使用 𝑂(𝑛/𝑘<em>log⁡(𝑛/𝑘)) 时间，则排序所有桶使用 𝑂(𝑛log⁡(𝑛/𝑘)) 时间。<em>*当桶数量 𝑘 比较大时，时间复杂度则趋向于 𝑂(𝑛)</em></em> 。合并结果时需要遍历所有桶和元素，花费 𝑂(𝑛+𝑘) 时间。</li>
<li><strong>自适应排序</strong>：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 𝑂(𝑛2) 时间。</li>
<li><strong>空间复杂度为 𝑂(𝑛+𝑘)、非原地排序</strong>：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ul>
<h2 id="如何实现平均分配"><a href="#如何实现平均分配" class="headerlink" title="如何实现平均分配"></a>如何实现平均分配</h2><p>桶排序的时间复杂度理论上可以达到 𝑂(𝑛) ，<strong>关键在于将元素均匀分配到各个桶中</strong>，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。</p>
<p>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong>。</p>
<p>如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204021017.png" alt="image-20240620204021017"></p>
<p>如果我们提前知道商品价格的概率分布，<strong>则可以根据数据概率分布设置每个桶的价格分界线</strong>。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p>
<p>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204045066.png" alt="image-20240620204045066"></p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>上面介绍了计数排序，它适用于数据量 𝑛 较大但数据范围 𝑚 较小的情况。假设我们需要对 $𝑛=10^6$ 个学号进行排序，而学号是一个 8 位数字，这意味着数据范围 $𝑚=10^8 $非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。</p>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p><strong>基数排序（radix sort）</strong>的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</p>
<p><strong>算法步骤：</strong></p>
<p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的流程如图所示。</p>
<ol>
<li>初始化位数 𝑘=1 。</li>
<li>对学号的第 𝑘 位执行“计数排序”。完成后，数据会根据第 𝑘 位从小到大排序。</li>
<li>将 𝑘 增加 1 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204242169.png" alt="image-20240620204242169"></p>
<p>对于一个 𝑑 进制的数字 𝑥 ，要获取其第 𝑘 位 $𝑥_𝑘 $，可以使用以下计算公式：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204349152.png" alt="image-20240620204349152"></p>
<p>其中 ⌊𝑎⌋ 表示对浮点数 𝑎 向下取整，而 <code>mod d</code> 表示对 𝑑 取模（取余）。对于学号数据，𝑑=10 且 𝑘∈[1,8] 。</p>
<p>此外，我们需要小幅改动计数排序代码，使之可以根据数字的第 𝑘 位进行排序：</p>
<blockquote>
<p>为什么从最低位开始排序？</p>
<p>在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 𝑎&lt;𝑏 ，而第二轮排序结果 𝑎&gt;𝑏 ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。</p>
</blockquote>
<p><strong>动图演示：</strong></p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3a6f1e5059386523ed941f0d6c3a136e.gif" alt="img"></p>
<h2 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">(num, exp <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序（根据 nums 第 k 位排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortDigit</span><span class="params">(nums []<span class="type">int</span>, exp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        d := digit(nums[i], exp) <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++             <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        counter[i] += counter[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        d := digit(nums[i], exp)</span><br><span class="line">        j := counter[d] - <span class="number">1</span> <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]    <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--        <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    max := math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">            max = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; max &gt;= exp; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        countingSortDigit(nums, exp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法特性-9"><a href="#算法特性-9" class="headerlink" title="算法特性"></a>算法特性</h2><p>相较于计数排序，基数排序适用于数值范围较大的情况，<strong>但前提是数据必须可以表示为固定位数的格式，且位数不能过大</strong>。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 𝑂(𝑛𝑘)≫𝑂(𝑛2) 。</p>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛𝑘)、非自适应排序</strong>：设数据量为 𝑛、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 𝑂(𝑛+𝑑) 时间，排序所有 𝑘 位使用 𝑂((𝑛+𝑑)𝑘) 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(𝑛+𝑑)、非原地排序</strong>：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 <code>res</code> 和 <code>counter</code> 。</li>
<li><strong>稳定排序</strong>：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果。</li>
</ul>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>Q</strong>：排序算法稳定性在什么情况下是必需的？</p>
<p>在现实中，我们有可能基于对象的某个属性进行排序。例如，学生有姓名和身高两个属性，我们希望实现一个多级排序：先按照姓名进行排序，得到 <code>(A, 180) (B, 185) (C, 170) (D, 170)</code> ；再对身高进行排序。由于排序算法不稳定，因此可能得到 <code>(D, 170) (C, 170) (A, 180) (B, 185)</code> 。</p>
<p>可以发现，学生 D 和 C 的位置发生了交换，姓名的有序性被破坏了，而这是我们不希望看到的。</p>
<p><strong>Q</strong>：哨兵划分中“从右往左查找”与“从左往右查找”的顺序可以交换吗？</p>
<p>不行，当我们以最左端元素为基准数时，必须先“从右往左查找”再“从左往右查找”。这个结论有些反直觉，我们来剖析一下原因。</p>
<p>哨兵划分 <code>partition()</code> 的最后一步是交换 <code>nums[left]</code> 和 <code>nums[i]</code> 。完成交换后，基准数左边的元素都 <code>&lt;=</code> 基准数，<strong>这就要求最后一步交换前 <code>nums[left] &gt;= nums[i]</code> 必须成立</strong>。假设我们先“从左往右查找”，那么如果找不到比基准数更大的元素，<strong>则会在 <code>i == j</code> 时跳出循环，此时可能 <code>nums[j] == nums[i] &gt; nums[left]</code></strong>。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。</p>
<p>举个例子，给定数组 <code>[0, 0, 0, 0, 1]</code> ，如果先“从左向右查找”，哨兵划分后数组为 <code>[1, 0, 0, 0, 0]</code> ，这个结果是不正确的。</p>
<p>再深入思考一下，如果我们选择 <code>nums[right]</code> 为基准数，那么正好反过来，必须先“从左往右查找”。</p>
<p><strong>Q</strong>：关于尾递归优化，为什么选短的数组能保证递归深度不超过 log⁡𝑛 ？</p>
<p>递归深度就是当前未返回的递归方法的数量。每轮哨兵划分我们将原数组划分为两个子数组。在尾递归优化后，向下递归的子数组长度最大为原数组长度的一半。假设最差情况，一直为一半长度，那么最终的递归深度就是 log⁡𝑛 。</p>
<p>回顾原始的快速排序，我们有可能会连续地递归长度较大的数组，最差情况下为 𝑛、𝑛−1、…、2、1 ，递归深度为 𝑛 。尾递归优化可以避免这种情况出现。</p>
<p><strong>Q</strong>：当数组中所有元素都相等时，快速排序的时间复杂度是 $𝑂(𝑛^2) $吗？该如何处理这种退化情况？</p>
<p>是的。对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p>
<p><strong>Q</strong>：桶排序的最差时间复杂度为什么是$ 𝑂(𝑛^2) $？</p>
<p>最差情况下，所有元素被分至同一个桶中。如果我们采用一个 $𝑂(𝑛^2)$ 算法来排序这些元素，则时间复杂度为$ 𝑂(𝑛^2) $。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到 𝑂(𝑛) 。</li>
<li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为 𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li>
<li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至 𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到 𝑂(log⁡𝑛) 。</li>
<li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为 𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至 𝑂(1) 。</li>
<li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配。</li>
<li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并且要求数据能够转换为正整数。</li>
<li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li>
</ul>
<p>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及正向自适应性等优点。然而，正如其他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据数据的特性来选择合适的排序算法。</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sorting_algorithms_comparison.png" alt="排序算法对比"></p>
<p>OK了，今天的算法学习就先到这里，该作题了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_sorting/">https://www.hello-algo.com/chapter_sorting/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/MisterBooo/Article">https://github.com/MisterBooo/Article</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4">https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">随便寻个地方</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/">http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">随便寻个地方'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/" title="I/O多路复用：select/poll/epoll"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">I/O多路复用：select/poll/epoll</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/" title="什么是一致性哈希算法？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">什么是一致性哈希算法？</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/17/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E2%80%9C%E6%B8%85%E6%9C%9D%E2%80%9D%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/" title="红黑树是什么？——一个“清朝”的遗留问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="title">红黑树是什么？——一个“清朝”的遗留问题</div></div></a></div><div><a href="/2024/06/19/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%88%E4%BA%8C%EF%BC%89/" title="腾讯面试——血与泪的教训（二）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-19</div><div class="title">腾讯面试——血与泪的教训（二）</div></div></a></div><div><a href="/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/" title="什么是一致性哈希算法？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-20</div><div class="title">什么是一致性哈希算法？</div></div></a></div><div><a href="/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/" title="腾讯面试(三)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="title">腾讯面试(三)</div></div></a></div><div><a href="/2024/06/27/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Paxos/" title="一致性算法——Paxos"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-27</div><div class="title">一致性算法——Paxos</div></div></a></div><div><a href="/2024/07/01/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Raft/" title="一致性算法——Raft"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-01</div><div class="title">一致性算法——Raft</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">随便寻个地方</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E7%BB%B4%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">评价维度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E6%83%B3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">理想排序算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-1"><span class="toc-number">3.3.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-2"><span class="toc-number">4.3.</span> <span class="toc-text">算法特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">4.4.</span> <span class="toc-text">优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-3"><span class="toc-number">5.3.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">6.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">6.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-4"><span class="toc-number">6.3.</span> <span class="toc-text">算法特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">链表排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">7.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-5"><span class="toc-number">7.3.</span> <span class="toc-text">算法特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">快速排序为什么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1"><span class="toc-number">7.5.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.1.</span> <span class="toc-text">基准数优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.2.</span> <span class="toc-text">尾递归优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">8.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">8.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-6"><span class="toc-number">8.3.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-7"><span class="toc-number">9.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.</span> <span class="toc-text">简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">9.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.</span> <span class="toc-text">完整实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">9.3.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-7"><span class="toc-number">9.4.</span> <span class="toc-text">算法特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">9.5.</span> <span class="toc-text">局限性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-8"><span class="toc-number">10.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">10.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-8"><span class="toc-number">10.3.</span> <span class="toc-text">算法特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D"><span class="toc-number">10.4.</span> <span class="toc-text">如何实现平均分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">11.</span> <span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-9"><span class="toc-number">11.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="toc-number">11.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-9"><span class="toc-number">11.3.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">一些问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">13.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/07/Untitled/" title="无题">无题</a><time datetime="2025-03-07T06:39:56.000Z" title="发表于 2025-03-07 14:39:56">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741099573219/" title="无题">无题</a><time datetime="2025-03-04T14:46:16.000Z" title="发表于 2025-03-04 22:46:16">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741098965071/" title="无题">无题</a><time datetime="2025-03-04T14:36:08.000Z" title="发表于 2025-03-04 22:36:08">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%A4%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/" title="顺序存储两兄弟——数组和切片，到底有什么区别？">顺序存储两兄弟——数组和切片，到底有什么区别？</a><time datetime="2024-11-07T05:04:09.000Z" title="发表于 2024-11-07 13:04:09">2024-11-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/24/%E4%BA%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="了解基础数据类型">了解基础数据类型</a><time datetime="2024-10-24T09:57:13.000Z" title="发表于 2024-10-24 17:57:13">2024-10-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 随便寻个地方</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>