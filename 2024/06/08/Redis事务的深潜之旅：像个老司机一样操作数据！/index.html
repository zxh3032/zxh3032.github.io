<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Redis事务的深潜之旅：像个老司机一样操作数据！ | 随便寻个地方'Blog</title><meta name="author" content="随便寻个地方"><meta name="copyright" content="随便寻个地方"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。 那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？ 为了解开这些疑问，也为了能更加熟练地掌握 Redis，成为一个老司机。今天，我们就来学习 Redis 事务相关的内容。 什么是Redis事务？Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis事务的深潜之旅：像个老司机一样操作数据！">
<meta property="og:url" content="http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/index.html">
<meta property="og:site_name" content="随便寻个地方&#39;Blog">
<meta property="og:description" content="在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。 那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？ 为了解开这些疑问，也为了能更加熟练地掌握 Redis，成为一个老司机。今天，我们就来学习 Redis 事务相关的内容。 什么是Redis事务？Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.png">
<meta property="article:published_time" content="2024-06-08T07:57:12.000Z">
<meta property="article:modified_time" content="2024-06-08T11:11:53.000Z">
<meta property="article:author" content="随便寻个地方">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis事务的深潜之旅：像个老司机一样操作数据！',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-08 19:11:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="随便寻个地方'Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="随便寻个地方'Blog"><span class="site-name">随便寻个地方'Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis事务的深潜之旅：像个老司机一样操作数据！</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-08T07:57:12.000Z" title="发表于 2024-06-08 15:57:12">2024-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-08T11:11:53.000Z" title="更新于 2024-06-08 19:11:53">2024-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis事务的深潜之旅：像个老司机一样操作数据！"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。</p>
<p>那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？</p>
<p>为了解开这些疑问，也为了能更加熟练地掌握 Redis，成为一个老司机。今天，我们就来学习 Redis 事务相关的内容。</p>
<h1 id="什么是Redis事务？"><a href="#什么是Redis事务？" class="headerlink" title="什么是Redis事务？"></a>什么是Redis事务？</h1><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h1 id="事务的基本使用"><a href="#事务的基本使用" class="headerlink" title="事务的基本使用"></a>事务的基本使用</h1><p>事务在其他语言中，一般分为以下三个阶段：</p>
<ul>
<li>开启事务——Begin Transaction</li>
<li>执行业务代码，提交事务——Commit Transaction</li>
<li>业务处理中出现异常，回滚事务——Rollback Transaction</li>
</ul>
<p>以 Java 中的事务执行为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redis 中的事务从开始到结束也是要经历三个阶段：</p>
<ul>
<li>开启事务</li>
<li>命令入列</li>
<li>执行事务/放弃事务</li>
</ul>
<p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p>
<p>下面一一介绍关于事务的命令。</p>
<h2 id="MULTI：聚会的开场白"><a href="#MULTI：聚会的开场白" class="headerlink" title="MULTI：聚会的开场白"></a>MULTI：聚会的开场白</h2><p>multi 命令用于开启事务，实现代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f2898390-5ddf-11ea-9d6d-67bd1a14f4fe" alt="img"></p>
<p>当客户端是非事务状态时，使用 multi 命令，客户端会返回结果 OK，如果客户端已经是事务状态，再执行 multi 命令会提示 multi 命令不能嵌套的错误，但不会终止客户端为事务的状态，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3aa4ae70-5de0-11ea-9d6d-67bd1a14f4fe" alt="img"></p>
<h2 id="常规命令：聚会人员入场"><a href="#常规命令：聚会人员入场" class="headerlink" title="常规命令：聚会人员入场"></a>常规命令：聚会人员入场</h2><p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>
<p>执行流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68d8d640-5de0-11ea-9d6d-67bd1a14f4fe" alt="img"></p>
<p>命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p>
<h2 id="EXEC：行动的高潮"><a href="#EXEC：行动的高潮" class="headerlink" title="EXEC：行动的高潮"></a>EXEC：行动的高潮</h2><p>执行事务的命令是 exec，输入 exec 后会执行开启事务后的所有操作。执行事务示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e31a4ab0-5de0-11ea-9359-3b811418c7dd" alt="img"></p>
<h2 id="DISCARD：优雅的撤退"><a href="#DISCARD：优雅的撤退" class="headerlink" title="DISCARD：优雅的撤退"></a>DISCARD：优雅的撤退</h2><p>放弃事务的命令是 discard，有时候，事情并不像你预想的那样发展，你决定取消事务。DISCARD就是你的优雅撤退，所有的准备工作都被抛之脑后，大家都当做什么都没发生过一样。</p>
<p>放弃事务示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">discard</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>具体的执行流程和 exec 一致。</p>
<h2 id="WATCH：秘密特工的侦查"><a href="#WATCH：秘密特工的侦查" class="headerlink" title="WATCH：秘密特工的侦查"></a>WATCH：秘密特工的侦查</h2><p>WATCH就是你在事务前的小心侦查，确保一切都在你的掌控之中。如果有人试图偷偷溜进来搞破坏，WATCH会立刻发出警报，保护你的数据不被篡改。</p>
<p>watch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个<strong>监控项被修改</strong>了，那么<strong>整个事务</strong>就会<strong>终止执行</strong>。</p>
<p>watch 基本语法如下：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure>
<p><code>watch</code> 示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p>
<p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 <code>get k</code> 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p>
<p>执行流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/191ad650-5de3-11ea-9e57-957b6467a3fc" alt="img"></p>
<p><strong>注意</strong>： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">(error) ERR WATCH inside MULTI is not allowed</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure>
<p>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</p>
<p>unwatch 示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">unwatch</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>以下是事务在 Java 中的使用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置键值</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启监视 watch</span></span><br><span class="line">        jedis.watch(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 开始事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="comment">// 命令入列</span></span><br><span class="line">        tx.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        tx.exec();</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="事务出现错误的处理"><a href="#事务出现错误的处理" class="headerlink" title="事务出现错误的处理"></a>事务出现错误的处理</h1><p>事务执行中的错误分为以下三类：</p>
<ul>
<li>执行时才会出现的错误（简称：执行时错误）；</li>
<li>入列时错误，不会终止整个事务；</li>
<li>入列时错误，会终止整个事务。</li>
</ul>
<h2 id="执行时出错"><a href="#执行时出错" class="headerlink" title="执行时出错"></a>执行时出错</h2><p>执行命令解释如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/aa0ca950-5de2-11ea-9e6b-b3dcd9fe8595" alt="img"></p>
<p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p>
<h2 id="入列错误不会导致事务结束"><a href="#入列错误不会导致事务结束" class="headerlink" title="入列错误不会导致事务结束"></a>入列错误不会导致事务结束</h2><p>执行命令解释如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/cc4111f0-5de2-11ea-9e6b-b3dcd9fe8595" alt="img"></p>
<p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果。</p>
<h2 id="入列错误导致事务结束"><a href="#入列错误导致事务结束" class="headerlink" title="入列错误导致事务结束"></a>入列错误导致事务结束</h2><p>执行命令解释如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fd00c6a0-5de2-11ea-9d6f-15d639c92acd" alt="img"></p>
<p>当然可以！让我们详细探讨一下Redis事务的局限性，揭开这种“完美的幻觉”，看看有哪些实际中的限制和注意事项。</p>
<h1 id="Redis事务的局限：完美的幻觉？"><a href="#Redis事务的局限：完美的幻觉？" class="headerlink" title="Redis事务的局限：完美的幻觉？"></a>Redis事务的局限：完美的幻觉？</h1><p>Redis事务通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>和<code>DISCARD</code>等命令实现了一定程度上的事务处理。然而，与传统关系型数据库的事务机制相比，Redis事务仍然存在一些局限性。</p>
<h2 id="乐观锁的陷阱"><a href="#乐观锁的陷阱" class="headerlink" title="乐观锁的陷阱"></a>乐观锁的陷阱</h2><p><strong>概念：</strong> Redis通过<code>WATCH</code>命令实现乐观锁。<code>WATCH</code>命令用于监视一个或多个键，当事务执行期间，如果这些键发生变化（例如被其他客户端修改），则事务会失败。</p>
<p><strong>局限性：</strong> </p>
<ul>
<li><strong>冲突频繁：</strong> 在高并发环境下，如果监视的键频繁被修改，事务成功的概率会降低，需要多次重试。</li>
<li><strong>数据竞争：</strong> 乐观锁适用于数据冲突较少的场景，对于高冲突的场景可能并不合适。</li>
</ul>
<h2 id="缺乏回滚机制"><a href="#缺乏回滚机制" class="headerlink" title="缺乏回滚机制"></a>缺乏回滚机制</h2><p><strong>概念：</strong> 在传统关系型数据库中，如果事务中的某个操作失败，可以回滚事务，撤销已经执行的操作。但是在Redis中，一旦执行<code>EXEC</code>命令，所有命令都会被依次执行，不支持部分回滚。</p>
<p><strong>局限性：</strong></p>
<ul>
<li><strong>不可中断：</strong> 一旦事务开始执行，无法中途停止或回滚已经成功的操作。</li>
<li><strong>操作不可逆：</strong> 如果事务中的某个操作失败，必须手动处理恢复或补救措施，不能依赖自动回滚。</li>
</ul>
<h1 id="更加深入的理解"><a href="#更加深入的理解" class="headerlink" title="更加深入的理解"></a>更加深入的理解</h1><h2 id="为什么-Redis-不支持回滚？"><a href="#为什么-Redis-不支持回滚？" class="headerlink" title="为什么 Redis 不支持回滚？"></a>为什么 Redis 不支持回滚？</h2><blockquote>
<p>如果你有使用关系式数据库的经验， 那么 “<strong>Redis 在事务失败时不进行回滚，而是继续执行余下的命令</strong>”这种做法可能会让你觉得有点奇怪。</p>
</blockquote>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， <strong>回滚并不能解决编程错误带来的问题</strong>。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p>
<h2 id="如何理解-Redis-与事务的-ACID？"><a href="#如何理解-Redis-与事务的-ACID？" class="headerlink" title="如何理解 Redis 与事务的 ACID？"></a>如何理解 Redis 与事务的 ACID？</h2><blockquote>
<p>一般来说，事务有四个性质称为ACID，分别是原子性，一致性，隔离性和持久性。这是基础，但是很多文章对Redis 是否支持ACID有一些异议，我觉的有必要梳理下：</p>
</blockquote>
<ul>
<li><strong>原子性 Atomicity</strong></li>
</ul>
<p>首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。</p>
<p>Redis官方文档给的理解是，<strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行</strong>。而不是完全成功。</p>
<ul>
<li><strong>一致性 Consistency</strong></li>
</ul>
<p>Redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非Redis进程意外终结。</p>
<ul>
<li><strong>隔离性 Isolation</strong></li>
</ul>
<p>Redis事务是严格遵守隔离性的，原因是Redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。</p>
<p>但是，Redis不像其它结构化数据库有隔离级别这种设计。</p>
<ul>
<li><strong>持久性 Durability</strong></li>
</ul>
<p><strong>Redis事务是不保证持久性的</strong>，这是因为Redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</p>
<p>关于 Redis 事务能不能保证 ACID这一问题，我在网上也是众说纷纭，但是在 <strong>一致性</strong> 和 <strong>隔离性</strong> 上，大家都保持着相同的看法，那就是能保证。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 Redis 事务的全部内容了，内容并不多，没有在学习 MySQL 时的海量内容，也可以看出其实在 Redis 中并不会很频繁的使用到事务，算一个小知识点吧。</p>
<p>我是怎么得出这个结论的？因为小林coding写的八股文中都找不到和事务相关的内容，所以我断言它不重要。</p>
<p>前天晚上死活睡不着，熬了个通宵之后直接来了一个说走就走的旅行，岳阳还是很好玩的。不得不说，晚上确实是一个容易冲动消费的时间，纠结了两周的耳机还是买了，不过不知道为什么没有之前买东西的那种期待感了。</p>
<p>这里就不得不吐槽一下京东了，太呆瓜了，我在晚上冲动消费后，中午觉得这样不行所以决定退了，但是思考两分钟后又觉得得买，所以我就取消了我的取消申请，客服同意后，快递竟然还是被退回来。我联系客服，客服跟我说没办法了。然后我就又申请了退款，结果快递又开始配送了，不得不联系美女客服帮我退款。京东找个真人客服是真难。害的我还得再等一天。</p>
<p>昨天高考开始，竟然没刷到几个丢准考证和身份证的，看来今年的学生学聪明了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7203274235425505336">redis 事务能保证ACID吗</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html">Redis 事务</a></p>
<p><a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">Redis 事务解析</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/16%20Redis%20%e4%ba%8b%e5%8a%a1%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90.md">Redis事务深度解析</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">随便寻个地方</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/">http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">随便寻个地方'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/" title="Redis的键值过期和内存淘汰机制：内存的游戏"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis的键值过期和内存淘汰机制：内存的游戏</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/" title="Redis数据结构五兄弟：数据江湖的武林盟主"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis数据结构五兄弟：数据江湖的武林盟主</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/" title="了解MongoDB——你想知道的都在这"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">了解MongoDB——你想知道的都在这</div></div></a></div><div><a href="/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/" title="分页与过滤：Redis中的渐进式数据处理妙招"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-10</div><div class="title">分页与过滤：Redis中的渐进式数据处理妙招</div></div></a></div><div><a href="/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/" title="深入解析管道（Pipelining）：提升性能的利器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-10</div><div class="title">深入解析管道（Pipelining）：提升性能的利器</div></div></a></div><div><a href="/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/" title="Redis为何快得飞起？解密闪电侠的内存魔法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">Redis为何快得飞起？解密闪电侠的内存魔法</div></div></a></div><div><a href="/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/" title="MySQL实战总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="title">MySQL实战总结</div></div></a></div><div><a href="/2024/06/12/Redis%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A7%98%E5%AF%86%E6%AD%A6%E5%99%A8/" title="Redis事件机制：高效运行的秘密武器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Redis事件机制：高效运行的秘密武器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">随便寻个地方</div><div class="author-info__description">最近在做博客重建，有些乱，请见谅……</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是Redis事务？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">事务的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MULTI%EF%BC%9A%E8%81%9A%E4%BC%9A%E7%9A%84%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">2.1.</span> <span class="toc-text">MULTI：聚会的开场白</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4%EF%BC%9A%E8%81%9A%E4%BC%9A%E4%BA%BA%E5%91%98%E5%85%A5%E5%9C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">常规命令：聚会人员入场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXEC%EF%BC%9A%E8%A1%8C%E5%8A%A8%E7%9A%84%E9%AB%98%E6%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">EXEC：行动的高潮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DISCARD%EF%BC%9A%E4%BC%98%E9%9B%85%E7%9A%84%E6%92%A4%E9%80%80"><span class="toc-number">2.4.</span> <span class="toc-text">DISCARD：优雅的撤退</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WATCH%EF%BC%9A%E7%A7%98%E5%AF%86%E7%89%B9%E5%B7%A5%E7%9A%84%E4%BE%A6%E6%9F%A5"><span class="toc-number">2.5.</span> <span class="toc-text">WATCH：秘密特工的侦查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.6.</span> <span class="toc-text">举个例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">事务出现错误的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%97%B6%E5%87%BA%E9%94%99"><span class="toc-number">3.1.</span> <span class="toc-text">执行时出错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F"><span class="toc-number">3.2.</span> <span class="toc-text">入列错误不会导致事务结束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F"><span class="toc-number">3.3.</span> <span class="toc-text">入列错误导致事务结束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B1%80%E9%99%90%EF%BC%9A%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%B9%BB%E8%A7%89%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">Redis事务的局限：完美的幻觉？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">4.1.</span> <span class="toc-text">乐观锁的陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E4%B9%8F%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">缺乏回滚机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E5%8A%A0%E6%B7%B1%E5%85%A5%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">更加深入的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">为什么 Redis 不支持回滚？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Redis-%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">如何理解 Redis 与事务的 ACID？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/07/Untitled/" title="无题">无题</a><time datetime="2025-03-07T06:39:56.000Z" title="发表于 2025-03-07 14:39:56">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741099573219/" title="无题">无题</a><time datetime="2025-03-04T14:46:16.000Z" title="发表于 2025-03-04 22:46:16">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741098965071/" title="无题">无题</a><time datetime="2025-03-04T14:36:08.000Z" title="发表于 2025-03-04 22:36:08">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%A4%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/" title="顺序存储两兄弟——数组和切片，到底有什么区别？">顺序存储两兄弟——数组和切片，到底有什么区别？</a><time datetime="2024-11-07T05:04:09.000Z" title="发表于 2024-11-07 13:04:09">2024-11-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/24/%E4%BA%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="了解基础数据类型">了解基础数据类型</a><time datetime="2024-10-24T09:57:13.000Z" title="发表于 2024-10-24 17:57:13">2024-10-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 随便寻个地方</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>