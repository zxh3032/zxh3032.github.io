<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-24T16:51:06.161Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统——理论基础</title>
    <link href="http://example.com/2024/06/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/06/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2024-06-24T09:22:59.000Z</published>
    <updated>2024-06-24T16:51:06.161Z</updated>
    
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯面试(三)</title>
    <link href="http://example.com/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/"/>
    <id>http://example.com/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/</id>
    <published>2024-06-24T07:44:25.000Z</published>
    <updated>2024-06-24T09:21:13.821Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯二面，没想到上次面试还有下文，隔了四天，周日晚上约今天的面试，那时我还躺在南昌酒店的床上享受着美好的假期生活。腾讯是真给机会啊，面完的感受，觉得还是差太多了，面试官问的问题我甚至都没听懂，不知道为什么，感觉很奇怪。面试时间不长，面试官也没开摄像头，没有自我介绍，直接开始拷打项目，但是也没有问什么深入的内容，就让自己介绍、有什么收获、重做一遍会有什么改进、做了多长时间等等，后面问一些八股，答得也不好，二十五分钟结束面试。反问项目组用什么语言、做什么内容，主要用 Go 和 C++，做一些关于大数据的内容（这不刚好吗，我可是千年学府、百年名校的湖南大学的第二届大数据学生）。</p><p>由于问题并不是很多，而且问题好像也不是很难，只是我没懂面试官的意思，脑子坏掉了，我就说我总是关键时刻掉链子。所以就简单记录一下都问了什么问题吧。</p><ol><li>挑一个项目介绍一下。<ul><li>传统项目了，果断挑选博客系统，巴拉巴拉介绍完。</li></ul></li><li>介绍一下项目里用到的数据结构和技术选型。<ul><li>太专业了，脑子没转过来也不知道怎么回答了，就讲了一下GET、POST请求，想继续讲登录操作，被打断了，可能是我太啰嗦了。</li></ul></li><li>项目里前端和后端是怎么通信的，用的是什么协议。<ul><li>这个问题我就更是一头雾水了，没明白什么意思，来回确认了三次我都没动要怎么回答。面试官问用的是 http 协议吗，我说是。中间还说到了 Ngnix，给面试官整笑了，反正这个问题从头到尾我都没明白是怎么回事，后面搜了一下，大概懂了。可能是要我说 http 协议和 RESTful 规范之类的吧。</li></ul></li><li>有没有考虑过项目中的架构问题。<ul><li>说实话，从来没有考虑过这些方面的内容，这个项目连部署我都没做。后面就说有学过秒杀系统的一些架构问题，不知道能不能用到这个上面。</li></ul></li><li>用户登录之后会看到什么？每个用户看到的都一样吗？在拉取文章列表的时候有看过性能方面的问题吗？<ul><li>用户登陆后会看到MySQL中存储的文章，每个用户看到的都一样，因为是直接从MySQL中拉取出来的。</li><li>性能方面的问题并没有去考量，脑子一抽说成了是一次性把所有数据拉去出来，其实在做的时候是设计了分页功能，先拉取一页的内容，后面再看的时候再拉取，我是傻逼，脑子跟不上嘴。</li></ul></li><li>为什么要用 MySQL 来做数据库存储？为什么不用其他的数据库？<ul><li>我知道这里面试官想要我去分析主流的数据库的优缺点，但是选择 MySQL 就是因为我当时只会 MySQL。</li><li>分析了 MongoDB 和 MySQL 的一些区别，就说为了学习效率考虑就选择已经学会的MySQL，而不是MongoDB。</li></ul></li><li>项目一共做了多久？有什么收获？如果重新做一遍会对那些地方进行改进？<ul><li>项目一共做了不到两个月，收获还是很多的，嘴瓢说的含糊不清。主要就是 Go 语言、常用库、数据库、学习能力的提升。</li><li>重做一遍会更多关注在性能上，也会结合实际情况加入更多的功能，补充前端的东西。</li></ul></li><li>八股就问了三个：Linux查看进程占用CPU情况的命令。进程有哪几种状态？端口在TCP/IP协议中的那一层？<ul><li>第一个问题，确实没怎么用过命令行，所以直接回答了不知道，实际是用 <code>top</code> 和 <code>ps</code> 命令。</li><li>三种状态，更扩展的就不记得了，阻塞不能直接到运行状态。</li><li>回答了四元组，说确定端口号和IP地址，脑子一抽胡说了个网络层和链路层，其实是传输层，一边回答着传输要用到四元组，一边回答另外的东西。</li></ul></li><li>了解C++吗？虚拟继承有什么用？<ul><li>这个确实不知道，一面的时候面试官问的都是Go相关的八股。这个确实不知道。</li></ul></li><li>反问：项目组主要用什么语言？主要是做什么的？需要学大数据相关的框架吗？<ul><li>主要用 Go 和 Java，处理大数据的时候会用到 C++。</li><li>主要做跟大数据有关的内容。</li><li>需要学。</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总是这样，在面试之前总是觉得好像已经没什么可学的了，面试完之后就觉得好像什么都没学过。拷打的体无完肤，还是知识储备不够。刚刚也去看了前后端通信的过程，还是不是很清楚要怎么回答面试官的那个问题。</p><p>不管结果如何，我都很感谢腾讯，每一次面试都能发现很多不足，自己确实还是有很多东西都没有考虑到。通过面试查漏补缺属实不是什么好方法，但是我自己在下面又不能全方面地排查问题，所以面试了一场又一场，发现了很多问题，却又被我一直拖着没做。</p><p>其他两个面试也没什么结果，字节都已经过了一周了，还没约二面，应该是没戏了。俊德内推地腾讯云智，我觉得面的还挺好的，也还没消息，可能是不缺人吧，也可能只是我觉得很好。</p><p>唉，总的来说，上一周好像到了巅峰，三场面试，这一周好像又要开始往下走了，祝我面试顺利。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;腾讯二面，没想到上次面试还有下文，隔了四天，周日晚上约今天的面试，那时我还躺在南昌酒店的床上享受着美好的假期生活。腾讯是真给机会啊，面完的感受，觉得还是差太多了，面试官问的问题我甚至都没听懂，不知道为什么，感觉很奇怪。面试时间不长，面试官也没开摄像头，没有自我介绍，直接开始</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用：select/poll/epoll</title>
    <link href="http://example.com/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/"/>
    <id>http://example.com/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/</id>
    <published>2024-06-21T07:26:39.000Z</published>
    <updated>2024-06-21T08:23:48.484Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前（三天前），我被问到一个熟悉又陌生的问题，了解I/O多路复用吗？我回答，了解但是还没开始学？是的，我学习的领域就是这么广泛又浅显，名词我都了解，但是就是不知道具体是什么。</p><p>说到 I/O多路复用，我学习的博客都把他归到了操作系统一类里面，我也学过操作系统啊，为什么就不知道这是什么呢？我问了我周围的同学，好像都不知道，应该是当时老师没讲，也可能是讲了我们都没听。我知道这个算法是在学习 Redis 的时候，我们在 Redis 为什么这么快 那篇博客里提到了 多路复用 这个算法，今天我们就来看一看 I/O多路复用的前世今生。</p><h1 id="最基础的-Socket-模型"><a href="#最基础的-Socket-模型" class="headerlink" title="最基础的 Socket 模型"></a>最基础的 <code>Socket</code> 模型</h1><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p><p>Socket 的中文名叫做插口，乍一看还挺迷惑的。事实上，双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。</p><p>创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。</p><p>UDP 的 Socket 编程相对简单些，这里我们只介绍基于 TCP 的 Socket 编程。</p><p>服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。</p><p>服务端首先调用 <code>socket()</code> 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 <code>bind()</code> 函数，给这个 Socket 绑定一个 <strong>IP 地址和端口</strong>，绑定这两个的目的是什么？</p><ul><li>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</li></ul><p>绑定完 IP 地址和端口后，就可以调用 <code>listen()</code> 函数进行监听，此时对应 TCP 状态图中的 <code>listen</code>，如果我们要判定服务器中一个网络程序有没有启动，可以通过 <code>netstat</code> 命令查看对应的端口号是否有被监听。</p><p>服务端进入了监听状态后，通过调用 <code>accept()</code> 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 <code>connect()</code> 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p><p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p><ul><li>一个是「还没完全建立」连接的队列，称为 <strong>TCP 半连接队列</strong>，这个队列都是没有完成三次握手的连接，此时服务端处于 <code>syn_rcvd</code> 的状态；</li><li>一个是「已经建立」连接的队列，称为 <strong>TCP 全连接队列</strong>，这个队列都是完成了三次握手的连接，此时服务端处于 <code>established</code> 状态；</li></ul><p>当 TCP 全连接队列不为空后，服务端的 <code>accept()</code> 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。</p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作<strong>监听 Socket</strong>；</li><li>一个叫作<strong>已连接 Socket</strong>；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <code>read()</code> 和 <code>write()</code> 函数来读写数据。</p><p>至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tcp_socket.png" alt="img"></p><p>看到这，不知道你有没有觉得读写 Socket 的方式，好像读写文件一样。</p><p>是的，基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。</p><h1 id="如何服务更多的用户？"><a href="#如何服务更多的用户？" class="headerlink" title="如何服务更多的用户？"></a>如何服务更多的用户？</h1><p>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p><p>可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。</p><p>在改进网络 I/O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？</p><p>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：<strong>本机IP, 本机端口, 对端IP, 对端端口</strong>。</p><p>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以<strong>最大 TCP 连接数 = 客户端 IP 数×客户端端口数</strong>。</p><p>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是<strong>服务端单机最大 TCP 连接数约为 2 的 48 次方</strong>。</p><p>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p><ul><li><strong>文件描述符</strong>，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li><strong>系统内存</strong>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p><p>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。</p><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</p><p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p><h1 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h1><p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，</p><p>可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。</p><p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" alt="img"></p><p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="img"></p><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 <strong>I/O 多路复用</strong>技术。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="img"></p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p><p>select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><p>select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>Select 实现多路复用的方式是，将以连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 Select 函数将文件描述符<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查有事件产生后，将此 Socket 标记为可读或者可写，接着再把整个文件描述符集合<strong>拷贝</strong>回用户态，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p><p><strong>函数签名与参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> errorfds,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p><p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><h3 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p><p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p><p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p><p>每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。</p><h3 id="socket-与-fd-的关系"><a href="#socket-与-fd-的关系" class="headerlink" title="socket 与 fd 的关系"></a>socket 与 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br></pre></td></tr></table></figure><p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。</p><p>可以这样理解：socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。socket 与 fd 是一一对应的。通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件。这也符合 Unix“一切皆文件”的哲学。</p><p>后面可以将 socket 和 fd 视为同义词。</p><h3 id="fd-set-文件描述符集合"><a href="#fd-set-文件描述符集合" class="headerlink" title="fd_set 文件描述符集合"></a>fd_set 文件描述符集合</h3><p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p><p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;  <span class="comment">// 将 fd_set 所有位置 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;   <span class="comment">// 将 fd_set 某一位置 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fd_set)</span>;  <span class="comment">// 将 fd_set 某一位置 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">// 检测 fd_set 某一位是否为 1</span></span><br></pre></td></tr></table></figure><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><p>下图的代码说明：</p><ol><li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li><li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li><li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li><li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li><li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li><li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li></ol><p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p><p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p><p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/15732186159520.jpg" alt="15732186159520"></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 和 select 几乎没有区别。poll 在用户态通过<strong>数组</strong>方式<strong>传递</strong>文件描述符，在内核会转为<strong>链表</strong>方式<strong>存储</strong>，没有最大数量的限制。</p><p>poll 的函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>fds</code> 是一个 <code>pollfd</code> 结构体类型的数组，调用 <code>poll()</code> 时必须通过 <code>nfds</code> 指出数组 <code>fds</code> 的大小，即文件描述符的数量。</p><p>poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><p>如下的代码中，先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><p><strong>第一点</strong>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p><strong>第二点</strong>， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p>从下图你可以看到 epoll 相关的接口作用：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/epoll.png" alt="img"></p><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><blockquote><p>插个题外话，网上文章不少说，<code>epoll_wait</code> 返回时，对于就绪的事件，epoll 使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。</p><p>这是错的！看过 epoll 内核源码的都知道，<strong>压根就没有使用共享内存这个玩意</strong>。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 <code>__put_user</code> 函数，这个函数就是将数据从内核拷贝到用户空间。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/__put_user.png" alt="img"></p><p>好了，这个题外话就说到这了，我们继续</p></blockquote><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p><p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p><p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p><p><code>epoll</code> 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>fd</code> 表示要监听的目标文件描述符</li><li><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</li><li><code>op</code>表示要对 <code>fd</code> 执行的操作，有以下几种：<ul><li><code>EPOLL_CTL_ADD</code>：为 <code>fd</code> 添加一个监听事件 <code>event</code></li><li><code>EPOLL_CTL_MOD</code>：Change the event event associated with the target file descriptor fd（<code>event</code> 是一个结构体变量，这相当于变量 <code>event</code> 本身没变，但是更改了其内部字段的值）</li><li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code> 的所有监听事件，这种情况下 <code>event</code> 参数没用</li></ul></li></ul><p>返回值 0 或 -1，表示上述操作成功与否。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li><li><code>maxevents</code> 指定 <code>events</code> 的大小</li><li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li></ul><p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）</strong>和<strong>水平触发（level-triggered，LT）</strong>。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><blockquote><p>另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：</p><blockquote><p>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.</p></blockquote><p>我谷歌翻译的结果：</p><blockquote><p>在Linux下，select() 可能会将一个 socket 文件描述符报告为 “准备读取”，而后续的读取块却没有。例如，当数据已经到达，但经检查后发现有错误的校验和而被丢弃时，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 O_NONBLOCK 可能更安全。</p></blockquote><p>简单点理解，就是<strong>多路复用 API 返回的事件并不一定可读写的</strong>，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I/O？"></a>为什么边缘触发必须使用非阻塞 I/O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</li><li><code>select</code> 可以使用阻塞 I/O 通过 <code>select</code> 获取到所有可读的文件描述符后，遍历每个文件描述符，<code>read</code> 一次数据<ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul></li><li>在 <code>epoll</code> 的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知<ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li></ul></li></ul><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。</p><p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。</p><ul><li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li></ul><p>而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。</p><p>I/O 多路复用在一定程度上成就了 Redis，这是我的理解，没有 I/O多路复用，Redis 可能就没这么快了，也许吧。</p><p>说说面试，前两天有三次面试，这让我觉得机会又来了，这也过了两三天了，都还没挂，也是好消息了，这三场面试也是让我学到了不少的东西，之前一直闷着头学习总是觉得没有方向，东一榔头西一棒槌，面试找到了不足，最近这几天也都在去补，所以还没怎么开始学新的内容，不过明天应该就差不多了，不管是学习还是实习又或者是秋招，都祝我好运。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">https://imageslr.com/2020/02/27/select-poll-epoll.html</a></p><p><a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</a></p><p><a href="https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久很久以前（三天前），我被问到一个熟悉又陌生的问题，了解I/O多路复用吗？我回答，了解但是还没开始学？是的，我学习的领域就是这么广泛又浅显，名词我都了解，但是就是不知道具体是什么。&lt;/p&gt;
&lt;p&gt;说到 I/O多路复用，我学习的博客都把他归到了操作系统一类里面，我也学过操作</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法大揭秘</title>
    <link href="http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/"/>
    <id>http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/</id>
    <published>2024-06-20T08:17:28.000Z</published>
    <updated>2024-06-20T12:54:00.350Z</updated>
    
    <content type="html"><![CDATA[<p>从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。</p><p>学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之前一直拖着没总结的东西重新学习并总结一下。</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法（sorting algorithm）用于对一组数据按照特定的顺序进行排序。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。</p><p>排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620163619694.png" alt="image-20240620163619694"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p><p><strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p><p><strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。</p><p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure><p><strong>自适应性</strong>：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。</p><p>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。</p><p><strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $𝑂(𝑛 log⁡𝑛)$ 。而非比较排序不使用比较运算符，时间复杂度可达 $𝑂(𝑛)$ ，但其通用性相对较差。</p><h2 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h2><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</p><p>接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。先看看各种算法的比较：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="image"></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>选择排序（selection sort）</strong>的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p><p><strong>算法步骤</strong>：</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ol><p><strong>动画演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1c7e20f306ddc02eb4e3a50fa7817ff4.gif" alt="img"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// 外循环：未排序区间为[i, n-1]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="comment">// 内循环：找到未排序区间内最小（大）的元素</span></span><br><span class="line">k := i</span><br><span class="line"><span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[k] &#123;</span><br><span class="line"><span class="comment">// 记录最小元素的值</span></span><br><span class="line">k = j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛2)、非自适应排序</strong>：外循环共 𝑛−1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛−1、…、3、2 轮内循环，求和为 $(𝑛−1)(𝑛+2)/2$ 。</li><li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>非稳定排序</strong>：如图 11-3 所示，元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620170153391.png" alt="image-20240620170153391"></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>冒泡排序（bubble sort）</strong>通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p><p><strong>算法步骤：</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/33a947c71ad62b254cab62e5364d2813.gif" alt="img"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为[0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回。</p><p>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 $𝑂(𝑛^2) $；但当输入数组完全有序时，可达到最佳时间复杂度 $𝑂(𝑛) $。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortWithFlag</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        flag := <span class="literal">false</span> <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">false</span> &#123; <span class="comment">// 此轮“冒泡”未交换任何元素，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 $𝑂(n^2)$、自适应排序</strong>：各轮“冒泡”遍历的数组长度依次为 𝑛−1、𝑛−2、…、2、1 ，总和为$ (𝑛−1)𝑛/2 $。在引入 <code>flag</code> 优化后，最佳时间复杂度可达到 $𝑂(𝑛)$ 。</li><li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>稳定排序</strong>：由于在“冒泡”中遇到相等元素不交换。</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>插入排序（insertion sort）</strong>是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p><p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p><p><strong>算法步骤：</strong></p><p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/91b76e8e4dab9b0cad9a017d7dd431e2.gif" alt="img"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        base := nums[i]</span><br><span class="line">        j := i<span class="number">-1</span></span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 $𝑂(𝑛2)$、自适应排序</strong>：在最差情况下，每次插入操作分别需要循环 𝑛−1、𝑛−2、…、2、1 次，求和得到 $(𝑛−1)𝑛/2 $，因此时间复杂度为 $𝑂(𝑛2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 𝑂(𝑛) 。</li><li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>稳定排序</strong>：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>插入排序的时间复杂度为$ 𝑂(𝑛^2) $，而我们即将学习的快速排序的时间复杂度为$ 𝑂(𝑛log⁡𝑛) $。尽管插入排序的时间复杂度更高，<strong>但在数据量较小的情况下，插入排序通常更快</strong>。</p><p>这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 𝑂(𝑛log⁡𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，𝑛2 和 𝑛log⁡𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。</p><p>实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。</p><p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $𝑂(𝑛^2) $，但在实际情况中，<strong>插入排序的使用频率显著高于冒泡排序和选择排序</strong>，主要有以下原因。</p><ul><li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，<strong>冒泡排序的计算开销通常比插入排序更高</strong>。</li><li>选择排序在任何情况下的时间复杂度都为 $𝑂(𝑛^2)$ 。<strong>如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</strong>。</li><li>选择排序不稳定，无法应用于多级排序。</li></ul><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>希尔排序（Shell Sort）</strong>通过将待排序数组分割成若干子序列，使得每个子序列分别进行插入排序，随着算法的进行逐渐减小子序列的间隔，最终使整个数组变得有序。希尔排序在最后一步中使用一个间隔为 1 的插入排序，这一步能够高效地将几乎有序的数组进行完全排序。</p><p><strong>算法步骤：</strong></p><ol><li><strong>选择初始增量（gap）</strong>：选择一个初始的增量序列，可以是数组长度的一半或者其他一些预定义的序列。</li><li><strong>分割子序列</strong>：根据当前的增量将数组分割成若干子序列，每个子序列由相隔增量距离的元素组成。</li><li><strong>对子序列进行插入排序</strong>：对每个子序列分别进行插入排序。</li><li><strong>缩小增量</strong>：减少增量的值，通常减小为原来的一半或者按照其他规则减小。</li><li><strong>重复上述步骤</strong>：重复分割子序列和排序的过程，直到增量缩小到 1，此时对整个数组进行一次插入排序。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="image"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 初始增量，通常取数组长度的一半</span></span><br><span class="line">    <span class="keyword">for</span> gap := n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := gap; i &lt; n; i++ &#123;</span><br><span class="line">            temp := nums[i]</span><br><span class="line">            j := i</span><br><span class="line">            <span class="keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-3"><a href="#算法特性-3" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度</strong>：希尔排序的时间复杂度依赖于增量序列的选择，最坏情况下为 $O(n^2)$，但在实际应用中通常表现优于插入排序和冒泡排序。</li><li><strong>空间复杂度</strong>：希尔排序是原地排序算法，空间复杂度为$ O(1)$。</li><li><strong>稳定性</strong>：希尔排序不是稳定排序，因为相同元素在不同子序列中的相对位置可能会发生变化。</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。</p><ol><li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ol><p><strong>算法步骤：</strong></p><p><strong>“划分阶段”</strong>从顶至底递归地将数组从中点切分为两个子数组。</p><ol><li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li><li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时终止。</li></ol><p><strong>“合并阶段”</strong>从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。</p><p><strong>动图演示：</strong></p><p><img src="https://static001.geekbang.org/infoq/cd/cdda3f11c6efbc01577f5c29a9066772.gif" alt="img"></p><p>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。</p><ul><li><strong>后序遍历</strong>：先递归左子树，再递归右子树，最后处理根节点。</li><li><strong>归并排序</strong>：先递归左子数组，再递归右子数组，最后处理合并。</li></ul><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 合并左子树组和右子数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span></span><br><span class="line">    <span class="comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化左子树组和右子数组的起始索引</span></span><br><span class="line">    i, j, k := left, mid+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= right &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j] &#123;</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将左子树组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &#123;</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j &lt;= right &#123;</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(tmp); k++ &#123;</span><br><span class="line">        nums[left+k] = tmp[k]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 划分阶段</span></span><br><span class="line">    mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">    mergeSort(nums, left, mid)</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-4"><a href="#算法特性-4" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：划分产生高度为 log⁡𝑛 的递归树，每层合并的总操作数量为 𝑛 ，因此总体时间复杂度为 𝑂(𝑛log⁡𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛)、非原地排序</strong>：递归深度为 log⁡𝑛 ，使用 𝑂(log⁡𝑛) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 𝑂(𝑛) 大小的额外空间。</li><li><strong>稳定排序</strong>：在合并过程中，相等元素的次序保持不变。</li></ul><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>对于链表，归并排序相较于其他排序算法具有显著优势，<strong>可以将链表排序任务的空间复杂度优化至 𝑂(1)</strong> 。</p><ul><li><strong>划分阶段</strong>：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。</li><li><strong>合并阶段</strong>：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p><strong>快速排序（quick sort）</strong>是一种基于分治策略的排序算法，运行高效，应用广泛。</p><p>快速排序的核心操作是 “哨兵划分”，其目标是：选择数组中某个元素作为 “基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p><p><strong>算法步骤：</strong></p><ol><li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li><li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤 <code>2</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ol><p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c411339b79f92499dcb7b5f304c826f4.gif" alt="img"></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>哨兵划分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哨兵划分</span></span><br><span class="line">    pivot := q.partition(nums, left, right)</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    q.quickSort(nums, left, pivot<span class="number">-1</span>)</span><br><span class="line">    q.quickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuickSort 非递归快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        high := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        low := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        p := Partition(arr, low, high)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p<span class="number">-1</span> &gt; low &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, low, p<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p+<span class="number">1</span> &lt; high &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, p+<span class="number">1</span>, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-5"><a href="#算法特性-5" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、自适应排序</strong>：在平均情况下，哨兵划分的递归层数为 log⁡𝑛 ，每层中的总循环数为 𝑛 ，总体使用 𝑂(𝑛log⁡𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 $𝑂(𝑛^2) $时间。</li><li><strong>空间复杂度为 𝑂(𝑛)、原地排序</strong>：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。</li><li><strong>非稳定排序</strong>：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</li></ul><h2 id="快速排序为什么快？"><a href="#快速排序为什么快？" class="headerlink" title="快速排序为什么快？"></a>快速排序为什么快？</h2><p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。</p><ul><li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 $𝑂(𝑛^2) $，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛log⁡𝑛) 的时间复杂度下运行。</li><li><strong>缓存使用效率高</strong>：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。</li><li><strong>复杂度的常数系数小</strong>：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="基准数优化"><a href="#基准数优化" class="headerlink" title="基准数优化"></a>基准数优化</h3><p><strong>快速排序在某些输入下的时间效率可能降低</strong>。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。</p><p>为了尽量避免这种情况发生，<strong>我们可以优化哨兵划分中的基准数的选取策略</strong>。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。</p><p>需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。</p><p>为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），<strong>并将这三个候选元素的中位数作为基准数</strong>。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 $𝑂(𝑛^2) $的概率大大降低。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选取三个候选元素的中位数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> medianThree(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    l, m, r := nums[left], nums[mid], nums[right]</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid <span class="comment">// m 在 l 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">return</span> left <span class="comment">// l 在 m 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哨兵划分（三数取中值）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    med := q.medianThree(nums, left, (left+right)/<span class="number">2</span>, right)</span><br><span class="line">    <span class="comment">// 将中位数交换至数组最左端</span></span><br><span class="line">    nums[left], nums[med] = nums[med], nums[left]</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">//从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">//从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">//返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。</p><p>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过 𝑛/2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序（尾递归优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortTailCall)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        pivot := q.partition(nums, left, right)</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> pivot-left &lt; right-pivot &#123;</span><br><span class="line">            q.quickSort(nums, left, pivot<span class="number">-1</span>) <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q.quickSort(nums, pivot+<span class="number">1</span>, right) <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 𝑂(𝑛log⁡𝑛) 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</p><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。</p><ol><li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li><li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li></ol><p>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。</p><p><strong>算法步骤：</strong></p><p>设数组的长度为 𝑛 </p><ol><li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li><li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。</li><li>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。</li><li>循环执行第 <code>2.</code> 步和第 <code>3.</code> 步。循环 𝑛−1 轮后，即可完成数组排序。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7073c729230e1a2c3c3c9207b25f6b43.gif" alt="img"></p><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(nums *[]<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        r := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">        ma := i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = r</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        siftDown(nums, <span class="built_in">len</span>(*nums), i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span></span><br><span class="line">        (*nums)[<span class="number">0</span>], (*nums)[i] = (*nums)[i], (*nums)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        siftDown(nums, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-6"><a href="#算法特性-6" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：建堆操作使用 𝑂(𝑛) 时间。从堆中提取最大元素的时间复杂度为 𝑂(log⁡𝑛) ，共循环 𝑛−1 轮。</li><li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：几个指针变量使用 𝑂(1) 空间。元素交换和堆化操作都是在原数组上进行的。</li><li><strong>非稳定排序</strong>：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li></ul><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>计数排序（counting sort）不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3c7ddb59df2d21b287e42a7b908409cb.gif" alt="img"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>给定一个长度为 𝑛 的数组 <code>nums</code> ，其中的元素都是“非负整数”。</p><p><strong>算法步骤：</strong></p><ol><li>遍历数组，找出其中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚+1 的辅助数组 <code>counter</code> 。</li><li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加 1 即可。</li><li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字出现次数从小到大的顺序填入 <code>nums</code> 即可。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620202353083.png" alt="image-20240620202353083"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 简单实现，无法用于排序对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortNaive</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="number">0</span>, <span class="number">0</span>; num &lt; m+<span class="number">1</span>; num++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; counter[num]; j++ &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计数排序与桶排序的联系</p><p>从桶排序的角度看，我们可以将计数排序中的计数数组 <code>counter</code> 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。</p></blockquote><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>细心的同学可能已经发现了，<strong>如果输入数据是对象，上述步骤 <code>3.</code> 就失效了</strong>。假设输入数据是商品对象，我们想按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。</p><p>那么如何才能得到原数据的排序结果呢？我们首先计算 <code>counter</code> 的“前缀和”。顾名思义，索引 <code>i</code> 处的前缀和 <code>prefix[i]</code> 等于数组前 <code>i</code> 个元素之和：</p><script type="math/tex; mode=display">prefix[𝑖]=∑_{𝑗=0}^𝑖counter[j]</script><p><strong>前缀和具有明确的意义，<code>prefix[num] - 1</code> 代表元素 <code>num</code> 在结果数组 <code>res</code> 中最后一次出现的索引</strong>。这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 <code>nums</code> 的每个元素 <code>num</code> ，在每轮迭代中执行以下两步。</p><ol><li>将 <code>num</code> 填入数组 <code>res</code> 的索引 <code>prefix[num] - 1</code> 处。</li><li>令前缀和 <code>prefix[num]</code> 减小 1 ，从而得到下次放置 <code>num</code> 的索引。</li></ol><p>遍历完成后，数组 <code>res</code> 中就是排序好的结果，最后使用 <code>res</code> 覆盖原数组 <code>nums</code> 即可。</p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        counter[i+<span class="number">1</span>] += counter[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment">// 初始化数组 res 用于记录结果</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        num := nums[i]</span><br><span class="line">        <span class="comment">// 将 num 放置到对应索引处</span></span><br><span class="line">        res[counter[num]<span class="number">-1</span>] = num</span><br><span class="line">        <span class="comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">        counter[num]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="built_in">copy</span>(nums, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-7"><a href="#算法特性-7" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛+𝑚)、非自适应排序</strong> ：涉及遍历 <code>nums</code> 和遍历 <code>counter</code> ，都使用线性时间。一般情况下 𝑛≫𝑚 ，时间复杂度趋于 𝑂(𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑚)、非原地排序</strong>：借助了长度分别为 𝑛 和 𝑚 的数组 <code>res</code> 和 <code>counter</code> 。</li><li><strong>稳定排序</strong>：由于向 <code>res</code> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <code>nums</code> 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <code>nums</code> 也可以得到正确的排序结果，但结果是非稳定的。</li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>看到这里，你也许会觉得计数排序非常巧妙，仅通过统计数量就可以实现高效的排序。然而，使用计数排序的前置条件相对较为严格。</p><p><strong>计数排序只适用于非负整数</strong>。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去。</p><p><strong>计数排序适用于数据量大但数据范围较小的情况</strong>。比如，在上述示例中 𝑚 不能太大，否则会占用过多空间。而当 𝑛≪𝑚 时，计数排序使用 𝑂(𝑚) 时间，可能比 𝑂(𝑛log⁡𝑛) 的排序算法还要慢。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p><strong>桶排序（bucket sort）</strong>是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p><p><strong>算法步骤：</strong></p><p>考虑一个长度为 𝑛 的数组，其元素是范围 [0,1) 内的浮点数。</p><ol><li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li><li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li><li>按照桶从小到大的顺序合并结果。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620203439496.png" alt="image-20240620203439496"></p><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b29c1a8ee42595e7992b6d2eb1030f76.gif" alt="img"></p><h2 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(nums []<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="type">float64</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        buckets[i] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i := <span class="type">int</span>(num * <span class="type">float64</span>(k))</span><br><span class="line">        <span class="comment">// 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i] = <span class="built_in">append</span>(buckets[i], num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="comment">// 使用内置切片排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        sort.Float64s(buckets[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-8"><a href="#算法特性-8" class="headerlink" title="算法特性"></a>算法特性</h2><p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p><ul><li><strong>时间复杂度为 𝑂(𝑛+𝑘)</strong> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 𝑛𝑘 。假设排序单个桶使用 𝑂(𝑛/𝑘<em>log⁡(𝑛/𝑘)) 时间，则排序所有桶使用 𝑂(𝑛log⁡(𝑛/𝑘)) 时间。<em>*当桶数量 𝑘 比较大时，时间复杂度则趋向于 𝑂(𝑛)</em></em> 。合并结果时需要遍历所有桶和元素，花费 𝑂(𝑛+𝑘) 时间。</li><li><strong>自适应排序</strong>：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 𝑂(𝑛2) 时间。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑘)、非原地排序</strong>：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ul><h2 id="如何实现平均分配"><a href="#如何实现平均分配" class="headerlink" title="如何实现平均分配"></a>如何实现平均分配</h2><p>桶排序的时间复杂度理论上可以达到 𝑂(𝑛) ，<strong>关键在于将元素均匀分配到各个桶中</strong>，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。</p><p>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong>。</p><p>如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204021017.png" alt="image-20240620204021017"></p><p>如果我们提前知道商品价格的概率分布，<strong>则可以根据数据概率分布设置每个桶的价格分界线</strong>。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p><p>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204045066.png" alt="image-20240620204045066"></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>上面介绍了计数排序，它适用于数据量 𝑛 较大但数据范围 𝑚 较小的情况。假设我们需要对 $𝑛=10^6$ 个学号进行排序，而学号是一个 8 位数字，这意味着数据范围 $𝑚=10^8 $非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。</p><h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p><strong>基数排序（radix sort）</strong>的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</p><p><strong>算法步骤：</strong></p><p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的流程如图所示。</p><ol><li>初始化位数 𝑘=1 。</li><li>对学号的第 𝑘 位执行“计数排序”。完成后，数据会根据第 𝑘 位从小到大排序。</li><li>将 𝑘 增加 1 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204242169.png" alt="image-20240620204242169"></p><p>对于一个 𝑑 进制的数字 𝑥 ，要获取其第 𝑘 位 $𝑥_𝑘 $，可以使用以下计算公式：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204349152.png" alt="image-20240620204349152"></p><p>其中 ⌊𝑎⌋ 表示对浮点数 𝑎 向下取整，而 <code>mod d</code> 表示对 𝑑 取模（取余）。对于学号数据，𝑑=10 且 𝑘∈[1,8] 。</p><p>此外，我们需要小幅改动计数排序代码，使之可以根据数字的第 𝑘 位进行排序：</p><blockquote><p>为什么从最低位开始排序？</p><p>在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 𝑎&lt;𝑏 ，而第二轮排序结果 𝑎&gt;𝑏 ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。</p></blockquote><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3a6f1e5059386523ed941f0d6c3a136e.gif" alt="img"></p><h2 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">(num, exp <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序（根据 nums 第 k 位排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortDigit</span><span class="params">(nums []<span class="type">int</span>, exp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        d := digit(nums[i], exp) <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++             <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        counter[i] += counter[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        d := digit(nums[i], exp)</span><br><span class="line">        j := counter[d] - <span class="number">1</span> <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]    <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--        <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    max := math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">            max = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; max &gt;= exp; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        countingSortDigit(nums, exp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-9"><a href="#算法特性-9" class="headerlink" title="算法特性"></a>算法特性</h2><p>相较于计数排序，基数排序适用于数值范围较大的情况，<strong>但前提是数据必须可以表示为固定位数的格式，且位数不能过大</strong>。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 𝑂(𝑛𝑘)≫𝑂(𝑛2) 。</p><ul><li><strong>时间复杂度为 𝑂(𝑛𝑘)、非自适应排序</strong>：设数据量为 𝑛、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 𝑂(𝑛+𝑑) 时间，排序所有 𝑘 位使用 𝑂((𝑛+𝑑)𝑘) 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 𝑂(𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑑)、非原地排序</strong>：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 <code>res</code> 和 <code>counter</code> 。</li><li><strong>稳定排序</strong>：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果。</li></ul><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>Q</strong>：排序算法稳定性在什么情况下是必需的？</p><p>在现实中，我们有可能基于对象的某个属性进行排序。例如，学生有姓名和身高两个属性，我们希望实现一个多级排序：先按照姓名进行排序，得到 <code>(A, 180) (B, 185) (C, 170) (D, 170)</code> ；再对身高进行排序。由于排序算法不稳定，因此可能得到 <code>(D, 170) (C, 170) (A, 180) (B, 185)</code> 。</p><p>可以发现，学生 D 和 C 的位置发生了交换，姓名的有序性被破坏了，而这是我们不希望看到的。</p><p><strong>Q</strong>：哨兵划分中“从右往左查找”与“从左往右查找”的顺序可以交换吗？</p><p>不行，当我们以最左端元素为基准数时，必须先“从右往左查找”再“从左往右查找”。这个结论有些反直觉，我们来剖析一下原因。</p><p>哨兵划分 <code>partition()</code> 的最后一步是交换 <code>nums[left]</code> 和 <code>nums[i]</code> 。完成交换后，基准数左边的元素都 <code>&lt;=</code> 基准数，<strong>这就要求最后一步交换前 <code>nums[left] &gt;= nums[i]</code> 必须成立</strong>。假设我们先“从左往右查找”，那么如果找不到比基准数更大的元素，<strong>则会在 <code>i == j</code> 时跳出循环，此时可能 <code>nums[j] == nums[i] &gt; nums[left]</code></strong>。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。</p><p>举个例子，给定数组 <code>[0, 0, 0, 0, 1]</code> ，如果先“从左向右查找”，哨兵划分后数组为 <code>[1, 0, 0, 0, 0]</code> ，这个结果是不正确的。</p><p>再深入思考一下，如果我们选择 <code>nums[right]</code> 为基准数，那么正好反过来，必须先“从左往右查找”。</p><p><strong>Q</strong>：关于尾递归优化，为什么选短的数组能保证递归深度不超过 log⁡𝑛 ？</p><p>递归深度就是当前未返回的递归方法的数量。每轮哨兵划分我们将原数组划分为两个子数组。在尾递归优化后，向下递归的子数组长度最大为原数组长度的一半。假设最差情况，一直为一半长度，那么最终的递归深度就是 log⁡𝑛 。</p><p>回顾原始的快速排序，我们有可能会连续地递归长度较大的数组，最差情况下为 𝑛、𝑛−1、…、2、1 ，递归深度为 𝑛 。尾递归优化可以避免这种情况出现。</p><p><strong>Q</strong>：当数组中所有元素都相等时，快速排序的时间复杂度是 $𝑂(𝑛^2) $吗？该如何处理这种退化情况？</p><p>是的。对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p><p><strong>Q</strong>：桶排序的最差时间复杂度为什么是$ 𝑂(𝑛^2) $？</p><p>最差情况下，所有元素被分至同一个桶中。如果我们采用一个 $𝑂(𝑛^2)$ 算法来排序这些元素，则时间复杂度为$ 𝑂(𝑛^2) $。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到 𝑂(𝑛) 。</li><li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为 𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li><li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至 𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到 𝑂(log⁡𝑛) 。</li><li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为 𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至 𝑂(1) 。</li><li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配。</li><li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并且要求数据能够转换为正整数。</li><li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li></ul><p>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及正向自适应性等优点。然而，正如其他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据数据的特性来选择合适的排序算法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sorting_algorithms_comparison.png" alt="排序算法对比"></p><p>OK了，今天的算法学习就先到这里，该作题了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.hello-algo.com/chapter_sorting/">https://www.hello-algo.com/chapter_sorting/</a></p><p><a href="https://github.com/MisterBooo/Article">https://github.com/MisterBooo/Article</a></p><p><a href="https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4">https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。&lt;/p&gt;
&lt;p&gt;学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之</summary>
      
    
    
    
    <category term="Hello,算法！" scheme="http://example.com/categories/Hello-%E7%AE%97%E6%B3%95%EF%BC%81/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是一致性哈希算法？</title>
    <link href="http://example.com/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
    <id>http://example.com/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/</id>
    <published>2024-06-20T06:45:14.000Z</published>
    <updated>2024-06-20T08:26:14.122Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希算法，一个躺在我书签里两周的知识点，之前就一直说要看要看，结果一直拖，拖到昨天被面试官问了，只能回答说不会。</p><p>一致性哈希算法、一致性算法，这两个内容我一直以为是一样的，所以刚开始决定放在一起学，刚刚得知，两个不是一个东西。露出尴尬的笑容，那就先学一致性哈希算法吧。</p><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p><p>一致性哈希算法是一种常用的分布式算法，其主要用途是在分布式系统中，将数据根据其键（key）进行散列（hash），然后将散列结果映射到环上，再根据数据节点的数量，将环划分为多个区间，每个节点负责处理环上一定区间范围内的数据。</p><p>按照老传统，我们逐步进行学习。</p><h1 id="如何分配请求？"><a href="#如何分配请求？" class="headerlink" title="如何分配请求？"></a>如何分配请求？</h1><p>大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。</p><p>但是问题来了，现在有这么多个节点，要如何保证分配客户端的请求呢？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b752a4f8dcaab8ed4d941ebcc6f606c5.png" alt="img"></p><p>其实这个问题就是负载均衡问题。解决负载均衡问题的算法有很多，不同的负载均衡算法对应的就是不同的分配策略，适应的业务场景也不同。</p><p>最简单的方式，引入一个中间的负载均衡层，让它将外界的请求「轮流」地转发给内部的集群。比如集群有三个节点，外界请求有三个，那么每个节点都会处理一个请求，达到了分配请求的目的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d3279ad754257977f98e702cb156e9cf.png" alt="img"></p><p>考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做加权轮询。</p><p>加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。</p><p>但是，加权轮询算法是无法应对「分布式系统（数据分片的系统）」的。因为分布式系统中，每个节点存储的数据是不相同的。</p><p>当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如<strong>一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的</strong>，不是说任意访问一个节点都可以得到缓存结果的。</p><p>因此，我们要想一个能应对分布式系统的负载均衡算法。</p><h1 id="使用普通哈希的问题"><a href="#使用普通哈希的问题" class="headerlink" title="使用普通哈希的问题"></a>使用普通哈希的问题</h1><p>小脑袋瓜机灵的同学很快就会想到 <strong>哈希算法</strong>。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 <code>key</code> 确定到一个节点了，可以满足系统的负载均衡需求。</p><p>哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 <code>hash(key) % 3</code> 公式对数据进行了映射。</p><p>如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key) % 3</span><br></pre></td></tr></table></figure><p>如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。</p><p>但是有一个很致命的问题，<strong>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</strong>，否则会出现查询不到数据的问题。</p><p>分布式集群中，对机器的添加、删除或者机器故障后自动脱离集群这些操作都是集群管理最基本的功能。如果采用那个常用的 <code>hash(object)%N</code> 取模的方式，在节点进行添加或删除后，需要重新进行迁移改变映射关系，否则可能导致原有的数据无法找到。</p><p><strong>举个例子：</strong></p><p>随着业务和流量的增加，假如我们的 Redis 查询服务节点扩展到了3个，为了将查询请求进行均衡，每次请求都在相同的Redis中，使用hv = hash(key) % 3的方式计算，对每次查询请求都通过hash值计算，得出来0、1 、2的值分别对应服务节点的编号，计算得到的hv的值就去对应的节点处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/462342823ffbc816c623152f48240598.png" alt="img"></p><p>但是这里有个问题，服务增减是需要对此时的key进行重新计算，比如减少一个服务的时候，此时需要按 hv = hash(key) % 2计算，而增加一个服务节点的时候需要按hv = hash(key) % 4计算，而这种取模基数的变化会改变大部分原来的映射关系。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3555435d14a54a088513b8dcc1049521.png" alt="img"></p><p>这个时候只能进行数据迁移，非常麻烦，所以我们应该选择一个更加好用的方案。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法能够很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p><p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</p><p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0ea3960fef48d4cbaeb4bec4345301e7.png" alt="img"></p><p>一致性哈希要进行两步哈希：</p><ul><li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li><li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；</li></ul><p>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p><p>问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？</p><p>答案是，映射的结果值往<strong>顺时针的方向的找到第一个节点</strong>，就是存储该数据的节点。</p><p>举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/83d7f363643353c92d252e34f1d4f687.png" alt="img"></p><p>接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。</p><p>比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。</p><p>所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：</p><ul><li>首先，对 key 进行哈希计算，确定此 key 在环上的位置；</li><li>然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。</li></ul><p>知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？</p><p>假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f8909edef2f3949f8945bb99380baab3.png" alt="img"></p><p>你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。</p><p>假设节点数量从 3 减少到了 2，比如将节点 A 移除：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/31485046f1303b57d8aaeaab103ea7ab.png" alt="img"></p><p>你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。</p><p>因此，<strong>在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</strong>。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。</p><p>但是<strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，这样就会带来一个问题，会有大量的请求集中在一个节点上。</p><p>比如，下图中 3 个节点的映射位置都在哈希环的右半边：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d528bae6fcec2357ba2eb8f324ad9fd5.png" alt="img"></p><p>这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。</p><p>另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。</p><p>比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。</p><p>所以，<strong>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</strong>。</p><h1 id="如何通过虚拟节点提高均衡度？"><a href="#如何通过虚拟节点提高均衡度？" class="headerlink" title="如何通过虚拟节点提高均衡度？"></a>如何通过虚拟节点提高均衡度？</h1><p>要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。</p><p>但问题是，实际中我们没有那么多节点。所以这个时候我们就加入<strong>虚拟节点</strong>，也就是对一个真实节点做多个副本。</p><p>具体做法是，<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</strong></p><p>比如对每个节点分别设置 3 个虚拟节点：</p><ul><li>对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03</li><li>对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03</li><li>对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03</li></ul><p>引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/602393536805bc21c12db2ecff73d4ab.png" alt="img"></p><p>你可以看到，<strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</p><p>上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。</p><p>另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</p><p>比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p><p>而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</p><p>因此，<strong>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同的负载均衡算法适用的业务场景也不同的。</p><p>轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。</p><p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p><p>为了减少迁移的数据量，就出现了一致性哈希算法。</p><p>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><p>但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</p><p>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</p><p>在聊到这个问题之前，我们讨论的是哈希冲突的解决方案，然后面试官抛出了这个问题，幸亏我没有胡乱回答，这和解决哈希冲突好像没什么关系。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93</a></p><p><a href="https://cloud.tencent.com/developer/article/2373162">https://cloud.tencent.com/developer/article/2373162</a></p><p><a href="https://github.com/fupengfei058/blog/blob/master/%E4%BA%94%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(consistent%20hashing).md">https://github.com/fupengfei058/blog/blob/master/%E4%BA%94%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(consistent%20hashing).md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一致性哈希算法，一个躺在我书签里两周的知识点，之前就一直说要看要看，结果一直拖，拖到昨天被面试官问了，只能回答说不会。&lt;/p&gt;
&lt;p&gt;一致性哈希算法、一致性算法，这两个内容我一直以为是一样的，所以刚开始决定放在一起学，刚刚得知，两个不是一个东西。露出尴尬的笑容，那就先学一致</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang中的闭包，你真的了解吗？</title>
    <link href="http://example.com/2024/06/20/Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/"/>
    <id>http://example.com/2024/06/20/Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/</id>
    <published>2024-06-20T04:58:35.000Z</published>
    <updated>2024-06-20T06:20:49.595Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p><p>因为Go语言的函数本身可以作为值进行传递，既支持匿名函数和闭包，又能满足接口，所以 Go 语言的函数属于一等公民。</p><p>本文将由一道题引出 Go 中的闭包。这是 Go 语言爱好者周刊第 90 期的一道题目。以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">app</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">t := <span class="string">&quot;Hi&quot;</span></span><br><span class="line">c := <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">t = t + <span class="string">&quot; &quot;</span> + b</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := app()</span><br><span class="line">b := app()</span><br><span class="line">a(<span class="string">&quot;go&quot;</span>)</span><br><span class="line">fmt.Println(b(<span class="string">&quot;All&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下，这里会输出什么，如果再加上一行代码 <code>fmt.Println(a(&quot;All&quot;))</code> ，它又会输出什么内容？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//fmt.Println(b(&quot;All&quot;))</span><br><span class="line">Hi All</span><br><span class="line">//fmt.Println(a(&quot;All&quot;))</span><br><span class="line">Hi go All</span><br></pre></td></tr></table></figure><p>发现什么神奇的东西了吗，新加入的一行代码的输出结果竟然包含着第17行中输入的字符串，这和我们之前学过的东西都不太一样，别急，继续往下看吧。</p><h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p>维基百科对<a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学">闭包的定义</a>) ：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了<strong>一个函数</strong>（通常是其入口地址）和<strong>一个关联的环境</strong>（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如 C++）。</p></blockquote><p>关于（函数）闭包，有几个关键点：</p><ul><li>函数是一等公民；</li><li>闭包所处环境，可以引用环境里的值；</li></ul><p>问到什么是闭包时，网上一般这么回答的：</p><blockquote><p>在支持函数是一等公民的语言中，一个函数的返回值是另一个函数，被返回的函数可以访问父函数内的变量，当这个被返回的函数在外部执行时，就产生了闭包。</p></blockquote><p>所以，上面题目中，函数 app 的返回值是另一个函数，因此产生了闭包。</p><p>回到最开始的问题：什么是闭包？</p><p>go官方的解释是：Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。</p><p>简单来说，闭包是由函数和与其相关的引用环境组合而成的实体。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/UML.jpg" alt="img"></p><p><strong>函数</strong>指的是在闭包实际实现的时候，往往通过调用一个外部函数返回其内部函数来实现的。用户得到一个闭包，也等同于得到了这个内部函数，每次执行这个闭包就等同于执行内部函数。</p><p><strong>引用环境</strong>可以简单理解为在函数外部定义但在函数内被引用的变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的所引用的外部变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。</p><h1 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h1><p>闭包是包含自由变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。由于自由变量包含在代码块中，所以只要闭包还被使用，那么这些自由变量以及它们引用的对象就不会被释放，要执行的代码为自由变量提供绑定的计算环境。</p><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</p><p>Golang 中的闭包同样也会引用到函数外的变量，闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。从形式上看，匿名函数都是闭包。</p><p>其实我们可以将闭包函数看成一个类 (C++)，一个闭包函数调用就是实例化一个对象，闭包的自由变量就是类的成员变量，闭包函数的参数就是类的函数对象的参数。</p><p>这让我想起了一句名言：<strong>对象是附有行为的数据，而闭包是附有数据的行为</strong>。</p><h1 id="闭包的意义"><a href="#闭包的意义" class="headerlink" title="闭包的意义"></a>闭包的意义</h1><p>我们会发现，使用普通函数和全局变量完全可以实现和闭包相同的功能。</p><p><strong>为什么不用全局变量？</strong></p><ul><li>缩小变量作用域，减少对全局变量的污染。上面的问题如果用全局变量进行实现，全局变量容易被其他人污染。</li><li>同时，如果我要实现n个闭包，如果我使用全局变量，就需要维护n个函数对应的全局变量。</li></ul><h1 id="使用闭包的一些例子"><a href="#使用闭包的一些例子" class="headerlink" title="使用闭包的一些例子"></a>使用闭包的一些例子</h1><h2 id="隔离数据"><a href="#隔离数据" class="headerlink" title="隔离数据"></a>隔离数据</h2><p>假设你想要创建一个函数，该函数可以访问即使在函数退出后仍会保留的数据。例如，您想要计算该函数被调用的次数，或者您想要创建一个斐波那契数生成器，但您不希望其他人访问该数据（这样他们就不会意外更改它）。您可以使用闭包来实现这一点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  gen := makeFibGen()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(gen())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeFibGen</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  f1 := <span class="number">0</span></span><br><span class="line">  f2 := <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    f2, f1 = (f1 + f2), f2</span><br><span class="line">    <span class="keyword">return</span> f1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装函数并创建中间件"><a href="#包装函数并创建中间件" class="headerlink" title="包装函数并创建中间件"></a>包装函数并创建中间件</h2><p>Go 中的函数是<a href="https://en.wikipedia.org/wiki/First-class_citizen#Functions">一等公民</a>。这意味着你不仅可以动态创建匿名函数，还可以将函数作为参数传递给函数。例如，在创建 Web 服务器时，通常会提供一个处理特定路由的 Web 请求的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, <span class="string">&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，该函数<code>hello()</code>被传递给<code>http.HandleFunc()</code>函数，并在该路由匹配时被调用。</p><p>虽然此代码不需要闭包，但如果我们想用更多逻辑包装处理程序，闭包非常有用。一个完美的例子是当我们想要创建中间件来在处理程序执行之前或之后执行工作时。</p><p>让我们看看一个简单的计时器中间件在 Go 中是如何工作的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, timed(hello))</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timed</span><span class="params">(f <span class="keyword">func</span>(http.ResponseWriter, *http.Request)</span></span>) <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    f(w, r)</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The request took&quot;</span>, end.Sub(start))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, <span class="string">&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们的<code>timed()</code>函数接受一个可用作处理程序函数的函数，并返回相同类型的函数，但返回的函数与传递给它的函数不同。返回的闭包记录当前时间，调用原始函数，最后记录结束时间并打印出请求的持续时间。所有这些都与处理程序函数内部实际发生的事情无关。</p><p>现在我们需要对处理程序进行计时，将它们包装起来<code>timed(handler)</code>并将闭包传递给<code>http.HandleFunc()</code>函数调用。</p><h2 id="访问通常不可用的数据"><a href="#访问通常不可用的数据" class="headerlink" title="访问通常不可用的数据"></a>访问通常不可用的数据</h2><p>闭包还可用于将数据包装在函数内部，否则函数通常无法访问这些数据。例如，如果你想在不使用全局变量的情况下为处理程序提供对数据库的访问权限，则可以编写如下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line">  Url <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(url <span class="type">string</span>)</span></span> Database &#123;</span><br><span class="line">  <span class="keyword">return</span> Database&#123;url&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db := NewDatabase(<span class="string">&quot;localhost:5432&quot;</span>)</span><br><span class="line"></span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello(db))</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(db Database)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, db.Url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以编写处理函数，就好像它们可以访问对象一样，<code>Database</code>同时仍返回具有预期签名的函数。这使我们能够绕过不允许我们传递自定义变量而不诉诸全局变量或任何此类变量的<code>http.HandleFunc()</code>事实。</p><h2 id="使用闭包进行二分搜索"><a href="#使用闭包进行二分搜索" class="headerlink" title="使用闭包进行二分搜索"></a>使用闭包进行二分搜索</h2><p>闭包也经常需要使用标准库中的包，比如<a href="https://golang.org/pkg/sort/">sort</a>包。</p><p>此包为我们提供了大量有用的函数和代码，用于对已排序列表进行排序和搜索。例如，如果您想对整数切片进行排序，然后在切片中搜索数字 7，则可以<code>sort</code>像这样使用该包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span>&#125;</span><br><span class="line">  sort.Ints(numbers)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Sorted:&quot;</span>, numbers)</span><br><span class="line">  index := sort.SearchInts(numbers, <span class="number">7</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;7 is at index:&quot;</span>, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果你想要搜索每个元素都是自定义类型的切片，会发生什么情况？或者，如果你想要查找第一个大于或等于 7 的数字的索引，而不仅仅是第一个 7 的索引，会发生什么情况？</p><p>为此，您应该使用<a href="https://golang.org/pkg/sort/#Search">sort.Search()</a>函数，并且需要传入一个闭包，该闭包可用于确定特定索引处的数字是否符合您的条件。</p><blockquote><p><code>sort.Search</code>是二分查找</p><p>该<code>sort.Search</code>函数执行二分搜索，因此它期望一个闭包，该闭包将对满足条件之前的任何索引返回 false，对满足条件之后的任何索引返回 true。这意味着您不能使用它来“在列表中找到 7 的索引”，而是需要将您的逻辑改写为“第一个大于或等于 7 的数字的索引是什么？”，然后在获取索引后检查该数字是否为 7。</p></blockquote><p>让我们使用上面描述的例子来实际看一下这一点；我们将搜索列表中大于或等于 7 的第一个数字的索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">-5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span>&#125;</span><br><span class="line">  sort.Ints(numbers)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Sorted:&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">  index := sort.Search(<span class="built_in">len</span>(numbers), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers[i] &gt;= <span class="number">7</span></span><br><span class="line">  &#125;)</span><br><span class="line">  fmt.Println(<span class="string">&quot;The first number &gt;= 7 is at index:&quot;</span>, index)</span><br><span class="line">  fmt.Println(<span class="string">&quot;The first number &gt;= 7 is:&quot;</span>, numbers[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们的闭包是作为第二个参数传递的简单小函数<code>sort.Search()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> numbers[i] &gt;= <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>numbers</code>即使从未传入切片，此闭包也会访问切片，并对任何大于或等于 7 的数字返回 true。通过这样做，它<code>sort.Search()</code>允许在无需了解您正在使用的底层数据类型或您试图满足的条件的情况下工作。它只需要知道特定索引处的值是否符合您的条件。</p><h2 id="用闭包-defer-进行处理异常"><a href="#用闭包-defer-进行处理异常" class="headerlink" title="用闭包 + defer 进行处理异常"></a>用闭包 + defer 进行处理异常</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;some except had happend:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">    *a = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some except had happend: runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure><p>recover 函数用于终止错误处理流程。一般情况下，recover 应该在一个使用 defer 关键字的函数中执行以有效截取错误处理流程。如果没有在发生异常的 goroutine 中明确调用恢复过程（调用 recover 函数），会导致该 goroutine 所属的进程打印异常信息后直接退出<br>对于第三方库的调用，在不清楚是否有 panic 的情况下，最好在适配层统一加上 recover 过程，否则会导致当前进程的异常退出，而这并不是我们所期望的。</p><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>这么有趣的东西，肯定有着不少的坑，也是我们在实际开发时要注意的东西。</p><h2 id="for-range-中使用闭包"><a href="#for-range-中使用闭包" class="headerlink" title="for range 中使用闭包"></a>for range 中使用闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                </span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;                             </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; </span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()                 </span><br><span class="line">    &#125;                        </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;    <span class="comment">// 阻塞模式                                                         </span></span><br><span class="line">&#125;                          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 嗯，结果应该是 a,b,c 吧</span></span><br></pre></td></tr></table></figure><p>来看看结果：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1262158-72c0946193c5d8e2.png" alt="img"></p><p>输出的结果不期而然，大家的结果也不一定和我相同。</p><p>对比下面的改进：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                </span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;                             </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; </span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;(v)   <span class="comment">//每次将变量 v 的拷贝传进函数                 </span></span><br><span class="line">    &#125;                        </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;                                                      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>所以结果当然是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><p>由于使用了 <code>go</code> 协程，并非顺序输出。</p><blockquote><p><strong>解释</strong>：也不用多解释了吧，在没有将变量 <code>v</code> 的拷贝值传进匿名函数之前，只能获取最后一次循环的值,这是新手最容易遇到的坑。</p></blockquote><h2 id="循环闭包引用"><a href="#循环闭包引用" class="headerlink" title="循环闭包引用"></a>循环闭包引用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> funcSlice []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      funcSlice = <span class="built_in">append</span>(funcSlice, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">println</span>(i)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">      funcSlice[j]()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>会输出什么？</strong></p><p>每次 append 操作仅将匿名函数放入到列表中，但并未执行，并且引用的变量都是 i，随着 i 的改变匿名函数中的 i 也在改变，所以当执行这些函数时，他们读取的都是环境变量 i 最后一次的值。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>声明新的变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> funcSlice []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      i := i</span><br><span class="line">      funcSlice = <span class="built_in">append</span>(funcSlice, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">println</span>(i)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">      funcSlice[j]()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明新变量：j := i，且把之后对 i 的操作改为对 j 操作。</li><li>声明新同名变量：i := i。注意：这里短声明右边是外层作用域的 i，左边是新声明的作用域在这一层的 i。原理同上。</li></ul><p>这相当于为这三个函数各声明一个变量，一共三个，这三个变量初始值分别对应循环中的 i 并且之后不会再改变。</p><p><strong>声明新匿名函数并传参</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> funcSlice []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         funcSlice = <span class="built_in">append</span>(funcSlice, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(i)</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;(i)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">      funcSlice[j]() <span class="comment">// 0, 1, 2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 println(i)使用的 i是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。</p><p>现在相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p><h1 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h1><h2 id="定义后立即被调用"><a href="#定义后立即被调用" class="headerlink" title="定义后立即被调用"></a>定义后立即被调用</h2><p>因为只会被使用一次，所以应该力图避免闭包对象的内存分配操作，那怎么优化一下呢？一下面的示例代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(byval)</span><br><span class="line">    byref++</span><br><span class="line">&#125;(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>在文章开头我们提到过闭包跟函数最大的不同在于，当捕捉闭包的时候，它的所引用的外部变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。如果闭包在定义后立即被调用，那它不会存在脱离上下文的使用场景，这时候其实可以将它转为简单函数的调用形式。</p><p>上面的闭包将被转换为简单函数调用的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(byval <span class="type">int</span>, &amp;byref *<span class="type">int</span>, a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(byval)</span><br><span class="line">    (*&amp;byref)++</span><br><span class="line">&#125;(byval, &amp;byref, <span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>我们注意到byval是值捕获，byref是引用捕获，这其实是根据变量在函数内部会不会被修改来决定的。我们知道在闭包内部修改变量会影响到外部环境，如果变量在闭包中会被修改，使用值捕获显然是不太合适的。</p><h2 id="定义后没有立即调用"><a href="#定义后没有立即调用" class="headerlink" title="定义后没有立即调用"></a>定义后没有立即调用</h2><p>这种情况下同一个闭包可能调用多次，这就需要创建闭包对象了，如何实现呢？</p><ul><li>如果变量是在函数内部不会被修改，并且该变量占用存储空间小于<code>2*sizeof(int)</code>，那么就通过在函数体内创建局部变量的形式来捕获的变量，相比于直接捕获变量地址，这么做的好处应该是考虑到减少引用数量、减少逃逸分析相关的计算。</li><li>如果变量在函数内部会被修改，或者变量占用存储空间较大（拷贝到本地做局部变量代价太大），则在捕获变量的地址。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ttt.svg" alt="image-UML"></p><h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transformclosure</span><span class="params">(xfunc *Node)</span></span> &#123;</span><br><span class="line">   lno := lineno</span><br><span class="line">   lineno = xfunc.Pos</span><br><span class="line">   clo := xfunc.Func.Closure</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> clo.Func.Top&amp;ctxCallee != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// If the closure is directly called, we transform it to a plain function call</span></span><br><span class="line">      <span class="comment">// with variables passed as args. This avoids allocation of a closure object.</span></span><br><span class="line">      <span class="comment">// Here we do only a part of the transformation. Walk of OCALLFUNC(OCLOSURE)</span></span><br><span class="line">      <span class="comment">// will complete the transformation later.</span></span><br><span class="line">      <span class="comment">// For illustration, the following closure:</span></span><br><span class="line">      <span class="comment">// func(a int) &#123;</span></span><br><span class="line">      <span class="comment">//    println(byval)</span></span><br><span class="line">      <span class="comment">//    byref++</span></span><br><span class="line">      <span class="comment">// &#125;(42)</span></span><br><span class="line">      <span class="comment">// becomes:</span></span><br><span class="line">      <span class="comment">// func(byval int, &amp;byref *int, a int) &#123;</span></span><br><span class="line">      <span class="comment">//    println(byval)</span></span><br><span class="line">      <span class="comment">//    (*&amp;byref)++</span></span><br><span class="line">      <span class="comment">// &#125;(byval, &amp;byref, 42)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// f is ONAME of the actual function.</span></span><br><span class="line">      f := xfunc.Func.Nname</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// We are going to insert captured variables before input args.</span></span><br><span class="line">      <span class="keyword">var</span> params []*types.Field</span><br><span class="line">      <span class="keyword">var</span> decls []*Node</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> xfunc.Func.Cvars.Slice() &#123;</span><br><span class="line">         <span class="keyword">if</span> !v.Name.Byval() &#123;</span><br><span class="line">            <span class="comment">// If v of type T is captured by reference,</span></span><br><span class="line">            <span class="comment">// we introduce function param &amp;v *T</span></span><br><span class="line">            <span class="comment">// and v remains PAUTOHEAP with &amp;v heapaddr</span></span><br><span class="line">            <span class="comment">// (accesses will implicitly deref &amp;v).</span></span><br><span class="line">            addr := newname(lookup(<span class="string">&quot;&amp;&quot;</span> + v.Sym.Name))</span><br><span class="line">            addr.Type = types.NewPtr(v.Type)</span><br><span class="line">            v.Name.Param.Heapaddr = addr</span><br><span class="line">            v = addr</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">         v.SetClass(PPARAM)</span><br><span class="line">         decls = <span class="built_in">append</span>(decls, v)</span><br><span class="line">    </span><br><span class="line">         fld := types.NewField()</span><br><span class="line">         fld.Nname = asTypesNode(v)</span><br><span class="line">         fld.Type = v.Type</span><br><span class="line">         fld.Sym = v.Sym</span><br><span class="line">         params = <span class="built_in">append</span>(params, fld)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(params) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="comment">// Prepend params and decls.</span></span><br><span class="line">         f.Type.Params().SetFields(<span class="built_in">append</span>(params, f.Type.Params().FieldSlice()...))</span><br><span class="line">         xfunc.Func.Dcl = <span class="built_in">append</span>(decls, xfunc.Func.Dcl...)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      dowidth(f.Type)</span><br><span class="line">      xfunc.Type = f.Type <span class="comment">// update type of ODCLFUNC</span></span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// The closure is not called, so it is going to stay as closure.</span></span><br><span class="line">      <span class="keyword">var</span> body []*Node</span><br><span class="line">      offset := <span class="type">int64</span>(Widthptr)</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> xfunc.Func.Cvars.Slice() &#123;</span><br><span class="line">         <span class="comment">// cv refers to the field inside of closure OSTRUCTLIT.</span></span><br><span class="line">         cv := nod(OCLOSUREVAR, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">         cv.Type = v.Type</span><br><span class="line">         <span class="keyword">if</span> !v.Name.Byval() &#123;</span><br><span class="line">            cv.Type = types.NewPtr(v.Type)</span><br><span class="line">         &#125;</span><br><span class="line">         offset = Rnd(offset, <span class="type">int64</span>(cv.Type.Align))</span><br><span class="line">         cv.Xoffset = offset</span><br><span class="line">         offset += cv.Type.Width</span><br><span class="line">    </span><br><span class="line">         <span class="keyword">if</span> v.Name.Byval() &amp;&amp; v.Type.Width &lt;= <span class="type">int64</span>(<span class="number">2</span>*Widthptr) &#123;</span><br><span class="line">            <span class="comment">// If it is a small variable captured by value, downgrade it to PAUTO.</span></span><br><span class="line">            v.SetClass(PAUTO)</span><br><span class="line">            xfunc.Func.Dcl = <span class="built_in">append</span>(xfunc.Func.Dcl, v)</span><br><span class="line">            body = <span class="built_in">append</span>(body, nod(OAS, v, cv))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Declare variable holding addresses taken from closure</span></span><br><span class="line">            <span class="comment">// and initialize in entry prologue.</span></span><br><span class="line">            addr := newname(lookup(<span class="string">&quot;&amp;&quot;</span> + v.Sym.Name))</span><br><span class="line">            addr.Type = types.NewPtr(v.Type)</span><br><span class="line">            addr.SetClass(PAUTO)</span><br><span class="line">            addr.Name.SetUsed(<span class="literal">true</span>)</span><br><span class="line">            addr.Name.Curfn = xfunc</span><br><span class="line">            xfunc.Func.Dcl = <span class="built_in">append</span>(xfunc.Func.Dcl, addr)</span><br><span class="line">            v.Name.Param.Heapaddr = addr</span><br><span class="line">            <span class="keyword">if</span> v.Name.Byval() &#123;</span><br><span class="line">               cv = nod(OADDR, cv, <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            body = <span class="built_in">append</span>(body, nod(OAS, addr, cv))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(body) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         typecheckslice(body, ctxStmt)</span><br><span class="line">         xfunc.Func.Enter.Set(body)</span><br><span class="line">         xfunc.Func.SetNeedctxt(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   lineno = lno</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>那么具体是怎么捕获的呢？</p><p>在Go 语言中函数也是一种变量，和普通变量一样可以通过参数传递，可以做函数返回值。Go 语言把这样的函数变量称为 function value，它本质上是一个指针，指向一个 <code>runtime.funcval</code> 结构体，这个结构体保存了函数的入口地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">   fn <span class="type">uintptr</span></span><br><span class="line">   <span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/t.png" alt="img"></p><p>举个例子：func A 的指令位于代码段的 addr1。由于 func A 对应的 function value 没有捕获列表，编译期间编译器会在只读数据段分配一个 function value 结构体，这个结构体本身的地址是 addr2 ，它保存了 func A 的地址 addr1，多次 func A 调用共享一个 funcval。执行阶段，addr2 会被赋予 f1 与 f2。执行 f1 就是通过 f1 找出对应的 funcval，进而拿到 func A 入口地址。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tt.png" alt="img"></p><p><strong>为什么不直接通过addr1调用函数，而要添加一层中间层function value呢？</strong></p><p>这其实是为了支持闭包的实现，function value这一中间层方便我们将同一个函数绑定到不同的引用环境上。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tttt.png" alt="img"></p><p>通常来讲，局部变量都是分配在栈的，上图也是这样。但是，如果捕获变量的值会发生改变，Go 编译器会在堆上分配局部变量，栈上只保存一个地址。这就是所谓的“局部变量堆分配”。function value 的捕获列表保存局部变量的地址，这样闭包函数和外层函数就指向同一个变量了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ttttt.png" alt="img"></p><p>来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      a, b = b, a+b</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f1, f2 := Fibonacci(), Fibonacci()</span><br><span class="line">   fmt.Println(f1, f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码会输出什么？</strong></p><p>我们会发现它们输出的地址是一样的，不可思议。按道理每次分配新的funcval，地址是不可能相等的。其实fmt.Printf识别出f1和f2是函数变量后，把<code>funcval.fn</code>给打印出来了，打印的是函数的真实地址，而不是funcval的地址。</p><p>如果要查看真实地址，可以采用下面这种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      a, b = b, a+b</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f1, f2 := Fibonacci(), Fibonacci()</span><br><span class="line">   a1 := *(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;f1))</span><br><span class="line">   a2 := *(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;f2))</span><br><span class="line">   fmt.Println(a1, a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>闭包实际上就是一种语法糖机制，这种语法糖机制可以简化编程，比如，有时候对外部的变量进行访问，没这种语法糖机制将会编写冗余的代码。而这正也是可以把这种闭包机制归结为一种设计模式。但是由于使用闭包会导致代码不够清晰，使用不当还会导致得到错误的结果。所以一般不建议使用闭包。</p><p>不知道为什么，在我的环境下运行坑这一部分的代码时，是不会出现任何问题的，可能是 go 的新版本把这些问题给改了吧，也可能是编译器的优化问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://llmxby.com/2022/08/27/%E6%8E%A2%E7%A9%B6Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/">https://llmxby.com/2022/08/27/%E6%8E%A2%E7%A9%B6Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</a></p><p><a href="https://learnku.com/articles/59988">https://learnku.com/articles/59988</a></p><p><a href="https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/">https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/</a></p><p><a href="https://polarisxu.studygolang.com/posts/go/action/go-closure/">https://polarisxu.studygolang.com/posts/go/action/go-closure/</a></p><p><a href="https://www.51cto.com/article/715815.html">https://www.51cto.com/article/715815.html</a></p><p><a href="https://www.cnblogs.com/liujiacai/p/17093687.html">https://www.cnblogs.com/liujiacai/p/17093687.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言从设计上对函数进行了优化和改进，让函数使用起来更加方便。&lt;/p&gt;
&lt;p&gt;因为Go语言的函数本身可以作为值进行传递，既支持匿名函数和闭包，又能满足接口，所以 Go 语言的函数属于一等公民。&lt;/p&gt;
&lt;p&gt;本文将由一道题引出 Go 中的闭包。这是 Go 语言爱好者周刊</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>腾讯面试——血与泪的教训（二）</title>
    <link href="http://example.com/2024/06/19/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2024/06/19/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-06-19T13:47:32.000Z</published>
    <updated>2024-06-19T15:50:43.816Z</updated>
    
    <content type="html"><![CDATA[<p>没想到啊，这个标题下的内容还能成为连续剧。</p><p>我终于明白我为什么找不到实习了，给我机会我不中用，我哭死，腾讯不愧是大公司，还给了我第四次面试机会，结果我还是没有把握住。有三分之一的问题没有回答出来，结果几乎全是之前就已经看过但是只是扫了一眼或者压根就只是躺在我的收藏夹里没动过。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a620f4b75df9a2cda1f0776b0d06015.jpg" alt="a620f4b75df9a2cda1f0776b0d06015"></p><p>还是借此机会，拾起来重新学吧。</p><p>今天的面试问题主要集中在两个方向，Go 语言基础的知识和数据库的一些底层内容。</p><h1 id="Golang中哪些不能作为map类型的key？"><a href="#Golang中哪些不能作为map类型的key？" class="headerlink" title="Golang中哪些不能作为map类型的key？"></a>Golang中哪些不能作为map类型的key？</h1><p>在 Go 语言中，<code>map</code> 的 <code>key</code> 可以是任意使用 <code>==</code> 或 <code>!=</code> 运算符进行比较的类型。这意味着一下类型可以作为 <code>map</code> 的键：</p><ul><li>基本类型：<code>int</code>、<code>float</code>、<code>bool</code>、<code>string</code></li><li>接口类型</li><li>指针类型</li><li>数组类型（数组中的元素必须是能作为键的类型）</li></ul><p>然而，以下类型<strong>不能</strong>作为 <code>map</code> 的键：</p><ul><li><code>slice</code></li><li><code>map</code></li><li><code>function</code></li><li>包含上述类型的结构体</li></ul><p>这是因为 <code>slice</code>、<code>map</code> 和 <code>function</code> 等类型的值不是固定的（它们在内存中的表示可能会改变），因此不能用于比较。例如，两个包含相同元素的 <code>slice</code> 在使用 <code>==</code> 运算符进行比较时会产生编译错误，因此 <code>slice</code> 不能作为 <code>map</code> 的键。</p><p>这就是我被问得满头大汗的起始点，从这个问题开始，我从语无伦次变得胡言乱语。</p><h1 id="Golang如何实现继承？"><a href="#Golang如何实现继承？" class="headerlink" title="Golang如何实现继承？"></a>Golang如何实现继承？</h1><p>我们在学习 Go 语言的时候就知道，它并不是一个常规的面向对象的编程的语言，所以在学习 Go 语言以及看一些底层实现的时候，我都没有认真地看过任何相关的内容。就在前两天我还看到了一个相关的内容，但是就扫了一眼，没有任何意外，我没记住，然后开始胡言乱语。</p><p>对于 go 语言的继承，之前总是模模糊糊的分不清是什么。不知道如何通过何种方式来继承的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dPoVSPtWE3.png!large" alt="秒懂 go 语言的继承"></p><p>那我们就先看看 Java 是怎么实现继承的吧，然后使用 Go 来完成同样的继承操作。</p><h2 id="Java-操作"><a href="#Java-操作" class="headerlink" title="Java 操作"></a>Java 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>   String name;</span><br><span class="line">    <span class="keyword">public</span> String subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喜欢吃：&quot;</span> + food + <span class="string">&quot;,它属于：&quot;</span> + subject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类。 猫类继承动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">// 猫自己的属性和方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;今年&quot;</span> + age + <span class="string">&quot;岁了，特别喜欢睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个动物实例</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        a.name = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">        a.subject = <span class="string">&quot;动物科&quot;</span>;</span><br><span class="line">        a.eat(<span class="string">&quot;肉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个猫实例</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.name = <span class="string">&quot;咪咪&quot;</span>;</span><br><span class="line">        cat.subject = <span class="string">&quot;猫科&quot;</span>;</span><br><span class="line">        cat.age = <span class="number">1</span>;</span><br><span class="line">        cat.eat(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">        cat.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果入下：</span><br><span class="line">    动物喜欢吃：肉,它属于：动物科</span><br><span class="line">    咪咪喜欢吃：鱼,它属于：猫科</span><br><span class="line">    咪咪今年1岁了，特别喜欢睡觉</span><br></pre></td></tr></table></figure><h2 id="Go-语言实现继承"><a href="#Go-语言实现继承" class="headerlink" title="Go 语言实现继承"></a>Go 语言实现继承</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  subject <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物的公共方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> eat(food <span class="type">string</span>) &#123;</span><br><span class="line">  fmt.Println(a.name + <span class="string">&quot;喜欢吃：&quot;</span> + food +<span class="string">&quot;,它属于:&quot;</span> + a.subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类，继承动物类</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 继承动物的属性和方法</span></span><br><span class="line">  Animal</span><br><span class="line">  <span class="comment">// 猫自己的属性</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类独有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> sleep() &#123;</span><br><span class="line">  fmt.Println(c.name + <span class="string">&quot; 今年&quot;</span> + strconv.Itoa(c.age) + <span class="string">&quot;岁了,特别喜欢睡觉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个动物类</span></span><br><span class="line">  animal := Animal&#123;name:<span class="string">&quot;动物&quot;</span>, subject:<span class="string">&quot;动物科&quot;</span>&#125;</span><br><span class="line">  animal.eat(<span class="string">&quot;肉&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个猫类</span></span><br><span class="line">  cat := Cat&#123;Animal: Animal&#123;name:<span class="string">&quot;咪咪&quot;</span>, subject:<span class="string">&quot;猫科&quot;</span>&#125;,age:<span class="number">1</span>&#125;</span><br><span class="line">  cat.eat(<span class="string">&quot;鱼&quot;</span>)</span><br><span class="line">  cat.sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">    动物喜欢吃：肉,它属于:动物科</span><br><span class="line">    咪咪喜欢吃：鱼,它属于:猫科</span><br><span class="line">    咪咪 今年1岁了,特别喜欢睡觉</span><br></pre></td></tr></table></figure><p>是不是有点懂了，但是这只是最基础的封装，现在，在其他语言中，我们都知道，大多数都是以 interface 的方式来进行封装的。那么我们用 interface ，以一种高级的方式改造上面的例子如下：</p><h2 id="使用接口的方式进行封装一个方法"><a href="#使用接口的方式进行封装一个方法" class="headerlink" title="使用接口的方式进行封装一个方法"></a>使用接口的方式进行封装一个方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler <span class="keyword">interface</span> &#123;</span><br><span class="line">    eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    food <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 eat() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(animal Animal)</span></span> eat() &#123;</span><br><span class="line">    fmt.Println(animal.name + <span class="string">&quot;今年&quot;</span>+ strconv.Itoa(animal.age) +<span class="string">&quot;岁了，&quot;</span> + <span class="string">&quot;喜欢吃&quot;</span> + animal.food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Animal</span><br><span class="line">    time <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Animal</span><br><span class="line">    plays <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫独有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> sleep() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我叫&quot;</span> + cat.name + <span class="string">&quot;， 我能睡&quot;</span> + strconv.Itoa(cat.time) + <span class="string">&quot;分钟&quot;</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 狗独有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span></span> play() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我叫&quot;</span> + dog.name + <span class="string">&quot;我喜欢玩&quot;</span> + dog.plays)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInterface</span><span class="params">(animaler Animaler)</span></span>  &#123;</span><br><span class="line">    animaler.eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    cat := Cat&#123;Animal:Animal&#123;name:<span class="string">&quot;咪咪&quot;</span>, age:<span class="number">2</span>, food:<span class="string">&quot;鱼&quot;</span>&#125;, time: <span class="number">8</span>&#125;</span><br><span class="line">    cat.sleep()</span><br><span class="line">    testInterface(cat)</span><br><span class="line"></span><br><span class="line">    dog := Dog&#123;Animal:Animal&#123;name:<span class="string">&quot;大黄&quot;</span>, age:<span class="number">2</span>, food:<span class="string">&quot;骨头&quot;</span>&#125;, plays:<span class="string">&quot;球球&quot;</span>&#125;</span><br><span class="line">    dog.play()</span><br><span class="line">    testInterface(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我叫咪咪， 我能睡8分钟</span><br><span class="line">咪咪今年2岁了，喜欢吃鱼</span><br><span class="line">我叫大黄我喜欢玩球球</span><br><span class="line">大黄今年2岁了，喜欢吃骨头</span><br></pre></td></tr></table></figure><p>通过如上的代码可以看到，</p><ul><li>在 go 语言中， <code>type name struct&#123;&#125;</code> 结构体 就相当于其他语言中的 <code>class</code> 类的概念。</li><li>在其他语言中，方法是直接写在在 类 里面的，而在 go 语言中，我们对于该结构体，如果存在方法，比如猫咪存在睡觉的方法那么是以 <code>func (结构体名) 方法名&#123;&#125;</code>，即 <code>func(c Cat) sleep&#123;&#125;</code> 的方式来声明方法。</li><li>在 java 中， string + int = string，int 类型的值不需要类型转换，而在 go 语言中，string + int，如果想要一个字符串，则需要对 int 类型的值转换为 string 类型，然后才能拼接。</li></ul><h3 id="下面着这两句话一定要熟记："><a href="#下面着这两句话一定要熟记：" class="headerlink" title="下面着这两句话一定要熟记："></a>下面着这两句话一定要熟记：</h3><ul><li>结构体解决的是基本数据类型不能满足我们日常需要的问题。再简单点理解就是一个结构体就是一个 json 类型的 object。</li><li>接口是一种类型。是一种特殊的类型，它规定了不同结构体有哪些相同的行为，只是制定标准，而不实现标准。就好比自来水厂只规定水龙头的半径大小，而不去考虑谁生产水龙头，生产水龙头的厂家不管用什么材料，只需要按照自来水厂的标准制定就好。</li></ul><p>其实我并不觉得这是继承相关的内容，在语法上我们没有显示地去声明某个类要去继承另外一个类，也不能使用该类去调用父类的函数，Go 语言继承说白了就是结构体内嵌，而且设计者的想法也是通过组合来代替掉复杂的继承机制。</p><h1 id="Golang中两个变量值的交换方式"><a href="#Golang中两个变量值的交换方式" class="headerlink" title="Golang中两个变量值的交换方式?"></a>Golang中两个变量值的交换方式?</h1><p>先来看看各种方式的实现吧。</p><p>在 Go 语言中，可以使用以下四种方法来交换两个变量的值：</p><ol><li><p><strong>使用临时变量</strong>：这是最传统的方法，我们创建一个临时变量来保存一个变量的值，然后将另一个变量的值赋给第一个变量，最后将临时变量的值赋给第二个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure></li><li><p><strong>使用多重赋值</strong>：Go 语言支持多重赋值，这使得我们可以在一行代码中交换两个变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure></li><li><p><strong>使用指针</strong>：我们也可以使用指针来交换两个变量的值。在这种方法中，我们创建两个指针，分别指向两个变量，然后通过这两个指针来交换两个变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line">a := <span class="number">100</span></span><br><span class="line">b := <span class="number">200</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用算术运算</strong>：我们还可以使用加法和减法（或者异或运算）来交换两个变量的值。但是这种方法可能会因为数值过大而导致溢出，所以在实际应用中并不常用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b <span class="comment">// b = (a+b) - b = a</span></span><br><span class="line">a = a - b <span class="comment">// a = (a+b) - a = b</span></span><br></pre></td></tr></table></figure></li></ol><p>上面的四种方法虽然都能是实现我们想要的功能，但是我们实际上会经常应用的就是第二种方法。下面我们来看一下<strong>多重赋值</strong>的底层实现。</p><h2 id="如何实现多重赋值？"><a href="#如何实现多重赋值？" class="headerlink" title="如何实现多重赋值？"></a>如何实现多重赋值？</h2><p>我们来做一个小实验，看看四值交换的 golang 代码的汇编代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line">c := <span class="number">3</span></span><br><span class="line">d := <span class="number">4</span></span><br><span class="line">a, b, c, d = b, c, d, a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$&gt;dlv debug main.go</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b main.main</span><br><span class="line">Breakpoint 1 set at 0x454b6a for main.main() ~/pathToProject/main.go:3</span><br><span class="line">(dlv) r</span><br><span class="line">Process restarted with PID 26528</span><br><span class="line">(dlv) c</span><br><span class="line">&gt; main.main() ~/pathToProject/main.go:3 (hits goroutine(1):1 total:1) (PC: 0x454b6a)</span><br><span class="line">     1: package main</span><br><span class="line">     2:</span><br><span class="line">=&gt;   3: func main() &#123;</span><br><span class="line">     4:         a := 1</span><br><span class="line">     5:         b := 2</span><br><span class="line">     6:         c := 3</span><br><span class="line">     7:         d := 4</span><br><span class="line">(dlv) disassemble</span><br><span class="line">TEXT main.main(SB) D:/Users/polar/go/src/mylab/main.go</span><br><span class="line">        main.go:3       0x454b50        65488b0c2528000000      mov rcx, qword ptr gs:[0x28]</span><br><span class="line">        main.go:3       0x454b59        488b8900000000          mov rcx, qword ptr [rcx]</span><br><span class="line">        main.go:3       0x454b60        483b6110                cmp rsp, qword ptr [rcx+0x10]</span><br><span class="line">        main.go:3       0x454b64        0f8619020000            jbe 0x454d83</span><br><span class="line">=&gt;      main.go:3       0x454b6a*       4883ec50                sub rsp, 0x50</span><br><span class="line">        main.go:3       0x454b6e        48896c2448              mov qword ptr [rsp+0x48], rbp</span><br><span class="line">        main.go:3       0x454b73        488d6c2448              lea rbp, ptr [rsp+0x48]</span><br><span class="line">        main.go:4       0x454b78        48c744242801000000      mov qword ptr [rsp+0x28], 0x1  // a := 1</span><br><span class="line">        main.go:5       0x454b81        48c744242002000000      mov qword ptr [rsp+0x20], 0x2  // b := 2</span><br><span class="line">        main.go:6       0x454b8a        48c744241803000000      mov qword ptr [rsp+0x18], 0x3  // c := 3</span><br><span class="line">        main.go:7       0x454b93        48c744241004000000      mov qword ptr [rsp+0x10], 0x4  // d := 4</span><br><span class="line">        main.go:9       0x454b9c        488b442428              mov rax, qword ptr [rsp+0x28]</span><br><span class="line">        main.go:9       0x454ba1        4889442440              mov qword ptr [rsp+0x40], rax  // temp = a</span><br><span class="line">        main.go:9       0x454ba6        488b442420              mov rax, qword ptr [rsp+0x20]</span><br><span class="line">        main.go:9       0x454bab        4889442428              mov qword ptr [rsp+0x28], rax  // a = b</span><br><span class="line">        main.go:9       0x454bb0        488b442418              mov rax, qword ptr [rsp+0x18]</span><br><span class="line">        main.go:9       0x454bb5        4889442420              mov qword ptr [rsp+0x20], rax  // b = c</span><br><span class="line">        main.go:9       0x454bba        488b442410              mov rax, qword ptr [rsp+0x10]</span><br><span class="line">        main.go:9       0x454bbf        4889442418              mov qword ptr [rsp+0x18], rax  // c = d</span><br><span class="line">        main.go:9       0x454bc4        488b442440              mov rax, qword ptr [rsp+0x40]</span><br><span class="line">        main.go:9       0x454bc9        4889442410              mov qword ptr [rsp+0x10], rax  // d = temp</span><br></pre></td></tr></table></figure><p>很好理解了，就是编译器帮我们在栈上创建了一个临时变量 temp, 然后按顺序交换其他各个变量的值。</p><p>那么下面这种情况，会发生什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := 1</span><br><span class="line">b := 2</span><br><span class="line">a, b, a = b, a, b</span><br></pre></td></tr></table></figure><p>a 和 b 最终的值是多少？</p><p>看一下汇编代码就清楚了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main.go:5   0x454b9b 48c744241801000000   mov qword ptr [rsp+0x18], 0x1  // a:=1</span><br><span class="line">main.go:6   0x454ba4 48c744241002000000   mov qword ptr [rsp+0x10], 0x2  // b:=2</span><br><span class="line">main.go:7   0x454bad 488b442418           mov rax, qword ptr [rsp+0x18]</span><br><span class="line">main.go:7   0x454bb2 4889442428           mov qword ptr [rsp+0x28], rax  // aTemp := a</span><br><span class="line">main.go:7   0x454bb7 488b442410           mov rax, qword ptr [rsp+0x10]</span><br><span class="line">main.go:7   0x454bbc 4889442420           mov qword ptr [rsp+0x20], rax  // bTemp := b</span><br><span class="line">main.go:7   0x454bc1 488b442410           mov rax, qword ptr [rsp+0x10]</span><br><span class="line">main.go:7   0x454bc6 4889442418           mov qword ptr [rsp+0x18], rax  // a = b</span><br><span class="line">main.go:7   0x454bcb 488b442428           mov rax, qword ptr [rsp+0x28]</span><br><span class="line">main.go:7   0x454bd0 4889442410           mov qword ptr [rsp+0x10], rax  // b = aTemp</span><br><span class="line">main.go:7   0x454bd5 488b442420           mov rax, qword ptr [rsp+0x20]</span><br><span class="line">main.go:7   0x454bda 4889442418           mov qword ptr [rsp+0x18], rax  // a = bTemp</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aTemp = a</span><br><span class="line">bTemp = b</span><br><span class="line">a, b, a = bTemp, aTemp, bTemp</span><br></pre></td></tr></table></figure><p>这里两个值交换的操作的原理是将两个被赋值的变量的值，都存储在临时变量里，然后再用临时变量去赋值。所以这个例子赋值顺序对结果是无影响的，其结果仍然是 a = 2, b = 1。</p><p>不用再像 C 语言那样写交换函数再内联了，相当于把脏活丢给编译器干了。</p><p>这个问题我好像不是很明白面试官的意图，他说要问我这种赋值方式的实现原理，但是实现原理其实就是我写出的代码，难道是我想复杂了？</p><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><blockquote><p>MySQL 中最常见的存储引擎有：InnoDB、MyISAM 和 MEMORY，其中 InnoDB 是 MySQL 5.1 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列，它的特点是稳定（能保证业务的完整性），但数据的读写效率一般。</p></blockquote><p>MySQL 有很多存储引擎（也叫数据引擎），所谓的存储引擎是指用于存储、处理和保护数据的核心服务。也就是存储引擎是数据库的底层软件组织。在 MySQL 中可以使用“show engines”来查询数据库的所有存储引擎，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240619230440251.png" alt="image-20240619230440251"></p><p>在上述列表中，我们最常用的存储引擎有以下 3 种：</p><ul><li>InnoDB</li><li>MyISAM</li><li>MEMORY</li></ul><p>下面我们分别来看。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><blockquote><p>InnoDB 是事务型数据库的首选引擎，支持事务安全表 (ACID)，支持行锁定和外键。MySQL5.5.5 之后，InnoDB 作为默认存储引擎，InnoDB 主要特性有：</p></blockquote><ol><li>InnoDB 给 MySQL 提供了具有<strong>提交</strong>、<strong>回滚</strong>和<strong>崩溃恢复能力的事务安全(ACID 兼容)</strong>存储引擎。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表与其他 MySQL 的表的类型混合起来，甚至在同一个查询中也可以混合。</li><li>InnoDB 是为<strong>处理巨大数据量</strong>的最大性能设计。它的 CPU 的效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。</li><li>InnoDB 存储引擎完全与 MySQL 服务器整合，InnoDB 存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB 将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被艰制为 2GB 的操作系统上。</li><li>InnoDB 支持<strong>外键完整性约束（FOREIGN KEY)</strong>。 存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会被每一行生成一个 6B 的 ROWID，并以此作为主健。</li><li>InnoDB 被用在众多需要高性能的大型数据库站点上。 InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MYSQL 数据目录下创建一个名为 ibdata1 的 10MB 大小的自动扩展数据文件，以及两个名为ib_logfile() 和 ib_logfile1 的 5MB 大小的日志文件。</li></ol><p>InnoDB 的优势是支持事务、支持外键、支持崩溃修复和自增列；它的缺点是读写效率较差、占用的数据空间较大。</p><h2 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h2><blockquote><p>MyISAM 基于 ISAM 的存储引擎，并对其进行扩展。它是在 Web、数据存储和其他应用环境下最常用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。不支持行级锁，因此在添加和修改操作时，会执行锁表操作，所以它的写入效率较低。在 MySQL5.5.5 之前的版本中，MyISAM 是默认存储引擎。MyISAM 主要特性有：</p></blockquote><ol><li>大文件（达 63 位文件长度）在支持大文件系统和操作系统上被支持。</li><li>当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少的碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。</li><li>每个 MyISAM 表最大索引数是 64，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。</li><li>BLOB 和 TEXT 列可以被索引。</li><li>NULL 值被允许在索引的列中。这个值占每个键的 0~1 个字节。</li><li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩。</li><li>每表一个 AUTO_INCREMENT 列的内部处理。MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列。使得 AUTO_INCREMENT 列更快（至少 10%）。在序列顶的值被删除除之后就不能再利用。</li><li>可以把数据文件和索引文件放在不同目录。</li><li>每个字符列可以有不同的字符集。</li><li>有 VARCHAR 的表可以固定或动态记录长度。</li><li>VARCHAR 和 CHAR 列可以多达 64KB</li></ol><blockquote><p>使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以表的名字开始，扩展名指出文件类型：frm 文件存储表定义，数据文件的扩展名为 .MYD(MYData)，索引文件的扩展名是 .MYI（MYIndex)。</p></blockquote><p>MyISAM 引擎保存了单独的索引文件 .myi，且它的索引是直接定位到 OFFSET 的，而 InnoDB 没有单独的物理索引存储文件，且 <strong>InnoDB 索引寻址是先定位到块数据，再定位到行数据，所以 MyISAM 的查询效率是比 InnoDB 的查询效率要高。</strong>但它不支持事务、不支持外键，所以它的适用场景是<strong>读多写少</strong>，且<strong>对完整性要求不高</strong>的业务场景。</p><h2 id="MEMORY-存储引擎"><a href="#MEMORY-存储引擎" class="headerlink" title="MEMORY 存储引擎"></a>MEMORY 存储引擎</h2><blockquote><p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。同样不支持事务、不支持外键。MEMORY 支持 Hash 索引或 B 树索引，其中 Hash 索引是基于 key 查询的，因此查询效率特别高，但如果是基于范围查询的效率就比较低了。MEMORY 主要特性有：</p></blockquote><ol><li>MEMORY 表的每个表可以多达 32 个索引，每个索引 16 列，以及 500B 的最大键长度。</li><li>MEMORY 存储引擎引擎执行 HASH 和 BTREE 索引。</li><li>可以在一个 MEMORY 表中有非唯一键。</li><li>MEMORY 不支持 BLOB 或 TEXT 列。</li><li>MEMORY 表使用一个固定的记录长度格式。</li><li>MEMORY 支持 AUTO_INCREMENT 列和对包含 NULL 值的列索引。</li><li>MEMORY 表内容被存在内存中，内存是 MEMORY 表和服务器在查询处理时的空闲中创建的内部表共享。</li><li>MEMORY 表在所有客户端之间共享（就像其他任何非 TEMPORARY 表）。</li><li>当不再需要 MEMORY 表的内容时，要释放被 MEMORY 表使用的内存，应该执行 DELETE FROM 或 TRUNCATE TABLE，或者删除整个表（使用 DROP TABLE)。</li></ol><p>MEMORY 读写性能很高，但 MySQL 服务重启之后数据会丢失，它不支持事务和外键。适用场景是读写效率要求高，但对数据丢失不敏感的业务场景。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">MyISAM</th><th style="text-align:left">Memory</th><th style="text-align:left">InnoDB</th></tr></thead><tbody><tr><td style="text-align:left">存储限制</td><td style="text-align:left">265TB</td><td style="text-align:left">RAM</td><td style="text-align:left">65TB</td></tr><tr><td style="text-align:left">支持事务</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">支持全文索引</td><td style="text-align:left">Yes</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">支持数索引</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">支持哈希索引</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">支持数据缓存</td><td style="text-align:left">No</td><td style="text-align:left">N/A</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">支持外键</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr></tbody></table></div><p>MyISAM 和 InnoDB 更详细的区别：</p><div class="table-container"><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">事务</td><td style="text-align:center">不支持</td><td>支持</td></tr><tr><td style="text-align:center">存储结构</td><td style="text-align:center">每个MyISAM在磁盘上存储成三个文件</td><td>所有的表都保存在同一个数据文件中</td></tr><tr><td style="text-align:center">存储空间</td><td style="text-align:center">可被压缩，存储空间较小</td><td>会在主内存中建立其专用的缓冲池（需要更多内存和存储）</td></tr><tr><td style="text-align:center">可移植性</td><td style="text-align:center">跨平台的数据转移中会很方便，在备份和恢复时可单独针对某个表进行操作</td><td>拷贝数据文件、备份 binlog，或者用 mysqldump</td></tr><tr><td style="text-align:center">事务支持</td><td style="text-align:center">每次查询具有原子性，但不支持事务</td><td>提供事务支持事务</td></tr><tr><td style="text-align:center">表锁差异</td><td style="text-align:center">只支持表级锁</td><td>支持行级锁</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持</td><td>不支持</td></tr><tr><td style="text-align:center">表主键</td><td style="text-align:center">允许没有任何索引和主键的表存在</td><td>如果未设置主键，会自动生成</td></tr><tr><td style="text-align:center">表总行数</td><td style="text-align:center">保存有</td><td>没有保存</td></tr><tr><td style="text-align:center">CURD</td><td style="text-align:center">对于select支持更好</td><td>INSERT/DELETE支持更好</td></tr><tr><td style="text-align:center">外键</td><td style="text-align:center">不支持</td><td>支持</td></tr><tr><td style="text-align:center">查询效率</td><td style="text-align:center">小型应用可以考虑使用</td><td>高并发、复杂情况表现更优</td></tr></tbody></table></div><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。</p><p>InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</p><h1 id="MySQL索引有哪些？"><a href="#MySQL索引有哪些？" class="headerlink" title="MySQL索引有哪些？"></a>MySQL索引有哪些？</h1><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<br>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。<br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。<br>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><h2 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h2><p>MySQL索引按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102315.73077093610994059043569245969116%253A50001231000000%253A2800%253A0811D2FDEE3B45B77393B5BF0FEC352D34506ADE23D6B11EF6A4AF3E0422E8DF.png" alt="img"></p><blockquote><p>InnoDB实际上也支持Hash索引，但是InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。</p></blockquote><p>又聊到了这个问题，B+ 树，先前有文章去分析过它，这里简单写一些当时没在意的内容。</p><p><strong>B+tree</strong> 是MySQL中被存储引擎采用最多的索引类型。<strong>B+tree</strong> 中的 <code>B</code> 代表平衡（balance），而不是二叉（binary），因为 <strong>B+tree</strong> 是从最早的平衡二叉树演化而来的。下面展示B+tree数据结构与其他数据结构的对比。</p><h3 id="B-树-和-B树的对比"><a href="#B-树-和-B树的对比" class="headerlink" title="B+树 和 B树的对比"></a>B+树 和 B树的对比</h3><p><strong>B-tree</strong> 中的每个节点根据实际情况可以包含多条数据信息和子节点，如下图所示为一个3阶的B-tree：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102331.30999891407256149613718451179943%253A50001231000000%253A2800%253A80D5E61F978DBBE67A0F8B41CB7F5D2B54CF2F344D3FD5A6AD9E97181B268771.png" alt="img"></p><p><strong>相对于B-tree，B+tree有以下三点不同：</strong></p><ul><li>B+tree 非叶子节点只存储键值信息， 数据记录都存放在叶子节点中。而B-tree的非叶子节点也存储数据。所以B+tree单个节点的数据量更小，在相同的磁盘I/O次数下，能查询更多的节点。</li><li>B+tree 所有叶子节点之间都采用单链表连接。适合MySQL中常见的基于范围的顺序检索场景，而B-tree无法做到这一点。</li><li>B+tree 的子树数量等于它的关键字的数量，而 B-tree是关键字数量 + 1.</li></ul><h3 id="B-树-和-Hash-的对比"><a href="#B-树-和-Hash-的对比" class="headerlink" title="B+树 和 Hash 的对比"></a>B+树 和 Hash 的对比</h3><p>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：</p><ul><li><p><strong>Hash 索引仅仅能满足 <code>=</code> , <code>IN</code> 和 <code>&lt;=&gt;</code>(表示NULL安全的等价) 查询，不能使用范围查询。</strong></p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p></li><li><p><strong>Hash 索引无法适用数据的排序操作。</strong></p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash值，而且Hash值的大小关系并不一定和 Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p></li><li><p><strong>Hash 索引不能利用部分索引键查询。</strong></p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p></li><li><p><strong>Hash 索引依然需要回表扫描。</strong></p><p>Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键可能存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p></li><li><p><strong>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</strong></p><p>选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</p></li></ul><p><strong>由于范围查询是MySQL数据库查询中常见的场景，Hash表不适合做范围查询，它更适合做等值查询。另外Hash表还存在Hash函数选择和Hash值冲突等问题。因此，B+tree索引要比Hash表索引有更广的适用场景。</strong></p><p>在这里又要挖一个坑，后面肯定学习一致性算法。</p><h2 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h2><p>MySQL索引按叶子节点存储的是否为完整表数据分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102427.53515137275530572272513487545890%253A50001231000000%253A2800%253A4882A822A534BD6DA268CFCAE86B5E86B8CD748C4C7D57A43454012D9F3F64D2.png" alt="img"></p><p>InnoDB表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个隐式的自增id列，并在此列上建立聚簇索引。</p><p><strong>以MyISAM为存储引擎的表不存在聚簇索引。</strong></p><p>MyISAM表中的主键索引和非主键索引的结构是一样的，索引的叶子节点不存储表数据，存放的是表数据的地址。所以，MyISAM表可以没有主键。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102441.88414806560933869728435063808011%253A50001231000000%253A2800%253ACC3375B7FDAD49A1CBBD4F38968D563DF92C374A3C9FCBF427126AA644A75848.png" alt="img"></p><p>MyISAM表的数据和索引是分开存储的。MyISAM表的主键索引和非主键索引的区别仅在于主键索引的B+tree上的key必须符合主键的限制，非主键索引B+tree上的key只要符合相应字段的特性就可以了。</p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102454.45282045827004763457106217296461%253A50001231000000%253A2800%253A0511EA1E0E6F9C254C9D44002CC031237E63DE0D2D2AB133B09C0B583B45BC9F.png" alt="img"></p><p><strong>回表查询</strong></p><p>由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102506.85588670262453085996806072422996%253A50001231000000%253A2800%253AAF69C7F57EA4B0651E3387A2E813AEFA88A5C9EDA2F510FB1C07C4FF79CC7C73.png" alt="img"></p><p>回表查询 需要额外的 <strong>B+tree</strong> 搜索过程，必然增大查询耗时。</p><p>需要注意的是，<strong>通过二级索引查询时，回表不是必须的过程</strong>，当<strong>SELECT的所有字段在单个二级索引中都能够找到</strong>时，就不需要回表，MySQL称此时的二级索引为<strong>覆盖索引</strong>或触发了<strong>索引覆盖</strong>。<br>可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现<strong>Using index</strong>，表示查询触发了<strong>索引覆盖</strong>。</p><h2 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h2><p>MySQL索引按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>建立在主键上的索引被称为<strong>主键索引</strong>，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>建立在UNIQUE字段上的索引被称为<strong>唯一索引</strong>，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>建立在普通字段上的索引被称为<strong>普通索引</strong>。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><strong>前缀索引</strong>是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p><h2 id="按索引字段个数分类"><a href="#按索引字段个数分类" class="headerlink" title="按索引字段个数分类"></a>按索引字段个数分类</h2><p>MySQL索引按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>建立在单个列上的索引被称为单列索引。</p><h3 id="联合索引（复合索引、组合索引）"><a href="#联合索引（复合索引、组合索引）" class="headerlink" title="联合索引（复合索引、组合索引）"></a>联合索引（复合索引、组合索引）</h3><p>建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是今天晚上的面试中我学习到的内容，并不是全部，还有关于算法和分布式系统的内容，我觉得内容会比较多，所以还是后面的博客里见吧，这次绝对不会再拖沓了，我要在考试周结束之前把所有之前欠下的东西补完。</p><p>我是个大**（自动消音：哔~），之前一直说的要沉淀沉淀，现在看来好像全是笑话。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.iamshuaidi.com/23129.html">问题一</a></p><p><a href="https://learnku.com/articles/32295">问题二</a></p><p>问题三</p><ul><li><p><a href="https://www.iamshuaidi.com/23169.html">https://www.iamshuaidi.com/23169.html</a></p></li><li><p><a href="https://studygolang.com/articles/20485">https://studygolang.com/articles/20485</a></p></li></ul><p>问题四</p><ul><li><a href="https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html">https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1076553">https://cloud.tencent.com/developer/article/1076553</a></li><li><a href="https://blog.csdn.net/qq_30108237/article/details/106672303">https://blog.csdn.net/qq_30108237/article/details/106672303</a></li><li><a href="https://www.runoob.com/note/28228">https://www.runoob.com/note/28228</a></li><li><a href="https://www.51cto.com/article/710761.html">https://www.51cto.com/article/710761.html</a></li></ul><p><a href="https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236">问题五</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没想到啊，这个标题下的内容还能成为连续剧。&lt;/p&gt;
&lt;p&gt;我终于明白我为什么找不到实习了，给我机会我不中用，我哭死，腾讯不愧是大公司，还给了我第四次面试机会，结果我还是没有把握住。有三分之一的问题没有回答出来，结果几乎全是之前就已经看过但是只是扫了一眼或者压根就只是躺在我的</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文——基础篇（三）</title>
    <link href="http://example.com/2024/06/19/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2024/06/19/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2024-06-19T10:07:33.000Z</published>
    <updated>2024-06-20T16:13:46.620Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 Java 基础八股文的第三篇，本文内容包括异常、泛型、反射、注解、SPI、I/O等，内容很杂也是一些重要内容，一两个问题讲不清的后面还是要单独来学习吧。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图"></p><h2 id="Exception-和-Error-有什么区别"><a href="#Exception-和-Error-有什么区别" class="headerlink" title="Exception 和 Error 有什么区别"></a>Exception 和 Error 有什么区别</h2><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。 <code>Throwable</code> 有两个重要的子类：</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h2 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h2><p><strong><code>Checked Exception</code></strong> 即<strong>受检查异常</strong>，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>比如下面这段 I/O 操作的代码：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/checked-exception.png" alt="img"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h2 id="Throwable类常用方法有哪些？"><a href="#Throwable类常用方法有哪些？" class="headerlink" title="Throwable类常用方法有哪些？"></a><code>Throwable</code>类常用方法有哪些？</h2><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h2 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a><code>try-catch-finally</code> 如何使用？</h2><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块：用于处理 try 捕获到的异常。</li><li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a><code>finally</code> 中的代码一定会执行吗？</h2><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h2><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = null;</span><br><span class="line">try &#123;</span><br><span class="line">    scanner = <span class="built_in">new</span> Scanner(<span class="built_in">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    while (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != null) &#123;</span><br><span class="line">        scanner.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li><li>……</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型？有什么作用？泛型的使用方式有哪几种？"><a href="#什么是泛型？有什么作用？泛型的使用方式有哪几种？" class="headerlink" title="什么是泛型？有什么作用？泛型的使用方式有哪几种？"></a>什么是泛型？有什么作用？泛型的使用方式有哪几种？</h2><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><hr><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-32.png" alt="泛型类、泛型接口、泛型方法"></p><p><strong>泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>泛型常用的通配符有哪些？</p></blockquote><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt; 无限制通配符</span><br><span class="line">&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br><span class="line">&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br></pre></td></tr></table></figure><blockquote><p>使用原则《Effictive Java》<br>为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</p><ol><li>如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</li><li>如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；</li><li>如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ol></blockquote><h2 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h2><p>所谓的泛型擦除，官方名叫“类型擦除”。</p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。</p><p>也就是说，在运行的时候是没有泛型的。</p><p>例如这段代码，往一群猫里放条狗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Cat&gt; cats = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Cat&gt;();</span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;  <span class="comment">// 注意我在这里把范型去掉了，但是list和cats是同一个链表！</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 完全没问题！</span></span><br></pre></td></tr></table></figure><p>因为 Java 的范型只存在于源码里，编译的时候给你静态地检查一下范型类型是否正确，而到了运行时就不检查了。上面这段代码在 JRE（Java<strong>运行</strong>环境）看来和下面这段没区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">cats</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  <span class="comment">// 注意：没有范型！</span></span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br></pre></td></tr></table></figure><p><strong>泛型的类型擦除原则</strong>是：</p><ul><li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><p>为什么要类型擦除呢？</p><p>主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p><h2 id="如何理解泛型的多态？泛型的桥接方法"><a href="#如何理解泛型的多态？泛型的桥接方法" class="headerlink" title="如何理解泛型的多态？泛型的桥接方法"></a>如何理解泛型的多态？泛型的桥接方法</h2><blockquote><p>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p></blockquote><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们想要一个子类继承它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p><p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>再看子类的两个重写的方法的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">DateInter</span> <span class="variable">dateInter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInter</span>();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());                  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。</p><p><strong>为什么会这样呢</strong>？</p><p>原因是这样的，我们传入父类的泛型类型是Date，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p><p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p><blockquote><p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p></blockquote><p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.tao.test.DateInter <span class="keyword">extends</span> <span class="title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.util.Date)</span>;  <span class="comment">//我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: invokespecial #<span class="number">16</span>                 <span class="comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Date <span class="title function_">getValue</span><span class="params">()</span>;    <span class="comment">//我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">23</span>                 <span class="comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span></span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">getValue</span><span class="params">()</span>;     <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokevirtual #<span class="number">28</span>                 <span class="comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span></span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">30</span>                 <span class="comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p><p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p><p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p><p>setValue方法是为了解决类型擦除与多态之间的冲突。</p><p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p><p>那么父类的getValue方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p><p>并且，还有一点也许会有疑问，子类中的桥方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p><h2 id="如何理解基本类型不能作为泛型类型？"><a href="#如何理解基本类型不能作为泛型类型？" class="headerlink" title="如何理解基本类型不能作为泛型类型？"></a>如何理解基本类型不能作为泛型类型？</h2><blockquote><p>比如，我们没有<code>ArrayList&lt;int&gt;</code>，只有<code>ArrayList&lt;Integer&gt;</code>, 为何？</p></blockquote><p>因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><p>另外需要注意，我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解？注解的生命周期？注解的解析方式？"><a href="#什么是注解？注解的生命周期？注解的解析方式？" class="headerlink" title="什么是注解？注解的生命周期？注解的解析方式？"></a>什么是注解？注解的生命周期？注解的解析方式？</h2><p><strong>Java 注解本质上是一个标记</strong>，可以理解成生活中的一个人的一些小装扮，比如戴什么什么帽子，戴什么眼镜。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-33.png" alt="Java注解和帽子"></p><p>注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值，比如帽子颜色是绿色。</p><p>有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处。</p><p>例如我们常见的 AOP，使用注解作为切点就是运行期注解的应用；比如 lombok，就是注解在编译期的运行。</p><p>注解<strong>生命周期</strong>有三大类，分别是：</p><ul><li><code>RetentionPolicy.SOURCE</code>：给编译器用的，不会写入 class 文件</li><li><code>RetentionPolicy.CLASS</code>：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了</li><li><code>RetentionPolicy.RUNTIME</code>：会写入 class 文件，永久保存，可以通过反射获取注解信息</li></ul><p>所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。</p><p>像常见的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-34.png" alt="Override注解"></p><p>就是给编译器用的，编译器编译的时候检查没问题就 over 了，class 文件里面不会有 Override 这个标记。</p><p>再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以<strong>在运行的时候可以通过反射得到注解的信息</strong>，还能拿到标记的值 required 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-35.png" alt="Autowired注解"></p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射是什么？应用？原理？"><a href="#反射是什么？应用？原理？" class="headerlink" title="反射是什么？应用？原理？"></a>反射是什么？应用？原理？</h2><p>创建一个对象是通过 new 关键字来实现的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>Person 类的信息在编译时就确定了，那假如在编译期无法确定类的信息，但又想在运行时获取类的信息、创建类的实例、调用类的方法，这时候就要用到反射。</p><p>反射功能主要通过 <code>java.lang.Class</code> 类及 <code>java.lang.reflect</code> 包中的类如 Method, Field, Constructor 等来实现。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-36.png" alt="三分恶面渣逆袭：Java反射相关类"></p><p>比如说我们可以装来动态加载类并创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure><p>比如说我们可以这样来访问字段和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载并实例化类</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;getTime&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj);</span><br><span class="line">System.out.println(<span class="string">&quot;Time: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;fastTime&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 对于私有字段需要这样做</span></span><br><span class="line">System.out.println(<span class="string">&quot;fastTime: &quot;</span> + field.getLong(obj));</span><br></pre></td></tr></table></figure><p><strong>反射有哪些应用场景</strong>？</p><p>一般我们平时都是在在写业务代码，很少会接触到直接使用反射机制的场景。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>像 Spring 里的很多 <strong>注解</strong> ，它真正的功能实现就是利用反射。</p><p>就像为什么我们使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为我们可以基于反射操作类，然后获取到类/属性/方法/方法的参数上的注解，注解这里就有两个作用，一是标记，我们对注解标记的类/属性/方法进行对应的处理；二是注解本身有一些信息，可以参与到处理的逻辑中。</p><p><strong>反射的原理是什么</strong>？</p><p>我们都知道 Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="什么是-SPI？它有什么用？"><a href="#什么是-SPI？它有什么用？" class="headerlink" title="什么是 SPI？它有什么用？"></a>什么是 SPI？它有什么用？</h2><p>SPI 即 <code>Service Provider Interface</code> ，字面意思就是：“<strong>服务提供者的接口</strong>”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg" alt="img"></p><h2 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h2><p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png" alt="img"></p><p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p><p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p><p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p><p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p><h2 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="SPI 的优缺点"></a>SPI 的优缺点</h2><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p><ul><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ul><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><h2 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h2><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>维基百科是如是介绍序列化的：</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a478c74d-2c48-40ae-9374-87aacf05188c.png" alt="img"></p><p><strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？</strong></p><p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p><p>如上图所示，OSI 七层协议模型中，<strong>表示层</strong>做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议<strong>应用层</strong>的一部分。</p><h2 id="了解哪些序列化方式？"><a href="#了解哪些序列化方式？" class="headerlink" title="了解哪些序列化方式？"></a>了解哪些序列化方式？</h2><p>Java 序列化方式有很多，常见的有三种：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-31.png" alt="Java常见序列化方式"></p><ul><li>Java 对象序列化 ：Java 原生序列化方法即通过 Java 原生流(InputStream 和 OutputStream 之间的转化)的方式进行转化，一般是对象输出流 <code>ObjectOutputStream</code>和对象输入流<code>ObjectInputStream</code>。</li><li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。</li><li>ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul><h2 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h2><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h2 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h2><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为<strong>字节流</strong>和<strong>字符流</strong>。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h2 id="有什么分类？"><a href="#有什么分类？" class="headerlink" title="有什么分类？"></a>有什么分类？</h2><p>Java IO 流的划分可以根据多个维度进行，包括数据流的方向（输入或输出）、处理的数据单位（字节或字符）、流的功能以及流是否支持随机访问等。</p><p><strong>按照数据流方向如何划分</strong>？</p><ul><li>输入流（Input Stream）：从源（如文件、网络等）读取数据到程序。</li><li>输出流（Output Stream）：将数据从程序写出到目的地（如文件、网络、控制台等）。</li></ul><p><strong>按处理数据单位如何划分</strong>？</p><ul><li>字节流（Byte Streams）：以字节为单位读写数据，主要用于处理二进制数据，如音频、图像文件等。</li><li>字符流（Character Streams）：以字符为单位读写数据，主要用于处理文本数据。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/shangtou-01.png" alt="二哥的 Java 进阶之路"></p><p><strong>按功能如何划分</strong>？</p><ul><li>节点流（Node Streams）：直接与数据源或目的地相连，如 FileInputStream、FileOutputStream。</li><li>处理流（Processing Streams）：对一个已存在的流进行包装，如缓冲流 BufferedInputStream、BufferedOutputStream。</li><li>管道流（Piped Streams）：用于线程之间的数据传输，如 PipedInputStream、PipedOutputStream。</li></ul><h2 id="IO-流为什么要分为字节流和字符流？"><a href="#IO-流为什么要分为字节流和字符流？" class="headerlink" title="IO 流为什么要分为字节流和字符流？"></a>IO 流为什么要分为字节流和字符流？</h2><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 IO 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li><li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li></ul><p>所以， IO 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><p><strong>文本存储是字节流还是字符流，视频文件呢</strong>？</p><p>在计算机中，文本和视频都是按照字节存储的，只是如果是文本文件的话，我们可以通过字符流的形式去读取，这样更方便的我们进行直接处理。</p><p>比如说我们需要在一个大文本文件中查找某个字符串，可以直接通过字符流来读取判断。</p><p>处理视频文件时，通常使用字节流（如 Java 中的<code>FileInputStream</code>、<code>FileOutputStream</code>）来读取或写入数据，并且会尽量使用缓冲流（如<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>）来提高读写效率。</p><p>因此，无论是文本文件还是视频文件，它们在物理存储层面都是以字节流的形式存在。区别在于，我们如何通过 Java 代码来解释和处理这些字节流：作为编码后的字符还是作为二进制数据。</p><h2 id="IO流用到了什么设计模式？"><a href="#IO流用到了什么设计模式？" class="headerlink" title="IO流用到了什么设计模式？"></a>IO流用到了什么设计模式？</h2><p>其实，Java 的 IO 流体系还用到了一个设计模式——<strong>装饰器模式</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-25.png" alt="Java IO流用到装饰器模式"></p><h2 id="BIO、NIO、AIO-之间的区别？"><a href="#BIO、NIO、AIO-之间的区别？" class="headerlink" title="BIO、NIO、AIO 之间的区别？"></a>BIO、NIO、AIO 之间的区别？</h2><p>BIO（Blocking I/O）：采用阻塞式 I/O 模型，线程在执行 I/O 操作时被阻塞，无法处理其他任务，适用于连接数较少的场景。</p><p>NIO（New I/O 或 Non-blocking I/O）：采用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，适用于连接数多但连接时间短的场景。</p><p>AIO（Asynchronous I/O）：使用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-20240404103618.png" alt="二哥的 Java 进阶之路：IO 分类"></p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO，也就是传统的 IO，基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，基于 Socket 和 ServerSocket 进行网络通信。</p><p>对于每个连接，都需要创建一个独立的线程来处理读写操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-27.png" alt="三分恶面渣逆袭：BIO"></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO，JDK 1.4 时引入，放在 java.nio 包下，提供了 Channel、Buffer、Selector 等新的抽象，基于 RandomAccessFile、FileChannel、ByteBuffer 进行文件读写，基于 SocketChannel 和 ServerSocketChannel 进行网络通信。</p><p>实际上，“旧”的 I/O 包已经使用 NIO 重新实现过，所以在进行文件读写时，NIO 并无法体现出比 BIO 更可靠的性能。</p><p>NIO 的魅力主要体现在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，极大地提高了网络编程的性能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-28.png" alt="三分恶面渣逆袭：NIO"></p><p>缓冲区 Buffer 也能极大提升一次 IO 操作的效率。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-29.png" alt="三分恶面渣逆袭：NIO完整示意图"></p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO 是 Java 7 引入的，放在 java.nio.channels 包下，提供了 AsynchronousFileChannel、AsynchronousSocketChannel 等异步 Channel。</p><p>它引入了异步通道的概念，使得 I/O 操作可以异步进行。这意味着线程发起一个读写操作后不必等待其完成，可以立即进行其他任务，并且当读写操作真正完成时，线程会被异步地通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;test.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">Future&lt;Integer&gt; result = fileChannel.read(buffer, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><h2 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h2><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>举个例子，Java 中的 <code>for-each</code> 就是一个常用的语法糖，其原理其实就是基于普通的 for 循环和迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;JavaGuide&quot;</span>, <span class="string">&quot;公众号：JavaGuide&quot;</span>, <span class="string">&quot;博客：https://javaguide.cn/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p><h2 id="Java-中有哪些常见的语法糖？"><a href="#Java-中有哪些常见的语法糖？" class="headerlink" title="Java 中有哪些常见的语法糖？"></a>Java 中有哪些常见的语法糖？</h2><p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，Java基础的常出现的八股文就已经结束了，只看一遍当然是不够的，有一些比较复杂的内容我也还没有完全理解，后面继续会看。</p><p>在写这种总结类型的博客时，我总会想这有什么用，我并不会一个字一个字地打出来，更多的还是把别人文章中的内容复制下来了，有的地方甚至会被我删掉，这也使得后面我再去看的时候可能会看不懂。所以我会在写博客和删博客的过程中浪费掉大量的时间，设置在开始写之前，我还会去浪费时间设计结构，美其名曰为了更好的知识组织，其实就是为了偷会懒。</p><p>但是写这些会省去我后面继续去查找资料的时间，而且如果不写下来的话，只看一遍基本上是什么都记不住的。</p><p>不管有没有意义，我都会一直坚持写写博客，这不只是为了秋招而做的准备，更是养成一种学习的习惯吧。</p><p>下一篇八股文就要在集合框架或者并发编程上见了。</p><p>让人惊讶的是，昨天晚上腾讯的面试竟然过了，如果有二面的机会，我一定会好好把握的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html">https://javaguide.cn/java/basis/java-basic-questions-03.html</a></p><p><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></p><p><a href="https://javabetter.cn/sidebar/sanfene/javase.html">https://javabetter.cn/sidebar/sanfene/javase.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是 Java 基础八股文的第三篇，本文内容包括异常、泛型、反射、注解、SPI、I/O等，内容很杂也是一些重要内容，一两个问题讲不清的后面还是要单独来学习吧。&lt;/p&gt;
&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存那些坑：击穿、穿透、雪崩与数据一致性</title>
    <link href="http://example.com/2024/06/18/Redis%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E5%9D%91%EF%BC%9A%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://example.com/2024/06/18/Redis%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E5%9D%91%EF%BC%9A%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-06-18T13:33:50.000Z</published>
    <updated>2024-06-18T15:49:40.637Z</updated>
    
    <content type="html"><![CDATA[<p>又是这几个老生常谈的问题，在正式开始学习 Redis 之前，我就知道这几个问题，在无数个老哥的面试经验里面看到过这四个问题，让我一直觉得在简历上写熟悉 Redis 就只需要准备这几个问题就行了，但是实际上好像并没有面试官会问这几个问题，至少对我来说是这样的。</p><p>在之前的博客里面也大概讲过前三个问题，但是当时就是把别人写的八股文给复制下来了，今天还是想要在重新记录一下。</p><h1 id="Redis-三兄弟"><a href="#Redis-三兄弟" class="headerlink" title="Redis 三兄弟"></a>Redis 三兄弟</h1><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p><p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/37e4378d2edcb5e217b00e5f12973efd-20230309232858764.png" alt="图片"></p><p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p><p>这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e2b8d2eb5536aa71664772457792ec40-20230309232851699.png" alt="图片"></p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片"></p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li>大量数据同时过期；</li><li>Redis 故障宕机；</li></ul><p>不同的诱因，应对的策略也会不同。</p><h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>均匀设置过期时间；</li><li>互斥锁；</li><li>后台更新缓存；</li></ul><ol><li><p>均匀设置过期时间</p><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p></li><li><p>互斥锁</p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></li><li><p>后台更新缓存</p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p></li></ol><h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul><ol><li><p>服务熔断或请求限流机制</p><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p></li><li><p>构建 Redis 缓存高可靠集群</p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p></li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/acb5f4e7ef24a524a53c39eb016f63d4-20230309232840753.png" alt="图片"></p><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b7031182f770a7a5b3c82eaf749f53b0-20230309232834574.png" alt="图片"></p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li>第一种方案，非法请求的限制；</li><li>第二种方案，缓存空值或者默认值；</li><li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li></ul><p><strong>第一种方案，非法请求的限制</strong></p><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p><p><strong>第二种方案，缓存空值或者默认值</strong></p><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p><p><strong>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</strong></p><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p><p>那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。</p><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/86b0046c2622b2c4bda697f9bc0f5b28.png" alt="图片"></p><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p><p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p><p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p><p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片"></p><h1 id="数据一致性：Redis和MySQL的“远距离恋爱”"><a href="#数据一致性：Redis和MySQL的“远距离恋爱”" class="headerlink" title="数据一致性：Redis和MySQL的“远距离恋爱”"></a>数据一致性：Redis和MySQL的“远距离恋爱”</h1><p>如何保证缓存和数据库一致性，这是一个老生常谈的话题了。</p><p>但很多人对这个问题，依旧有很多疑惑：</p><ul><li>到底是更新缓存还是删缓存？</li><li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li><li>为什么要引入消息队列保证一致性？</li><li>延迟双删会有什么问题？到底要不要用？</li><li>…</li></ul><p>为了解开上面的这些疑惑，我们一步一步来看。</p><h2 id="引入缓存提高性能"><a href="#引入缓存提高性能" class="headerlink" title="引入缓存提高性能"></a>引入缓存提高性能</h2><p>我们从最简单的场景开始讲起。</p><p>如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310437299742.jpg" alt="img"></p><p>但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。</p><p>这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074028.jpg" alt="img"></p><p>当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。</p><p>但引入缓存之后，你就会面临一个问题：<strong>之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？</strong></p><p>最简单直接的方案是「全量数据刷到缓存中」：</p><ul><li>数据库的数据，全量刷入缓存（不设置失效时间）</li><li>写请求只更新数据库，不更新缓存</li><li>启动一个定时任务，定时把数据库的数据，更新到缓存中</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074037.jpg" alt="img"></p><p>这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。</p><p>但缺点也很明显，有 2 个问题：</p><ol><li><strong>缓存利用率低</strong>：不经常访问的数据，还一直留在缓存中</li><li><strong>数据不一致</strong>：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）</li></ol><p>所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。</p><p>那如果我们的业务体量很大，怎么解决这 2 个问题呢？</p><h2 id="缓存利用率和一致性问题"><a href="#缓存利用率和一致性问题" class="headerlink" title="缓存利用率和一致性问题"></a>缓存利用率和一致性问题</h2><p>先来看第一个问题，如何提高<strong>缓存利用率</strong>？</p><p>想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？</p><p>我们可以这样优化：</p><ul><li>写请求依旧只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074043.jpg" alt="img"></p><p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。</p><hr><p>再来看<strong>数据一致性</strong>问题。</p><p>要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。</p><p>所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。</p><p>但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p><ol><li>先更新缓存，后更新数据库</li><li>先更新数据库，后更新缓存</li></ol><p>哪个方案更好呢？</p><p>先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。</p><p>因为操作分为两步，那么就很有可能存在<strong>「第一步成功、第二步失败」</strong>的情况发生。</p><h3 id="先更新缓存，后更新数据库"><a href="#先更新缓存，后更新数据库" class="headerlink" title="先更新缓存，后更新数据库"></a><strong>先更新缓存，后更新数据库</strong></h3><p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。</p><p>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。</p><p>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p><h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a><strong>先更新数据库，再更新缓存</strong></h3><p>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。</p><p>之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。</p><p>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。</p><hr><p>可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？</p><p>别急，后面我会详细给出对应的解决方案。</p><p>我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？</p><p>这里我们还需要重点关注：<strong>并发问题</strong>。</p><h2 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h2><p>在两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？</p><p>有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p><ol><li>线程 A 更新数据库（缓存）（X = 1）</li><li>线程 B 更新数据库（缓存）（X = 2）</li><li>线程 B 更新缓存（数据库）（X = 2）</li><li>线程 A 更新缓存（数据库）（X = 1）</li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/454a8228a6549176ad7e0484fba3c92b.png" alt="图片"></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/8febac10b14bed16cb96d1d944cd08da.png" alt="图片"></p><p>从上面的两张流程图也不难看出，即使两步都能成功执行，也无法保证数据库和缓存之间的一致性。</p><hr><p>那怎么解决这个问题呢？这里通常的解决方案是，加<strong>「分布式锁」</strong>。</p><p>两个线程要修改「同一条」数据，每个线程在改之前，先去申请分布式锁，拿到锁的线程才允许更新数据库和缓存，拿不到锁的线程，返回失败，等待下次重试。</p><p>这么做的目的，就是为了只允许一个线程去操作数据和缓存，避免并发问题。</p><p>除此之外，我们从<strong>「缓存利用率」</strong>的角度来评估这个方案，也是不太推荐的。</p><p>这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。</p><p>而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。</p><p>由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。</p><p>所以此时我们需要考虑另外一种方案：<strong>删除缓存</strong>。</p><h2 id="删除缓存能保证一致性吗？"><a href="#删除缓存能保证一致性吗？" class="headerlink" title="删除缓存能保证一致性吗？"></a>删除缓存能保证一致性吗？</h2><p>同样地，先来看「第二步」操作失败的情况。</p><p>先删除缓存，后更新数据库，第二步操作失败，数据库没有更新成功，那下次读缓存发现不存在，则从数据库中读取，并重建缓存，此时数据库和缓存依旧保持一致。</p><p>但如果是先更新数据库，后删除缓存，第二步操作失败，数据库是最新值，缓存中是旧值，发生不一致。所以，这个方案依旧存在问题。</p><p>总之，和前面提到的问题类似，第二步失败依旧有不一致的风险。</p><p>好，我们再来看<strong>「并发」</strong>问题，这个问题是我们需要关注的「重点」。</p><hr><h3 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a><strong>先删除缓存，后更新数据库</strong></h3><p>假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/cc208c2931b4e889d1a58cb655537767.png" alt="图片"></p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p><p>可以看到，<strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。</p><h3 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h3><p>继续用「读 + 写」请求的并发的场景来分析。</p><p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1cc7401143e79383ead96582ac11b615.png" alt="图片"></p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</p><p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p><p>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p><p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p><p>为了确保万无一失，给缓存数据加上了「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p><p>好，解决了并发问题，我们继续来看前面遗留的，<strong>第二步执行「失败」导致数据不一致的问题</strong>。</p><h2 id="如何保证两部都执行成功？"><a href="#如何保证两部都执行成功？" class="headerlink" title="如何保证两部都执行成功？"></a>如何保证两部都执行成功？</h2><p>前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p><p><strong>保证第二步成功执行，就是解决问题的关键</strong>。</p><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>想一下，程序在执行过程中发生异常，最简单的解决办法是什么？</p><p>答案是：<strong>重试</strong>。</p><p>是的，其实这里我们也可以这样做。</p><p>无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。</p><p>那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？</p><p>答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p><ul><li>立即重试很大概率「还会失败」</li><li>「重试次数」设置多少才合理？</li><li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li></ul><p>看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。</p><p>那更好的方案应该怎么做？</p><p>答案是：<strong>异步重试</strong>。什么是异步重试？</p><p>其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。</p><p>或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</p><p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？</p><p>这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p><p>所以，这里我们必须把重试消息或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p><ul><li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li><li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的需求）</li></ul><p>至于写队列失败和消息队列的维护成本问题：</p><ul><li><strong>写队列失败</strong>：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li><li><strong>维护成本</strong>：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li></ul><p>所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074049.jpg" alt="img"></p><h3 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h3><p>那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？</p><p>方案还是有的，这就是近几年比较流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p><p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。</p><p>那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。</p><p>拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074053.jpg" alt="img"></p><p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p><ul><li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li><li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li></ul><p>当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。</p><blockquote><p>如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。</p></blockquote><p>至此，我们可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p><h2 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h2><p>到这里，还有 2 个问题，是我们没有重点分析过的。</p><p><strong>第一个问题</strong>，还记得前面讲到的「先删除缓存，再更新数据库」导致不一致的场景么？</p><p>这里我再把例子拿过来让你复习一下：</p><p>2 个线程要并发「读写」数据，可能会发生以下场景：</p><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p><strong>第二个问题</strong>：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。</p><p>如果使用「先更新数据库，再删除缓存」方案，其实也发生不一致：</p><ol><li>线程 A 更新主库 X = 2（原值 X = 1）</li><li>线程 A 删除缓存</li><li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li><li>从库「同步」完成（主从库 X = 2）</li><li>线程 B 将「旧值」写入缓存（X = 1）</li></ol><p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p><p>看到了么？这 2 个问题的核心在于：<strong>缓存都被回种了「旧值」</strong>。</p><p>那怎么解决这类问题呢？</p><p>最有效的办法就是，<strong>把缓存删掉</strong>。</p><p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。</p><p>按照延时双删策略，这 2 个问题的解决方案是这样的：</p><p><strong>解决第一个问题</strong>：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p><p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p><p>这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。</p><p>但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p><ul><li>问题1：延迟时间要大于「主从复制」的延迟时间</li><li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li></ul><p>但是，<strong>这个时间在分布式和高并发场景下，其实是很难评估的。</strong></p><p>很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。</p><p>所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p><p>所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p><h2 id="可以做到强一致吗？"><a href="#可以做到强一致吗？" class="headerlink" title="可以做到强一致吗？"></a>可以做到强一致吗？</h2><p>看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？</p><p>其实很难。</p><p>要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。</p><p>相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？</p><p>没错，<strong>性能</strong>。</p><p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。</p><p>所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。</p><p>虽然我们可以通过加「分布锁」的方式来实现，但我们也要付出相应的代价，甚至很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。</p><p>同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，第一部分内容已经被讲烂掉了，但是第二部分内容却是比较重要和新奇的，虽然之前有了解到这样的问题，但是以笔者这样的拖延症晚期，一般是不会马上学习的，写本文时也是笔者第一次学习这部分内容。明天继续面试，祝我面试顺利。</p><p>本以为这个老生常谈的话题，写起来很好写，没想到在写的过程中，还是挖到了很多之前没有深度思考过的细节。</p><p>好了，总结一下这篇文章的重点。</p><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况</p><p>4、采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估</p><p>5、采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致</p><p>6、采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/">http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/</a></p><p><a href="https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7">https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又是这几个老生常谈的问题，在正式开始学习 Redis 之前，我就知道这几个问题，在无数个老哥的面试经验里面看到过这四个问题，让我一直觉得在简历上写熟悉 Redis 就只需要准备这几个问题就行了，但是实际上好像并没有面试官会问这几个问题，至少对我来说是这样的。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>红黑树是什么？——一个“清朝”的遗留问题</title>
    <link href="http://example.com/2024/06/17/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E2%80%9C%E6%B8%85%E6%9C%9D%E2%80%9D%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/06/17/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E2%80%9C%E6%B8%85%E6%9C%9D%E2%80%9D%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/</id>
    <published>2024-06-17T13:38:37.000Z</published>
    <updated>2024-06-18T09:36:36.786Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学我们的老朋友——红黑树。为什么今天的标题透着一股诡异的气息，清朝的遗留问题，其实是笔者从大一就开始说要去学一直到现在都没学的一个知识点。</p><p>为什么最近突然想起来这个老朋友了？最近 Java 的基础知识也学得差不多了，所以开始看一些 Java 的集合框架，学的过程中我又看到了这个老朋友。做事实在是太拖拉了，都两年多了才开始学一些基础的东西，被秒挂也不是什么稀奇事了。</p><h1 id="红黑树为什么必须掌握？"><a href="#红黑树为什么必须掌握？" class="headerlink" title="红黑树为什么必须掌握？"></a>红黑树为什么必须掌握？</h1><p>来看看，红黑树的广泛的应用</p><ul><li>JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树</li><li>Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构</li><li>Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。</li><li>多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。</li></ul><p>面试过程中，HashMap 常常是面试的重点， 而且会以<strong>连环炮 的方式</strong>进行发问，</p><p>所以， <strong>红黑树基本是 面试必须的 要点</strong>， <strong>如果 答不上来，面试就有 很大程度 就黄了</strong>。笔者就有相似的经历，被面试官突然提起的红黑树硬控了几秒，回忆起三年前的青葱岁月（bushi）。</p><p>红黑树，又比较复杂，有非常多的场景, 大家记住不容易。</p><p>那为了更加全面地了解红黑树，我们就不得不再一次提起之前在 MySQL 索引方面提到的几种二叉树了。还是再看看吧，加深一下记忆。</p><h1 id="BST-二叉搜索树"><a href="#BST-二叉搜索树" class="headerlink" title="BST 二叉搜索树"></a>BST 二叉搜索树</h1><p>二叉查找树（BST）具备以下特性：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ol><h2 id="完美的二叉搜索树"><a href="#完美的二叉搜索树" class="headerlink" title="完美的二叉搜索树"></a>完美的二叉搜索树</h2><p>一般人们理解的二叉树（<strong>又叫二叉搜索树 BST</strong>）会出现一个问题，完美的情况下，它是这样的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8555d3dc4ccc9c65bd59977ff14397ee.png" alt="img"></p><h2 id="极端情况下的二叉搜索树"><a href="#极端情况下的二叉搜索树" class="headerlink" title="极端情况下的二叉搜索树"></a>极端情况下的二叉搜索树</h2><p>二叉查找树是有缺点的，在不断插入的时候，<strong>有可能出现这样一种情况：</strong>很容易“退化”成链表，</p><p>如果bst 树的节点正好从大到小的插入，此时树的结构也类似于链表结构，这时候的查询或写入耗时与链表相同。</p><h4 id="退化成为了-链表的特殊BST"><a href="#退化成为了-链表的特殊BST" class="headerlink" title="退化成为了 链表的特殊BST"></a>退化成为了 链表的特殊BST</h4><p>一颗特殊BST，退化成为了 链表，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fbbb12eb4a708f7c02cfaf1cda065d24.png" alt="img"></p><p>它和链表一样，搜索的时候，最坏情况的时间复杂度O(n) 。</p><h4 id="那么我们怎么避免这种情况呢？"><a href="#那么我们怎么避免这种情况呢？" class="headerlink" title="那么我们怎么避免这种情况呢？"></a>那么我们怎么避免这种情况呢？</h4><p>为了避免这种特殊的情况发生，引入了平衡二叉树（AVL）和红黑树（red-black tree）。</p><p>AVL 、rbt 都是通过本身的建树原则来控制树的层数和节点位置，</p><p>因为 rbtree 是由AVL演变而来，所以我们从了解AVL开始。</p><h1 id="AVL-平衡二叉树"><a href="#AVL-平衡二叉树" class="headerlink" title="AVL 平衡二叉树"></a>AVL 平衡二叉树</h1><p>平衡二叉树也叫AVL（发明者名字简写），也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡。</p><blockquote><p>AVL树是最先发明的自平衡二叉查找树。</p><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。</p><p>增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p></blockquote><h2 id="AVL-的特性"><a href="#AVL-的特性" class="headerlink" title="AVL 的特性"></a>AVL 的特性</h2><p>AVL树本质上还是一棵二叉搜索树，它有以下特性：</p><ul><li>特性1： 对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li><li>特性2：对于AVL树而言，其中任何子树仍然是AVL树；</li><li>特性3：每个节点的左右子节点的高度之差的绝对值最多为1；</li></ul><blockquote><p>特性1表明，AVL 继承于 BST , 所以:</p><p>1.AVL本身首先是一棵BST 二叉搜索树。<br>2.AVL带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p></blockquote><p>在插入、删除树节点的时候，如果破坏了以上的原则，<strong>AVL树会自动进行调整</strong>使得以上三条原则仍然成立。</p><p>也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。</p><h2 id="AVL-的平衡功能"><a href="#AVL-的平衡功能" class="headerlink" title="AVL 的平衡功能"></a>AVL 的平衡功能</h2><p>举个例子，下左图为AVL树最长的2节点与最短的8节点高度差为1；</p><p>当插入一个新的节点后，根据上面第一条原则，它会出现在2节点的左子树，但这样一来就违反了原则3。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a075215c8d79d1930c4233e44bb7a8ae.png" alt="img"></p><p>此时AVL树会通过节点的旋转进行进行平衡，</p><p>AVL调整的过程称之为左旋和右旋。</p><h3 id="调整过程"><a href="#调整过程" class="headerlink" title="调整过程"></a>调整过程</h3><p><strong>旋转之前，首先确定旋转支点（pivot）：</strong> 这个旋转支点就是失去平衡这部分树，在自平衡之后的根节点，</p><p>平衡的调整过程，需要根据pivot它来进行旋转。</p><p>我们在学习AVL树的旋转时，不要将失衡问题扩大到整个树来看，这样会扰乱你的思路，</p><p>我们只关注<strong>失衡子树的根结点</strong> 及它的子节点和孙子节点即可。</p><p>事实上，AVL树的旋转，我们权且叫“AVL旋转”是有规律可循的，因为只要聚焦到<strong>失衡子树，</strong>然后进行左旋、右旋即可。</p><blockquote><p>很多人在左旋和右旋有时候弄不明白，</p><p>其实左旋就是逆时针转，右旋是顺时针转</p></blockquote><h2 id="AVL-子树的四大场景"><a href="#AVL-子树的四大场景" class="headerlink" title="AVL 子树的四大场景"></a>AVL 子树的四大场景</h2><p>导致AVL失衡的场景就是有限的4个：</p><ul><li>左左结构失衡（LL型失衡）</li><li>右右结构失衡（RR型失衡）</li><li>左右结构失衡（LR型失衡）</li><li>右左结构失衡（RL型失衡）</li></ul><p>删除元素，也会导致AVL失衡，需要再平衡，但是原理和插入元素是类似的。</p><p>这里聚焦 介绍插入元素的平衡过程， 删除元素，不做介绍。</p><h3 id="场景一：LL型失衡-左左结构失衡（右旋）"><a href="#场景一：LL型失衡-左左结构失衡（右旋）" class="headerlink" title="场景一：LL型失衡-左左结构失衡（右旋）"></a>场景一：LL型失衡-左左结构失衡（右旋）</h3><p>场景： 插入的元素在子树root的左侧不平衡元素的左侧</p><p>此时，以root的左儿为支点，也就是，左侧的不平衡元素为pivot(支点), 进行右旋</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618164813142.png" alt="image-20240618164813142"></p><p>来一个右旋的动画：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/96a7aa160f13424abb4acd1ada47edbf.webp" alt="在这里插入图片描述"></p><blockquote><p>右旋过程中，如果pivot有右子树，则作为 原root的 左子树， 保障AVL的特性1</p></blockquote><h4 id="记忆要点"><a href="#记忆要点" class="headerlink" title="记忆要点"></a><strong>记忆要点</strong></h4><blockquote><p>旋转的反向，与失衡的方向相反，</p><p>LL 型失衡，与左边 相反的方向， 是右边，所以是右旋</p></blockquote><h3 id="场景二：RR型失衡-右右结构失衡（左旋）"><a href="#场景二：RR型失衡-右右结构失衡（左旋）" class="headerlink" title="场景二：RR型失衡-右右结构失衡（左旋）"></a>场景二：RR型失衡-右右结构失衡（左旋）</h3><blockquote><p>场景：插入的元素在子树root右侧的不平衡子树的右侧</p><p>此时，以root的右儿为支点，也就是，右侧的不平衡元素 为 pivot(支点)， 进行左旋</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dea622e0576539552458e3afcffb1f59.png" alt="img"></p><p>来一个左旋的动画：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba1adc2895cf4b1aaef2e7088d9f6a69.webp" alt="在这里插入图片描述"></p><blockquote><p>左旋过程中，如果pivot有左子树，则作为 原root的 右子树，</p><p>保障AVL的特性1，</p></blockquote><h4 id="记忆要点-1"><a href="#记忆要点-1" class="headerlink" title="记忆要点"></a><strong>记忆要点</strong></h4><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RR 型失衡，与右边 相反的方向， 是左边，所以是左旋</p></blockquote><h3 id="场景三：LR型失衡-左右结构失衡（左旋-右旋）"><a href="#场景三：LR型失衡-左右结构失衡（左旋-右旋）" class="headerlink" title="场景三：LR型失衡-左右结构失衡（左旋+右旋）"></a>场景三：LR型失衡-左右结构失衡（左旋+右旋）</h3><blockquote><p>场景： 插入的元素在左侧的不平衡元素的右侧</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a50f45a2c27e4f330603481789d5234c.png" alt="img"></p><h4 id="记忆要点-2"><a href="#记忆要点-2" class="headerlink" title="记忆要点"></a>记忆要点</h4><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>LR型失衡，与只相反的方向是 RL，但是先旋转底部，再旋转顶部，RL进行次序颠倒，LR</p><p>所以， LR型失衡，旋转的方式，是先左旋， 再右旋</p></blockquote><h3 id="场景四：RL失衡-右左结构失衡-（右旋-左旋）"><a href="#场景四：RL失衡-右左结构失衡-（右旋-左旋）" class="headerlink" title="场景四：RL失衡:-右左结构失衡 （右旋+左旋）"></a>场景四：RL失衡:-右左结构失衡 （右旋+左旋）</h3><p>场景： 插入的元素在右侧的不平衡元素的左侧</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/24326f9fded29e6f566738f86525d468.png" alt="img"></p><h4 id="记忆要点-3"><a href="#记忆要点-3" class="headerlink" title="记忆要点"></a>记忆要点</h4><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RL型失衡，与只相反的方向是 LR，但是先旋转底部，再旋转顶部，所以，LR进行次序颠倒，RL</p><p>最终， RL型失衡，旋转的方式，是先右旋， 再左旋</p></blockquote><h3 id="AVL-的删除"><a href="#AVL-的删除" class="headerlink" title="AVL 的删除"></a>AVL 的删除</h3><p><strong>删除的判断标准</strong></p><ol><li>要删除的节点是什么类型的节点？；</li><li>删除后是否会破坏平衡 ；</li></ol><p><strong>节点类型</strong></p><ol><li>叶子节点；</li><li>节点只有左子树或只有右子树 ；</li><li>既有左右子树都有。</li></ol><p><strong>处理的思路</strong></p><ol><li>当删除为叶子节点，则直接删除，并从父亲节点开始往上看，判断是否失衡；如果没有失衡，再判断父亲的父节点是否失衡，直到根节点。若失衡则判断失衡类型（LL、LR、RR、RL），再进行相应的调整。</li><li>删除的节点只有左子树或只有右子树，那么将节点删除，以左子树或右子树进行代替，并进行相应的平衡判断，若失衡则调整，一直到根节点 ；</li><li>删除的节点既有左子树又有右子树，找到其前驱或者后驱节点将其替换，再判断是否失衡，然后根据失衡情况调整，直到根节点。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>既然AVL树可以保证二叉树的平衡，这就意味着AVL搜索的时候，它最坏情况的时间复杂度O(logn) ，要低于普通二叉树BST和链表的最坏情况O(n)。</p><p>那么HashMap直接使用AVL树来替换链表就好了，为什么选择用红黑树呢？</p><p>原因是：</p><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;= 1，所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p><p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是 <strong>增加删除 频繁</strong>的场景。</p><p><strong>红黑树(rbt)做了什么优化呢？</strong></p><p>红黑树(rbt)继承了AVL可自平衡的优点，</p><p>同时, 红黑树(rbt)在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除 频繁</strong>的场景。</p><p>在实际应用中，红黑树的使用要多得多。</p><h1 id="RBTree-红黑树"><a href="#RBTree-红黑树" class="headerlink" title="RBTree 红黑树"></a>RBTree 红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树）</p><p>红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees），在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p>红黑树也是一种自平衡二叉查找树，它与AVL树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。</p><p>与AVL树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时<strong>较少的旋转</strong>操作，整体来说性能要优于AVL树。</p><p>虽然 RBTree 是复杂的, 但它的<strong>最坏情况运行时间</strong>也是非常良好的,并且在实践中是高效的：</p><blockquote><p>它可以在<strong>O(log n)</strong>时间内做查找,插入和删除,这里的<strong>n 是树中元素的数目.</strong></p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>红黑树是实际应用中最常用的平衡二叉查找树，它不严格的具有平衡属性，但平均的使用性能非常良好。</p><p>在红黑树中，节点被标记为红色和黑色两种颜色。</p><p>红黑树的原则有以下几点：</p><ul><li>特性1：节点非黑即红</li><li>特性2：根节点一定是黑色</li><li>特性3：叶子节点（NIL）一定是黑色</li><li>特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p><strong>红色属性</strong> 说明，红色节点的孩子，一定是黑色。 但是，RBTree 黑色节点的孩子，可以是红色，也可以是黑色，具体如下图。</p><p><strong>叶子属性</strong> 说明， 叶子节点可以是空nil ，AVL的叶子节点不是空的，具体如下图。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20200901114718174.png" alt="img"></p><p>基于上面的原则，我们一般在插入红黑树节点的时候，会将这个节点设置为红色，</p><p>原因参照最后一条原则： <strong>红色破坏原则的可能性最小</strong>，如果是黑色, 很可能<strong>导致这条支路的黑色节点比其它支路的要多1</strong>，破坏了平衡。</p><p>黑色属性，可以理解为<strong>平衡特征</strong>， 如果满足不了平衡特征，就要进行平衡操作。</p><p><strong>空间换时间</strong></p><p>RBT有点属于一种<strong>空间换时间</strong>类型的优化，</p><p>在 AVL 的节点上，增加了<strong>颜色属性的 数据</strong>，相当于增加了空间的消耗。通过颜色属性的增加，换取后面平衡操作的次数减少。</p><h2 id="黑色完美平衡"><a href="#黑色完美平衡" class="headerlink" title="黑色完美平衡"></a>黑色完美平衡</h2><p>红黑树并不是一颗<strong>AVL平衡二叉搜索树</strong>，从图上可以看到，根节点P的左子树显然比右子树高</p><p>根据 红黑树的特性5，从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点， 说明：</p><blockquote><p>rbt 的 左子树和右子树的黑节点的层数是相等的</p><p>红黑树的平衡条件，不是以整体的高度来约束的，而是以黑色 节点的 高度，来约束的。</p></blockquote><p>所以称红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210410220909965.png" alt="在这里插入图片描述"></p><p>看看<strong>黑色完美平衡</strong>的效果，</p><p>去掉 rbt中的红色节点，会得到 一个四叉树， 从根节点到每一个叶子，高度相同，就是rbt的root到叶子的黑色路径长度。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618170439695.png" alt=""></p><h2 id="红黑树的平衡操作"><a href="#红黑树的平衡操作" class="headerlink" title="红黑树的平衡操作"></a>红黑树的平衡操作</h2><p>一旦红黑树5个原则有不满足的情况，我们视为平衡被打破，如何恢复平衡？</p><p>靠它的三种操作：<strong>变色、左旋、右旋</strong>。</p><h3 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h3><p>节点的颜色由红变黑或由黑变红。（这个操作很好了解）</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的左子树（左旋），pivot的原左子树变成 原root节点的 右子树，pivot的原右子树保持不变。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba1adc2895cf4b1aaef2e7088d9f6a69.webp" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618170920241.png" alt="image-20240618170920241"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的右子树（<strong>右旋</strong>），pivot的原右子树变成 原root节点的 左子树，pivot的原左子树保持不变。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/96a7aa160f13424abb4acd1ada47edbf.webp" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618171005287.png" alt="image-20240618171005287"></p><p>红黑树的左旋、右旋操作，AVL树的左旋，右旋操作差不多</p><h2 id="插入节点场景分析"><a href="#插入节点场景分析" class="headerlink" title="插入节点场景分析"></a>插入节点场景分析</h2><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>默认新插入的节点为红色</strong>：</p><p>因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突</p><h3 id="场景一：红黑树为空树"><a href="#场景一：红黑树为空树" class="headerlink" title="场景一：红黑树为空树"></a>场景一：红黑树为空树</h3><p>直接把插入结点作为根节点就可以了</p><p>另外：根据红黑树性质 2根节点是黑色的。还需要把插入节点设置为黑色。</p><h3 id="场景二：插入节点的-Key-已经存在"><a href="#场景二：插入节点的-Key-已经存在" class="headerlink" title="场景二：插入节点的 Key 已经存在"></a>场景二：插入节点的 Key 已经存在</h3><p>更新当前节点的值，为插入节点的值。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412094118977.png" alt="在这里插入图片描述"></p><h3 id="场景三：插入节点的父节点为黑色"><a href="#场景三：插入节点的父节点为黑色" class="headerlink" title="场景三：插入节点的父节点为黑色"></a>场景三：插入节点的父节点为黑色</h3><p>由于插入的节点是红色的，当插入节点的父节点是黑色时，不会影响红黑树的平衡，</p><p>所以： <strong>直接插入无需做自平衡</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412094724987.png" alt="在这里插入图片描述"></p><h3 id="场景四：插入节点的父节点为红色"><a href="#场景四：插入节点的父节点为红色" class="headerlink" title="场景四：插入节点的父节点为红色"></a>场景四：插入节点的父节点为红色</h3><p>根据性质2：根节点是黑色。</p><p>如果插入节点的父节点为红色节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点(三代关系)。</p><p>根据性质4：每个<strong>红色</strong>节点的两个子节点一定是<strong>黑色</strong>的。不能有<strong>两个红色节点相连</strong>。</p><p>此时会出现两种状态：</p><ul><li>父亲和叔叔为红色</li><li>父亲为红色，叔叔为黑色</li></ul><p>如图</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412100154174.png" alt="在这里插入图片描述"></p><h4 id="场景4-1：父亲和叔叔为红色节点"><a href="#场景4-1：父亲和叔叔为红色节点" class="headerlink" title="场景4.1：父亲和叔叔为红色节点"></a>场景4.1：父亲和叔叔为红色节点</h4><p>根据性质4：<strong>红色节点不能相连 ==》祖父节点肯定为黑色节点：</strong></p><p>父亲为红色，那么此时该插入子树的红黑树层数的情况是：黑红红。</p><p>因为不可能同时存在两个相连的红色节点，需要进行 变色， 显然处理方式是把其改为：红黑红</p><p><strong>变色 处理</strong>：黑红红 ==&gt; 红黑红</p><p>1.将F和V节点改为黑色</p><p>2.将P改为红色</p><p>3.将P设置为当前节点，进行后续处理</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2021041210371914.png" alt="在这里插入图片描述"></p><p>可以看到，将P设置为红色了，</p><p>如果<strong>P的父节点是黑色</strong>，那么无需做处理；</p><p>但如果P的父节点是红色，则违反红黑树性质了，所以需要将P设置为当前节点，继续插入操作, 作自平衡处理，直到整体平衡为止。</p><h4 id="场景4-2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点"><a href="#场景4-2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点" class="headerlink" title="场景4.2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点"></a>场景4.2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点</h4><p>叔叔为黑色，或者不存在（NIL）也是黑节点，并且节点的父亲节点是祖父节点的左子节点</p><p>注意：单纯从插入来看，叔叔节点非红即黑(NIL节点)，否则破坏了红黑树性质5，此时路径会比其他路径多一个黑色节点。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412104637494.png" alt="在这里插入图片描述"></p><h5 id="场景4-2-1：LL型失衡"><a href="#场景4-2-1：LL型失衡" class="headerlink" title="场景4.2.1：LL型失衡"></a>场景4.2.1：LL型失衡</h5><p>细分场景 1： 新插入节点，为其父节点的左子节点(LL红色情况)， 插入后 就是LL 型失衡</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412151911439.png" alt="在这里插入图片描述"></p><h5 id="自平衡处理："><a href="#自平衡处理：" class="headerlink" title="自平衡处理："></a>自平衡处理：</h5><p>1.变颜色：将F设置为黑色，将P设置为红色</p><p>2.对F节点进行<strong>右旋</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412160626713.png" alt="在这里插入图片描述"></p><h5 id="场景4-2-2：LR型失衡"><a href="#场景4-2-2：LR型失衡" class="headerlink" title="场景4.2.2：LR型失衡"></a>场景4.2.2：LR型失衡</h5><p>细分场景 2： 新插入节点，为其父节点的右子节点(LR红色情况)， 插入后 就是LR 型失衡</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412153113242.png" alt="在这里插入图片描述"></p><h5 id="自平衡处理：-1"><a href="#自平衡处理：-1" class="headerlink" title="自平衡处理："></a>自平衡处理：</h5><p>1.对F进行左旋</p><p>2.将F设置为当前节点，得到LL红色情况</p><p>3.按照LL红色情况处理(1.变色 2.右旋P节点)<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412153954767.png" alt="在这里插入图片描述"></p><h4 id="情景4-3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点"><a href="#情景4-3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点" class="headerlink" title="情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点"></a>情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点</h4><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412155353126.png" alt="在这里插入图片描述"></p><h5 id="情景4-3-1：RR型失衡"><a href="#情景4-3-1：RR型失衡" class="headerlink" title="情景4.3.1：RR型失衡"></a>情景4.3.1：RR型失衡</h5><p>新插入节点，为其父节点的右子节点(RR红色情况)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412155529702.png" alt="在这里插入图片描述"></p><p><strong>自平衡处理</strong>：</p><p>1.变色：将F设置为黑色，将P设置为红色</p><p>2.对P节点进行<strong>左旋</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412160829355.png" alt="在这里插入图片描述"></p><h5 id="情景4-3-2：RL型失衡"><a href="#情景4-3-2：RL型失衡" class="headerlink" title="情景4.3.2：RL型失衡"></a>情景4.3.2：RL型失衡</h5><p>新插入节点，为其父节点的左子节点(RL红色情况)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412161045393.png" alt="在这里插入图片描述"></p><p><strong>自平衡处理</strong>：</p><p>1.对F进行右旋</p><p>2.将F设置为当前节点，得到RR红色情况</p><p>3.按照RR红色情况处理(1.变色 2.左旋 P节点)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412161924591.png" alt="在这里插入图片描述"></p><h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="有了二叉搜索树，为什么还需要平衡二叉树？"><a href="#有了二叉搜索树，为什么还需要平衡二叉树？" class="headerlink" title="有了二叉搜索树，为什么还需要平衡二叉树？"></a><strong>有了二叉搜索树，为什么还需要平衡二叉树？</strong></h3><p>二叉搜索树容易退化成一条链</p><p>这时，查找的时间复杂度从O ( log n）也将退化成O ( N )</p><p>引入对左右子树高度差有限制的平衡二叉树 AVL，保证查找操作的最坏时间复杂度也为O ( log n）。</p><h3 id="有了平衡二叉树，为什么还需要红黑树？"><a href="#有了平衡二叉树，为什么还需要红黑树？" class="headerlink" title="有了平衡二叉树，为什么还需要红黑树？"></a>有了平衡二叉树，为什么还需要红黑树？</h3><p>AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡</p><p>在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣</p><p>红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，</p><p>整体性能优于AVL</p><ul><li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</li><li>红黑树的红黑规则，保证最坏的情况下，也能在O ( log n）时间内完成查找操作。</li></ul><h3 id="红黑树那几个原则，你还记得么？"><a href="#红黑树那几个原则，你还记得么？" class="headerlink" title="红黑树那几个原则，你还记得么？"></a>红黑树那几个原则，你还记得么？</h3><p>可以按照括号里边的分类，记住 红黑树的几个原则：</p><ul><li>（<strong>颜色属性</strong>）节点非黑即红</li><li>（<strong>根属性</strong>）根节点一定是黑色</li><li>（<strong>叶子属性</strong>）叶子节点（NIL）一定是黑色</li><li>（<strong>红色属性</strong>）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li><strong>（黑色属性）</strong>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><h3 id="红黑树写入操作-，是如何找到它的父节点的？"><a href="#红黑树写入操作-，是如何找到它的父节点的？" class="headerlink" title="红黑树写入操作 ，是如何找到它的父节点的？"></a>红黑树写入操作 ，是如何找到它的父节点的？</h3><p>红黑树的节点 TreeNode它就是继承Node结构，</p><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TreeNode在Node基础上加了几个字段，分别指向父节点parent，然后指向左子节点left，还有指向右子节点的right，</p><p>然后还有表示颜色red属性</p><p><strong>红黑树的插入操作</strong>：</p><p>首先是找到一个合适的插入点，就是找到插入节点的父节点，</p><p>由于红黑树 它又满足BST二叉查找树的 有序特性，这个找父节点的操作和二叉查找树是完全一致的。</p><p>二叉查找树，左子节点小于当前节点，右子节点大于当前节点，</p><p>然后每一次向下查找一层就可以排除掉一半的数据，查找的效率在log(N)</p><p>最终查找到nil节点或者 key一样的节点。</p><p>如果最终查找到 key一样的节点，进行更新操作。这个TreeNode.key 与当前 put.key 完全一致。这就不需要插入，替换value就可以了，父节点就是当前节点的父节点</p><p>如果最终查找到nil节点，进行插入操作。nil节点的父节点，就是当前节点的父节点，把插入的节点替换nil节点。然后进行红黑树的 平衡处理。</p><h3 id="红黑树的有那些内部操作"><a href="#红黑树的有那些内部操作" class="headerlink" title="红黑树的有那些内部操作"></a>红黑树的有那些内部操作</h3><p><strong>变色</strong></p><p>把一个红色的节点变成黑色，或者把一个黑色的节点变成红色，就是对这个节点的<code>变色</code>。</p><p><strong>旋转</strong></p><p>与平衡二叉树的旋转操作类似。</p><h3 id="红黑树与AVL树区别"><a href="#红黑树与AVL树区别" class="headerlink" title="红黑树与AVL树区别"></a>红黑树与AVL树区别</h3><p><strong>1、调整平衡的实现机制不同</strong></p><p>红黑树根据路径上黑色节点数目一致，来确定是否失衡，如果失衡，就通过变色和旋转来恢复</p><p>AVL根据树的<a href="https://so.csdn.net/so/search?q=平衡因子&amp;spm=1001.2101.3001.7020">平衡因子</a>(<strong>所有节点的左右子树高度差的绝对值不超过1</strong>)，来确定是否失衡，如果失衡，就通过旋转来恢复</p><p><strong>2、红黑树的插入效率更高</strong></p><p>红黑树是用<strong>非严格的平衡</strong>来换取增删节点时候旋转次数的降低，<strong>任何不平衡都会在三次旋转之内解决</strong>，</p><p>红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能</p><p>而AVL是<strong>严格平衡树</strong>(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</p><p>所以红黑树的插入效率更高</p><p><strong>3、红黑树统计性能比AVL树更高</strong></p><p>红黑树能够以<strong>O(log n)</strong> 的时间复杂度进行查询、插入、删除操作。</p><p>AVL树查找、插入和删除在平均和最坏情况下都是<strong>O(log n)</strong>。</p><p>红黑树的算法时间复杂度和AVL相同，<strong>但统计性能比AVL树更高</strong>，</p><p><strong>4、适用性：AVL查找效率高</strong></p><p><strong>如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树</strong>。</p><p>即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>隔了好几天才又开始写博客，前几天实在是有太多考试了。又考试又生病，搞得我一点学习的心情都没有了，好在今天算是好一点了，最近几天估计要更新好几篇内容，都是最近学习的内容。</p><p>由于最近考试，找到实习的舍友回来了，听他讲了很多在腾讯工作的事情，实名羡慕了。感觉挺好的，可能就是有点卷，但是没办法，大家都在卷，不卷就要走人了。</p><p>学校这两周考试周，我们已经考完了，所以未来两周将会究极闲，突然想学一下测试相关的东西了，大概了解一下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/crazymakercircle/p/16320430.html">https://www.cnblogs.com/crazymakercircle/p/16320430.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1739709">https://cloud.tencent.com/developer/article/1739709</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来学我们的老朋友——红黑树。为什么今天的标题透着一股诡异的气息，清朝的遗留问题，其实是笔者从大一就开始说要去学一直到现在都没学的一个知识点。&lt;/p&gt;
&lt;p&gt;为什么最近突然想起来这个老朋友了？最近 Java 的基础知识也学得差不多了，所以开始看一些 Java 的集合框架，</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统</title>
    <link href="http://example.com/2024/06/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2024/06/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-06-17T05:23:58.000Z</published>
    <updated>2024-06-18T13:23:08.936Z</updated>
    
    <content type="html"><![CDATA[<p>秒杀活动是指网络商家为促销等目的组织或网上限时抢购活动，这种活动具有瞬时并发量大、库存量少和业务逻辑简单等特点。设计一个秒杀系统需要考虑的因素很多，比如对现有业务的影响、网络带宽消耗以及超卖等因素。</p><p>选择学习这部分内容主要是因为秒杀、抽奖这些实际开发中会遇到的问题是面试的高频问题，而且整个设计过程确实涉及了很多方面的内容。本文会讨论秒杀系统的各个环节可能存在的问题以及解决方案。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>秒杀系统设计是国内系统设计面试的高频题，在面试中，你需要分析架构的瓶颈，潜在问题以及不同方案的优缺点，在本文的最后我们会提到这些面试技巧。开始之前，你需要了解如何设计一个基础的电商系统，秒杀系统只是在电商系统上增加了一些特定条件。现在的电商系统功能繁多，除了最基本的购买商品功能，还有物流跟踪，订单管理，社区交互等功能。不过面试中关注的主要是购买商品功能，我们将其他次要功能归类为其他业务功能，购买商品流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618175932074.png" alt="image-20240618175932074"></p><ol><li>客户通过客户端下单</li><li>如果下单成功则进入支付阶段，否则返回购买失败</li><li>进入支付阶段后，如果在一定时间内支付成功则返回购买成功，否则返回购买失败</li></ol><h1 id="从0到1000"><a href="#从0到1000" class="headerlink" title="从0到1000"></a>从0到1000</h1><p>想象你自己从零搭建一个电商平台，一开始平台里的商品种类以及日订单量都较少，商品种类有 100 款，日订单量只有 1000 条。根据以上信息，我们可以设计出架构 1：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f254536253945254236254536253945253834312e737667" alt="img"></p><ol><li>客户端发送下单请求给服务端</li><li>服务端查询数据库<ul><li>若该商品库存大于零，将库存减一并且返回下单成功</li><li>若该商品库存等于零的话，返回下单失败</li></ul></li></ol><p>架构 1 简单直观，它忽略了系统可用性以及可扩展性，但在日订单量少，不会出现多位客户对同一件商品同时下单的情况下，它很好地完成了我们需要的功能。</p><h1 id="从1000到100万"><a href="#从1000到100万" class="headerlink" title="从1000到100万"></a>从1000到100万</h1><p>经过一段时间后，你的电商平台商品种类增加到 1 万款，日订单量飙升到 100 万条，而且在高峰期，例如晚饭后，睡觉前的订单量会特别多。这是一个好的消息，不过同时你发现了一个问题，某些商品的成功下单量要大于库存量，也就是说出现了商品超卖的情况。这可是个严重的问题，因为没办法及时交货给客户对电商平台的信誉有极大影响。仔细分析架构 1 后，我们发现了问题的根源：当商品库存只剩下 1 件而有多位客户同时下单的时候，每个下单请求在查询的时候都发现库存大于零，并且将库存减 1 返回下单成功。下图中，在库存只有 1 件的时候，两个请求却都返回下单成功。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545352542392542362545352538462539312545352541452538392545352538352541382e737667" alt="并发安全"></p><p>幸运的是，我们知道大部分并发问题都可以通过锁机制或者队列服务来解决：</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>我们可以观察到，超卖问题的原因在于事务查询和更新库区期间，库存已经被其他事务修改了。在学习悲观锁之前，我们先了解下什么是两阶段加锁，两阶段加锁是一个典型的悲观锁策略：</p><blockquote><p>两阶段加锁方法类似，但锁的强制性更高。多个事务可以同时读取同一对象，当只要出现任何写操作（包括修改或删除），则必须加锁以独占访问。—-《数据密集型应用系统设计》</p></blockquote><p>我们的电商系统中可以应用两阶段加锁，由于下单请求涉及到修改库存，可以先使用排他锁锁定记录，防止被其他事务所修改。大部分关系型数据库都提供这种功能（在 MySQL 和 PostgresSQL 里面的语法是 SELECT … FOR 下UPDATE）。流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545362538322542322545382541372538322545392539342538312e737667" alt="悲观锁"></p><ol><li>蓝色请求先获取排他锁，查询和更新库存，在此期间黑色请求等待获取排他锁。</li><li>蓝色请求更新库存后释放排他锁，返回下单成功</li><li>黑色请求获取排他锁，发现库存为 0，释放排他锁，返回下单失败</li></ol><p>我们可以看到悲观锁成功解决了商品超卖问题，不过它的缺点也比较明显：</p><ol><li>处理性能不高，当一件商品有多位客户同时下单的时候，每个请求需要等待排他锁，也要较长才知道是否下单成功。</li><li>容易发生死锁：在实际工程中，下单操作不只涉及了库存修改，还可能涉及其他业务功能，由于悲观锁下每个请求都轮流持有锁，应用层的代码处理不好的话会更容易发生死锁。</li></ol><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>和悲观锁不同，乐观锁策略下事务会记录下查询时的版本号，当事务准备更新库存的时候，如果此时的版本号与查询时的版本号不同，则代表库存被其他事务修改了，这时候就会回滚事务，流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545342542392539302545382541372538322545392539342538312e737667" alt="乐观锁"></p><ol><li>蓝色请求与黑色请求查询库存，并记录库存版本号</li><li>蓝色请求先更新库存为 0，返回下单成功</li><li>黑色请求更新前发现版本与之前版本号不同，回归事务，返回下单失败</li></ol><p>乐观锁因为并不需要等待锁，所以在事务竞争较少的情况下比悲观锁有更好的性能，缺点是事务竞争较多的情况下，由于经常需要回滚事务导致性能反而较差。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁在服务端以及数据库之间加上分布式组件来保证请求的并发安全，国内较常使用 Redis 或者 ZooKeeper。和悲观锁类似，每个请求需要先从组件中获取分布式锁之后才可以继续执行。流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545352538382538362545352542382538332545352542432538462545392539342538312e737667" alt="分布式锁"></p><ol><li>蓝色请求先获取分布式锁，查询和更新库存，在此期间黑色请求等待获取分布式锁</li><li>蓝色请求更新库存后释放分布式锁，返回下单成功</li><li>黑色请求获取分布式锁，查询库存，发现库存为 0，释放分布式锁，返回下单失败</li></ol><p>分布式锁的优点是将功能进行分离，分布式组件负责解决并发安全的问题，数据库负责数据存储。不过缺点在于：</p><ol><li>分布式锁的正确实现并不简单，错误的实现方式容易引起其他一致性的问题。</li><li>分布式锁在高并发下也会产生锁竞争的问题，性能不佳。</li><li>由于引入了新的组件，要考虑分布式组件的可靠性，以及崩溃之后的恢复机制。</li></ol><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>另一个直观的解决方法就是使用消息队列，确保每个商品每个时刻只有一个请求，流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545362542362538382545362538312541462545392539382539462545352538382539372e737667" alt="消息队列"></p><ol><li>客户端发送下单请求给服务端</li><li>服务端将请求发送到消息队列</li><li>数据库每次从消息队列取出请求<ul><li>若该商品库存大于零，将库存减一</li><li>若该商品库存等于零的话，不做操作</li></ul></li><li>服务端根据消息队列里的消息状态返回下单结果</li></ol><h1 id="从电商系统到秒杀系统"><a href="#从电商系统到秒杀系统" class="headerlink" title="从电商系统到秒杀系统"></a>从电商系统到秒杀系统</h1><p>秒杀系统和电商系统有两个核心区别：</p><ol><li>双十一也有极大的流量，但是双十一的商品种类很多，所以流量会分布到不同的商品中。而秒杀系统中，商品的种类和库存都比较少，导致大部分流量集中在少量商品中。</li><li>秒杀系统由于商品稀缺，价值高。同一位客户可能会对同一商品多次提交下单请求，而且恶意刷单的请求比较多，所以系统接收到的无效请求及非法请求较多。</li></ol><p>针对这两个区别，我们发现架构 2 有 3 个潜在问题：</p><ol><li>当一款商品库存只有 10 件却有 1 万名用户下单的时候，只有前 10 名客户可以下单成功，其他用户都浪费时间在队列等待以及无意义地查询库存，既牺牲了用户体验也增加了消息队列以及数据库的压力。</li><li>由于库存过少，有大量的请求（例如非法用户的请求，超过秒杀活动开始一定时间的请求）其实是没有机会抢到商品的，所以没有必要到达服务器，更不用说数据库了。</li><li>大量的客户端在下单前同时请求同一个商品的秒杀页面，导致服务器压力骤升。</li></ol><p>针对这三个问题我们可以考虑两个方案：<strong>流量控制</strong>和<strong>资源隔离</strong>。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>第三个问题相对简单，可以将秒杀页面使用 CDN 缓存起来，客户端就可以直接从 CDN 获取到秒杀页面，不需要重复请求服务器。另外两个问题可以通过流量限制来解决，可以通过限流器，负载均衡以及安全验证组件实现：</p><ul><li>限流器分为前端限流与后端限流：<ul><li>前端限流包括验证答题，防止重复点击按钮等常见机制。</li><li>后端限流使用限流算法进行流量限制，简单情况下可以使用固定限流算法，例如秒杀商品的库存是 10 件，只要限流器接收到 10 <em> k（k 可以根据业务进行调整）个请求之后，就停止接受该商品的所有请求。这样无论有多少个下单请求，最终到达服务器的单个商品请求数量都不超过 10 </em> k。实际工程中，因为有客户可能会出现支付超时导致释放库存的情况，系统需要通知限流器接受新的请求。</li></ul></li><li>负载均衡负责将下单请求通过负载均衡算法转发到最合适的服务器。</li><li>安全验证组件分为前端安全验证以及后端安全验证：<ul><li>后端安全验证包括黑名单校验，IP 地址校验等机制。</li><li>前端安全验证包括：客户端账户验证（确保客户有资格参考秒杀活动），客户端版本安全验证（防止反编译以及修改客户端代码），秒杀接口动态生成（防止使用刷单脚本）等机制。</li></ul></li></ul><p>这时候系统的整体架构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545362542352538312545392538372538462545392539392539302545352538382542362e737667" alt="img"></p><h2 id="热门资源隔离"><a href="#热门资源隔离" class="headerlink" title="热门资源隔离"></a>热门资源隔离</h2><p>既然大部分流量集中在少量商品中，我们能不能针对这些商品进行特殊处理呢？这样既可以防止秒杀活动影响其他业务功能，也可以针对热门商品进行资源分配，答案是可以的，首先我们需要识别出热门商品，这里有两种常见的方法：</p><ul><li>静态识别：包括京东在内的一些电商平台，客户在参加秒杀活动之前需要先进行预约，只有预约过的客户才能参考秒杀活动。这样系统可以提早识别热门商品以及进行流量预估。</li><li>动态识别：通过实时数据分析系统在秒杀活动前统计出现在较多客户浏览的热门商品，针对预估结果进行资源分配。</li></ul><p>识别出热门商品之后，我们可以将热门商品的资源进行隔离，并且设置独立的策略，例如</p><ul><li>使用特殊的限流器，由于秒杀系统的库存很少，在下单请求开始阶段就可以随机丢弃大部分请求。</li><li>使用单独的数据库，在架构 2 中，下单请求的处理速度受限于消费者的处理速度，也就是数据库的处理速度。我们可以对热门商品进行分库分表，这样可以将请求处理的压力分摊到多个数据库中。下图中，我们将秒杀系统的一些组件独立开来：</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545382542352538342545362542412539302545392539412539342545372541362542422e737667" alt="资源隔离"></p><p>根据以上两个方案，我们可以设计出最后的架构 3：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f254536253945254236254536253945253834332e737667" alt="架构3"></p><ol><li>客户端从 CDN 获取到秒杀页面</li><li>客户端发送下单请求给网关</li><li>在网关或者服务器前进行流量控制以及负载均衡等策略</li><li>服务端将请求发送到消息队列</li><li>数据库每次从消息队列取出请求<ul><li>若该商品库存大于零，将库存减一</li><li>若该商品库存等于零的话，不做操作</li></ul></li><li>服务端根据消息队列里的消息状态返回下单结果</li></ol><hr><p>关于秒杀系统的大概设计流程已经讲完了，但这也就只能回答面试官一个问题——设计流程，如果细问，依旧还有很多细节要学习，下面我们来看更多的细节问题。</p><p>一般在<strong>秒杀时间点</strong>前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量才会到达顶峰。</p><p>但由于这类活动是大量用户抢少量商品的场景，必定会出现<code>狼多肉少</code>的情况，所以其实绝大部分用户秒杀会失败，只有极少部分用户能够成功。</p><p>正常情况下，大部分用户会收到商品已经抢完的提醒，收到该提醒后，他们大概率不会在那个活动页面停留了，如此一来，用户并发量又会急剧下降。所以这个峰值持续的时间其实是非常短的，这样就会出现瞬时高并发的情况，下面用一张图直观的感受一下流量的变化：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/99ec913130454ce291652c97bedca7bc%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="图片"></p><p>像这种瞬时高并发的场景，传统的系统很难应对，我们需要设计一套全新的系统。可以从以下几个方面入手：</p><ol><li>页面静态化</li><li>CDN加速</li><li>缓存</li><li>mq异步处理</li><li>限流</li></ol><h1 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h1><p>活动页面是用户流量的第一入口，所以是并发量最大的地方。</p><p>如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618200428203.png" alt="image-20240618200428203"></p><p>不知道你是否还记得，最早的秒杀系统其实是要刷新整体页面的，但后来秒杀的时候，你只要点击“刷新抢宝”按钮就够了，这种变化的本质就是动静分离，分离之后，客户端大幅度减少了请求的数据量。这不自然就“快”了吗？</p><p>活动页面绝大多数内容都是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做<code>静态化</code>处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618200852213.png" alt="image-20240618200852213"></p><p>这样能过滤大部分无效请求。</p><p>但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。</p><p>如何才能让用户最快访问到活动页面呢？</p><p>这就需要使用CDN，它的全称是Content Delivery Network，即内容分发网络。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1e5c1fb0fa47ba4eae4977f4cfc564c2.jpeg" alt="img"></p><p>使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><h2 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h2><p>那到底什么才是动静分离呢？所谓“动静分离”，其实就是把用户请求的数据（如HTML页面）划分为“动态数据”和“静态数据”。</p><p>简单来说，<strong>“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和URL、浏览者、时间、地域相关，以及是否含有Cookie等私密数据</strong>。比如说：</p><ol><li>很多媒体类的网站，某一篇文章的内容不管是你访问还是我访问，它都是一样的。所以它就是一个典型的静态数据，但是它是个动态页面。</li><li>我们如果现在访问淘宝的首页，每个人看到的页面可能都是不一样的，淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。</li></ol><p>这里再强调一下，我们所说的静态数据，不能仅仅理解为传统意义上完全存在磁盘上的HTML页面，它也可能是经过Java系统产生的页面，但是它输出的页面本身不包含上面所说的那些因素。也就是所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据。</p><p>还有一点要注意，就是页面中“不包含”，指的是“页面的HTML源码中不含有”，这一点务必要清楚。</p><p>理解了静态数据和动态数据，我估计你很容易就能想明白“动静分离”这个方案的来龙去脉了。分离了动静数据，我们就可以对分离出来的静态数据做缓存，有了缓存之后，静态数据的“访问效率”自然就提高了。</p><p>那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。</p><p><strong>第一，你应该把静态数据缓存到离用户最近的地方</strong>。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN上或者在服务端的Cache中。你应该根据情况，把它们尽量缓存到离用户最近的地方。</p><p><strong>第二，静态化改造就是要直接缓存HTTP连接</strong>。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存HTTP连接而不是仅仅缓存数据，如下图所示，Web代理服务器根据请求URL，直接取出对应的HTTP响应头和响应体然后直接返回，这个响应过程简单得连HTTP协议都不用重新组装，甚至连HTTP请求头也不需要解析。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2c608715621afc9c95570dce00a87546.jpg" alt="img"></p><p><strong>第三，让谁来缓存静态数据也很重要。</strong>不同语言写的Cache软件处理缓存数据的效率也各不相同。以Java为例，因为Java系统本身也有其弱点（比如不擅长处理大量连接请求，每个连接消耗的内存较多，Servlet容器解析HTTP协议较慢），所以你可以不在Java层做缓存，而是直接在Web服务器层上做，这样你就可以屏蔽Java语言层面的一些弱点；而相比起来，Web服务器（如Nginx、Apache、Varnish）也更擅长处理大并发的静态文件请求。</p><h2 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h2><p>理解了动静态数据的“why”和“what”，接下来我们就要看“how”了。我们如何把动态页面改造成适合缓存的静态页面呢？其实也很简单，就是去除前面所说的那几个影响因素，把它们单独分离出来，做动静分离。</p><p>下面，我以典型的商品详情系统为例来详细介绍。这里，你可以先打开京东或者淘宝的商品详情页，看看这个页面里都有哪些动静数据。我们从以下5个方面来分离出动态内容。</p><ol><li><strong>URL唯一化</strong>。商品详情系统天然地就可以做到URL唯一化，比如每个商品都由ID来标识，那么 <a href="http://item.xxx.com/item.htm?id=xxxx">http://item.xxx.com/item.htm?id=xxxx</a> 就可以作为唯一的URL标识。为啥要URL唯一呢？前面说了我们是要缓存整个HTTP连接，那么以什么作为Key呢？就以URL作为缓存的Key，例如以id=xxx这个格式进行区分。</li><li><strong>分离浏览者相关的因素</strong>。浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。</li><li><strong>分离时间因素</strong>。服务端输出的时间也通过动态请求获取。</li><li><strong>异步化地域因素</strong>。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。</li><li><strong>去掉Cookie</strong>。服务端输出的页面包含的Cookie可以通过代码软件来删除，如Web服务器Varnish可以通过unset req.http.cookie 命令去掉Cookie。注意，这里说的去掉Cookie并不是用户端收到的页面就不含Cookie了，而是说，在缓存的静态数据中不含有Cookie。</li></ol><p>分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户ID是否匹配等，所以这个时候我们应该将这些信息JSON化（用JSON格式组织这些数据），以方便前端获取。</p><p>前面我们介绍里用缓存的方式来处理静态数据。而动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和CSI（Client Side Include）方案。</p><ol><li><strong>ESI方案（或者SSI）</strong>：即在Web代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。</li><li><strong>CSI方案</strong>。即单独发起一个异步JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</li></ol><h2 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a>架构方案</h2><p>根据架构上的复杂度，有3种方案可选：</p><ol><li>实体机单机部署；</li><li>统一Cache层；</li><li>上CDN。</li></ol><p>上面我们也谈到要使用 CDN 来实现动静分离，所以在这里着重讨论一下，其余方案就不在细讲了。</p><p>使用 CDN 我们将面临以下几个问题：</p><ol><li><strong>失效问题</strong>。前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要保证CDN可以在秒级时间内，让分布在全国各地的Cache同时失效，这对CDN的失效系统要求很高。</li><li><strong>命中率问题</strong>。Cache最重要的一个衡量指标就是“高命中率”，不然Cache的存在就失去了意义。同样，如果将数据全部放到全国的CDN上，必然导致Cache分散，而Cache分散又会导致访问请求命中同一个Cache的可能性降低，那么命中率就成为一个问题。</li><li><strong>发布更新问题</strong>。如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。</li></ol><p>从前面的分析来看，将商品详情系统放到全国的所有CDN节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：</p><ol><li>靠近访问量比较集中的地区；</li><li>离主站相对较远；</li><li>节点到主站间的网络比较好，而且稳定；</li><li>节点容量比较大，不会占用其他CDN太多的资源。</li></ol><p>最后，还有一点也很重要，那就是：节点不要太多。</p><p>基于上面几个因素，选择CDN的二级Cache比较合适，因为二级Cache数量偏少，容量也更大，让用户的请求先回源的CDN的二级Cache中，如果没命中再回源站获取数据，部署方式如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202203356.png" alt="image-20240618202203356"></p><p>使用CDN的二级Cache作为缓存，可以达到和当前服务端静态化Cache类似的命中率，因为节点数不多，Cache不是很分散，访问量也比较集中，这样也就解决了命中率问题，同时能够给用户最好的访问体验，是当前比较理想的一种CDN化方案。</p><p>除此之外，CDN化部署方案还有以下几个特点：</p><ol><li>把整个页面缓存在用户浏览器中；</li><li>如果强制刷新整个页面，也会请求CDN；</li><li>实际有效请求，只是用户对“刷新抢宝”按钮的点击。</li></ol><p>这样就把90%的静态数据缓存在了用户端或者CDN上，当真正秒杀时，用户只需要点击特殊的“刷新抢宝”按钮，而不需要刷新整个页面。这样一来，系统只是向服务端请求很少的有效数据，而不需要重复请求大量的静态数据。</p><p>秒杀的动态数据和普通详情页面的动态数据相比更少，性能也提升了3倍以上。所以“抢宝”这种设计思路，让我们不用刷新页面就能够很好地请求到服务端最新的动态数据。</p><h1 id="秒杀按钮"><a href="#秒杀按钮" class="headerlink" title="秒杀按钮"></a>秒杀按钮</h1><p>大部分用户怕错过<code>秒杀时间点</code>，一般会提前进入活动页面。此时看到的<code>秒杀按钮</code>是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。</p><p>但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。</p><p>从前面得知，该活动页面是静态的。那么我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？</p><p>没错，使用js文件控制。</p><p>为了性能考虑，一般会将css、js和图片等静态资源文件提前缓存到CDN上，让用户能够就近访问秒杀页面。</p><p>看到这里，有些聪明的小伙伴，可能会问：CDN上的js文件是如何更新的？</p><p>秒杀开始之前，js标志为false，还有另外一个随机参数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202349540.png" alt="image-20240618202349540"></p><p>当秒杀开始的时候系统会生成一个新的js文件，此时标志为true，并且随机参数生成一个新值，然后同步给CDN。由于有了这个随机参数，CDN不会缓存数据，每次都能从CDN中获取最新的js代码。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202411522.png" alt="image-20240618202411522"></p><p>此外，前端还可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。</p><h1 id="读多写少"><a href="#读多写少" class="headerlink" title="读多写少"></a>读多写少</h1><p>在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。</p><p>由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。</p><p>这是非常典型的：<code>读多写少</code> 的场景。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c5c91688e2704bfb9779b46d716d6a66%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="图片"></p><p>如果有数十万的请求过来，同时通过数据库查缓存是否足够，此时数据库可能会挂掉。因为数据库的连接资源非常有限，比如：MySQL，无法同时支持这么多的连接。</p><p>而应该改用缓存，比如：redis。单个 Redis 可以处理几万的 QPS，如果预估请求的 QPS 大于几万，我们还可以使用 Redis 集群模式来增加 Redis 的处理能力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202831227.png" alt="image-20240618202831227"></p><p>在 Redis 存放和售卖商品数目大小相同的数字，秒杀服务每次访问数据库之前，都需要先去 Redis 中扣减库存，扣减成功才能继续更新数据库。这样，最终到的数据库的请求数目和需要售卖商品的数目基本一致，数据库的压力可以大大减少。</p><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><p>通常情况下，我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。</p><p>用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。</p><p>大致流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203128539.png" alt="image-20240618203128539"></p><p>根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。</p><p>这个过程表面上看起来是OK的，但是如果深入分析一下会发现一些问题。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>比如商品A第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。</p><p>然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。</p><p>如何解决这个问题呢？</p><p>这就需要加锁，最好使用分布式锁。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203215050.png" alt="image-20240618203215050"></p><p>当然，针对这种情况，最好在项目启动之前，先把缓存进行<code>预热</code>。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。</p><p>是不是上面加锁这一步可以不需要了？</p><p>表面上看起来，确实可以不需要。但如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加速同样可能出现缓存击穿。</p><p>其实这里加锁，相当于买了一份保险。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>如果有大量的请求传入的商品id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。</p><p>由于前面已经加了锁，所以即使这里的并发量很大，也不会导致数据库直接挂掉。</p><p>但很显然这些请求的处理性能并不好，有没有更好的解决方案？</p><p>这时可以想到<code>布隆过滤器</code>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203349855.png" alt="image-20240618203349855"></p><p>系统根据商品id，先从布隆过滤器中查询该id是否存在，如果存在则允许从缓存中查询数据，如果不存在，则直接返回失败。</p><p>虽说该方案可以解决缓存穿透问题，但是又会引出另外一个问题：布隆过滤器中的数据如何更缓存中的数据保持一致？</p><p>这就要求，如果缓存中数据有更新，则要及时同步到布隆过滤器中。如果数据同步失败了，还需要增加重试机制，而且跨数据源，能保证数据的实时一致性吗？</p><p>显然是不行的。</p><p>所以布隆过滤器绝大部分使用在缓存数据更新很少的场景中。</p><p>如果缓存数据更新非常频繁，又该如何处理呢？</p><p>这时，就需要把不存在的商品id也缓存起来。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203456511.png" alt="image-20240618203456511"></p><p>下次，再有该商品id的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。</p><h1 id="库存问题"><a href="#库存问题" class="headerlink" title="库存问题"></a>库存问题</h1><p>对于库存问题看似简单，实则里面还是有些东西。</p><p>真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。</p><p>所以，在这里引出了一个<code>预扣库存</code>的概念，预扣库存的主要流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203626470.png" alt="image-20240618203626470"></p><p>扣减库存中除了上面说到的<code>预扣库存</code>和<code>回退库存</code>之外，还需要特别注意的是<strong>库存不足</strong>和<strong>库存超卖</strong>问题。</p><p>检测库存不足问题，无论是直接使用 MySQL 的操作还是 Redis 的操作都会出现同一个问题，查询操作和更新操作不是原子的，在高并发的情况下，这种问题是绝对不能出现的。如何解决？</p><p>最简单的方法就是加锁。</p><p>虽然加锁可以解决商品超卖的问题，但是效率太低了。还有没有更好的方法，那就是 lua 脚本。</p><p>我们都知道lua脚本，是能够保证原子性的，它跟redis一起配合使用，能够完美解决上面的问题。</p><p>lua脚本有段非常经典的代码：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder <span class="attr">lua</span> = new StringBuilder()<span class="comment">;</span></span><br><span class="line">lua.append(&quot;if (redis.call(&#x27;exists&#x27;, KEYS<span class="section">[1]</span>) == 1) then&quot;)<span class="comment">;</span></span><br><span class="line">lua.append(&quot;    local <span class="attr">stock</span> = tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    if (<span class="attr">stock</span> == -<span class="number">1</span>) then<span class="string">&quot;);</span></span><br><span class="line"><span class="string">lua.append(&quot;</span>        return <span class="number">1</span><span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    end<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    if (stock &gt; 0) then&quot;)<span class="comment">;</span></span><br><span class="line">lua.append(&quot;        redis.call(&#x27;incrby&#x27;, KEYS<span class="section">[1]</span>, -1)<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;        return stock<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    end<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    return 0<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;end<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;return -1<span class="comment">;&quot;);</span></span><br></pre></td></tr></table></figure><p>该代码的主要流程如下：</p><ol><li>先判断商品id是否存在，如果不存在则直接返回。</li><li>获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。</li><li>如果库存大于0，则扣减库存。</li><li>如果库存等于0，是直接返回，表示库存不足。</li></ol><h1 id="mq-异步处理"><a href="#mq-异步处理" class="headerlink" title="mq 异步处理"></a>mq 异步处理</h1><p>我们都知道在真实的秒杀场景中，有三个核心流程：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204648082.png" alt="image-20240618204648082"></p><p>而这三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。</p><p>于是，秒杀后下单的流程变成如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204727363.png" alt="image-20240618204727363"></p><p>如果使用 mq，需要关注以下几个问题：</p><h2 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h2><p>秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。</p><p>那么，如何防止消息丢失呢？</p><p>答：加一张消息发送表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204856901.png" alt="image-20240618204856901"></p><p>在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。</p><p>如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。</p><p>这时候，要如何处理呢？</p><p>答：使用job，增加重试机制。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204933636.png" alt="image-20240618204933636"></p><p>用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。</p><h2 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h2><p>本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。</p><p>那么，如何解决重复消息问题呢？</p><p>答：加一张消息处理表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205124237.png" alt="image-20240618205124237"></p><p>消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。</p><p>有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。</p><h2 id="垃圾消息问题"><a href="#垃圾消息问题" class="headerlink" title="垃圾消息问题"></a>垃圾消息问题</h2><p>这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。</p><p>那么，如何解决这个问题呢？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205305967.png" alt="image-20240618205305967"></p><p>每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。</p><p>这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。</p><h2 id="延迟消费问题"><a href="#延迟消费问题" class="headerlink" title="延迟消费问题"></a>延迟消费问题</h2><p>通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。</p><p>那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？</p><p>我们首先想到的可能是job，因为它比较简单。</p><p>但job有个问题，需要每隔一段时间处理一次，实时性不太好。还有更好的方案吗？</p><p>答：使用延迟队列。</p><p>我们都知道 RocketMQ，自带了延迟队列的功能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205417060.png" alt="image-20240618205417060"></p><p>下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。</p><p>还有个关键点，用户完成支付之后，会修改订单状态为已支付。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205435274.png" alt="image-20240618205435274"></p><h1 id="如何限流？"><a href="#如何限流？" class="headerlink" title="如何限流？"></a>如何限流？</h1><p>通过秒杀活动，如果我们运气爆棚，可能会用非常低的价格买到不错的商品（这种概率堪比买福利彩票中大奖）。</p><p>但有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。</p><p>如果是我们手动操作，一般情况下，一秒钟只能点击一次秒杀按钮。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205554568.png" alt="image-20240618205554568"></p><p>但是如果是服务器，一秒钟可以请求成上千接口。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205609980.png" alt="image-20240618205609980"></p><p>这种差距实在太明显了，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。</p><p>所以，我们有必要识别这些非法请求，做一些限制。那么，我们该如何现在这些非法请求呢？</p><p>目前有两种常用的限流方式：</p><ol><li>基于nginx限流</li><li>基于redis限流</li></ol><h2 id="对同一用户限流"><a href="#对同一用户限流" class="headerlink" title="对同一用户限流"></a>对同一用户限流</h2><p>为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205710985.png" alt="image-20240618205710985"></p><p>限制同一个用户id，比如每分钟只能请求5次接口。</p><h2 id="对同一ip限流"><a href="#对同一ip限流" class="headerlink" title="对同一ip限流"></a>对同一ip限流</h2><p>有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。</p><p>这时需要加同一ip限流功能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205822876.png" alt="image-20240618205822876"></p><p>限制同一个ip，比如每分钟只能请求5次接口。</p><p>但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。</p><h2 id="对接口限流"><a href="#对接口限流" class="headerlink" title="对接口限流"></a>对接口限流</h2><p>别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。</p><p>这时可以限制请求的接口总次数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618210012653.png" alt="image-20240618210012653"></p><p>在高并发场景下，这种限制对于系统的稳定性是非常有必要的。但可能由于有些非法请求次数太多，达到了该接口的请求上限，而影响其他的正常用户访问该接口。看起来有点得不偿失。</p><h2 id="加入验证码"><a href="#加入验证码" class="headerlink" title="加入验证码"></a>加入验证码</h2><p>相对于上面三种方式，加验证码的方式可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618210111861.png" alt="image-20240618210111861"></p><p>通常情况下，用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。</p><p>此外，验证码一般是一次性的，同一个验证码只允许使用一次，不允许重复使用。</p><p>普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。</p><p>还有一个验证码叫做：<code>移动滑块</code>，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选。</p><h2 id="提高业务门槛"><a href="#提高业务门槛" class="headerlink" title="提高业务门槛"></a>提高业务门槛</h2><p>上面说的加验证码虽然可以限制非法用户请求，但是有些影响用户体验。用户点击秒杀按钮前，还要先输入验证码，流程显得有点繁琐，秒杀功能的流程不是应该越简单越好吗？</p><p>其实，有时候达到某个目的，不一定非要通过技术手段，通过业务手段也一样。</p><p>12306刚开始的时候，全国人民都在同一时刻抢火车票，由于并发量太大，系统经常挂。后来，重构优化之后，将购买周期放长了，可以提前20天购买火车票，并且可以在9点、10、11点、12点等整点购买火车票。调整业务之后（当然技术也有很多调整），将之前集中的请求，分散开了，一下子降低了用户并发量。</p><p>回到这里，我们通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。</p><p>这样简单的提高一点门槛，即使是黄牛党也束手无策，他们总不可能为了参加一次秒杀活动，还另外花钱充值会员吧？</p><h1 id="面试中的常见问题"><a href="#面试中的常见问题" class="headerlink" title="面试中的常见问题"></a>面试中的常见问题</h1><ul><li>“应该在什么时候扣除库存，是下单后扣除库存还是支付后扣除库存呢？为什么？”</li></ul><blockquote><p>应该在下单的时候扣除库存，如果在支付成功再扣除库存的话会出现下单请求成功数量大于库存的情况。</p></blockquote><ul><li>“对秒杀商品进行分库分表之后可能导致某个分表库存为零，但其他分表还有库存，如何解决这个问题？”</li></ul><blockquote><p>“有三种解决方案：</p><ul><li>如果当前分表没有库存的话，到其他分表进行重试，缺点是会放大流量。</li><li>通过路由组件记录每个分表的库存情况，将下单请求转发到有库存的分表中。</li><li>使用分布式缓存记录每个分表的库存情况，并且每次下单请求只更新缓存，缓存后续再更新到数据库中，缺点是可能出现缓存和数据库不一致的问题。”</li></ul></blockquote><ul><li>“客户下单后可能支付超时并释放库存，这时候有哪些要注意的？”</li></ul><blockquote><p>“服务器能够通知限流器以及前端库存发生变化，限流器能够重新接收请求，前端页面显示可下单的页面，确保后续的用户能继续购买商品。”</p></blockquote><ul><li>“消息队列方案有什么潜在问题吗？”</li></ul><blockquote><p>“秒杀系统下，可能 80% 的流量都指向同一个热门商品，那么消息队列中的分区会特别大，影响了两个方面：</p><ol><li><p>消息队列本身的稳定性，吞吐量会受单个分区限制，也可能影响其他业务。</p></li><li><p>下单请求受到消费者消费能力的限制，即使消息队列每秒可以处理大量消息，但是数据库每秒处理的数量有限。可以使用以下几种方案：</p><ul><li><p>压力测试：在前期压力测试的时候，模拟流量极端分布的情况，确保现有架构能够支持服务。</p></li><li><p>资源隔离：对秒杀商品使用独立的消息队列，使用特殊的流量限流策略，配置更好的资源。</p></li><li><p>合并下单请求：将多个下单请求合并成一个请求，再交给数据库处理。不过在实际工程中，下单业务可能比较复杂，不只包含扣减库存。所以合并逻辑会影响后续业务的可扩展性。</p></li><li><p>合并事务：将多个事务合并成一个事务执行，这样能有效减少数据库压力，缺点是逻辑会比较复杂，而且一个事务执行失败会影响多个订单。</p></li></ul></li></ol></blockquote><p>“消息队列怎么保证消息有且仅生效一次（Exactly Once）？”</p><blockquote><ul><li>为了保证最少一次生效, 消费者需要下单成功后才能返回确认 ACK，否则有可能会丢失消息。</li><li>为了防止消息重复消费的问题，需要使下单逻辑变为幂等操作，常见的解决方案是保证下单请求有全局唯一的 ID，并在消息队列中对 ID 进行持久化，在发送给消费者之前先检查 ID 是否已经消费过。要注意中间层的重试机制不要修改这个全局唯一的 ID，不然会导致消息队列误以为该消息没有消费过。</li></ul></blockquote><p>“分布式锁和数据库悲观锁相比有什么优势？有什么共同的缺点？”</p><blockquote><ul><li>优点：加锁的操作不依赖数据库，降低数据库资源冲突的概率和压力。</li><li>共同缺点：可扩展性差，对于单个商品都是串行操作，假如每个订单执行要 100ms，每秒只能执行 10 个对应的订单，可能会出现大量请求阻塞的情况。</li></ul></blockquote><p>“如果电商系统流量过大，如何进行降级服务？”</p><blockquote><ul><li>暂停非核心业务：例如淘宝在双十一会暂时关闭退款功能。</li><li>拒绝服务：当系统压力到达一个阈值的的时候，随机丢弃部分秒杀请求。</li><li>减少重试：将重试次数降低甚至设置为0，否则容易造成雪崩效应，系统陷入负反馈循环，无法正常恢复。</li></ul></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于秒杀系统的设计，方法有很多种，本文中也就只介绍了很少的一部分。在架构方面还有更都需要去学习的，需要考虑的因素很多，二八原则、流量削峰等等都是很有趣的内容，当然在本文中也有提到过一些相关的设计。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F</a></p><p><a href="https://github.com/resumejob/How-to-design-a-spike-system?tab=readme-ov-file">https://github.com/resumejob/How-to-design-a-spike-system?tab=readme-ov-file</a></p><p><a href="https://juejin.cn/post/6990307911117307934">https://juejin.cn/post/6990307911117307934</a></p><p><a href="https://xie.infoq.cn/article/3b5c445bb62a5ca425489c08a">https://xie.infoq.cn/article/3b5c445bb62a5ca425489c08a</a></p><p><a href="https://gongfukangee.github.io/2019/06/09/SecondsKill/">https://gongfukangee.github.io/2019/06/09/SecondsKill/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;秒杀活动是指网络商家为促销等目的组织或网上限时抢购活动，这种活动具有瞬时并发量大、库存量少和业务逻辑简单等特点。设计一个秒杀系统需要考虑的因素很多，比如对现有业务的影响、网络带宽消耗以及超卖等因素。&lt;/p&gt;
&lt;p&gt;选择学习这部分内容主要是因为秒杀、抽奖这些实际开发中会遇到的</summary>
      
    
    
    
    <category term="技术剖析" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis高可用宝典：三招搞定你的数据堡垒</title>
    <link href="http://example.com/2024/06/13/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9D%E5%85%B8%EF%BC%9A%E4%B8%89%E6%8B%9B%E6%90%9E%E5%AE%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A0%A1%E5%9E%92/"/>
    <id>http://example.com/2024/06/13/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9D%E5%85%B8%EF%BC%9A%E4%B8%89%E6%8B%9B%E6%90%9E%E5%AE%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A0%A1%E5%9E%92/</id>
    <published>2024-06-13T11:10:16.000Z</published>
    <updated>2024-06-13T13:36:22.580Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发通常会提到一个名词 “三高”，即高并发、高性能、高可用。</p><p>具体的指标定义，如：高并发方面要求QPS 大于 10万；高性能方面要求请求延迟小于 100 ms；高可用方面要高于 99.99%。</p><p>在前面学习 Redis 时，我们也可以看出 Redis 已经实现了前两个“高”。今天，我们就来看一下 Redis 是否实现了第三个“高”——高可用。</p><h1 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h1><p>高可用(High Availability,即HA)，指的是通过尽量缩短日常维护操作和突发的系统崩溃所导致的停机时间，以提高系统和应用的可用性。一个业务系统如果全年无一时刻不在提供服务，它的可用性可达100%。那么什么样的系统可以称之为高可用呢，业界一般用几个九来衡量系统的可用性，当系统运行时间达到4个九即99.99%时的系统为高可用的，全年宕机时间为52分钟左右。</p><p> 高可用一般来说有两个含义：一是数据尽量不丢失，二是保证服务尽可能可用。 AOF 和 RDB 数据持久化保证了数据尽量不丢失，而多节点来保证服务尽可能提供服务。单个节点的系统缺点明显，一旦发生故障会导致服务不可用。而且，单个节点处理所有的请求，吞吐量有限，容量也有限。</p><p>关于数据持久化，前面已经聊过了，今天要看的就是 Redis 如何保证服务尽可能可用。</p><p>Redis 高可用的手段主要有以下三种：</p><ul><li>主从数据同步（主从复制）</li><li>Redis 哨兵模式（Sentinel）</li><li>Redis 集群（Cluster）</li></ul><p>主从数据同步可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换至另一台服务器以继续提供服务；哨兵模式用于发生故障之后自动切换服务器；而 Redis 集群提供了多主多从的 Redis 分布式集群环境，用于提供性能更好的 Redis 服务，并且它自身拥有故障自动切换的能力。</p><h1 id="主从复制-老少皆宜的经典菜"><a href="#主从复制-老少皆宜的经典菜" class="headerlink" title="主从复制 - 老少皆宜的经典菜"></a>主从复制 - 老少皆宜的经典菜</h1><p>主从复制（Master-Slave Replication）像是一道经典菜式，简单易懂，老少皆宜。主库写数据，从库读数据，轻松实现读写分离。</p><blockquote><p>主从复制，是指将一台 Redis 服务器的数据复制到其他的 Redis 服务器。前者成为<strong>主节点(master)</strong>，后者成为<strong>从节点(slave)</strong>；数据的复制是单向的，只能由主节点到从节点。</p><p>主从模式实现读写分离，只有master节点提供数据的事务性操作（增删改），slave节点只提供读操作。所有slave节点的数据都是从master节点同步过来的，该模式的结构图如下：</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-1.png" alt="img"></p><p><strong>主从复制的作用</strong>主要包括：</p><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="主从复制策略"><a href="#主从复制策略" class="headerlink" title="主从复制策略"></a>主从复制策略</h2><blockquote><p>注意：在2.8版本之前只有全量复制，而2.8版本后有全量和增量复制：</p></blockquote><ul><li><code>全量（同步）复制</code>：比如第一次同步时</li><li><code>增量（同步）复制</code>：只会把主从库网络断连期间主库收到的命令，同步给从库</li></ul><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><blockquote><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p></blockquote><p><strong>全量复制的三个阶段</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-2.jpg" alt="img"></p><p><strong>第一个阶段是主从库建立连接、协商同步的过程，</strong>主要是为全量复制做准备/在这一步，从库和主库建立其连接，并告诉主库即将进行同步，主库确认回复后，主从库就可以开始同步了。</p><p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。<strong>runID</strong>，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。<strong>offset</strong>，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，<strong>FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库</strong>。</p><p><strong>第二阶段，主库将所有数据同步到从库</strong>。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p><p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。<strong>为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</strong></p><p><strong>第三阶段，主库会把第二阶段执行过程中新收到的写命令再发送给从库</strong>。</p><p>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><blockquote><p>在 Redis 2.8 版本引入了增量复制。</p></blockquote><p><strong>为什么要设计增量复制？</strong></p><p>如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。</p><p><strong>增量复制的流程</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-3.jpg" alt="img"></p><p>先看两个概念： <code>replication buffer</code> 和 <code>repl_backlog_buffer</code></p><p><code>repl_backlog_buffer</code>：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以<strong>repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率</strong>。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。</p><p><code>replication buffer</code>：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。</p><p><strong>如果在网络断开期间，repl_backlog_size环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢</strong>？</p><p>对于这个问题来说，有两个关键点：</p><ol><li>一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。</li><li>每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。</li></ol><h2 id="更加深入"><a href="#更加深入" class="headerlink" title="更加深入"></a>更加深入</h2><blockquote><p>我们通过几个问题来深入理解主从复制。</p></blockquote><h3 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h3><blockquote><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</p></blockquote><p><strong>为什么不持久化的主服务器自动重启非常危险呢</strong>？为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了。</p><ul><li>我们设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</li><li>这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</li><li>节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。</li><li>当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</li></ul><p>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p><h3 id="为什么主从全量复制使用RDB而不使用AOF？"><a href="#为什么主从全量复制使用RDB而不使用AOF？" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF？"></a>为什么主从全量复制使用RDB而不使用AOF？</h3><ol><li><p>RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。</p></li><li><p>假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。</p></li></ol><h3 id="为什么还有无磁盘复制模式？"><a href="#为什么还有无磁盘复制模式？" class="headerlink" title="为什么还有无磁盘复制模式？"></a>为什么还有无磁盘复制模式？</h3><p>Redis 默认是磁盘复制，但是<strong>如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力</strong>。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。</p><p><strong>无磁盘复制模式</strong>：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。</p><p>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><p>使用<code>repl-diskless-sync-delay</code> 参数来配置传输开始的延迟时间；master等待一个<code>repl-diskless-sync-delay</code>的秒数，如果没slave来的话，就直接传，后来的得排队等了; 否则就可以一起传。</p><h3 id="主从级联模式分担全量复制时的主库压力"><a href="#主从级联模式分担全量复制时的主库压力" class="headerlink" title="主从级联模式分担全量复制时的主库压力"></a>主从级联模式分担全量复制时的主库压力</h3><p>通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。</p><p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。那么，有没有好的解决方法可以分担主库压力呢？</p><p>其实是有的，这就是“主 - 从 - 从”模式。</p><p>在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，我们可以通过“主 - 从 - 从”模式<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。</p><p>简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 所选从库的IP 6379</span><br></pre></td></tr></table></figure><p>这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-4.jpg" alt="img"></p><p>级联的“主-从-从”模式好了，到这里，我们了解了主从库间通过全量复制实现数据同步的过程，以及通过“主 - 从 - 从”模式分担主库压力的方式。那么，一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</p><h3 id="读写分离及其中的问题"><a href="#读写分离及其中的问题" class="headerlink" title="读写分离及其中的问题"></a>读写分离及其中的问题</h3><p>在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。下面介绍在使用Redis读写分离时，需要注意的问题。</p><ul><li><strong>延迟与不一致问题</strong></li></ul><p>前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。</p><p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的slave-serve-stale-data参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。</p><ul><li><strong>数据过期问题</strong></li></ul><p>在单机版Redis中，存在两种删除策略：</p><ul><li><code>惰性删除</code>：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li><li><code>定期删除</code>：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li></ul><p>在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p><p>Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p><ul><li><strong>故障切换问题</strong></li></ul><p>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ol><li>配置简单，易于实现。</li><li>实现数据冗余，提高数据可靠性。</li><li>读写分离，提高系统性能。</li></ol><p><strong>缺点</strong>：</p><ol><li>主节点故障时，需要手动切换到从节点，故障恢复时间较长。</li><li>主节点承担所有写操作，可能成为性能瓶颈。</li><li>无法实现数据分片，受单节点内存限制。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主从复制模式适用于以下场景：</p><ol><li>数据备份和容灾恢复：通过从节点备份主节点的数据，实现数据冗余。</li><li>读写分离：将读操作分发到从节点，减轻主节点压力，提高系统性能。</li><li>在线升级和扩展：在不影响主节点的情况下，通过增加从节点来扩展系统的读取能力。</li></ol><h1 id="哨兵模式-忠诚的侍卫队"><a href="#哨兵模式-忠诚的侍卫队" class="headerlink" title="哨兵模式 - 忠诚的侍卫队"></a>哨兵模式 - 忠诚的侍卫队</h1><p>Redis哨兵模式（Sentinel）就像是一队忠诚的侍卫，时刻守护着你的Redis主从结构。它们监控主库的健康状态，一旦主库挂了，马上选出一个新的主库，确保服务不间断。</p><blockquote><p>Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-1.png" alt="img"></p><p>哨兵实现了什么功能呢？下面是Redis官方文档的描述：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h2 id="哨兵集群的组件"><a href="#哨兵集群的组件" class="headerlink" title="哨兵集群的组件"></a>哨兵集群的组件</h2><blockquote><p>上图中哨兵集群是如何组件的呢？哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。</p></blockquote><p>在主从集群中，主库上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到<code>__sentinel__:hello</code>频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-6.jpg" alt="img"></p><p>通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。</p><h2 id="哨兵监控-Redis-库"><a href="#哨兵监控-Redis-库" class="headerlink" title="哨兵监控 Redis 库"></a>哨兵监控 Redis 库</h2><blockquote><p>哨兵监控什么呢？怎么监控呢？</p></blockquote><p>这是由哨兵向主库发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-7.jpg" alt="img"></p><h2 id="主库下线的判定"><a href="#主库下线的判定" class="headerlink" title="主库下线的判定"></a>主库下线的判定</h2><blockquote><p>哨兵如何判断主库已经下线了呢？</p></blockquote><p>首先要理解两个概念：<strong>主观下线</strong>和<strong>客观下线</strong></p><ul><li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；</li></ul><p>当某个哨兵（如下图中的哨兵2）判断主库“主观下线”后，就会给其他哨兵发送 <code>is-master-down-by-addr</code> 命令。接着，其他哨兵会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-2.jpg" alt="img"></p><p>如果赞成票数（这里是2）是大于等于哨兵配置文件中的 <code>quorum</code> 配置项（比如这里如果是quorum=2）, 则可以判定<strong>主库客观下线</strong>了。</p><h2 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h2><blockquote><p>判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。</p></blockquote><p><strong>为什么必然会出现选举/共识机制？</strong></p><p>为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。</p><p><strong>哨兵的选举机制是什么样的？</strong></p><p>哨兵的选举机制其实很简单，就是一个Raft选举算法： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong>。</p><ul><li>任何一个想成为 Leader 的哨兵，要满足两个条件： <ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul></li></ul><p>需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。这一点很重要，你在实际应用时可不能忽略了。</p><blockquote><p>更进一步理解</p><p>这里很多人会搞混 <strong>判定客观下线</strong> 和 <strong>是否能够主从切换（用到选举机制）</strong> 两个概念，我们再看一个例子。</p><p>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？</p><p>经过实际测试：</p><p>1、哨兵集群可以判定主库“主观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，<strong>哨兵集群可以判定主库为“客观下线”</strong>。</p><p>2、<strong>但哨兵不能完成主从切换</strong>。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到<code>N/2+1</code>选票的结果。</p></blockquote><h2 id="选举新主库"><a href="#选举新主库" class="headerlink" title="选举新主库"></a>选举新主库</h2><blockquote><p>主库既然判定客观下线了，那么如何从剩余的从库中选择一个新的主库呢？</p></blockquote><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-3.jpg" alt="img"></p><h2 id="故障的转移"><a href="#故障的转移" class="headerlink" title="故障的转移"></a>故障的转移</h2><blockquote><p>新的主库选择出来后，就可以开始进行故障的转移了。</p></blockquote><p>假设根据我们一开始的图：（我们假设：判断主库客观下线了，同时选出<code>sentinel 3</code>是哨兵leader）</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240613201758671.png" alt="image-20240613201758671"></p><p><strong>故障转移流程如下</strong>：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-4.png" alt="img"></p><ul><li>将slave-1脱离原从节点（PS: 5.0 中应该是<code>replicaof no one</code>)，升级主节点，</li><li>将从节点slave-2指向新的主节点</li><li>通知客户端主节点已更换</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点</li></ul><p><strong>转移之后</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-5.png" alt="img"></p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ol><li>自动故障转移，提高系统的高可用性。</li><li>具有主从复制模式的所有优点，如数据冗余和读写分离。</li></ol><p><strong>缺点</strong>：</p><ol><li>配置和管理相对复杂。</li><li>依然无法实现数据分片，受单节点内存限制。</li></ol><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>哨兵模式适用于以下场景：</p><ol><li>高可用性要求较高的场景：通过自动故障转移，确保服务的持续可用。</li><li>数据备份和容灾恢复：在主从复制的基础上，提供自动故障转移功能。</li></ol><h1 id="集群模式-坚不可摧的堡垒"><a href="#集群模式-坚不可摧的堡垒" class="headerlink" title="集群模式 - 坚不可摧的堡垒"></a>集群模式 - 坚不可摧的堡垒</h1><p>Redis集群模式（Cluster）像是一座坚不可摧的堡垒，分片存储数据，每个节点都是独立的守卫，即使其中一个倒下，其余的仍能坚守阵地。</p><p>当我们保存大量数据，单机的吞吐无法承受持续扩增的流量的时候，最好的办法是从横向（scale out） 和 纵向（scale up）两方面进行扩展。</p><ul><li>纵向扩展（scale up）：将单个实例的硬件资源做提升，比如 CPU核数量、内存容量、SSD容量。</li><li>横向扩展（scale out）：横向扩增 Redis 实例数，这样每个节点只负责一部分数据就可以，分担一下压力，典型的分治思维。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723113011412-1229895745.png" alt="image"></p><p>那横向扩展和纵向扩展各有什么优缺点呢？</p><ul><li>scale up 虽然操作起来比较简易。但是没法解决Redis一些瓶颈问题，比如持久化（如轮式RDB快照还是AOF指令），遇到大数据量的时候，照样效率会很低，响应慢。另外，单台服务机硬件扩容也是有限制的，不可能无限操作。</li><li>scale out 更容易扩展，分片的模式可以解决很多问题，包括单一实例节点的硬件扩容限制、成本限制，还可以分摊压力，精细化治理，精细化维护。但是同时也要面临分布式带来的一些问题</li></ul><p>现实情况下，在面对千万级甚至亿级别的流量的时候，很多大厂都是在千百台的实例节点组成的集群上进行流量调度、服务治理的。所以，使用Cluster模式，是业内广泛采用的模式。</p><h2 id="什么是Cluster模式？"><a href="#什么是Cluster模式？" class="headerlink" title="什么是Cluster模式？"></a>什么是Cluster模式？</h2><p>Cluster 即 集群模式，类似MySQL，Redis 集群也是一种分布式数据库方案，集群通过分片（sharding）模式来对数据进行管理，并具备分片间数据复制、故障转移和流量调度的能力。</p><p>Redis集群的做法是 将数据划分为 16384（2的14次方）个哈希槽（slots），如果你有多个实例节点，那么每个实例节点将管理其中一部分的槽位，槽位的信息会存储在各自所归属的节点中。以下图为例，该集群有4个 Redis 节点，每个节点负责集群中的一部分数据，数据量可以不均匀。比如性能好的实例节点可以多分担一些压力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723162102412-2114027779.png" alt="image"></p><p>一个Redis集群一共有16384个哈希槽，你可以有1 ~ n个节点来分配这些哈希槽，可以不均匀分配，每个节点可以处理0个 到至多 16384 个槽点。<br>当16384个哈希槽都有节点进行管理的时候，集群处于online 状态。同样的，如果有一个哈希槽没有被管理到，那么集群处于offline状态。</p><p>上面图中4个实例节点组成了一个集群，集群之间的信息通过 <a href="https://www.jianshu.com/p/37231c0455a9?u_atoken=8f004d09-69b0-426f-b061-eb2beec366bd&amp;u_asession=01kPy2LmGTRcCRkywzTBYEHCkosMcq1sc9kA_QMxQzS0laSORdnXM_dgnvDG1wTbw8X0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K-N03wKh1fGpdgnBALMXOj6nHmbkqVcEgdObpAroqY1_GBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05mlGEb2mTIXVShMltoDiqa8mmSULaVgG2oC6fDPX8mGfiV1LZT1wLbYW94ZRRUgNN2m30YJvBI8QN0vcGpawzqQ56Wvq9ANJ8evvyrzij6204SAUiczKrC3sz7bqPpXbYaozWZDEauebiZYp_CIfFOT2ReLQHIkgXR5cKZYDZCf_9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzRlYRaI5LXI74XoQdbRrBZ3vA9ftOKk0zloJSVmQmIfB6xbSxAaWh9ph0bRUFW-6vO3h9VXwMyh6PgyDIVSG1W_7c_dy_6Dl1wgLC3Whv7tuy_Ck9NIynL3sfTheEXzY-rYacisV-aUEZiNNy5yxHlkwafvmAr9jpurPBo8emYF2mWspDxyAEEo4kbsryBKb9Q&amp;u_aref=tGICtqx3upDt17e1WtJxSOZFJWU%3D">Gossip协议</a> 进行交互，这样就可以在某一节点记录其他节点的哈希槽（slots）的分配情况。</p><h2 id="Cluster-实现原理"><a href="#Cluster-实现原理" class="headerlink" title="Cluster 实现原理"></a>Cluster 实现原理</h2><h3 id="集群的组群过程"><a href="#集群的组群过程" class="headerlink" title="集群的组群过程"></a>集群的组群过程</h3><p>集群是由一个个互相独立的节点（readis node）组成的， 所以刚开始的时候，他们都是隔离，毫无联系的。我们需要通过一些操作，把他们聚集在一起，最终才能组成真正的可协调工作的集群。<br>各个节点的联通是通过 CLUSTER MEET 命令完成的：<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 。<br>具体的做法是其中一个node向另外一个 node（指定 ip 和 port） 发送 CLUSTER MEET 命令，这样就可以让两个节点进行握手（handshake操作） ，握手成功之后，node 节点就会将握手另一侧的节点添加到当前节点所在的集群中。<br>这样一步步的将需要聚集的节点都圈入同一个集群中，如下图：<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723160118701-1673167327.png" alt="image"></p><h3 id="集群数据分片原理"><a href="#集群数据分片原理" class="headerlink" title="集群数据分片原理"></a>集群数据分片原理</h3><p>现在的Redis集群分片的做法，主要是使用了官方提供的 Redis Cluster 方案。这种方案就是的核心就是集群的实例节点与哈希槽（slots）之间的划分、映射与管理。下面我们来看看他具体的步骤。</p><p><strong>哈希槽（slots）的划分</strong></p><p>这个前面已经说过了，我们会将整个Redis数据库划分为16384个哈希槽，你的Redis集群可能有n个实例节点，每个节点可以处理0个 到至多 16384 个槽点，这些节点把 16384个槽位瓜分完成。<br>而你实际存储的Redis键值信息也必然归属于这 16384 个槽的其中一个。slots 与 Redis Key 的映射是通过以下两个步骤完成的：</p><ul><li>使用 CRC16 算法计算键值对信息的Key，会得出一个 16 bit 的值。</li><li>将 第1步中得到的 16 bit 的值对 16384 取模，得到的值会在 0 ～ 16383 之间，映射到对应到哈希槽中。<br>当然，可能在一些特殊的情况下，你想把某些key固定到某个slot上面，也就是同一个实例节点上。这时候可以用hash tag能力，强制 key 所归属的槽位等于 tag 所在的槽位。<br>其实现方式为在key中加个{}，例如test_key{1}。使用hash tag后客户端在计算key的crc16时，只计算{}中数据。如果没使用hash tag，客户端会对整个key进行crc16计算。下面演示下hash tag使用:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">127.0.0.1:6380&gt;</span> cluster keyslot <span class="symbol">user:</span><span class="keyword">case</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">(integer) <span class="number">1024</span></span><br><span class="line"><span class="meta prompt_">127.0.0.1:6380&gt;</span> cluster keyslot <span class="symbol">user:</span>favor</span><br><span class="line">(integer) <span class="number">1023</span></span><br><span class="line"><span class="meta prompt_">127.0.0.1:6380&gt;</span> cluster keyslot <span class="symbol">user:</span>info&#123;<span class="number">1</span>&#125;</span><br><span class="line">(integer) <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>如上，使用hash tag 后会对应到通一个hash slot：1024中。</p><p><strong>哈希槽（slots）的映射</strong></p><p>一种是初始化的时候均匀分配 ，使用 cluster create 创建，会将 16384 个slots 平均分配在我们的集群实例上，比如你有n个节点，那每个节点的槽位就是 16384 / n 个了 。<br>另一种是通过 CLUSTER MEET 命令将 node1、node2、ndoe3、node4 4个节点联通成一个集群，刚联通的时候因为还没分配哈希槽，还是处于offline状态。我们使用 <code>cluster addslots</code> 命令来指定。<br>指定的好处就是性能好的实例节点可以多分担一些压力。</p><p>可以通过 addslots 命令指定哈希槽范围，比如下图中，我们哈希槽是这么分配的：实例 1 管理 0 ～ 7120 哈希槽，实例 2 管理 7121~9945 哈希槽，实例 3 管理 9946 ～ 13005 哈希槽，实例 4 管理 13006 ～ 16383 哈希槽。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">0</span><span class="string">,7120</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">7121</span><span class="string">,9945</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">9946</span><span class="string">,13005</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">13006</span><span class="string">,16383</span></span><br></pre></td></tr></table></figure><p>slots 和 Redis 实例之间的映射关系如下：<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723163103375-2028951983.png" alt="image"></p><p>key <code>testkey_1</code> 和 <code>testkey_2</code> 经过 CRC16 计算后再对slots的总个数 16384 取模，结果分别匹配到了 cache1 和 cache3 上。</p><h3 id="数据复制过程和故障转移"><a href="#数据复制过程和故障转移" class="headerlink" title="数据复制过程和故障转移"></a>数据复制过程和故障转移</h3><p><strong>数据复制</strong></p><p>Cluster 是具备Master 和 Slave模式，Redis 集群中的每个实例节点都负责一些槽位，比如上图中的四个节点分管了不同的槽位区间。而每个Master至少需要一个Slave节点，Slave 节点是通过主从复制方式同步主节点数据。 节点之间保持TCP通信，当Master发生了宕机，Redis Cluster自动会将对应的Slave节点选为Master，来继续提供服务。与纯主从模式不同的是，主从节点之间并没有读写分离， Slave 只用作 Master 宕机的高可用备份，所以更合理来说应该是主备模式。</p><p>如果主节点没有从节点，那么一旦发生故障时，集群将完全处于不可用状态。 但也允许配置 <code>cluster-require-full-coverage</code>参数，及时部分节点不可用，其他节点正常提供服务，这是为了避免全盘宕机。</p><p>主从切换之后，故障恢复的主节点，会转化成新主节点的从节点。这种自愈模式对提高可用性非常有帮助。</p><p><strong>故障检测</strong></p><p>一个节点认为某个节点宕机不能说明这个节点真的挂起了，无法提供服务了。只有占据多数的实例节点都认为某个节点挂起了，这时候cluster才进行下线和主从切换的工作。</p><p>Redis 集群的节点采用 Gossip 协议来广播信息，每个节点都会定期向其他节点发送ping命令，如果接受 ping 消息的节点在指定时间内没有回复 pong，则会认为该节点失联了（PFail），则发送 ping 的节点就把接受 ping 的节点标记为主观下线。</p><p>如果集群半数以上的主节点都将主节点 xxx 标记为主观下线，则节点 xxx 将被标记为客观下线，然后向整个集群广播，让其它节点也知道该节点已经下线，并立即对下线的节点进行主从切换。</p><p><strong>主从故障转移</strong></p><p>当一个从节点发现自己正在复制的主节点进入了已下线，则开始对下线主节点进行故障转移，故障转移的步骤如下：</p><ul><li>如果只有一个slave节点，则从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>如果是多个slave节点，则采用选举模式进行，竞选出新的Master<ul><li>集群中设立一个自增计数器，初始值为 0 ，每次执行故障转移选举，计数就会+1。</li><li>检测到主节点下线的从节点向集群所有master广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，所有收到消息、并具备投票权的主节点都向这个从节点投票。</li><li>如果收到消息、并具备投票权的主节点未投票给其他从节点（只能投一票哦，所以投过了不行），则返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示支持。</li><li>参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，如果收集到的选票 大于等于 (n/2) + 1 支持，n代表所有具备选举权的master，那么这个从节点就被选举为新主节点。</li><li>如果这一轮从节点都没能争取到足够多的票数，则发起再一轮选举（自增计数器+1），直至选出新的master。</li></ul></li><li>新的主节点会撤销所有对已下线主节点的slots指派，并将这些slots全部指派给自己。</li><li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ul><p>跟哨兵类似，两者都是基于 Raft 算法来实现的，流程如图所示：<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220730150510040-589928276.png" alt="image"></p><h2 id="client-访问数据集群的过程"><a href="#client-访问数据集群的过程" class="headerlink" title="client 访问数据集群的过程"></a>client 访问数据集群的过程</h2><blockquote><p>Redis cluster采用去中心化的架构，集群的主节点各自负责一部分槽，客户端如何确定key到底会映射到哪个节点上呢？这就是我们要讲的请求重定向。</p></blockquote><p>在cluster模式下，<strong>节点对请求的处理过程</strong>如下：</p><ul><li>检查当前key是否存在当前NODE？ <ul><li>通过crc16（key）/16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果</li><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？</li><li>若key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若Slot未迁出，检查Slot是否导入中？</li><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul><p>这个过程中有两点需要具体理解下： <strong>MOVED重定向</strong> 和 <strong>ASK重定向</strong>。</p><h3 id="Moved-重定向"><a href="#Moved-重定向" class="headerlink" title="Moved 重定向"></a>Moved 重定向</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-3.png" alt="img"></p><ul><li>槽命中：直接返回结果</li><li>槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个Moved 重定向，客户端根据Moved 重定向所包含的内容找到目标节点，再一次发送命令。</li></ul><h3 id="ASK-重定向"><a href="#ASK-重定向" class="headerlink" title="ASK 重定向"></a>ASK 重定向</h3><p>Ask重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据可能已经迁移到了目标节点，使用Ask重定向来解决此种情况。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-5.png" alt="img"></p><h3 id="smart客户端"><a href="#smart客户端" class="headerlink" title="smart客户端"></a>smart客户端</h3><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来<strong>减低复杂性，追求更好的性能</strong>。客户端内部负责计算/维护键-&gt; 槽 -&gt; 节点映射，用于快速定位目标节点。</p><p>实现原理：</p><ul><li>从集群中选取一个可运行节点，使用 cluster slots得到槽和节点的映射关系</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-6.png" alt="img"></p><ul><li>将上述映射关系存到本地，通过映射关系就可以直接对目标节点进行操作（CRC16(key) -&gt; slot -&gt; node），很好地避免了Moved重定向，并为每个节点创建JedisPool</li><li>至此就可以用来进行命令操作</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-7.png" alt="img"></p><h2 id="更加深入-1"><a href="#更加深入-1" class="headerlink" title="更加深入"></a>更加深入</h2><h3 id="为什么Redis-Cluster的Hash-Slot-是16384？"><a href="#为什么Redis-Cluster的Hash-Slot-是16384？" class="headerlink" title="为什么Redis Cluster的Hash Slot 是16384？"></a>为什么Redis Cluster的Hash Slot 是16384？</h3><p>我们知道一致性hash算法是2的16次方，为什么hash slot是2的14次方呢？</p><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 <em> 8 (8 bit) </em> 1024(1k) = 16K），也就是说使用2k的空间创建了16k的槽数。</p><p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（8 <em> 8 (8 bit) </em> 1024(1k) =65K），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。</p><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢？"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢？" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢？"></a>为什么Redis Cluster中不建议使用发布订阅呢？</h3><p>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会严重消耗带宽，不建议使用。（虽然官网上讲有时候可以使用Bloom过滤器或其他算法进行优化的）</p><h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ol><li>数据分片，实现大规模数据存储。</li><li>负载均衡，提高系统性能。</li><li>自动故障转移，提高高可用性。</li></ol><p><strong>缺点</strong>：</p><ol><li>配置和管理较复杂。</li><li>一些复杂的多键操作可能受到限制。</li></ol><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>Cluster模式适用于以下场景：</p><ol><li>大规模数据存储：通过数据分片，突破单节点内存限制。</li><li>高性能要求场景：通过负载均衡，提高系统性能。</li><li>高可用性要求场景：通过自动故障转移，确保服务的持续可用。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了Redis的三大集群模式：主从复制、哨兵模式和Cluster模式。每种模式都有其特点和应用场景，具体如下：</p><ol><li><strong>主从复制模式</strong>：适用于数据备份和读写分离场景，配置简单，但在主节点故障时需要手动切换。</li><li><strong>哨兵模式</strong>：在主从复制的基础上实现自动故障转移，提高高可用性，适用于高可用性要求较高的场景。</li><li><strong>Cluster模式</strong>：通过数据分片和负载均衡实现大规模数据存储和高性能，适用于大规模数据存储和高性能要求场景。</li></ol><p>在实际应用中，可以根据系统的需求和特点选择合适的Redis集群模式，以实现高可用性、高性能和大规模数据存储。</p><blockquote><p>碎碎念阶段：</p><p>今天是个好日子，虽然天气不是很好，但最起码我出门的时候天气一直都还不错。拍了张无敌的照片，就放做本文的封面吧。</p><p>今天有参加了一个面试，不太明白为什么会出现这种情况，就问了一个技术相关的问题，答的不是很好，感觉永远都想不到面试官会问什么问题。字节今天下午约了下周二的面试，应该是要到实习时间了，被别人鸽了。不知道那一场面试有会以什么问题结束我的大厂梦呢。感觉面试都快PTSD了，一想到面试就开始心慌。祝我好运吧，毕竟之前高考后我的运气就变得好了一点。希望今年也能这样吧。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6997944007812710414">https://juejin.cn/post/6997944007812710414</a></li><li><a href="https://www.cnblogs.com/yangyixin/p/17436853.html">https://www.cnblogs.com/yangyixin/p/17436853.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html</a></li><li><a href="https://www.cnblogs.com/wzh2010/p/15886799.html">https://www.cnblogs.com/wzh2010/p/15886799.html</a></li><li><a href="https://www.cnblogs.com/yidengjiagou/p/17345831.html">https://www.cnblogs.com/yidengjiagou/p/17345831.html</a></li></ul><p>实际操作方面可以看下面的文章</p><ul><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/36%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/36%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/37%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/37%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/38%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/38%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/39%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/39%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/40%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/40%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件开发通常会提到一个名词 “三高”，即高并发、高性能、高可用。&lt;/p&gt;
&lt;p&gt;具体的指标定义，如：高并发方面要求QPS 大于 10万；高性能方面要求请求延迟小于 100 ms；高可用方面要高于 99.99%。&lt;/p&gt;
&lt;p&gt;在前面学习 Redis 时，我们也可以看出 Re</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文——基础篇（二）</title>
    <link href="http://example.com/2024/06/12/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2024/06/12/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-06-12T13:42:11.000Z</published>
    <updated>2024-06-19T10:09:33.507Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 Java 基础常见八股文的第二篇，主要内容是关于面向对象的，非常重要，一点一点来看吧。</p><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h2><ul><li><strong>⾯向过程</strong> ：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。</li><li><strong>⾯向对象</strong> ：面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。</li></ul><p>用一个比喻：面向过程是编年体；面向对象是纪传体。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-10.png" alt="面向对象和面向过程的区别"></p><h2 id="面向对象编程有哪些特性？"><a href="#面向对象编程有哪些特性？" class="headerlink" title="面向对象编程有哪些特性？"></a>面向对象编程有哪些特性？</h2><p>面向对象编程有三大特性：封装、继承、多态。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-20240330115129.png" alt="二哥的 Java 进阶之路"></p><ul><li><p><strong>封装</strong>：封装是指将数据（属性，或者叫字段）和操作数据的方法（行为）捆绑在一起，形成一个独立的对象（类的实例）。</p><p>封装是把一个对象的属性私有化，同时提供一些可以被外界访问的方法。</p></li><li><p><strong>继承</strong>：继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。以提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p></li><li><p><strong>多态</strong>：多态允许不同类的对象对同一消息做出响应，但表现出不同的行为（即方法的多样性）。</p><p>多态其实是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象类型的不同产生不同的结果。</p><p>多态的前置条件有三个：</p><ul><li>子类继承父类</li><li>子类重写父类的方法</li><li>父类引用指向子类的对象</li></ul></li></ul><h2 id="多态解决了什么问题？"><a href="#多态解决了什么问题？" class="headerlink" title="多态解决了什么问题？"></a>多态解决了什么问题？</h2><p>多态的目的是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。比如说动态绑定，允许在程序在运行时再确定调用的是子类还是父类的方法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/extends-bigsai-2bf1876f-0c1c-4e83-8721-e6f48d6451c0.png" alt="bigsai：封装继承多态"></p><h2 id="访问修饰符-public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符-public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符 public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符 public、private、protected、以及不写（默认）时的区别？</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-12.png" alt="访问修饰符和可见性"></p><h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><p>一个类只能继承一个抽象类；但一个类可以实现多个接口。所以我们在新建线程类的时候一般推荐使用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。</p><p>抽象类符合 is-a 的关系，而接口更像是 has-a 的关系，比如说一个类可以序列化的时候，它只需要实现 Serializable 接口就可以了，不需要去继承一个序列化类。</p><p>抽象类更多地是用来为多个相关的类提供一个共同的基础框架，包括状态的初始化，而接口则是定义一套行为标准，让不同的类可以实现同一接口，提供行为的多样化实现。</p><h3 id="抽象类可以定义构建函数吗？"><a href="#抽象类可以定义构建函数吗？" class="headerlink" title="抽象类可以定义构建函数吗？"></a>抽象类可以定义构建函数吗？</h3><p>可以，抽象类可以有构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);  <span class="comment">// 调用抽象类的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口可以定义构建函数吗？"><a href="#接口可以定义构建函数吗？" class="headerlink" title="接口可以定义构建函数吗？"></a>接口可以定义构建函数吗？</h3><p>不能，接口主要用于定义一组方法规范，没有具体的实现细节。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-20240512090855.png" alt="二哥的 Java 进阶之路：接口不能定义构造方法"></p><h3 id="继承和抽象的区别？"><a href="#继承和抽象的区别？" class="headerlink" title="继承和抽象的区别？"></a>继承和抽象的区别？</h3><p>继承是一种允许子类继承父类属性和方法的机制。通过继承，子类可以重用父类的代码。</p><p>抽象是一种隐藏复杂性和只显示必要部分的技术。在面向对象编程中，抽象可以通过抽象类和接口实现。</p><h2 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h2><ol><li><strong>从语法形式上看</strong>：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li><strong>从变量在内存中的存储⽅式来看</strong>：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。</li><li><strong>从变量在内存中的⽣存时间上看</strong>：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。</li><li><strong>成员变量如果没有被赋初值</strong>：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。</li></ol><h2 id="静态变量和实例变量的区别？静态方法、实例方法呢？"><a href="#静态变量和实例变量的区别？静态方法、实例方法呢？" class="headerlink" title="静态变量和实例变量的区别？静态方法、实例方法呢？"></a>静态变量和实例变量的区别？静态方法、实例方法呢？</h2><blockquote><p>静态变量和实例变量的区别？</p></blockquote><p><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。</p><p><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><blockquote><p>静态⽅法和实例⽅法有何不同?</p></blockquote><p>类似地。</p><p><strong>静态方法</strong>：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”<strong>类名.⽅法名</strong>“的⽅式，也可以使⽤”<strong>对象名.⽅法名</strong>“的⽅式。静态方法里不能访问类的非静态成员变量和方法。</p><p><strong>实例⽅法</strong>：依存于类的实例，需要使用”<strong>对象名.⽅法名</strong>“的⽅式调用；可以访问类的所有成员变量和方法。</p><h2 id="final、finally、finalize"><a href="#final、finally、finalize" class="headerlink" title="final、finally、finalize"></a>final、finally、finalize</h2><ul><li><p><code>final</code>：final 是一个修饰符，可以修饰类、方法和变量。</p><ul><li>当 final 修饰一个类时，表明这个类不能被继承。比如，String 类、Integer 类和其他包装类都是用 final 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（Override）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 final 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。但是引用指向的对象内容可以改变。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-13.png" alt="三分恶面渣逆袭：final修饰变量"></p></li><li><p><code>finally</code>： 是 Java 中异常处理的一部分，用来创建 try 块后面的 finally 块。无论 try 块中的代码是否抛出异常，finally 块中的代码总是会被执行。通常，finally 块被用来释放资源，如关闭文件、数据库连接等。</p></li><li><p><code>finalize</code>： 是 object 类的一个方法，用于在垃圾回收器将对象从内存中清除出去之前作业写必要的清理工作。</p><p>这个方法在垃圾回收器准备释放对象占用的内存之前被自动调用。我们不能显式地调用 finalize 方法，因为它总是由垃圾回收器在适当的时间自动调用。</p></li></ul><h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p>我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/shallow%2526deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p><h2 id="Java-是值传递，还是引用传递？"><a href="#Java-是值传递，还是引用传递？" class="headerlink" title="Java 是值传递，还是引用传递？"></a>Java 是值传递，还是引用传递？</h2><p>Java 是值传递，不是引用传递。</p><p>当一个对象被作为参数传递到方法中时，参数的值就是该对象的引用。引用的值是对象在堆中的地址。</p><p>对象是存储在堆中的，所以传递对象的时候，可以理解为把变量存储的对象地址给传递过去。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-14.png" alt="三分恶面渣逆袭：Java引用数据值传递示意图"></p><h3 id="引用类型的变量有什么特点？"><a href="#引用类型的变量有什么特点？" class="headerlink" title="引用类型的变量有什么特点？"></a>引用类型的变量有什么特点？</h3><p>引用类型的变量存储的是对象的地址，而不是对象本身。因此，引用类型的变量在传递时，传递的是对象的地址，也就是说，传递的是引用的值。</p><h2 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h2><p>该问题考察 JVM、GC等知识。</p><ol><li>强引用：只要引用关系还在，对象就永远不会被回收。强引用其实就是指普通对象的引用，只要还有引用关系存在，就表示对象还活着，垃圾回收器就无法回收这一类对象。只有在没有其他引用关系或者超过引用作用域，再或者将对象引用强制赋值为 null 的情况下，垃圾回收器才会回收这个对象。</li><li>软引用：非必须存活的对象，JVM 会在内存溢出前对其进行回收。软引用是一种相对于强引用来说弱一些的引用。可以让对象豁免一些垃圾回收的操作。只有当JVM判断内存不足的时候，才会试图回收引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足的时候就会清理掉。这样就可以保证在使用缓存的同时，不会耗尽内存。</li><li>弱引用：非必须存活的对象，不管内存是否够用，下次GC一定回收。弱引用是相对于强引用而言的，它是在允许存在引用关联的情况下能被回收的对象。在垃圾回收线程扫描它所管辖的内存区域的过程中，一旦发现只具有弱引用的对象，不管当前的内存空间是否足够，垃圾回收器都会回收这个对象。</li><li>虚引用：等同于没有引用，对象被回收时会收到通知。虚引用不会决定对象的生命周期，它提供一种确保对象被“finalize”以后去做某些事情的机制。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入与之关联的引用队列中，程序可以通过判断引用队列是否已经加入虚引用来决定被引用对象是否要被垃圾回收器回收。然后，我们就可以在引用对象被回收之前执行一些必要的操作。所以，虚引用必须和引用队列一起使用。</li></ol><p>举个例子：</p><ul><li>强引用就好比电视剧中的男主角，怎么都死不了。</li><li>软引用就像女主角，虽有一段经历，但还是没走到最后。</li><li>弱引用就是男二号，注定是用来牺牲的。</li><li>虚引用就是路人甲了。</li></ul><h1 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h1><h2 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-对象的创建过程"><a href="#Java-对象的创建过程" class="headerlink" title="Java 对象的创建过程"></a>Java 对象的创建过程</h2><p>在实例化一个对象的时候，JVM 首先会去<strong>检查目标对象是否已经被加载并初始化</strong>了，如果没有，则 JVM 需要立刻去加载目标类，然后调用目标类的构造器完成初始化。目标类的加载是通过类加载器来实现的，主要就是把一个类加载到内存里面。</p><p>然后，初始化主要是对目标类里面的静态变量、成员变量、静态代码块进行初始化。当目标类被初始化以后，就可以从常量池里面找到对应的类元信息，并且目标对象的大小在类加载之后就已经确定了，所以这个时候就需要为新创建的对象，根据目标对象的大小在堆内存里面分配内存空间。</p><p>内存分配的方式一般有两种，一种是指针碰撞，另一种是空闲列表，JVM 会根据 Java 堆内存是否规整来决定内存分配方式。<br>接下来，JVM 会把目标对象里面的普通成员变量初始化为零值，比如 int 类型初始化为0.</p><p>对象类型初始化为null（类变量在类加载的准备阶段就已经初始化过了）。这一步操作主要是保证对象里面的实例字段不用初始化就可以直接使用，也就是程序能够获得这些字段对应数据类型的零值。</p><p>然后，JVM 还需要对目标对象的对象头做一些设置，比如对象所属的类元信息、对象的GC 分代年龄、hashCode、锁标记等。</p><p>完成这些步骤以后，对于 JVM水说，新对象的创建工作就完成了、但是对于 Java 语言来说，对象创建才算开始。</p><p>接下来要做的，就是执行目标对象内部生成的 init 方法，初始化成员变量的值、执行构造块，最后执行目标对象的构建方法，完成对象的构建。</p><p>其中，init 方法是 Java 文件编译之后在字节码文件中生成的，它是一个实例构造器，这个构造器会把语句块、变量初始化、调用父类构造器等操作组织在一起。所以调用 init 方法能够完成一系列初始化动作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fb99e86aaf36945df1a34b11d4fd0da.jpg" alt="fb99e86aaf36945df1a34b11d4fd0da"></p><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a><code>==</code> 和 <code>equals()</code> 的区别</h2><p><code>==</code> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a><code>hashCode</code></h2><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/java-hashcode-method.png" alt="hashCode() 方法"></p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>的值默认时 JVM 使用随机数生成的，两个不同的对象可能会生成相同的 <code>hashCode</code>。</p><ul><li><strong>为什么要提供 <code>hashCode()</code> 方法？</strong></li></ul><p>看《Head First Java》中的这一段：</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><ul><li><strong>为什么要同时提供这两个方法？</strong></li></ul><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><ul><li><strong>那为什么不只提供 <code>hashCode</code> 方法？</strong></li></ul><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><ul><li><strong>为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></li></ul><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h2 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</h2><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h2 id="一个空的-Object-对象占多大内存？"><a href="#一个空的-Object-对象占多大内存？" class="headerlink" title="一个空的 Object 对象占多大内存？"></a>一个空的 Object 对象占多大内存？</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612231739612.png" alt="image-20240612231739612"></p><ol><li>对象头，包括 Markword、类元指针、数组长度。其中 Markword 用来存储对象运行时的相关数据，比如 hashCode、GC 分代年龄等。在64位操作系统中占8字节，在32位操作系统中占4字节。类元指针指向当前实例对象所属哪个类，在开启压缩指针的情况下占4字节，未开启则占8字节。数组长度只有对象数组才会存在，占4字节。</li><li>实例数据，主要用来存储对象中的字段信息。</li><li>对齐填充，用来补充实现 Java 对象大小的倍数对齐。在JVM 中，Java 对象的大小需要按照8字节或者8字节的倍数来对齐，从而避免伪共享问题。</li></ol><p>根据以上分析，我们来总结一下。</p><ol><li>一个Java 空对象，在开启压缩指针的情况下，占用12字节。其中，Markword 占8字节、类元指针占4字节。但是为了避免伪共享问题，JVM会按照8字节的倍数进行填充，所以会在对齐填充区填充4字节，变成16字节。</li><li>在关闭压缩指针的情况下，Object 默认会占用16字节。其中，Markword 占8字节，类元指针占4字节，对齐填充占4字节。16字节正好是8的整数倍，因此不需要填充。</li></ol><p>所以结论是，一般情况下，一个空的 Java Object 对象占用 16 字节的内存空间。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><h3 id="值可变性"><a href="#值可变性" class="headerlink" title="值可变性"></a>值可变性</h3><p><code>String</code> 是不可变的。因此每次修改 String 的值，都会产生一个新的对象。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，所以都是<strong>可变类</strong>，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全方面"><a href="#线程安全方面" class="headerlink" title="线程安全方面"></a>线程安全方面</h3><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p><p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h3><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。性能最差。</p><p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。性能第二。</p><p>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="数据存储方面"><a href="#数据存储方面" class="headerlink" title="数据存储方面"></a>数据存储方面</h3><p><code>String</code> 存储在<strong>字符串常量池</strong>中，<code>StringBuilder</code> 与 <code>StringBuffer</code> 存储在<strong>堆内存</strong>中。</p><h3 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a><strong>对于三者使用的总结：</strong></h3><ul><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ul><h2 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h2><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol></blockquote><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><h3 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h3><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure><p>上面的代码对应的字节码如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20220422161637929.png" alt="img"></p><p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20220422161320823.png" alt="img"></p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20220422162327415.png" alt="img"></p><p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 <a href="https://openjdk.org/jeps/280">JEP 280open in new window</a> 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。可以看看<a href="https://juejin.cn/post/7182872058743750715">这篇文章</a>。</p><h2 id="String-s1-new-String-“hello”-这句话创建了几个字符串对象？-字符串常量池"><a href="#String-s1-new-String-“hello”-这句话创建了几个字符串对象？-字符串常量池" class="headerlink" title="String s1 = new String(“hello”);这句话创建了几个字符串对象？|| 字符串常量池"></a>String s1 = new String(“hello”);这句话创建了几个字符串对象？|| 字符串常量池</h2><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>String s1 = new String(“abc”);这句话创建了几个字符串对象？</strong></p><p>会创建 一个 或 两个 字符串对象。看看详情：</p><blockquote><p>首先，这个语句里面有一个 new关键字，这个关键字是在程序运行时，根据已经加载的系统类 String，在堆内存里面实例化的一个字符串对象，如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/144a58947a1f84578369ffbe81fde1d.jpg" alt="144a58947a1f84578369ffbe81fde1d" style="zoom: 25%;" /></p><p>然后，在这个 String 的构造方法里面，传递了一个 hello字符串，因为 String 里面的字符串成员变量是 final 修饰的，所以它是一个字符串常量。<br>接下来，JVM 会用字面量hello 去字符串常量池里面试图获取它对应的 String 对象引用，如果获取不到，就会在堆内存里面创建一个 hello 的 String 对象，并且把引用保存到字符串常量池里面。<br>后续如果再有字面量 hello 的定义，因为字符串常量池里面己经存在了字面量 hello的引用，所以只需要从常量池里面获取对应的引用就可以了，不需要再创建。<br>所以，对于这个问题，分以下两种情况：</p><ol><li>如果 hello这个字符串常量不存在，则创建两个对象，分别是hello这个字符串常量，以及 new String<br>这个实例对象。</li><li>如果 hello这个字符串常量存在，则只会创建一个对象。</li></ol></blockquote><p>看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span> + <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hel&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s5.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;h&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;ello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> s7 + s8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s9);<span class="comment">//false</span></span><br><span class="line">System.out.println(s4 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s6);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>接下来简单分析一下，由于s2 指向的字面量 hello 在常量池中已经存在（s1 先于s2），于是JVM 就返回这个字面量绑定的引用，所以 <code>s1 == s2</code>。</p><p>s3中字面量的拼接其实就是hello，在编译期间就已经对它进行了优化，所以s1 和 s3 也是相等的。</p><p>S4 中的new String（”lo”）生成了两个对象：lo 和 new String（”lo”）。lo存在于字符串常量池中，new String（”lo”）存在于堆中，String s4 = “hel” + new String（”lo”）实质上是两个对象的相加，编译器不会进行优化，相加的结果存在于堆中，而s1 存在于字符串常量池中，当然不相等。<code>s1 == s9</code>的原理也一样。</p><p>对于 s4 == s5，因为两个相加的结果都在堆中，不用说，肯定不相等。</p><p>对于 s1 == s6，s5.intern()方法能使一个位于堆中的字符串，在运行期间动态地加入字符串常量池（字符串常量池的内容是在程序启动的时候就已经加载好了的）。如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用；否则，复制一份该字面量到字符串常量池并返回它的引用。因此s1 ==s6输出 true。</p><blockquote><p><strong>常量折叠</strong></p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+” 拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节内容比较杂乱，但基本都是 Java 基础中的重点，而且会对实际开发有很多启发，需要着重记忆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是 Java 基础常见八股文的第二篇，主要内容是关于面向对象的，非常重要，一点一点来看吧。&lt;/p&gt;
&lt;h1 id=&quot;面向对象基础&quot;&gt;&lt;a href=&quot;#面向对象基础&quot; class=&quot;headerlink&quot; title=&quot;面向对象基础&quot;&gt;&lt;/a&gt;面向对象基础&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Redis事件机制：高效运行的秘密武器</title>
    <link href="http://example.com/2024/06/12/Redis%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A7%98%E5%AF%86%E6%AD%A6%E5%99%A8/"/>
    <id>http://example.com/2024/06/12/Redis%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A7%98%E5%AF%86%E6%AD%A6%E5%99%A8/</id>
    <published>2024-06-12T12:35:25.000Z</published>
    <updated>2024-06-12T13:36:03.568Z</updated>
    
    <content type="html"><![CDATA[<p>对，没错，这又是一篇讲为什么 Redis 如此之快的文章。不过这次的内容于<a href="https://zxh3032.github.io/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/">上一篇文章</a>不一样，本文将聚焦在 Redis 的事件机制的基础概念和实现，不在过多提及它对 Redis 速度的影响。</p><p>我在之前的文章中多次提过，Redis 是单线程的，你是否想过，一个线程要如何处理来自各个客户端的各种请求呢？它忙的过来吗？</p><p>了解 Redis 的都知道，它不光忙得过来，还做的井井有条。其中就多亏了 IO 多路复用，不仅仅是它，事件机制在其中也是一个不错的设计。</p><p>关于 IO 多路复用，我们在之前的文章中也提到过很多次了，所以这里就只聚焦在 Redis 的事件机制上。</p><h1 id="如果是你，会怎么做？"><a href="#如果是你，会怎么做？" class="headerlink" title="如果是你，会怎么做？"></a>如果是你，会怎么做？</h1><p>让我们来设计一个 redis，我们要怎么处理请求连接呢？</p><p>最笨的方法，那就是来一个客户端就 <code>accept</code> 一次，然后有什么请求就做什么事，先来先做。显然，这样做别说一个线程了，就算有十个线程都不够用的，太慢了。</p><p>我们还可以这样设计，来一个我就单独开设一个线程处理它，相当于你一来我就单独找一个人为你服务，而服务的人最终会将请求给到一个处理中心，让处理中心统一去处理，然后将结果返回。但显然 Redis 没有那么多资源让你浪费。</p><p>各种设计都不能满足要求，那就摇人，叫大哥——IO多路复用。至少他能帮我解决前面服务的问题，fd 我就不管了，直接告诉我哪些人来了，并且告诉我有事的是哪些人。</p><p>既然 epoll_wait 能 告诉我们有那些 socket 已经就绪，那么我们就处理就绪的这些就可以了。但我们需要一个合理的机制来帮我们来优雅的处理他们，毕竟 Redis 后面只有个单线程在处理。由于处理没这么快，肯定需要一个地方来存放未处理的这些事件，那很合理就能想到需要一个类似 buffer 的东西。</p><p>所以，对于这个事件机制，我第一个想法就是弄个队列，或者 ringbuffer 来搞，那不就是一个生产消费者模型吗？</p><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>Redis中的事件驱动库只关注网络IO，以及定时器。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><p>事件驱动库的代码主要是在<code>src/ae.c</code>中实现的，其示意图如下所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612205406918.png" alt="image-20240612205406918"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件：Redis-的特工队"><a href="#文件事件：Redis-的特工队" class="headerlink" title="文件事件：Redis 的特工队"></a>文件事件：Redis 的特工队</h2><blockquote><p>Redis基于<strong>Reactor模式</strong>开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p></blockquote><p><strong>Redis 事件想用框架 ae_event 及文件事件处理器</strong></p><p>Redis并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。事件响应框架一般都采用该架构，比如 netty 和 libevent。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-2.png" alt="img"></p><p>如下图所示，文件事件处理器有四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器以及事件处理器。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-3.png" alt="img"></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 <code>accept</code>、<code>read</code>、<code>write</code>和 <code>close</code> 等操作时，就会产生一个文件事件。因为 Redis 通常会连接多个套接字，所以多个文件事件有可能并发的出现。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件派发器传递那些产生了事件的套接字。</p><p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生的套接字都放到同一个队列(也就是后文中描述的aeEventLoop的fired就绪事件表)里边，然后文件事件处理器会以有序、同步、单个套接字的方式处理该队列中的套接字，也就是处理就绪的文件事件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-4.png" alt="img"></p><p>所以，一次 Redis 客户端与服务器进行连接并且发送命令的过程如上图所示。</p><ul><li>客户端向服务端发起<strong>建立 socket 连接的请求</strong>，那么监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行。处理器会对客户端的连接请求</li><li>进行<strong>应答</strong>，然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器关联。</li><li>客户端建立连接后，向服务器<strong>发送命令</strong>，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行，处理器读取客户端命令，然后传递给相关程序去执行。</li><li><strong>执行命令获得相应的命令回复</strong>，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器将命令回复全部写入到套接字中。</li></ul><p>其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p><h2 id="时间事件：Redis的时间旅行者"><a href="#时间事件：Redis的时间旅行者" class="headerlink" title="时间事件：Redis的时间旅行者"></a>时间事件：Redis的时间旅行者</h2><blockquote><p>Redis 的时间事件分为以下两类：</p></blockquote><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 的时间事件的具体定义结构如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 全局唯一ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="comment">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="comment">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    <span class="comment">/* 时间处理器 */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    <span class="comment">/* 事件结束回调函数，析构一些资源*/</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="comment">/* 私有数据 */</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="comment">/* 前驱节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">/* 后继节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：</p><ul><li>如果返回值是 <code>AE_NOMORE</code>，那么这个事件是一个定时事件，该事件在达到后删除，之后不会再重复。</li><li>如果返回值是非 <code>AE_NOMORE</code> 的值，那么这个事件为周期性事件，当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 when 属性进行更新，让这个事件在一段时间后再次达到。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-5.png" alt="img"></p><p>服务器所有的时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能。</p><h1 id="aeEventLoop的具体实现"><a href="#aeEventLoop的具体实现" class="headerlink" title="aeEventLoop的具体实现"></a><code>aeEventLoop</code>的具体实现</h1><blockquote><p>介绍完文件事件和时间事件，我们接下来看一下 <code>aeEventLoop</code>的具体实现</p></blockquote><h2 id="创建事件管理器"><a href="#创建事件管理器" class="headerlink" title="创建事件管理器"></a>创建事件管理器</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器<code>aeEventLoop</code>对象。</p><p>函数<code>aeCreateEventLoop</code>将创建一个事件管理器，主要是初始化 <code>aeEventLoop</code>的各个属性值，比如events、fired、timeEventHead和apidata：</p><ul><li>首先创建<code>aeEventLoop</code>对象。</li><li>初始化未就绪文件事件表、就绪文件事件表。events指针指向未就绪文件事件表、fired指针指向就绪文件事件表。表的内容在后面添加具体事件时进行初变更。</li><li>初始化时间事件列表，设置<code>timeEventHead</code>和<code>timeEventNextId</code>属性。</li><li>调用<code>aeApiCreate</code> 函数创建epoll实例，并初始化 <code>apidata</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *<span class="title function_">aeCreateEventLoop</span><span class="params">(<span class="type">int</span> setsize)</span> &#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* 创建事件状态结构 */</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* 创建未就绪事件表、就绪事件表 */</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* 设置数组大小 */</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    <span class="comment">/* 初始化执行最近一次执行时间 */</span></span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 初始化时间事件结构 */</span></span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 将多路复用io与事件管理器关联起来 */</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* 初始化监听事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line">err:</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aeApiCreate</code> 函数首先创建了<code>aeApiState</code>对象，初始化了epoll就绪事件表；然后调用epoll_create创建了epoll实例，最后将该<code>aeApiState</code>赋值给<code>apidata</code>属性。</p><p><code>aeApiState</code>对象中epfd存储epoll的标识，events是一个epoll就绪事件数组，当有epoll事件发生时，所有发生的epoll事件和其描述符将存储在这个数组中。这个就绪事件数组由应用层开辟空间、内核负责把所有发生的事件填充到该数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 初始化epoll就绪事件表 */</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建 epoll 实例 */</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 事件管理器与epoll关联 */</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* epoll_event 实例描述符*/</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="comment">/* 存储epoll就绪事件表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br></pre></td></tr></table></figure><h2 id="创建文件事件"><a href="#创建文件事件" class="headerlink" title="创建文件事件"></a>创建文件事件</h2><p><code>aeFileEvent</code>是文件事件结构，对于每一个具体的事件，都有读处理函数和写处理函数等。Redis 调用<code>aeCreateFileEvent</code>函数针对不同的套接字的读写事件注册对应的文件事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 监听事件类型掩码,值可以是 AE_READABLE 或 AE_WRITABLE */</span></span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="comment">/* 读事件处理器 */</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    <span class="comment">/* 写事件处理器 */</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="comment">/* 多路复用库的私有数据 */</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"><span class="comment">/* 使用typedef定义的处理器函数的函数类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">aeFileProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, </span></span><br><span class="line"><span class="params"><span class="type">int</span> fd, <span class="type">void</span> *clientData, <span class="type">int</span> mask)</span>;</span><br></pre></td></tr></table></figure><p>比如说，Redis 进行主从复制时，从服务器需要主服务器建立连接，它会发起一个 socekt连接，然后调用<code>aeCreateFileEvent</code>函数针对发起的socket的读写事件注册了对应的事件处理器，也就是syncWithMaster函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/* 符合aeFileProc的函数定义 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syncWithMaster</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;....&#125;</span><br></pre></td></tr></table></figure><p><code>aeCreateFileEvent</code>的参数fd指的是具体的socket套接字，proc指fd产生事件时，具体的处理函数，<code>clientData</code>则是回调处理函数时需要传入的数据。</p><p><code>aeCreateFileEvent</code>主要做了三件事情：</p><ul><li>以fd为索引，在events未就绪事件表中找到对应事件。</li><li>调用<code>aeApiAddEvent</code>函数，该事件注册到具体的底层 I/O 多路复用中，本例为epoll。</li><li>填充事件的回调、参数、事件类型等参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">                       aeFileProc *proc, <span class="type">void</span> *clientData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 取出 fd 对应的文件事件结构, fd 代表具体的 socket 套接字 */</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    <span class="comment">/* 监听指定 fd 的指定事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    <span class="comment">/* 置文件事件类型，以及事件的处理器 */</span></span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    <span class="comment">/* 私有数据 */</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上文所说，<strong>Redis 基于的底层 I/O 多路复用库有多套</strong>，所以<code>aeApiAddEvent</code>也有多套实现，下面的源码是epoll下的实现。其核心操作就是调用epoll的epoll_ctl函数来向epoll注册响应事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">/* 如果 fd 没有关联任何事件，那么这是一个 ADD 操作。如果已经关联了某个/某些事件，那么这是一个 MOD 操作。 */</span></span><br><span class="line">    <span class="type">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册事件到 epoll */</span></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">/* 调用epoll_ctl 系统调用，将事件加入epoll中 */</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>因为 Redis 中同时存在文件事件和时间事件两个事件类型，所以服务器必须对这两个事件进行调度，决定何时处理文件事件，何时处理时间事件，以及如何调度它们。</p><p><code>aeMain</code>函数以一个无限循环不断地调用<code>aeProcessEvents</code>函数来处理所有的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="comment">/* 如果有需要在事件处理前执行的函数，那么执行它 */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">/* 开始处理事件*/</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>aeProcessEvents</code>的伪代码，它会首先计算距离当前时间最近的时间事件，以此计算一个超时时间；然后调用<code>aeApiPoll</code>函数去等待底层的I/O多路复用事件就绪；<code>aeApiPoll</code>函数返回之后，会处理所有已经产生文件事件和已经达到的时间事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">/* 获取到达时间距离当前时间最接近的时间事件*/</span></span><br><span class="line">    time_event = aeSearchNearestTimer();</span><br><span class="line">    <span class="comment">/* 计算最接近的时间事件距离到达还有多少毫秒*/</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now();</span><br><span class="line">    <span class="comment">/* 如果事件已经到达，那么remaind_ms为负数，将其设置为0 */</span></span><br><span class="line">    <span class="keyword">if</span> (remaind_ms &lt; <span class="number">0</span>) remaind_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 根据 remaind_ms 的值，创建 timeval 结构*/</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms);</span><br><span class="line">    <span class="comment">/* 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 结构决定，如果remaind_ms 的值为0，则aeApiPoll 调用后立刻返回，不阻塞*/</span></span><br><span class="line">    <span class="comment">/* aeApiPoll调用epoll_wait函数，等待I/O事件*/</span></span><br><span class="line">    aeApiPoll(timeval);</span><br><span class="line">    <span class="comment">/* 处理所有已经产生的文件事件*/</span></span><br><span class="line">    processFileEvents();</span><br><span class="line">    <span class="comment">/* 处理所有已经到达的时间事件*/</span></span><br><span class="line">    processTimeEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>aeApiAddEvent</code>类似，<code>aeApiPoll</code>也有多套实现，它其实就做了两件事情，调用<code>epoll_wait</code>阻塞等待epoll的事件就绪，超时时间就是之前根据最快达到时间事件计算而来的超时时间；然后将就绪的epoll事件转换到fired就绪事件。<code>aeApiPoll</code>就是上文所说的I/O多路复用程序。具体过程如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-6.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="type">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 调用epoll_wait函数，等待时间为最近达到时间事件的时间计算而来。</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 有至少一个事件就绪？</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">/*为已就绪事件设置相应的模式，并加入到 eventLoop 的 fired 数组中*/</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> =</span> state-&gt;events+j;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN)</span><br><span class="line">        mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT)</span><br><span class="line">        mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) </span><br><span class="line">        mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP)</span><br><span class="line">        mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">/* 设置就绪事件表元素 */</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回已就绪事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processFileEvent是处理就绪文件事件的伪代码，也是上文所述的文件事件分派器，它其实就是遍历fired就绪事件表，然后根据对应的事件类型来调用事件中注册的不同处理器，读事件调用rfileProc，而写事件调用wfileProc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processFileEvent</span><span class="params">(<span class="type">int</span> numevents)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">/* 从已就绪数组中获取事件 */</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> fired = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line">            <span class="comment">/* 读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">/* 调用读处理函数 */</span></span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 写事件. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而processTimeEvents是处理时间事件的函数，它会遍历<code>aeEventLoop</code>的事件事件列表，如果时间事件到达就执行其timeProc函数，并根据函数的返回值是否等于AE_NOMORE来决定该时间事件是否是周期性事件，并修改器到达时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxId;</span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">    ....</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 遍历时间事件链表 */</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="type">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 删除需要删除的时间事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* id 大于最大maxId,是该循环周期生成的时间事件，不处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="comment">/* 事件已经到达，调用其timeProc函数*/</span></span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* 如果返回值不等于 AE_NOMORE,表示是一个周期性事件，修改其when_sec和when_ms属性*/</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 一次性事件，标记为需删除，下次遍历时会删除*/</span></span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><p>当不在需要某个事件时，需要把事件删除掉。例如: 如果fd同时监听读事件、写事件。当不在需要监听写事件时，可以把该fd的写事件删除。</p><p>aeDeleteEventLoop函数的执行过程总结为以下几个步骤</p><ul><li>根据fd在未就绪表中查找到事件</li><li>取消该fd对应的相应事件标识符</li><li>调用aeApiFree函数，内核会将epoll监听红黑树上的相应事件监听取消。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那我们通过 Redis 的事件机制能学到什么呢？</p><ol><li>这个事件机制的模型很通用也很清晰，包含：接收、循环、处理，三个部分，很标准的设计</li><li>其中对于任务的处理有一个专门的分配器去分配，这在很多 handler 的设计中非常实用，熟悉 java 的同学应该知道 DispatcherServlet 没错这样的模型会更加的清晰</li><li>易于扩展，这里的扩展有两方面一方面是对于处理器的扩展，之后有其他事件类型只需要增加事件处理器就可以了；而另一方面这里的扩展还包括了多线程的扩展，方便了同时支持多个事件的处理。<br>其实，Redis 的事件机制是一个标准的 <strong>Reactor模式</strong> 是一种基于事件驱动的设计模式，所以我们更多的是要学到这样设计模式，来运用到以后的编码中，可以更清晰也易扩展。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://betterprogramming.pub/internals-workings-of-redis-718f5871be84">https://betterprogramming.pub/internals-workings-of-redis-718f5871be84</a></li><li><a href="https://www.linkinstars.com/post/2b007902.html">https://www.linkinstars.com/post/2b007902.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对，没错，这又是一篇讲为什么 Redis 如此之快的文章。不过这次的内容于&lt;a href=&quot;https://zxh3032.github.io/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis消息队列：你的数据，随时待命</title>
    <link href="http://example.com/2024/06/11/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%9A%8F%E6%97%B6%E5%BE%85%E5%91%BD/"/>
    <id>http://example.com/2024/06/11/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%9A%8F%E6%97%B6%E5%BE%85%E5%91%BD/</id>
    <published>2024-06-11T15:07:23.000Z</published>
    <updated>2024-06-12T12:21:38.015Z</updated>
    
    <content type="html"><![CDATA[<p>现如今的互联网应用大多是采用分布式系统机构设计的，所以<strong>消息队列</strong>已经逐渐成为企业应用系统内部通信的核心手段，它具有<strong>低耦合、可靠投递、广播、流量控制、最终一致性</strong>等一系列功能。</p><p>当前使用较多的 消息队列 有 <code>RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ</code> 等，而部分数据库如 Redis、MySQL 以及 phxsql ，如果硬搞的话，其实也可实现消息队列的功能。</p><p>可能有人觉得，各种开源的 MQ 已经足够使用了，为什么需要用 Redis 实现 MQ 呢?</p><p>有些简单的业务场景，可能不需要重量级的 MQ 组件(相比 Redis 来说，Kafka 和 RabbitMQ 都算是重量级的消息队列)</p><p>那你有考虑过用 Redis 做消息队列吗?</p><p>这一章，我会结合消息队列的特点和 Redis 做消息队列的使用方式，以及实际项目中的使用，来探讨下 Redis 消息队列的方案。</p><h1 id="消息队列是什么？"><a href="#消息队列是什么？" class="headerlink" title="消息队列是什么？"></a>消息队列是什么？</h1><p>消息队列是指利用<strong>高效可靠</strong>的消息传递机制<strong>进行与平台无关</strong>的数据交流，并基于数据通信来进行分布式系统的集成。</p><p>通过提供<strong>消息传递</strong>和<strong>消息排队</strong>模型，它可以在<strong>分布式环境</strong>下提供 应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步 等等功能，其作为<strong>分布式系统架构</strong>中的一个重要组件，有着举足轻重的地位。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d215809a9e90cbfc765470545e496c35.jpg" alt="img"></p><p>现在回顾一下，我们使用的消息队列一般有什么样的特点：</p><ul><li>三个角色：生产者、消费者 和 消息处理中心。</li><li>异步处理模式：生产者将消息发送到一条虚拟的通道(消息队列)上，而无需等待响应。消费者则订阅或是监听该通道，取出消息。两者互不干扰，甚至都不用同时在线，也就是我们说的松耦合。</li><li>可靠性：消息要可以保证不丢失、不重复消费、有时可能还需要顺序性的保证。</li></ul><p>撇开我们常用的消息中间件不说， Redis 的哪些数据类型可以满足 MQ 的常规需求~~</p><h1 id="Redis-如何实现消息队列？"><a href="#Redis-如何实现消息队列？" class="headerlink" title="Redis 如何实现消息队列？"></a>Redis 如何实现消息队列？</h1><p>思来想去，也就只有 List 和 Stream 两种数据类型，可以实现消息队列的这些需求，当然，Redis 还提供了 发布/订阅(pub/sub) 模式。</p><p>下面我们一一来看。</p><h2 id="List-实现消息队列"><a href="#List-实现消息队列" class="headerlink" title="List 实现消息队列"></a>List 实现消息队列</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。</p><p>所以常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/50837e00-6f6b-11ea-8377-13f07d2f46fb" alt="list存取图.png"></p><p>List 使用命令的方式实现消息队列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mq &quot;hello&quot; #推送消息 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush mq &quot;msg&quot; #推送消息 msg</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 hello</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 msg</span><br><span class="line">&quot;mq&quot;</span><br></pre></td></tr></table></figure><p>其中，mq 就相当于频道名称 channel，而 lpush 用于生产消息， rpop 拉取消息。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>接下来我们用 Java 代码的方式来实现 List 形式的消息队列，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMQExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;mq&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收到了消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收到消息：Hello, List.</span><br></pre></td></tr></table></figure><p>我们使用无限循环来获取队列中的数据，这样就可以实时地获取相关信息了，但这样会带来另一个新的问题，当队列中如果没有数据的情况下，无限循环会一直消耗系统的资源，这时候我们可以使用 brpop 替代 rpop 来完美解决这个问题。</p><p>b 是 blocking 的缩写，表示<strong>阻塞读</strong>，也就是当队列没有数据时，它会进入休眠状态，当有数据进入队列之后，它才会“苏醒”过来执行读取任务，这样就可以解决 while 循环一直执行消耗系统资源的问题了，改良版代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMQExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 消费者 改良版</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; bConsumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 2.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 3.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者（阻塞版）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞读</span></span><br><span class="line">            <span class="keyword">for</span> (String item : jedis.brpop(<span class="number">0</span>,<span class="string">&quot;mq&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 读取到相关数据，进行业务处理</span></span><br><span class="line">                System.out.println(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，brpop() 方法的第一个参数是设置超时时间的，设置 0 表示一直阻塞。</p><h3 id="可靠队列模式-ack-机制"><a href="#可靠队列模式-ack-机制" class="headerlink" title="可靠队列模式 | ack 机制"></a><strong>可靠队列模式 | ack 机制</strong></h3><p>以上方式中， List 队列中的消息一经发送出去，便从队列里删除。如果由于网络原因消费者没有收到消息，或者消费者在处理这条消息的过程中崩溃了，就再也无法还原出这条消息。究其原因，就是缺少消息确认机制。</p><p>为了保证消息的可靠性，消息队列都会有完善的消息确认机制(Acknowledge)，即消费者向队列报告消息已收到或已处理的机制。</p><p>Redis List 怎么搞一搞呢?</p><p>有两个命令， RPOPLPUSH、BRPOPLPUSH (阻塞)从一个 list 中获取消息的同时把这条消息复制到另一个 list 里(可以当做备份)，而且这个过程是原子的。</p><p>这样我们就可以在业务流程安全结束后，再删除队列元素，实现消息确认机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myqueue one </span><br><span class="line">(integer) 1 </span><br><span class="line">127.0.0.1:6379&gt; rpush myqueue two </span><br><span class="line">(integer) 2 </span><br><span class="line">127.0.0.1:6379&gt; rpush myqueue three </span><br><span class="line">(integer) 3 </span><br><span class="line">127.0.0.1:6379&gt; rpoplpush myqueue queuebak </span><br><span class="line">&quot;three&quot; </span><br><span class="line">127.0.0.1:6379&gt; lrange myqueue 0 -1 </span><br><span class="line">1) &quot;one&quot; </span><br><span class="line">2) &quot;two&quot; </span><br><span class="line">127.0.0.1:6379&gt; lrange queuebak 0 -1 </span><br><span class="line">1) &quot;three&quot; </span><br><span class="line">1.2.3.4.5.6.7.8.9.10.11.12.13.</span><br></pre></td></tr></table></figure><p><a href="https://s2.51cto.com/oss/202101/12/ee1d7097728566b6c3782d9c26b6bbd0.jpg"><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ee1d7097728566b6c3782d9c26b6bbd0.jpg" alt="img"></a></p><p>之前做过的项目中就有用到这样的方式去处理数据，数据标识从一个 List 取出后放入另一个 List，业务操作安全执行完成后，再去删除 List 中的数据，如果有问题的话，很好回滚。</p><p>当然，还有更特殊的场景，可以通过 zset 来实现延时消息队列，原理就是将消息加到 zset 结构后，将要被消费的时间戳设置为对应的 score 即可，只要业务数据不会是重复数据就 OK。</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>List 优点：</p><ul><li>消息可以被持久化，借助 Redis 本身的持久化（AOF、RDB 或者是混合持久化），可以有效的保存数据；</li><li>消费者可以积压消息，不会因为客户端的消息过多而被强行断开。</li></ul><p>List 缺点：</p><ul><li>消息不能被重复消费，一个消息消费完就会被删除；</li><li>没有主题订阅的功能。</li></ul><p>ZSet 优点：</p><ul><li>支持消息持久化；</li><li>相比于 List 查询更方便，ZSet 可以利用 score 属性很方便的完成检索，而 List 则需要遍历整个元素才能检索到某个值。</li></ul><p>ZSet 缺点：</p><ul><li>ZSet 不能存储相同元素的值，也就是如果有消息是重复的，那么只能插入一条信息在有序集合中；</li><li>ZSet 是根据 score 值排序的，不能像 List 一样，按照插入顺序来排序；</li><li>ZSet 没有向 List 的 brpop 那样的阻塞弹出的功能。</li></ul><h2 id="订阅与发布实现消息队列"><a href="#订阅与发布实现消息队列" class="headerlink" title="订阅与发布实现消息队列"></a>订阅与发布实现消息队列</h2><p>我们都知道消息模型有两种</p><ul><li>点对点：Point-to-Point(P2P)</li><li>发布订阅：Publish/Subscribe(Pub/Sub)</li></ul><p>List 实现方式其实就是点对点的模式，下边我们再看下 Redis 的发布订阅模式(消息多播)，这才是“根正苗红”的 Redis MQ。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612194335222.png" alt="image-20240612194335222"></p><h3 id="普通订阅与发布"><a href="#普通订阅与发布" class="headerlink" title="普通订阅与发布"></a>普通订阅与发布</h3><p>消息队列有两个重要的角色，一个是发送者，另一个就是订阅者，对应的命令如下：</p><ul><li>发布消息：publish channel “message”</li><li>订阅消息：subscribe channel</li></ul><p>下面我们来看具体的命令实现。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612195223104.png" alt="image-20240612195223104"></p><p>上方订阅频道 channel，下方在频道 channel 中发布消息。</p><p>此命令支持订阅一个或多个频道的命令，也就是说一个订阅者可以订阅多个频道。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612195632980.png" alt="image-20240612195632980"></p><p><strong>订阅消息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel ...]</span><br></pre></td></tr></table></figure><p><strong>发送消息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure><p>最后的返回值表示成功发送给几个订阅方，1 表示成功发给了一个订阅者，这个数字可以是 0~n，这是由订阅者的数量决定的。</p><h3 id="主题订阅"><a href="#主题订阅" class="headerlink" title="主题订阅"></a>主题订阅</h3><p>上面介绍了普通的订阅与发布模式，但如果我要订阅某一个类型的消息就不适用了，例如我要订阅日志类的消息队列，它们的命名都是 logXXX，这个时候就需要使用 Redis 提供的另一个功能 Pattern Subscribe 主题订阅，这种方式可以使用 <code>*</code> 来匹配多个频道，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c071d520-6905-11ea-bfcb-156eb66fb883" alt="主题订阅2.png"></p><p>主题模式的具体实现代码如下，订阅者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe log_* #主题订阅 log_*</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_user&quot; #接收到频道 log_user 的消息推送</span><br><span class="line">4) &quot;user message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_sys&quot; #接收到频道 log_sys 的消息推送</span><br><span class="line">4) &quot;sys message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_db&quot; #接收到频道 log_db 的消息推送</span><br><span class="line">4) &quot;db message&quot;</span><br></pre></td></tr></table></figure><p>从上面的运行结果，可以看出使用命令 <code>psubscribe log_*</code> 可以接收到所有频道包含 log_XXX 的消息。</p><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psubscribe <span class="keyword">pattern</span> [<span class="keyword">pattern</span> ...]</span><br></pre></td></tr></table></figure><p>生产者的代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish log_user &quot;user message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_sys &quot;sys message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_db &quot;db message&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面我们使用 Jedis 实现普通的发布订阅模式和主题订阅的功能。</p><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a><strong>普通模式</strong></h4><p>消费者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 接收并处理消息</span></span><br><span class="line">    jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 推送消息</span></span><br><span class="line">    jedis.publish(<span class="string">&quot;channel&quot;</span>, <span class="string">&quot;Hello, channel.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布者和订阅者模式运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程作为消费者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure><h4 id="主题订阅模式"><a href="#主题订阅模式" class="headerlink" title="主题订阅模式"></a><strong>主题订阅模式</strong></h4><p>主题订阅模式的生产者的代码是一样，只有消费者的代码是不同的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    jedis.psubscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> &#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(pattern + <span class="string">&quot; 主题 | 频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题模式运行代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; pConsumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel* 主题 | 频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>发布订阅模式存在以下两个缺点：</p><ol><li>无法持久化保存消息，如果 Redis 服务器宕机或重启，那么所有的消息将会丢失；</li><li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li></ol><p>然而这些缺点在 Redis 5.0 添加了 Stream 类型之后会被彻底的解决。</p><p>除了以上缺点外，发布订阅模式还有另一个需要注意问题：当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</p><h3 id="Pub-Sub-常用命令："><a href="#Pub-Sub-常用命令：" class="headerlink" title="Pub/Sub 常用命令："></a>Pub/Sub 常用命令：</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">PSUBSCRIBE</td><td style="text-align:left">PSUBSCRIBE pattern [pattern …]</td><td style="text-align:left">订阅一个或多个符合给定模式的频道</td></tr><tr><td style="text-align:left">PUBSUB</td><td style="text-align:left">PUBSUB subcommand [argument [argument …]]</td><td style="text-align:left">查看订阅与发布系统状态</td></tr><tr><td style="text-align:left">PUBLISH</td><td style="text-align:left">PUBLISH channel message</td><td style="text-align:left">将信息发送到指定的频道</td></tr><tr><td style="text-align:left">PUNSUBSCRIBE</td><td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]</td><td style="text-align:left">退订所有给定模式的频道</td></tr><tr><td style="text-align:left">SUBSCRIBE</td><td style="text-align:left">SUBSCRIBE channel [channel …]</td><td style="text-align:left">订阅给定的一个或多个频道的信息</td></tr><tr><td style="text-align:left">UNSUBSCRIBE</td><td style="text-align:left">UNSUBSCRIBE [channel [channel …]]</td><td style="text-align:left">指退订给定的频道</td></tr></tbody></table></div><h2 id="Stream-实现消息队列"><a href="#Stream-实现消息队列" class="headerlink" title="Stream 实现消息队列"></a>Stream 实现消息队列</h2><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式 PubSub，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>列表实现消息队列的方式不能重复消费，一个消息消费完就会被删除；</li><li>有序集合消息队列的实现方式不能存储相同 value 的消息，并且不能阻塞读取消息。</li></ul><p>并且以上三种方式在实现消息队列时，只能存储单 value 值，也就是如果你要存储一个对象的情况下，必须先序列化成 JSON 字符串，在读取之后还要反序列化成对象才行，这也给用户的使用带来的不便，基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它借鉴了 Kafka 的设计思路，它支持消息的持久化和消息轨迹的消费，支持 ack 确认消息的模式，让消息队列更加的稳定和可靠。</p><p>接下来我们先来了解 Stream 自身的一些特性，然后在综合 Stream 的特性，结合 Java 代码完整的实现一个完美的消息队列示例。</p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>Stream 既然是一个数据类型，那么和其他数据类型相似，它也有一些自己的操作方法，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述</th><th style="text-align:left">用法</th></tr></thead><tbody><tr><td style="text-align:left">添加消息到末尾，保证有序，可以自动生成唯一ID</td><td style="text-align:left">XADD key ID field value [field value …]</td></tr><tr><td style="text-align:left">对流进行修剪，限制长度</td><td style="text-align:left">XTRIM key MAXLEN [~] count</td></tr><tr><td style="text-align:left">删除消息</td><td style="text-align:left">XDEL key ID [ID …]</td></tr><tr><td style="text-align:left">获取流包含的元素数量，即消息长度</td><td style="text-align:left">XLEN key</td></tr><tr><td style="text-align:left">获取消息列表，会自动过滤已经删除的消息</td><td style="text-align:left">XRANGE key start end [COUNT count]</td></tr><tr><td style="text-align:left">以阻塞或非阻塞方式获取消息列表</td><td style="text-align:left">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id [id …]</td></tr><tr><td style="text-align:left">创建消费者组</td><td style="text-align:left">XGROUP [CREATE key groupname id-or-] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</td></tr><tr><td style="text-align:left">读取消费者组中的消息</td><td style="text-align:left">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key …] ID [ID …]</td></tr><tr><td style="text-align:left">将消息标记为”已处理”</td><td style="text-align:left">XACK key group ID [ID …]</td></tr><tr><td style="text-align:left">为消费者组设置新的最后递送消息ID</td><td style="text-align:left">XGROUP SETID [CREATE key groupname id-or-] [DESTROY key groupname]</td></tr><tr><td style="text-align:left">删除消费者</td><td style="text-align:left">XGROUP DELCONSUMER [CREATE key groupname id-or-] [DESTROY key groupname]</td></tr><tr><td style="text-align:left">删除消费者组</td><td style="text-align:left">XGROUP DESTROY [CREATE key groupname id-or-] [DESTROY key groupname] [DEL</td></tr><tr><td style="text-align:left">显示待处理消息的相关信息</td><td style="text-align:left">XPENDING key group [start end count] [consumer]</td></tr><tr><td style="text-align:left">查看流和消费者组的相关信息</td><td style="text-align:left">XINFO [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]</td></tr><tr><td style="text-align:left">打印流信息</td><td style="text-align:left">XINFO STREAM [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]</td></tr></tbody></table></div><p>具体使用如下所述。</p><h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a><strong>添加消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis age 10</span><br><span class="line">&quot;1580880750844-0&quot; #结果返回的是消息 id</span><br></pre></td></tr></table></figure><p>其中 <code>*</code> 表示使用 Redis 的规则：时间戳 + 序号的方式自动生成 ID，用户也可以自己指定 ID。</p><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xadd <span class="keyword">key</span> ID field <span class="type">string</span> [field <span class="type">string</span> ...]</span><br></pre></td></tr></table></figure><h4 id="查询消息的长度"><a href="#查询消息的长度" class="headerlink" title="查询消息的长度"></a><strong>查询消息的长度</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlen <span class="keyword">key</span></span><br></pre></td></tr></table></figure><h4 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a><strong>删除消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis</span><br><span class="line">&quot;1580881585129-0&quot; #消息 ID</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xdel key 1580881585129-0 #删除消息，根据 ID</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdel key ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持删除一条或多条消息，根据消息 ID。</p><h4 id="删除整个-Stream"><a href="#删除整个-Stream" class="headerlink" title="删除整个 Stream"></a><strong>删除整个 Stream</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key #删除整个 Stream</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">del</span> key <span class="selector-attr">[key ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个 Stream。</p><h4 id="查询区间消息"><a href="#查询区间消息" class="headerlink" title="查询区间消息"></a><strong>查询区间消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xrange mq - +</span><br><span class="line">1) 1) &quot;1580882060464-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;redis&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;10&quot;</span><br><span class="line">2) 1) &quot;1580882071524-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;java&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>其中：<code>-</code> 表示第一条消息，<code>+</code> 表示最后一条消息。</p><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xrange key <span class="keyword">start</span> <span class="keyword">end</span> [COUNT count]</span><br></pre></td></tr></table></figure><h4 id="查询某个消息之后的消息"><a href="#查询某个消息之后的消息" class="headerlink" title="查询某个消息之后的消息"></a><strong>查询某个消息之后的消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 streams mq 1580882060464-0</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580882071524-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;java&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>在名称为 mq 的 Stream 中，从消息 ID 为 1580882060464-0 的，往后查询一条消息。</p><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xread <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[BLOCK milliseconds]</span> STREAMS key <span class="selector-attr">[key ...]</span> ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure><p>此命令提供了阻塞读的参数 block，我们可以使用它读取从当前数据以后新增数据，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br></pre></td></tr></table></figure><p>其中 <code>block 0</code> 表示一直阻塞，<code>$</code> 表示从最后开始读取，这个时候新开一个命令行插入一条数据，此命令展示的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mq * name sql age 20 #新窗口添加数据</span><br><span class="line">&quot;1580890737890-0&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞读取到的新数据</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580890737890-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;sql&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">(36.37s)</span><br></pre></td></tr></table></figure><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 Stream 消费分组实现消息队列的功能和列表方式的消息队列比较相似，使用 xadd 命令和 xread 循环读取就可以实现基础版的消息队列，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id</span> <span class="operator">=</span> jedis.xadd(<span class="string">&quot;mq&quot;</span>, <span class="literal">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，new StreamEntryID().LAST_ENTRY 标识获取当前时间以后的新增消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(<span class="string">&quot;mq&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().LAST_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xread(<span class="number">1</span>, <span class="number">120</span> * <span class="number">1000</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID());</span><br><span class="line">                <span class="comment">// 使用 Gson 来打印 JSON 格式的消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息添加成功 ID：1580895735148-0</span><br><span class="line">读取到消息 ID：1580895735148-0</span><br><span class="line">内容：&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;10&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>以上代码需要特殊说明的是，我们使用 <code>new StreamEntryID().LAST_ENTRY</code> 来实现读取当前时间以后新增的消息，如果要从头读取历史消息把这行代码中的 <code>.LAST_ENTRY</code> 去掉即可。</p><p>还有一点需要注意，在 Jedis 框架中如果使用 jedis.xread() 方法来阻塞读取消息队列，第二个参数 long block 必须设置大于 0，如果设置小于 0，此阻塞条件就无效了，我查看了 jedis 的源码发现，它只有判断在大于 0 的时候才会设置阻塞属性，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    params[streamsIndex++] = Keyword.BLOCK.raw;</span><br><span class="line">    params[streamsIndex++] = Protocol.toByteArray(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 block 属性我们可以设置一个比较大的值来阻塞读取消息。</p><blockquote><p>所谓的阻塞读取消息指的是当队列中没有数据时会进入休眠模式，等有数据之后才会唤醒继续执行。</p></blockquote><h3 id="消息分组"><a href="#消息分组" class="headerlink" title="消息分组"></a>消息分组</h3><p><strong>创建消费者组</strong></p><p>xread 虽然可以扇形分发到 N 个客户端，然而，在某些问题中，我们想要做的不是向许多客户端提供相同的消息流，而是从同一流向许多客户端提供不同的消息子集。比如下图这样，三个消费者按轮训的方式去消费一个 Stream。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8bf0522cc8145d9a177b74c1f99716ae.jpg" alt="img"></p><p>前面我们也提到过，Redis Stream 借鉴了很多 Kafka 的设计。</p><ul><li>Consumer Group：有了消费组的概念，每个消费组状态独立，互不影响，一个消费组可以有多个消费者</li><li>last_delivered_id ：每个消费组会有个游标 last_delivered_id 在数组之上往前移动，表示当前消费组已经消费到哪条消息了</li><li>pending_ids ：消费者的状态变量，作用是维护消费者的未确认的 id。pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack。如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack，它就开始减少。这个 pending_ids 变量在 Redis 官方被称之为 PEL，也就是 Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612200916341.png" alt="image-20240612200916341"></p><p>Stream 不像 Kafak 那样有分区的概念，如果想实现类似分区的功能，就要在客户端使用一定的策略将消息写到不同的 Stream。</p><ul><li>xgroup create：创建消费者组</li><li>xgreadgroup：读取消费组中的消息</li><li>xack：ack 掉指定消息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息，也可以自己指定</span> </span><br><span class="line">127.0.0.1:6379&gt; xgroup create mystream mygroup $ </span><br><span class="line">OK </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 查看流和消费者组的相关信息，可以查看流、也可以单独查看流下的某个组的信息</span> </span><br><span class="line">127.0.0.1:6379&gt; xinfo stream mystream </span><br><span class="line"> 1) &quot;length&quot; </span><br><span class="line"> 2) (integer) 4  # 共 4 个消息 </span><br><span class="line"> 3) &quot;radix-tree-keys&quot; </span><br><span class="line"> 4) (integer) 1 </span><br><span class="line"> 5) &quot;radix-tree-nodes&quot; </span><br><span class="line"> 6) (integer) 2 </span><br><span class="line"> 7) &quot;last-generated-id&quot; </span><br><span class="line"> 8) &quot;1609408943089-0&quot; </span><br><span class="line"> 9) &quot;groups&quot; </span><br><span class="line">10) (integer) 1  # 一个消费组 </span><br><span class="line">11) &quot;first-entry&quot; # 第一个消息 </span><br><span class="line">12) 1) &quot;1609405178536-0&quot; </span><br><span class="line">    2) 1) &quot;f5&quot; </span><br><span class="line">       2) &quot;v5&quot; </span><br><span class="line">13) &quot;last-entry&quot;  # 最后一个消息 </span><br><span class="line">14) 1) &quot;1609408943089-0&quot; </span><br><span class="line">    2) 1) &quot;f6&quot; </span><br><span class="line">       2) &quot;v6&quot; </span><br><span class="line">127.0.0.1:6379&gt;  </span><br></pre></td></tr></table></figure><p><strong>按消费组消费</strong></p><p>Stream 提供了 xreadgroup 指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息 ID。它同 xread 一样，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 PEL(正在处理的消息) 结构里，客户端处理完毕后使用 xack 指令通知服务器，本条消息已经处理完毕，该消息 ID 就会从 PEL 中移除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#  消费组 mygroup1 中的 消费者 c1 从 mystream 中 消费组数据 </span><br><span class="line"># &gt; 号表示从当前消费组的 last_delivered_id 后面开始读 </span><br><span class="line"># 每当消费者读取一条消息，last_delivered_id 变量就会前进 </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c1 count 1 streams mystream &gt; </span><br><span class="line">1) 1) &quot;mystream&quot; </span><br><span class="line">   2) 1) 1) &quot;1609727806627-0&quot; </span><br><span class="line">         2) 1) &quot;f1&quot; </span><br><span class="line">            2) &quot;v1&quot; </span><br><span class="line">            3) &quot;f2&quot; </span><br><span class="line">            4) &quot;v2&quot; </span><br><span class="line">            5) &quot;f3&quot; </span><br><span class="line">            6) &quot;v3&quot; </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c1 count 1 streams mystream &gt; </span><br><span class="line">1) 1) &quot;mystream&quot; </span><br><span class="line">   2) 1) 1) &quot;1609727818650-0&quot; </span><br><span class="line">         2) 1) &quot;f4&quot; </span><br><span class="line">            2) &quot;v4&quot; </span><br><span class="line"># 已经没有消息可读了             </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c1 count 2 streams mystream &gt; </span><br><span class="line">(nil) </span><br><span class="line"> </span><br><span class="line"># 还可以阻塞式的消费 </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c2 block 0 streams mystream &gt; </span><br><span class="line">µ1) 1) &quot;mystream&quot; </span><br><span class="line">   2) 1) 1) &quot;1609728270632-0&quot; </span><br><span class="line">         2) 1) &quot;f5&quot; </span><br><span class="line">            2) &quot;v5&quot; </span><br><span class="line">(89.36s) </span><br><span class="line"> </span><br><span class="line"># 观察消费组信息 </span><br><span class="line">127.0.0.1:6379&gt; xinfo groups mystream </span><br><span class="line">1) 1) &quot;name&quot; </span><br><span class="line">   2) &quot;mygroup1&quot; </span><br><span class="line">   3) &quot;consumers&quot; </span><br><span class="line">   4) (integer) 2  # 2个消费者 </span><br><span class="line">   5) &quot;pending&quot; </span><br><span class="line">   6) (integer) 3   # 共 3 条正在处理的信息还没有 ack </span><br><span class="line">   7) &quot;last-delivered-id&quot; </span><br><span class="line">   8) &quot;1609728270632-0&quot; </span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; xack mystream mygroup1 1609727806627-0  # ack掉指定消息 </span><br><span class="line">(integer) 1 </span><br></pre></td></tr></table></figure><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamGroupExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq&quot;</span>; <span class="comment">// 流 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;g1&quot;</span>; <span class="comment">// 分组名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_CONSUMER_NAME</span> <span class="operator">=</span> <span class="string">&quot;c1&quot;</span>; <span class="comment">// 消费者 1 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_CONSUMER2_NAME</span> <span class="operator">=</span> <span class="string">&quot;c2&quot;</span>; <span class="comment">// 消费者 2 的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">        <span class="comment">// 创建消费组</span></span><br><span class="line">        createGroup(_STREAM_KEY, _GROUP_NAME);</span><br><span class="line">        <span class="comment">// 消费者 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 消费者 2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer2()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建消费分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stream    流 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 分组名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createGroup</span><span class="params">(String stream, String groupName)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        jedis.xgroupCreate(stream, groupName, <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 添加消息 1</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id</span> <span class="operator">=</span> jedis.xadd(_STREAM_KEY, <span class="literal">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">        <span class="comment">// 添加消息 2</span></span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id2</span> <span class="operator">=</span> jedis.xadd(_STREAM_KEY, <span class="literal">null</span>, map2);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="literal">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 1 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER2_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="literal">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 2 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息添加成功 ID：1580971482344-0</span><br><span class="line">消息添加成功 ID：1580971482415-0</span><br><span class="line">Consumer 1 读取到消息 ID：1580971482344-0 内容：&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;redis&quot;</span>&#125;</span><br><span class="line">Consumer 2 读取到消息 ID：1580971482415-0 内容：&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;java&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经对 Stream 实现消息队列有了基本的了解，由于笔者的 redis 版本较低，还不支持 Stream，所以对本小节的理解仅限于阅读层面，并未实际测试。</p><p>个人感觉，目前 Stream还是不能当作主流的 MQ 去使用，使用案例较少，所以仅限于学习一下就好了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节不想其他 Redis 学习是的内容，最重要的东西在我的电脑里面不能运行，所以都是看别人文章来学习的，好在Redis做消息队列并不会经常使用，也不是主流，仅限了解就好。</p><p>在业务上要避免过度复用一个 Redis。既用它做缓存、做计算，还拿它做消息队列，这样的话 Redis 会很累的。</p><p>今天又是在学习 Java 路上的一天，在深入学习 Java 之后，我的眼界好像一下子就被打开了，之前一直觉得在用 Go 写代码时只需要用 <code>go get ……</code> 就可以得到想要的工具包，还嫌弃Java麻烦。有了 Maven 也可以实现类似的效果，加上 Java 的各种工具包十分充足，会有更好的开发体验。</p><p>Java是世界上最好的开发语言.go</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.51cto.com/article/640335.html">https://www.51cto.com/article/640335.html</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/24%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e2%80%94%e2%80%94%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/24%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e2%80%94%e2%80%94%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/25%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%85%b6%e4%bb%96%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/25%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%85%b6%e4%bb%96%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/26%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8a%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/26%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8a%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/27%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8b%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/27%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8b%ef%bc%89.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现如今的互联网应用大多是采用分布式系统机构设计的，所以&lt;strong&gt;消息队列&lt;/strong&gt;已经逐渐成为企业应用系统内部通信的核心手段，它具有&lt;strong&gt;低耦合、可靠投递、广播、流量控制、最终一致性&lt;/strong&gt;等一系列功能。&lt;/p&gt;
&lt;p&gt;当前使用较多的 消息</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文——基础篇（一）</title>
    <link href="http://example.com/2024/06/11/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2024/06/11/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-06-11T11:43:48.000Z</published>
    <updated>2024-06-12T13:53:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>从开始学习 Java 已经有一个多月了，但实际的学习时长应该也就不到一周，刚开始心血来潮苦学两天，发现单是基础内容就多如牛毛，相比于 Go 的简单语法，实在是太过复杂。</p><p>好在不是为了应付考试，所以就先了解了大概的语法内容，后续通过项目和算法题来熟练巩固知识。</p><p>关于八股文，这应该是 Java 最好找的学习资料了，但凡是与其他具体内容有关的知识基本都是收费的，感觉不如 Go (bushi)。今天就先记录一部分已经学过的知识吧，以免后面忘记了。</p><h1 id="基础概念和常识"><a href="#基础概念和常识" class="headerlink" title="基础概念和常识"></a>基础概念和常识</h1><p>本节学习 Java 的语言特性内容。</p><h2 id="Java-的语言特性"><a href="#Java-的语言特性" class="headerlink" title="Java 的语言特性"></a>Java 的语言特性</h2><p>Java 有很多优秀的特点，以下是几个比较突出的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-2.png" alt="Java语言特点"></p><ol><li>面型对象：封装、继承、多态。</li><li>平台无关性： Java 虚拟机实现平台无关性。</li><li>支持多线程：C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；</li><li>支持 JIT 编译：JIT 是 Just-In-Time 的缩写，指的是即时编译器，它可以在程序运行时将字节码转换为本地机器码来提高程序运行速度。</li></ol><p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天依然有很多人觉得跨平台是 Java 最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p><h2 id="JVM、JDK-和-JRE"><a href="#JVM、JDK-和-JRE" class="headerlink" title="JVM、JDK 和 JRE"></a>JVM、JDK 和 JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节吗的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言<code>“一次编译，随处可以运行”</code>的关键所在。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言"></p><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><hr><p>也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/jdk-include-jre.png" alt="JDK 包含 JRE"></p><p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ <a href="http://openjdk.java.net/jeps/282">jlinkopen in new window</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。</p><p>在 <a href="https://javaguide.cn/java/new-features/java9.html">Java 9 新特性概览open in new window</a>这篇文章中：</p><blockquote><p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p></blockquote><p>也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的 JRE。</p><p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的。</p><h2 id="什么是字节码？字节码的好处是什么？"><a href="#什么是字节码？字节码的好处是什么？" class="headerlink" title="什么是字节码？字节码的好处是什么？"></a>什么是字节码？字节码的好处是什么？</h2><p>所谓的字节码，就是 Java 程序经过编译之类产生的 <code>.class</code> 文件，字节码不面向任何特定的处理器，只面向虚拟机，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-4.png" alt="Java程序执行过程"></p><p>只需要把 Java 程序编译成 Java 虚拟机能识别的 Java 字节码，不同的平台安装对应的 Java 虚拟机，这样就可以可以实现 Java 语言的平台无关性。</p><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p><blockquote><p>HotSpot（热点代码） 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p></blockquote><p>下面这张图是 JVM 的大致结构模型。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/jvm-rough-structure-model.png" alt="JVM 的大致结构模型"></p><h2 id="“编译与解释并存”？"><a href="#“编译与解释并存”？" class="headerlink" title="“编译与解释并存”？"></a>“编译与解释并存”？</h2><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。</p><p>简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/compiled-and-interpreted-languages.png" alt="编译型语言和解释型语言"></p><p>比如，你想读一本外国的小说，你可以找一个翻译人员帮助你翻译，有两种选择方式，你可以先等翻译人员将全本的小说（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须再经过 JVM 解释成操作系统能识别的机器码，再由操作系统执行。因此，我们可以认为 Java 语言<strong>编译</strong>与<strong>解释</strong>并存。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240611202213215.png" alt="image-20240611202213215"></p><h2 id="AOT是什么？AOT有什么优点？为什么不全部使用AOT？"><a href="#AOT是什么？AOT有什么优点？为什么不全部使用AOT？" class="headerlink" title="AOT是什么？AOT有什么优点？为什么不全部使用AOT？"></a>AOT是什么？AOT有什么优点？为什么不全部使用AOT？</h2><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p><strong>JIT 与 AOT 两者的关键指标对比</strong>:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/jit-vs-aot.png" alt="JIT vs AOT">JIT vs AOT</p><p>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>提到 AOT 就不得不提 <a href="https://www.graalvm.org/">GraalVMopen in new window</a> 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。</p><p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><p>本节记录 Java 中一些基础数据类型相关的问题。</p><h2 id="什么是自动拆箱-装箱？"><a href="#什么是自动拆箱-装箱？" class="headerlink" title="什么是自动拆箱/装箱？"></a>什么是自动拆箱/装箱？</h2><ul><li><strong>装箱</strong>：将基本数据类型转换为包装类型（Byte、Short、Integer、Long、Float、Double、Character、Boolean）。</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-8.png" alt="三分恶面渣逆袭:装箱和拆箱">三分恶面渣逆袭:装箱和拆箱</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>上面这两行代码对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h2 id="为什么有了基本类型还要设计包装类型？"><a href="#为什么有了基本类型还要设计包装类型？" class="headerlink" title="为什么有了基本类型还要设计包装类型？"></a>为什么有了基本类型还要设计包装类型？</h2><blockquote><p>Java 一共设计了八种基础类型，每一种基础类型都会对应着唯一的包装类，为什么要这样设计，不是多此一举吗？</p></blockquote><p>在 Java 里面，之所以要对基础类型设计一个对应的封装类型，是因为 Java 本身是一门面向对象的语言，对象是 Java 的基础操作单元，我们时时刻刻都在创建对象，也随时都在使用对象，很多时候传递数据也需要对象，不如 <code>ArrayList、HashMap</code> 这些集合，只能存储对象类型，因此封装类型存在的意义还是很大的。</p><p>此外，封装类型还有很多好处，如安全性好，可以避免外部操作随意修改成员变量的值，保证了成员变量和数据传递的安全性；隐藏了实现细节，对使用者更加友好，只需要调用对象提供的方法就可以完成对应的操作</p><p>在定义基础数据类型时，我们可以直接定义一个变量名并赋值；但是包装类型需要使用 <code>new</code> 关键字创建对象基本类型。当两种类型混合使用时，Java 会自动通过拆箱和封箱实现类型转换。</p><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p> 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><h2 id="包装类型的缓存机制（享元模式）"><a href="#包装类型的缓存机制（享元模式）" class="headerlink" title="包装类型的缓存机制（享元模式）"></a>包装类型的缓存机制（享元模式）</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><hr><p>正是由于这个特性，衍生出另外一个经典的面试题。</p><h3 id="为什么-1000-1000为-false，100-100为true？"><a href="#为什么-1000-1000为-false，100-100为true？" class="headerlink" title="为什么 1000==1000为 false，100==100为true？"></a>为什么 <code>1000==1000</code>为 false，<code>100==100</code>为true？</h3><p>还记得 integer 的缓存范围吗？[-128, 127]，而 1000 超过了它的缓存范围，则会重新创建一个新的对象。而 <code>==</code> 比较的又是两个标识符引用的对象是否相同，所以才会出现这么一个看起来没问题的问题。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>本节记录有关变量的问题。</p><h2 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h2><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p><p><strong>为什么成员变量有默认值？</strong></p><ol><li>先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</li><li>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</li><li>对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。</li></ol><h2 id="静态变量有什么用？"><a href="#静态变量有什么用？" class="headerlink" title="静态变量有什么用？"></a>静态变量有什么用？</h2><p>静态变量也就是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p><p>静态变量是通过类名来访问的，例如<code>StaticVariableExample.staticVar</code>（如果被 <code>private</code>关键字修饰就无法这样访问了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h2><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>《Java 核心技术》这本书是这样介绍重载的：</p><blockquote><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>Java 允许重载任何方法， 而不只是构造器方法。</p></blockquote><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><div class="table-container"><table><thead><tr><th><strong>区别点</strong></th><th><strong>重载</strong></th><th><strong>重写</strong></th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table></div><p><strong>方法的重写要遵循“两同两小一大”</strong></p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超人&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Hero <span class="title function_">hero</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SuperMan <span class="title function_">hero</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面就简单写了一些在初学 Java 时了解到的一些八股文的内容，当然这只是非常皮毛的一部分。重要内容还是要到面向对象开始之后才行，慢慢来吧。</p><p>汇报一下现在的学习进度，现在开始跟着黑马的视频基本了解一下 Java 开发时会用到的框架，像 JavaWeb、Spring Boot、Mybatis等等，不得不说，想要从头学一个东西确实很难，光是配置环境我就被整的焦头烂额。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从开始学习 Java 已经有一个多月了，但实际的学习时长应该也就不到一周，刚开始心血来潮苦学两天，发现单是基础内容就多如牛毛，相比于 Go 的简单语法，实在是太过复杂。&lt;/p&gt;
&lt;p&gt;好在不是为了应付考试，所以就先了解了大概的语法内容，后续通过项目和算法题来熟练巩固知识。&lt;</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Why Java? Why not Java?</title>
    <link href="http://example.com/2024/06/10/Why%20Java%20Why%20not%20Java/"/>
    <id>http://example.com/2024/06/10/Why%20Java%20Why%20not%20Java/</id>
    <published>2024-06-10T08:57:14.000Z</published>
    <updated>2024-06-10T12:42:36.417Z</updated>
    
    <content type="html"><![CDATA[<p>对的，没错，这是一篇记录笔者从零开始学习 Java 的博客，后面还会有更多关于 Java 的博客被记录。</p><p>关于 Java 学习过程中的那些基础知识，在这里就不过多的去介绍了，没什么意义，更多还是去聊一下面向对象或者一些新奇的东西。</p><p>既然是开篇之作，还是多写一点轻松的内容，其实就是还没有总结完。所以文本就简单写一下我对 Java 的认识吧。</p><h1 id="我与-Java"><a href="#我与-Java" class="headerlink" title="我与 Java"></a>我与 Java</h1><p>关于 Java，应该是除了 C++ 之外我最先了解到的编程语言了，其实在大一上没结束的时候我就已经开始准备选择一个语言进行学习，为以后找工作打算了。</p><p>大一的我提起 Java，觉得不够有趣，选择 Python；大二的我提起 Java，嗤之以鼻，想着学了它，那我和大专的学生有什么区别；大三的我提起 Java，想到被 Go 语言的实习打击的惨样，悲从中来，后悔没有早点学。呜呜呜……</p><p>就像这个系列里的分类一样，我对 Java 的态度从”Java？狗都不学“ 到 ”Java！！！世界上最好的语言“。很抽象，但没办法。</p><hr><p>不知道你有没有想过，世界上有那么多编程语言，每种语言都有自己的特性，为什么 Java 能如此流行，在各行各业都被广泛使用，兴趣才是学习的第一动力，所以还是应该先了解一下 Java 的历史和设计哲学。</p><h1 id="Java-的诞生"><a href="#Java-的诞生" class="headerlink" title="Java 的诞生"></a>Java 的诞生</h1><p>计算机业内一般认为：B 语言导致了 C 语言的诞生，C 语言演变出了 C++，而 C++ 会被 Java 语言所打败。是什么导致了 Java 的诞生？想要解决这个问题，我们先来看看 Java 的前辈们。</p><h2 id="C-语言的诞生"><a href="#C-语言的诞生" class="headerlink" title="C 语言的诞生"></a>C 语言的诞生</h2><p>C 语言的产生是人们追求结构化、高效率、高级语言的结果，它可以替代汇编进行开发，它的出现改变了人们之前的编程方法和思路。</p><p>C 语言的出现解决了之前语言的各种不足，比如：FORTRAN 高效但不适用于编写系统程序。BASIC 虽然容易学习，但是功能不够强大。汇编高效，但是学习成本很大，且很难调试。</p><p>另外，C 语言之前的语言没有考虑结构化设计。它们大量使用 <code>GOTO</code> 语句来对程序进行控制。这样做的结果是<strong>程序极其混乱</strong>，各种跳转和条件分支交织在一起极大地影响了程序的可读性。人们解决该问题的愿望非常强烈，且日益迫切。20世界70年代初，计算机革命开始，人们对于软件的需求日益增加，使用当时的语言开发软件已经无法满足需求。人们在此期间进行了很多的尝试，但是没有发明出更好的语言。直到一个新机遇的到来：<strong>计算机硬件资源的富余</strong>。由于计算机硬件的增多，程序员可以随意的使用计算机，随意进行各种尝试，这就给了他们开发自己工具的机会。后来Ken Thompson (同样是 Go 语言之父) 发明了 B 语言，B 语言演化到了 C 语言。1989年美国国家标准化组织制定了 C 语言的标准，C 语言被正式标准化。C 语言是由程序员对编程实践的总结而发明出来的，它能够解决早期语言的种种缺陷。</p><h2 id="C-的诞生"><a href="#C-的诞生" class="headerlink" title="C++ 的诞生"></a>C++ 的诞生</h2><p>C语言被用的好好的，为何出现了C++呢？原因是C语言太复杂了。当一个工程项目达到一定规模之后，使用结构化编程方法，编程人员就无法对它的复杂性进行有效管理。20世纪80年代初期，许多工程项目的复杂性都超过了结构化方法的极限。为了解决这个问题，面向对象诞生了。<strong>面向对象的特性：继承，封装，多态</strong>是用来帮助组织复杂程序的编程方法。因此出现了C++，C++ 的产生是基于 C 的，它包含了 C 的所有特征，属性和优点。</p><h2 id="Java出现的时机到了"><a href="#Java出现的时机到了" class="headerlink" title="Java出现的时机到了"></a>Java出现的时机到了</h2><p>在20世纪80年代末到90年代初，使用面向对象的 C++ 语言占主导地位。然而，推动计算机语言进化的力量正在酝酿。万维网（WWW）和Internet在随后的几年达到了临界状态，这就促成了编程的另一场革命。</p><h3 id="Java-诞生"><a href="#Java-诞生" class="headerlink" title="Java 诞生"></a>Java 诞生</h3><p>由于嵌入式系统的发展，人们对一种独立于平台的语言更加渴望，这种语言可以嵌入微波炉，遥控器等各种家用电器设备的软件。用作控制器芯片的CPU是多种多样的，但是C和C++只能对特定目标进行编译。比如某个CPU要编译C++代码，那么就要创建一个针对该CPU的C++编译器，而创建编译器是一项耗时耗长，耗资大的工作。为了解决这个问题，Gosling和其他人一直在开发一种可移植，跨平台的语言。该语言能够生成运行于不同环境，不同CPU芯片上的代码。经过不懈的努力，在1991年被James Gosling，Patrick Naughton，Chris Warth，Ed Frank和Mike Sheridan发明出来。第一版花了18个月。刚开始叫 Oak，于1995年更名为 Java。</p><blockquote><p>有趣的知识：JAVA其实是印度尼西亚一座岛屿的名称，中文名也叫爪哇，因盛产咖啡而出名。据说许多程序设计师工作之余都喜欢来一杯热腾腾的香浓咖啡，，并从中得到灵感，JAVA的寓意是为世人端上一杯热咖啡，因此JAVA的logo就是一个热气腾腾的咖啡形状。</p><p>  Oak正是由JAVA之父James Gosling领导的绿色计划(Green Project)中的产品，在1995年更名为JAVA，并在SunWord大会上正式提出了”Write Once，Run Anywhere”口号。<strong>岁月如流，转眼间距离第一个JAVA版本诞生到现在已经20多年的时间，通过下面的时间线，一起回顾那些年我们学习过的JAVA。</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d30e34758a114691af5f058489b158df%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211129234040459"></p><h3 id="Java-流行"><a href="#Java-流行" class="headerlink" title="Java 流行"></a>Java 流行</h3><p>在万维网（WWW）出现之前Java处于有用、默默无闻的用于电子消费品编程的状态。然而由于万维网的出现，Java被推到了计算机语言的设计的最前沿，<strong>因为万维网也需要可移植的程序。</strong></p><p>因特网是由不同的、分布式的系统组成，其中包含各种类型的计算机，操作系统和CPU。尽管许多类型的平台都可以与因特网连接，但是用户仍然希望他们能够运行同样的程序。</p><p>1993年，Java设计小组的成员发现解决嵌入式控制器可移植性的方法，也可以用来解决因特网的代码的可移植性问题。也就是Java不仅可以用来解决小范围的问题，也可以用来解决大范围的问题。这样他们将Java的重心由电子消费品，转移到Internet编程上。</p><h1 id="Java-能够长久不衰的原因"><a href="#Java-能够长久不衰的原因" class="headerlink" title="Java 能够长久不衰的原因"></a>Java 能够长久不衰的原因</h1><p>从1995年在Sun World大会上的1.0版本正式提出“Write Once,Run Anywhere”到现在常年占据编程语言流行排行榜Top3，JAVA为什么能够如此受欢迎？下面我们就来盘点盘点！</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>所谓面向对象指的是在进行程序开发时将应用程序的数据及操作方法封装成一个便于我们理解的”对象”的特性，使我们在开发过程能够更易理解、并实现信息的封装及模块化。</p><p>简单讲就是一个程序就可以被抽象成一个人，一个人会有两个眼睛、一个嘴巴等属性，可以有吃饭、行走等行为，程序也可以抽象成类似的属性和行为。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240610203303974.png" alt="image-20240610203303974"></p><h2 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h2><p>说一个东西简不简单其实是需要有东西对比才能够体现出来，了解或者学习过其他语言(如C++)的小伙伴就知道，JAVA中大体上语法和C++相类似，但是C++中一些比较难以理解、容易混淆的概念在JAVA中是没有的(如指针)，JAVA是通过一种更清楚、更易理解的方式(即引用)来实现这些容易让人混淆的概念，所以对比起来就会感觉JAVA是更加简单的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d7c27d9ddd7d45788812403d93d407b3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211130233811412"></p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p><strong>跨平台指的是使用JAVA语言开发的程序能够运行在不同的软件平台和硬件平台上。</strong> 程序最终的执行是需要转成计算机硬件的机器指令来执行，而不同操作系统的、不同的计算机硬件是存在差异的，因此专门为某一种计算机硬件或者软件开发的程序直接放在另一个计算机硬件上是无法执行的(就像让大人穿小孩子的衣服，撑爆了也穿不进去)，至少需要做移植操作，比如有些在Windows系统上编译的应用程序是无法直接拿到Unix系统上运行的。</p><p>想要解决这个问题，则需要程序语言不依赖于特定的操作系统或硬件，JAVA语言则正好满足这个条件，<strong>JAVA中引入了虚拟机概念，JVM实现了不同平台的JAVA接口，屏蔽了底层硬件的差异性，JAVA编译器将JAVA语言开发的程序编程成与计算机结构无关的字节码(也就是我们常说的class文件),只要安装了JAVA虚拟机，JAVA应用程序就可以在相应的环境下被执行。</strong>因此，Java 也有着“一次编译，到处运行”的顺口溜。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-5.png" alt="编译与解释"></p><h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p><strong>何为健壮性：通俗理解含义是软件(程序)对于规范要求以外的输入能够判断出这个输入不符合规范要求，并能有合理的处理方式。</strong> 比如：一个字段取值只允许为数组和字母，但是用户却输入了中文，此时，对于规范以外(非数组和字母)的输入，程序需要能够作出合理的响应(如提示用户输入不符合规范)，而不是直接报错或者无响应。</p><p>再举个通俗的例子：你到银行提款机取钱，但是输入密码后提款机就卡死了，该怎么办？这时候你可以请求柜员帮助，柜员可以理解为银行为异常情况提供了一个兜底方案，这时候你肯定会给银行好评，因为如果没有柜员，提款机卡死后你除了等待就无法做其他事情，想要拿回银行卡就可能需要等到银行派专门人来才行，这时候用户体验就会非常差，程序亦是如此。</p><p>使用JAVA语言编写的程序则具有这方面的特性。<strong>首先JAVA语言程序会在编译和运行时对可能出现的问题进行检查，减少因未知原因导致程序崩溃的情况。同时，JAVA语言提供了异常处理机制，它能够在编译时提示未被处理异常或者为运行抛出异常提供兜底方案，防止程序崩溃。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240610203738049.png" alt=""></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>JAVA可以说是一种安全的网络语言，它屏蔽了指针类型，对内存的操作通过对象实例实现，同时，JAVA还在编译、解释层面进行了安全性的保证。</p><p>如：在编译层，JAVA会进行各种语法检测，不满足语法的写法在编译时报错无法被解释执行，在解释层，会对JAVA程序编译出来的字节码校验，同时还会进行代码段格式、类型转换是否合法等方面的检查，从而保障程序执行的一个安全性。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8278d53ec1924334a91697ed46d83ba2%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211201220414352"></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>随着科技的发展，人们对软件的使用体验有了更高的要求，响应速度就是其中非常重要的指标。JAVA内置了多线程的支持，通过多线程，计算机可以同时处理多个任务，因为处理器处速度远快于人接受信息的速度，人们会感觉软件的响应非常快，用户体验非常好。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/19953134ae51449eafd911ada0b9df85%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211201221700156"></p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>JAVA的可移植性主要与它的跨平台(平台无关性)有关，JAVA中的类库也实现了与平台无关的接口，从而具有了可移植性。JAVA的编译器也是使用JAVA语言编写的(源码可查看：<a href="https://link.juejin.cn?target=http%3A%2F%2Fhg.openjdk.java.net%2Fjdk6%2Fjdk6%2Flangtools%2Ffile%2F779c45081059%2Fsrc%2Fshare%2Fclasses%2Fcom%2Fsun%2Ftools%2Fjavac">JAVA编译器实现</a>)，解释器则是由标准的C实现，所以整个JAVA系统都具有可移植性。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/800b98d785ea421e97439302cf8a046f%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211201222423285"></p><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><p>JAVA中基础的单元就是类，类可以是开发者自定义，也可以是引用第三方定义好的类库，<strong>在JAVA中，类是运行时动态进行状态的，因此对类库添加新的属性和方法无序重新编译程序，这样JAVA就实现了动态维护程序和引用的类库。</strong></p><p>而C/C++则是在编译时将相应的函数库或类库中使用到的类、函数生成机器码，如果后续类库升级如添加了新的函数，则C/C++程序想要使用类库中新增的功能，需要对程序进行重新修改、编译。</p><h2 id="社区活跃度高、文档齐全"><a href="#社区活跃度高、文档齐全" class="headerlink" title="社区活跃度高、文档齐全"></a>社区活跃度高、文档齐全</h2><p>这个特点是得益于前面的描述的8个特点，正是因为JAVA语言有简单、跨平台等特性，才会吸引大量的开发者，社区的活跃度才会高，层层嵌套，所以JAVA才会流行至今。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>什么？你要学 Java？你为什么学 Java？</p><p>这是我的朋友们在知道我开始学 Java 之后问的最多的问题，在开始学之前，我们问了自己很多次这些问题。我为什么要从头开始学 Java？实在是现如今几乎所有公司都在使用 Java 这门语言，它好像一个无所不能的神，统治者国内的大小公司。</p><p>Go 语言绝对算得上目前为止我最喜欢得一个编程语言了，这一是我坚持学习时间最长得语言，但是找了三个月的实习，实在是太艰难了，大厂只有几家可以投，大多数科技公司都不会使用 Go 语言进行开发，小厂就更不用提了，所有的加在一起估计都没有 Java 的零头多。我毕竟不是一个理想主义者，还是务实一点的。</p><p>其实如果不是时间紧张，我应该也会对 Java 感兴趣，但是学习时间实在是太短了，而且暂时还没有找到很好的教程，只能像一个没头苍蝇一样到处乱撞。在更加深入学习之前，还是要先摆平心态。</p><p>本文到此就正式结束了，其实就是想说一下我要开始学 Java 了，最近几天要整理一下基础的知识点，在下一篇博客中记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对的，没错，这是一篇记录笔者从零开始学习 Java 的博客，后面还会有更多关于 Java 的博客被记录。&lt;/p&gt;
&lt;p&gt;关于 Java 学习过程中的那些基础知识，在这里就不过多的去介绍了，没什么意义，更多还是去聊一下面向对象或者一些新奇的东西。&lt;/p&gt;
&lt;p&gt;既然是开篇之作</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis家族再添新成员：探索Bitmaps、HyperLogLog和Geo的魅力</title>
    <link href="http://example.com/2024/06/10/Redis%E5%AE%B6%E6%97%8F%E5%86%8D%E6%B7%BB%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%8E%A2%E7%B4%A2Bitmaps%E3%80%81HyperLogLog%E5%92%8CGeo%E7%9A%84%E9%AD%85%E5%8A%9B/"/>
    <id>http://example.com/2024/06/10/Redis%E5%AE%B6%E6%97%8F%E5%86%8D%E6%B7%BB%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%8E%A2%E7%B4%A2Bitmaps%E3%80%81HyperLogLog%E5%92%8CGeo%E7%9A%84%E9%AD%85%E5%8A%9B/</id>
    <published>2024-06-10T07:40:09.000Z</published>
    <updated>2024-06-10T08:53:02.875Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的博客中，我们已经学习了 Redis 中的五种基础数据结构和六种底层数据结构。随着 Redis 在江湖上的名气越来越大，又有不少的英雄豪杰加入了 Redis 这一大帮派。</p><p>这个家族又迎来了三位新的成员：Bitmaps、HyperLogLog 和 Geo，三者各怀绝技，进一步巩固了Redis在数据江湖中的地位。</p><p>接下来就让我们来看一下这三位的实力把。</p><h1 id="Bitmaps-：位操作的巧匠"><a href="#Bitmaps-：位操作的巧匠" class="headerlink" title="Bitmaps ：位操作的巧匠"></a>Bitmaps ：位操作的巧匠</h1><p>根据官网介绍：</p><blockquote><p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p><p>Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。</p></blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p><h2 id="用来解决什么问题？"><a href="#用来解决什么问题？" class="headerlink" title="用来解决什么问题？"></a>用来解决什么问题？</h2><p>思考一个问题，在一个场景下，我们需要存储大规模的布尔数据类型，比如用户的签到信息、用户是否在线、某个时间段用户是否观看了某个视频等等。使用传统的数据结构可能会消耗大量的内存。</p><p>那要怎么实现我们想要的功能？</p><p>使用 <code>Bitmaps</code> 。bitmap 最大的优势之一是存储信息时，它经常可以极大的节省空间。例如，一个用户的系统中，使用递增的 id 来表示不同的用户，这时候 bitmap 使用 512MB 内存就可以记录 40 亿用户的一个比特信息（例如，1是男生，0是女生，一个男生的id为19，那么这个 bitmap 的第 19 位就是 1）。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="img"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之前值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 …</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td></tr></tbody></table></div><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>查看某一天是否有打卡！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>统计操作，统计 打卡的天数！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p><ul><li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><h1 id="HyperLogLog：基数估计的神算"><a href="#HyperLogLog：基数估计的神算" class="headerlink" title="HyperLogLog：基数估计的神算"></a>HyperLogLog：基数估计的神算</h1><h2 id="为什么要使用-HyperLogLog"><a href="#为什么要使用-HyperLogLog" class="headerlink" title="为什么要使用 HyperLogLog"></a>为什么要使用 <code>HyperLogLog</code></h2><p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p><p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p><p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p><p>HLL 具有以下几个特点：</p><ul><li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li><li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li><li>误差可以被设置辅助计算因子进行降低。</li></ul><p>Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p><ul><li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element <span class="selector-attr">[element ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持添加一个或多个元素至 HLL 结构中。</p><h4 id="统计不重复的元素"><a href="#统计不重复的元素" class="headerlink" title="统计不重复的元素"></a><strong>统计不重复的元素</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持统计一个或多个 HLL 结构。</p><h4 id="合并一个或多个-HLL-至新结构"><a href="#合并一个或多个-HLL-至新结构" class="headerlink" title="合并一个或多个 HLL 至新结构"></a><strong>合并一个或多个 HLL 至新结构</strong></h4><p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd k &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd k2 &quot;redis&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge k3 k k2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount k3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey <span class="selector-attr">[sourcekey ...]</span></span><br></pre></td></tr></table></figure><p><strong>pfmerge 使用场景</strong></p><p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>接下来我们使用 Java 代码来实现 HLL 的三个基础功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HyperLogLogExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计元素</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印统计元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k：&quot;</span> + count);</span><br><span class="line">        <span class="comment">// 合并 HLL</span></span><br><span class="line">        jedis.pfmerge(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印新 HLL</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k2：&quot;</span> + jedis.pfcount(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k：2</span><br><span class="line">k2：2</span><br></pre></td></tr></table></figure><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>HyperLogLog 算法来源于论文 <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</em></a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p><p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p><ul><li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li><li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li><li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li></ul><p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p><p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p><p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p><blockquote><p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500‬ 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1⁄1000+1⁄100000)≈1998 元，显然此算法更符合实际平均数。</p></blockquote><p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文。</p><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p><ul><li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul><h1 id="Geo：地理位置的游侠"><a href="#Geo：地理位置的游侠" class="headerlink" title="Geo：地理位置的游侠"></a>Geo：地理位置的游侠</h1><p>受过高等教育的我们都知道，我们所处的任何位置都可以用经度和纬度来标识，经度的范围 -180 到 180，纬度的范围为 -90 到 90。纬度以赤道为界，赤道以南为负数，赤道以北为正数；经度以本初子午线（英国格林尼治天文台）为界，东边为正数，西边为负数。</p><p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，GEO 本质上是基于 ZSet 实现的。</p><p>关于 GEO 的命令不多，主要包含以下 6 个：</p><ol><li>geoadd：添加地理位置</li><li>geopos：查询位置信息</li><li>geodist：距离统计</li><li>georadius：查询某位置内的其他成员信息</li><li>geohash：查询位置的哈希值</li><li>zrem：删除地理位置</li></ol><p>下面我们分别来看这些命令的使用。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="添加地理位置"><a href="#添加地理位置" class="headerlink" title="添加地理位置"></a><strong>添加地理位置</strong></h3><p>我们先用百度地图提供的经纬度查询工具，地址：</p><blockquote><p><a href="http://api.map.baidu.com/lbsapi/getpoint/index.html">http://api.map.baidu.com/lbsapi/getpoint/index.html</a></p></blockquote><p>如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/assets/c91f60b0-63a2-11ea-99a6-09fef5109e7b" alt="百度经纬度查询工具.png"></p><p>找了以下 4 个地点，添加到 Redis 中：</p><ol><li>天安门：116.404269,39.913164</li><li>月坛公园：116.36,39.922461</li><li>北京欢乐谷：116.499705,39.874635</li><li>香山公园：116.193275,39.996348</li></ol><p>代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd site 116.404269 39.913164 tianan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.36 39.922461 yuetan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.499705 39.874635 huanle</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.193275 39.996348 xiangshan</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude <span class="keyword">member</span> [longitude latitude <span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>重点参数说明如下：</p><ul><li>longitude 表示经度</li><li>latitude 表示纬度</li><li>member 是为此经纬度起的名字</li></ul><p>此命令支持一次添加一个或多个位置信息。</p><h3 id="查询位置信息"><a href="#查询位置信息" class="headerlink" title="查询位置信息"></a><strong>查询位置信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos site tianan</span><br><span class="line">1) 1) &quot;116.40541702508926392&quot;</span><br><span class="line">   2) &quot;39.91316289865137179&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持查看一个或多个位置信息。</p><h3 id="距离统计"><a href="#距离统计" class="headerlink" title="距离统计"></a><strong>距离统计</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist site tianan yuetan km</span><br><span class="line">&quot;3.9153&quot;</span><br></pre></td></tr></table></figure><p>可以看出天安门距离月坛公园的直线距离大概是 3.9 km，我们打开地图使用工具测试一下咱们的统计结果是否准确，如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/assets/de8bb110-63a2-11ea-b997-6566d32f1735" alt="天安门到月坛公园距离统计图.png"></p><p>可以看出 Redis 的统计和使用地图工具统计的距离是完全吻合的。</p><blockquote><p>注意：此命令统计的距离为两个位置的直线距离。</p></blockquote><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 <span class="selector-attr">[unit]</span></span><br></pre></td></tr></table></figure><p>unit 参数表示统计单位，它可以设置以下值：</p><ul><li>m：以米为单位，默认单位；</li><li>km：以千米为单位；</li><li>mi：以英里为单位；</li><li>ft：以英尺为单位。</li></ul><h3 id="查询某位置内的其他成员信息"><a href="#查询某位置内的其他成员信息" class="headerlink" title="查询某位置内的其他成员信息"></a><strong>查询某位置内的其他成员信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>此命令的意思是查询天安门（116.405419,39.913164）附近 5 公里范围内的成员列表。</p><p>相关语法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">georadius</span> <span class="selector-tag">key</span> <span class="selector-tag">longitude</span> <span class="selector-tag">latitude</span> <span class="selector-tag">radius</span> <span class="selector-tag">m</span>|<span class="selector-tag">km</span>|<span class="selector-tag">ft</span>|<span class="selector-tag">mi</span> <span class="selector-attr">[WITHCOORD]</span> <span class="selector-attr">[WITHDIST]</span> <span class="selector-attr">[WITHHASH]</span> <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[ASC|DESC]</span></span><br></pre></td></tr></table></figure><p>可选参数说明如下。</p><p><strong>1. WITHCOORD</strong></p><p>说明：返回满足条件位置的经纬度信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withcoord</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) 1) &quot;116.40426903963088989&quot;</span><br><span class="line">      2) &quot;39.91316289865137179&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) 1) &quot;116.36000186204910278&quot;</span><br><span class="line">      2) &quot;39.92246025586381819&quot;</span><br></pre></td></tr></table></figure><p><strong>2. WITHDIST</strong></p><p>说明：返回满足条件位置与查询位置的直线距离。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br></pre></td></tr></table></figure><p><strong>3. WITHHASH</strong></p><p>说明：返回满足条件位置的哈希信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withhash</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) (integer) 4069885552230465</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) (integer) 4069879797297521</span><br></pre></td></tr></table></figure><p><strong>4. COUNT count</strong></p><p>说明：指定返回满足条件位置的个数。</p><p>例如，指定返回一条满足条件的信息，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km count 1</span><br><span class="line">1) &quot;tianan&quot;</span><br></pre></td></tr></table></figure><p><strong>5. ASC|DESC</strong></p><p>说明：从近到远|从远到近排序返回。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km desc</span><br><span class="line">1) &quot;yuetan&quot;</span><br><span class="line">2) &quot;tianan&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km asc</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>当然以上这些可选参数也可以一起使用，例如以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist desc</span><br><span class="line">1) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br><span class="line">2) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br></pre></td></tr></table></figure><p><strong>5. 查询哈希值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash site tianan</span><br><span class="line">1) &quot;wx4g0cgp000&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持查询一个或多个地址的哈希值。</p><p><strong>6. 删除地理位置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem site xiaoming</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个位置信息。</p><h2 id="代码实战-1"><a href="#代码实战-1" class="headerlink" title="代码实战"></a>代码实战</h2><p>下面我们用 Java 代码，来实现查询附近的人，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoCoordinate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoRadiusResponse;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoUnit;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeoHashExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, GeoCoordinate&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加小明的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoming&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.404269</span>, <span class="number">39.913164</span>));</span><br><span class="line">        <span class="comment">// 添加小红的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaohong&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.36</span>, <span class="number">39.922461</span>));</span><br><span class="line">        <span class="comment">// 添加小美的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaomei&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.499705</span>, <span class="number">39.874635</span>));</span><br><span class="line">        <span class="comment">// 添加小二</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoer&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.193275</span>, <span class="number">39.996348</span>));</span><br><span class="line">        jedis.geoadd(<span class="string">&quot;person&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询小明和小红的直线距离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小明和小红相距：&quot;</span> + jedis.geodist(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xiaohong&quot;</span>, GeoUnit.KM) + <span class="string">&quot; KM&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询小明附近 5 公里的人</span></span><br><span class="line">        List&lt;GeoRadiusResponse&gt; res = jedis.georadiusByMemberReadonly(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, GeoUnit.KM);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明附近的人：&quot;</span> + res.get(i).getMemberByString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明和小红相距：3.9153 KM</span><br><span class="line">小明附近的人：xiaohong</span><br></pre></td></tr></table></figure><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>Redis 中的 GEO 经典使用场景如下：</p><ol><li>查询附近的人、附近的地点等；</li><li>计算相关的距离信息。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是 Redis 后续新增的三种数据结构的介绍和基本使用方法。在实际开发中，我们要实现的很多功能其实都要用到这三种数据结构。其实博客项目看似好像是一个烂大街的玩具，但其实如果真的要开发一款能推向市场的博客系统，还是要费很大的功夫的。</p><p>越往深处学就会发现它们的应用就在我们身边，这可能就是计算机不好入行的原因吧，刚开始学的全是一些抽象的东西，想要去实现一个我们平常使用的功能基本是不可能的，只有在深入学习各种框架、技术之后才能更好地理解身边的技术实现。</p><p>今天写的这几篇博客其实都有一点抽象，主要是因为之前在学 Redis 时，因为刚入门，所以很多东西都要去深入学习，最近几天看到的内容都是一个功能的实现，没有深挖的内容，所以在记录博客时就直接照着别人的总结写了一遍。你说这有用吗，应该比直接看一遍有用。</p><p>这两天都在学 Java 的基础知识，感觉和 Go 差的太多了，很麻烦，东西很杂。昨晚想通了一个问题，既然决定直接备战秋招了，时间还有差不多两三个月，其实可以不用那么急躁，囫囵吞枣式的学习只会带来更快的遗忘。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%9f%a5%e8%af%a2%e9%99%84%e8%bf%91%e7%9a%84%e4%ba%ba%e2%80%94%e2%80%94GEO.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%9f%a5%e8%af%a2%e9%99%84%e8%bf%91%e7%9a%84%e4%ba%ba%e2%80%94%e2%80%94GEO.md</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e4%bc%98%e7%a7%80%e7%9a%84%e5%9f%ba%e6%95%b0%e7%bb%9f%e8%ae%a1%e7%ae%97%e6%b3%95%e2%80%94%e2%80%94HyperLogLog.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e4%bc%98%e7%a7%80%e7%9a%84%e5%9f%ba%e6%95%b0%e7%bb%9f%e8%ae%a1%e7%ae%97%e6%b3%95%e2%80%94%e2%80%94HyperLogLog.md</a></p><p><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">https://javaguide.cn/database/redis/redis-data-structures-02.html</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的博客中，我们已经学习了 Redis 中的五种基础数据结构和六种底层数据结构。随着 Redis 在江湖上的名气越来越大，又有不少的英雄豪杰加入了 Redis 这一大帮派。&lt;/p&gt;
&lt;p&gt;这个家族又迎来了三位新的成员：Bitmaps、HyperLogLog 和 Geo，</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>分页与过滤：Redis中的渐进式数据处理妙招</title>
    <link href="http://example.com/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/"/>
    <id>http://example.com/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/</id>
    <published>2024-06-10T07:35:36.000Z</published>
    <updated>2024-06-10T08:53:02.865Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容就先有一篇小故事来引出吧。</p><h1 id="一个问题引发的「血案」"><a href="#一个问题引发的「血案」" class="headerlink" title="一个问题引发的「血案」"></a>一个问题引发的「血案」</h1><p>曾经发生过这样一件事，我们的 Redis 服务器存储了海量的数据，其中登录用户信息是以 user_token_id 的形式存储的。运营人员想要当前所有的用户登录信息，然后悲剧就发生了：因为我们的工程师使用了 <code>keys user_token_*</code> 来查询对应的用户，结果导致 Redis 假死不可用，以至于影响到线上的其他业务接连发生问题，然后就收到了一堆的系统预警短信。并且这个假死的时间是和存储的数据成正比的，数据量越大假死的时间就越长，导致的故障时间也越长。</p><p>那如何避免这个问题呢？</p><h1 id="问题的解决方法"><a href="#问题的解决方法" class="headerlink" title="问题的解决方法"></a>问题的解决方法</h1><p>在 Redis 2.8 之前，我们只能使用 keys 命令来查询我们想要的数据，但这个命令存在两个缺点：</p><ol><li>此命令没有分页功能，我们只能一次性查询出所有符合条件的 key 值，如果查询结果非常巨大，那么得到的输出信息也会非常多；</li><li>keys 命令是遍历查询，因此它的查询时间复杂度是 o(n)，所以数据量越大查询时间就越长。</li></ol><p>然而，比较幸运的是在 Redis 2.8 时推出了 Scan，解决了我们这些问题，下面来看 Scan 的具体使用。</p><h1 id="Scan命令使用"><a href="#Scan命令使用" class="headerlink" title="Scan命令使用"></a><code>Scan</code>命令使用</h1><p>我们先来模拟海量数据，使用 Pipeline 添加 10w 条数据，Java 代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加 10w 条数据</span></span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100001</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;user_token_&quot;</span> + i, <span class="string">&quot;id&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据插入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来查询用户 id 为 9999* 的数据，Scan 命令使用如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match user_token_9999* count 10000</span><br><span class="line">1) &quot;127064&quot;</span><br><span class="line">2) 1) &quot;user_token_99997&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 127064 match user_token_9999* count 10000</span><br><span class="line">1) &quot;1740&quot;</span><br><span class="line">2) 1) &quot;user_token_9999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1740 match user_token_9999* count 10000</span><br><span class="line">1) &quot;21298&quot;</span><br><span class="line">2) 1) &quot;user_token_99996&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 21298 match user_token_9999* count 10000</span><br><span class="line">1) &quot;65382&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 65382 match user_token_9999* count 10000</span><br><span class="line">1) &quot;78081&quot;</span><br><span class="line">2) 1) &quot;user_token_99998&quot;</span><br><span class="line">   2) &quot;user_token_99992&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 78081 match user_token_9999* count 10000</span><br><span class="line">1) &quot;3993&quot;</span><br><span class="line">2) 1) &quot;user_token_99994&quot;</span><br><span class="line">   2) &quot;user_token_99993&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3993 match user_token_9999* count 10000</span><br><span class="line">1) &quot;13773&quot;</span><br><span class="line">2) 1) &quot;user_token_99995&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 13773 match user_token_9999* count 10000</span><br><span class="line">1) &quot;47923&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 47923 match user_token_9999* count 10000</span><br><span class="line">1) &quot;59751&quot;</span><br><span class="line">2) 1) &quot;user_token_99990&quot;</span><br><span class="line">   2) &quot;user_token_99991&quot;</span><br><span class="line">   3) &quot;user_token_99999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 59751 match user_token_9999* count 10000</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) (empty list or set)</span><br></pre></td></tr></table></figure><p>从以上的执行结果，我们看出两个问题：</p><ol><li>查询的结果为空，但游标值不为 0，表示遍历还没结束；</li><li>设置的是 count 10000，但每次返回的数量都不是 10000，且不固定，这是因为 count 只是限定服务器单次遍历的字典槽位数量（约等于），而不是规定返回结果的 count 值。</li></ol><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>cursor：光标位置，整数值，从 0 开始，到 0 结束，查询结果是空，但游标值不为 0，表示遍历还没结束；</li><li>match pattern：正则匹配字段；</li><li>count：限定服务器单次遍历的字典槽位数量（约等于），只是对增量式迭代命令的一种提示（hint），并不是查询结果返回的最大数量，它的默认值是 10。</li></ul><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>本文我们使用 Java 代码来实现 Scan 的查询功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanParams;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 定义 match 和 count 参数</span></span><br><span class="line">        <span class="type">ScanParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanParams</span>();</span><br><span class="line">        params.count(<span class="number">10000</span>);</span><br><span class="line">        params.match(<span class="string">&quot;user_token_9999*&quot;</span>);</span><br><span class="line">        <span class="comment">// 游标</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ScanResult&lt;String&gt; res = jedis.scan(cursor, params);</span><br><span class="line">            <span class="keyword">if</span> (res.getCursor().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 表示最后一条</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = res.getCursor(); <span class="comment">// 设置游标</span></span><br><span class="line">            <span class="keyword">for</span> (String item : res.getResult()) &#123;</span><br><span class="line">                <span class="comment">// 打印查询结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;查询结果：&quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询结果：user_token_99997</span><br><span class="line">查询结果：user_token_9999</span><br><span class="line">查询结果：user_token_99996</span><br><span class="line">查询结果：user_token_99998</span><br><span class="line">查询结果：user_token_99992</span><br><span class="line">查询结果：user_token_99994</span><br><span class="line">查询结果：user_token_99993</span><br><span class="line">查询结果：user_token_99995</span><br><span class="line">查询结果：user_token_99990</span><br><span class="line">查询结果：user_token_99991</span><br><span class="line">查询结果：user_token_99999</span><br></pre></td></tr></table></figure><h1 id="Scan-相关命令"><a href="#Scan-相关命令" class="headerlink" title="Scan 相关命令"></a>Scan 相关命令</h1><p>Scan 是一个系列指令，除了 Scan 之外，还有以下 3 个命令：</p><ol><li>HScan 遍历字典游标迭代器</li><li>SScan 遍历集合的游标迭代器</li><li>ZScan 遍历有序集合的游标迭代器</li></ol><p>来看这些命令的具体使用。</p><h2 id="HScan-使用"><a href="#HScan-使用" class="headerlink" title="HScan 使用"></a><strong>HScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan myhash 0 match k2* count 10</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;k2&quot;</span><br><span class="line">   2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h2 id="SScan-使用"><a href="#SScan-使用" class="headerlink" title="SScan 使用"></a><strong>SScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan myset 0 match v2* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h2 id="ZScan-使用"><a href="#ZScan-使用" class="headerlink" title="ZScan 使用"></a><strong>ZScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan zset 0 match red* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;redis&quot;</span><br><span class="line">   2) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h1 id="Scan-说明"><a href="#Scan-说明" class="headerlink" title="Scan 说明"></a>Scan 说明</h1><p>官方对 Scan 命令的描述信息如下。</p><h2 id="Scan-guarantees"><a href="#Scan-guarantees" class="headerlink" title="Scan guarantees"></a><strong>Scan guarantees</strong></h2><blockquote><p>The SCAN command, and the other commands in the SCAN family, are able to provide to the user a set of guarantees associated to full iterations.</p><ul><li>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point SCANreturned it to the user.</li><li>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, SCAN ensures that this element will never be returned.</li></ul><p>However because SCAN has very little state associated (just the cursor) it has the following drawbacks:</p><ul><li>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</li><li>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</li></ul></blockquote><p>官方文档地址：</p><blockquote><p><a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p></blockquote><p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p><ul><li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li><li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li></ul><p>然后，Scan 命令包含以下缺点：</p><ul><li>一个元素可能被返回多次，需要客户端来实现去重；</li><li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本文我们可以知道 Scan 包含以下四个指令：</p><ol><li>Scan：用于检索当前数据库中所有数据；</li><li>HScan：用于检索哈希类型的数据；</li><li>SScan：用于检索集合类型中的数据；</li><li>ZScan：由于检索有序集合中的数据。</li></ol><p>Scan 具备以下几个特点：</p><ol><li>Scan 可以实现 keys 的匹配功能；</li><li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li><li>Scan 提供了 count 参数，可以规定遍历的数量；</li><li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li><li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li><li>单次返回空值且游标不为 0，说明遍历还没结束；</li><li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li><li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li></ol><p>本文内容与上面那篇文章有着相同的情况，内容较少，所以只读了一篇文章，贴在上面。</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/21%20%e6%b8%b8%e6%a0%87%e8%bf%ad%e4%bb%a3%e5%99%a8%ef%bc%88%e8%bf%87%e6%bb%a4%e5%99%a8%ef%bc%89%e2%80%94%e2%80%94Scan.md">原文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文的主要内容就先有一篇小故事来引出吧。&lt;/p&gt;
&lt;h1 id=&quot;一个问题引发的「血案」&quot;&gt;&lt;a href=&quot;#一个问题引发的「血案」&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的「血案」&quot;&gt;&lt;/a&gt;一个问题引发的「血案」&lt;/h1&gt;&lt;p&gt;曾经发生过这</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>深入解析管道（Pipelining）：提升性能的利器</title>
    <link href="http://example.com/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/"/>
    <id>http://example.com/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/</id>
    <published>2024-06-10T07:35:11.000Z</published>
    <updated>2024-06-10T08:53:02.875Z</updated>
    
    <content type="html"><![CDATA[<p>管道技术 (Pipeline) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p><p>通常情况下 Redis 都是单行执行的，客户端先向服务期发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。但是当出现大批量请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p><p>普通命令模式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/30beb330-63a1-11ea-9c08-6f91e6eaabb6" alt="普通模式.png"></p><p>管道模式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b5d1f60-63a1-11ea-8be0-ebada4c42c48" alt="管道模式.png"></p><blockquote><p>小贴士：管道中命令越多，管道技术的作用就更大，相比于普通模式来说执行效率就越高。</p></blockquote><h1 id="管道解决了什么问题？"><a href="#管道解决了什么问题？" class="headerlink" title="管道解决了什么问题？"></a>管道解决了什么问题？</h1><p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><p>这里介绍使用采用Java语言。</p><p>首先先获取 Pipeline 对象，再为 Pipeline 对象设置需要执行的命令，最后再使用 sync() 方法或 syncAndReturnAll() 方法来统一执行这些命令，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            pipe.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：297毫秒</span><br></pre></td></tr></table></figure><p>如果要接收管道所有命令的执行结果，可使用 syncAndReturnAll() 方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令并返回结果</span></span><br><span class="line">        List&lt;Object&gt; res = pipe.syncAndReturnAll();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : res) &#123;</span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道技术-VS-普通命令"><a href="#管道技术-VS-普通命令" class="headerlink" title="管道技术 VS 普通命令"></a>管道技术 VS 普通命令</h3><p>上面使用管道技术执行一个 for 循环所用的时间为 297 毫秒，接下来我们用普通的命令执行此循环，看下程序的执行时间，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            jedis.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：17276毫秒</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>从上面的结果可以看出，管道的执行时间是 297 毫秒，而普通命令执行时间是 17276 毫秒，管道技术要比普通的执行快了 58 倍。</p><h3 id="管道技术需要注意的事项"><a href="#管道技术需要注意的事项" class="headerlink" title="管道技术需要注意的事项"></a>管道技术需要注意的事项</h3><p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p><ul><li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li><li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li><li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率，但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p><p>本文并非笔者自己所写，由于此知识点内容较少，没必要阅读过多资料，所以选择了一个内容不错的文章来学习。这里就把学习的文章的内容放进来了。</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/19%20Redis%20%e7%ae%a1%e9%81%93%e6%8a%80%e6%9c%af%e2%80%94%e2%80%94Pipeline.md">原文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;管道技术 (Pipeline) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。&lt;/p&gt;
&lt;p&gt;通常情况下 Redis 都是单行执行的，客户端先向服务期发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
