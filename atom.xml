<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-25T12:14:14.320Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能日志库——Zap</title>
    <link href="http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/"/>
    <id>http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/</id>
    <published>2024-05-25T09:39:37.000Z</published>
    <updated>2024-05-25T12:14:14.320Z</updated>
    
    <content type="html"><![CDATA[<p>今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>在任何一个投入使用的项目中，都需要一个好的日志系统（关于什么是<a href="https://zxh3032.github.io/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/">日志</a>，可以看之前的总结，更建议看总结中的参考）。在 Go 语言中，我们有很多能够投入使用的日志库，比如<code>log</code>、<code>zap</code>等。对于一个好的日志记录器来说，我们需要它能够实现一下功能：</p><ul><li>能够将事件记录到文件中，而不是应用程序控制台。</li><li>日志切割-能够根据文件大小、时间或间隔等来切割日志文件。</li><li>支持不同的日志级别。例如INFO，DEBUG，ERROR等。</li><li>能够打印基本信息，如调用文件/函数名和行号，日志时间等。</li></ul><h1 id="默认的Go-Logger"><a href="#默认的Go-Logger" class="headerlink" title="默认的Go Logger"></a>默认的Go Logger</h1><p>在学习Uber-go的zap包之前，还是先学习一下Go语言提供的基本日志功能。由于之前写项目的时候在日志系统设计方面并没有很在意，所以根本就没记住什么东西，还是重新学一下吧。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。</p><p>那就来看一段简单的实现代码吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFileLocation, _ := os.OpenFile(<span class="string">&quot;test.log&quot;</span>, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="number">0744</span>)</span><br><span class="line">log.SetOutput(logFileLocation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error fetching url %s : %s&quot;</span>, url, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Status Code for %s : %s&quot;</span>, url, resp.Status)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">SetupLogger()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行上述代码后，会有一个 <code>test.log</code> 文件被创建，文件中的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Error fetching url www.baidu.com <span class="punctuation">:</span> Get <span class="attr">&quot;www.baidu.com&quot;</span><span class="punctuation">:</span> unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Status Code for http<span class="punctuation">:</span><span class="comment">//www.baidu.com : 200 OK</span></span><br></pre></td></tr></table></figure><h2 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>它最大的优点是使用非常简单。我们可以设置任何<code>io.Writer</code>作为日志记录输出并向其发送要写入的日志。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>仅限基本的日志级别<ul><li>只有一个<code>Print</code>选项。不支持<code>INFO</code>/<code>DEBUG</code>等多个级别。</li></ul></li><li>对于错误日志，它有 <code>Fatal</code> 和 <code>Panic</code><ul><li>Fatal日志通过调用<code>os.Exit(1)</code>来结束程序</li><li>Panic日志在写入日志消息之后抛出一个panic</li><li>但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误</li></ul></li><li>缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。</li><li>不提供日志切割的能力。</li></ul><h1 id="Uber-go-Zap"><a href="#Uber-go-Zap" class="headerlink" title="Uber-go Zap"></a>Uber-go Zap</h1><p>由于上面提到的 <code>Logger</code> 库的劣势并不能帮助我们设计一个良好的日志记录器，所以在本项目中选择了另一个功能更丰富等库——<code>Zap</code>。它同时提供了结构化日志记录和 printf 风格的日志记录。</p><p>那这时候就有同学会有疑问了，提供了更多的功能会不会导致在完成设定的任务时变得更慢呢？</p><p>一个优秀的工具就是实现了既要又要，根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好——也比标准库更快。 以下是Zap发布的基准测试信息</p><p>记录一条消息和10个字段:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">862 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">5 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">1250 ns/op</td><td style="text-align:center">+45%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">4021 ns/op</td><td style="text-align:center">+366%</td><td style="text-align:center">76 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">4542 ns/op</td><td style="text-align:center">+427%</td><td style="text-align:center">105 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">26785 ns/op</td><td style="text-align:center">+3007%</td><td style="text-align:center">115 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">29501 ns/op</td><td style="text-align:center">+3322%</td><td style="text-align:center">125 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">29906 ns/op</td><td style="text-align:center">+3369%</td><td style="text-align:center">122 allocs/op</td></tr></tbody></table></div><p>记录一个静态字符串，没有任何上下文或printf风格的模板：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">118 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">191 ns/op</td><td style="text-align:center">+62%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">93 ns/op</td><td style="text-align:center">-21%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">280 ns/op</td><td style="text-align:center">+137%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">standard library</td><td style="text-align:center">499 ns/op</td><td style="text-align:center">+323%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">1990 ns/op</td><td style="text-align:center">+1586%</td><td style="text-align:center">10 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">3129 ns/op</td><td style="text-align:center">+2552%</td><td style="text-align:center">24 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">3887 ns/op</td><td style="text-align:center">+3194%</td><td style="text-align:center">23 allocs/op</td></tr></tbody></table></div><h2 id="Zap的特性"><a href="#Zap的特性" class="headerlink" title="Zap的特性"></a>Zap的特性</h2><ul><li>高性能：zap 对日志输出进行了多项优化以提高它的性能</li><li>日志分级：有 Debug，Info，Warn，Error，DPanic，Panic，Fatal 等</li><li>日志记录结构化：日志内容记录是结构化的，比如 json 格式输出</li><li>自定义格式：用户可以自定义输出的日志格式</li><li>自定义公共字段：用户可以自定义公共字段，大家输出的日志内容就共同拥有了这些字段</li><li>调试：可以打印文件名、函数名、行号、日志时间等，便于调试程序</li><li>自定义调用栈级别：可以根据日志级别输出它的调用栈信息</li><li>Namespace：日志命名空间。定义命名空间后，所有日志内容就在这个命名空间下。命名空间相当于一个文件夹</li><li>支持 hook 操作</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  url := <span class="string">&quot;http://example.org/api&quot;</span></span><br><span class="line">  logger.Info(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">    zap.Int(<span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    zap.Duration(<span class="string">&quot;backoff&quot;</span>, time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  sugar := logger.Sugar()</span><br><span class="line">  sugar.Infow(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span>, url,</span><br><span class="line">    <span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;backoff&quot;</span>, time.Second,</span><br><span class="line">  )</span><br><span class="line">  sugar.Infof(<span class="string">&quot;Failed to fetch URL: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>zap</code>库的使用与其他的日志库非常相似。先创建一个<code>logger</code>，然后调用各个级别的方法记录日志（<code>Debug/Info/Error/Warn</code>）。</p><p><code>zap</code>提供了几个快速创建<code>logger</code>的方法</p><ul><li><code>zap.NewExample()</code></li><li><code>`zap.NewDevelopment()</code></li><li><code>zap.NewProduction()</code></li><li>还有高度定制化的创建方法<code>zap.New()</code>。</li></ul><p>创建前 3 个<code>logger</code>时，<code>zap</code>会使用一些预定义的设置，它们的使用场景也有所不同。<code>Example</code>适合用在测试代码中，<code>Development</code>在开发环境中使用，<code>Production</code>用在生成环境。</p><p><code>zap</code>底层 API 可以设置缓存，所以一般使用<code>defer logger.Sync()</code>将缓存同步到文件中。</p><hr><p>Zap提供了两种类型的日志记录器—<code>Sugared Logger</code>和<code>Logger</code>。</p><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li>通过调用<code>zap.NewProduction()</code>/<code>zap.NewDevelopment()</code>或者<code>zap.Example()</code>创建一个Logger。</li><li>上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。</li><li>通过Logger调用Info/Error等。</li><li>默认情况下日志都会打印到应用程序的console界面。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(</span><br><span class="line"><span class="string">&quot;Error fetching url..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">zap.Error(err))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Success..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;statusCode&quot;</span>, resp.Status),</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url))</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先创建了一个Logger，然后使用Info/ Error等Logger方法记录消息。</p><h3 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h3><p>现在让我们使用Sugared Logger来实现相同的功能。</p><ul><li>大部分的实现基本都相同。</li><li>惟一的区别是，我们通过调用主logger的<code>. Sugar()</code>方法来获取一个<code>SugaredLogger</code>。</li><li>然后使用<code>SugaredLogger</code>以<code>printf</code>格式记录语句</li></ul><p>下面是修改过后使用<code>SugaredLogger</code>代替<code>Logger</code>的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line"><span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么会有两种？"><a href="#为什么会有两种？" class="headerlink" title="为什么会有两种？"></a>为什么会有两种？</h3><p>由于<code>fmt.Printf</code>之类的方法大量使用<code>interface&#123;&#125;</code>和反射，会有不少性能损失，并且增加了内存分配的频次。<code>zap</code>为了提高性能、减少内存分配次数，没有使用反射，而且默认的<code>Logger</code>只支持强类型的、结构化的日志。必须使用<code>zap</code>提供的方法记录字段。<code>zap</code>为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，<code>zap.Type</code>（<code>Type</code>为<code>bool/int/uint/float64/complex64/time.Time/time.Duration/error</code>等）就表示该类型的字段，<code>zap.Typep</code>以<code>p</code>结尾表示该类型指针的字段，<code>zap.Types</code>以<code>s</code>结尾表示该类型切片的字段。如：</p><ul><li><code>zap.Bool(key string, val bool) Field</code>：<code>bool</code>字段</li><li><code>zap.Boolp(key string, val *bool) Field</code>：<code>bool</code>指针字段；</li><li><code>zap.Bools(key string, val []bool) Field</code>：<code>bool</code>切片字段。</li></ul><p>当然也有一些特殊类型的字段：</p><ul><li><code>zap.Any(key string, value interface&#123;&#125;) Field</code>：任意类型的字段；</li><li><code>zap.Binary(key string, val []byte) Field</code>：二进制串的字段。</li></ul><p>当然，每个字段都用方法包一层用起来比较繁琐。<code>zap</code>也提供了便捷的方法<code>SugarLogger</code>，可以使用<code>printf</code>格式符的方式。调用<code>logger.Sugar()</code>即可创建<code>SugaredLogger</code>。<code>SugaredLogger</code>的使用比<code>Logger</code>简单，只是性能比<code>Logger</code>低 50% 左右，可以用在非热点函数中。调用<code>SugarLogger</code>以<code>f</code>结尾的方法与<code>fmt.Printf</code>没什么区别，如例子中的<code>Infof</code>。同时<code>SugarLogger</code>还支持以<code>w</code>结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可。</p><h2 id="记录层级关系"><a href="#记录层级关系" class="headerlink" title="记录层级关系"></a>记录层级关系</h2><p>前面记录的日志都是一层结构，没有嵌套的层级。我们可以使用 <code>zap.Namespace(key string) Field</code> 构建一个<strong>命名空间</strong>，后续的<code>Filed</code>都记录在此命名空间中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  logger.Info(<span class="string">&quot;tracked some metrics&quot;</span>,</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  logger2 := logger.With(</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line">  logger2.Info(<span class="string">&quot;tracked some metrics&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrics&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrices&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面我们演示了两种<code>Namespace</code>的用法，一种是直接作为字段传入<code>Debug/Info</code>等方法，一种是调用<code>With()</code>创建一个新的<code>Logger</code>，新的<code>Logger</code>记录日志时总是带上预设的字段。</p><h2 id="定制Logger"><a href="#定制Logger" class="headerlink" title="定制Logger"></a>定制<code>Logger</code></h2><p>调用<code>NexExample()/NewDevelopment()/NewProduction()</code>这 3 个方法，<code>zap</code>使用默认的配置。我们也可以手动调整，配置结构如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/config.go</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Level AtomicLevel <span class="string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span></span><br><span class="line">  Encoding <span class="type">string</span> <span class="string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span></span><br><span class="line">  EncoderConfig zapcore.EncoderConfig <span class="string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span></span><br><span class="line">  OutputPaths []<span class="type">string</span> <span class="string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span></span><br><span class="line">  ErrorOutputPaths []<span class="type">string</span> <span class="string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span></span><br><span class="line">  InitialFields <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Level</code>：日志级别；</li><li><code>Encoding</code>：输出的日志格式，默认为 JSON；</li><li><code>OutputPaths</code>：可以配置多个输出路径，路径可以是文件路径和<code>stdout</code>（标准输出）；</li><li><code>ErrorOutputPaths</code>：错误输出路径，也可以是多个；</li><li><code>InitialFields</code>：每条日志中都会输出这些值。</li></ul><p>其中<code>EncoderConfig</code>为编码配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/zapcore/encoder.go</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  MessageKey    <span class="type">string</span> <span class="string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span></span><br><span class="line">  LevelKey      <span class="type">string</span> <span class="string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span></span><br><span class="line">  TimeKey       <span class="type">string</span> <span class="string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span></span><br><span class="line">  NameKey       <span class="type">string</span> <span class="string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span></span><br><span class="line">  CallerKey     <span class="type">string</span> <span class="string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span></span><br><span class="line">  StacktraceKey <span class="type">string</span> <span class="string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span></span><br><span class="line">  LineEnding    <span class="type">string</span> <span class="string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span></span><br><span class="line">  EncodeLevel    LevelEncoder    <span class="string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span></span><br><span class="line">  EncodeTime     TimeEncoder     <span class="string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span></span><br><span class="line">  EncodeDuration DurationEncoder <span class="string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span></span><br><span class="line">  EncodeCaller   CallerEncoder   <span class="string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span></span><br><span class="line">  EncodeName NameEncoder <span class="string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>MessageKey</code>：日志中信息的键名，默认为<code>msg</code>；</li><li><code>LevelKey</code>：日志中级别的键名，默认为<code>level</code>；</li><li><code>EncodeLevel</code>：日志中级别的格式，默认为小写，如<code>debug/info</code>。</li></ul><h3 id="将日志写入文件而不是终端"><a href="#将日志写入文件而不是终端" class="headerlink" title="将日志写入文件而不是终端"></a>将日志写入文件而不是终端</h3><p>在实际运行的项目中，将日志写入终端显然不是一个好的想法，即不方便查看，又不能够长时间存储。所以，将日志单独写入到一个文件夹中，是一个非常好的设计。这时，我们就要用到<code>zap.New()</code>方法来定制创建logger。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span></span> *Logger</span><br></pre></td></tr></table></figure><p><code>zapcore.Core</code>需要三个配置——<code>Encoder</code>，<code>WriteSyncer</code>，<code>LogLevel</code>。</p><ol><li><strong>Encoder</strong>：编码器（如何写入日志）。</li><li><strong>WriterSyncer</strong> ：指定日志将写到哪里去。</li><li><strong>Log Level</strong>：哪种级别的日志将被写入。</li></ol><p>在本项目的实际开发中，对以上三个配置都做出了相应的设计。根据日期以及日志的等级实现了相应的日志分割功能，将日志输出的时间格式也进行了更加简洁的设置。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是在本项目中已经使用的有关 <code>Zap</code> 库的内容，更加详细和底层的东西还是去看大佬的博客和实际源码吧，我写的博客也只是为了强化一下记忆。</p><p>呜呜呜……，暑期实习还是没有一点眉目，不知道该怎么办了，真是不想背八股文啊！！！昨天面了边无际的面试，感觉这才应该是面试该有的情况，就不要问那些要靠死记硬背的八股文了，日常工作又能用到多少，谁会在写代码的时候需要考虑三次握手怎么握呀。不过不问八股好像也没什么可问的了。这就是绝大多数本科生的悲哀之处吧，上了四年学，什么都没学到。</p><p>不过边无际的面试面的好像也没有多好，不过这是我三个月以来说过最流畅的自我介绍了，感觉还是得深入的学习一下Redis和Docker的内容了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://darjun.github.io/2020/04/23/godailylib/zap/">Go 每日一库之 Zap</a></p></li><li><p><a href="https://www.liwenzhou.com/posts/Go/zap/">李文周的博客</a></p></li><li><a href="https://www.cnblogs.com/jiujuan/p/17304844.html">更加详细的Zap介绍</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。&lt;/p&gt;
&lt;h1 id=&quot;日志系统&quot;&gt;&lt;a href=&quot;#日志系统&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>命令行解析——flag</title>
    <link href="http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/"/>
    <id>http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/</id>
    <published>2024-05-23T12:18:13.000Z</published>
    <updated>2024-05-23T13:01:07.684Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用<code>Set</code>显示设置的 &gt; 命令行选项 &gt; 环境变量 &gt; 配置文件 &gt; 默认值。</p><p>在实际项目开发中一般不会直接 <code>Set</code> 来设置，因为要使用的配置现象过多。因此，在考虑直接读取配置文件之前，我们要先做一件事，那就是解析命令行，看看有没有相应的键值设置。</p><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><h1 id="如何获取命令行参数？"><a href="#如何获取命令行参数？" class="headerlink" title="如何获取命令行参数？"></a>如何获取命令行参数？</h1><p>如果只是简单的想要获取命令行参数，可以直接使用 <code>os.Args</code> 来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./args_demo a b c d</span><br><span class="line">args[0]=./args_demo</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=b</span><br><span class="line">args[3]=c</span><br><span class="line">args[4]=d</span><br></pre></td></tr></table></figure><p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p><h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p><code>flag</code>用于解析命令行选项。</p><p>命令行选项在实际开发中很常用，特别是在写工具的时候。</p><ul><li>指定配置文件的路径，如<code>redis-server ./redis.conf</code>以当前目录下的配置文件<code>redis.conf</code>启动 Redis 服务器；</li><li>自定义某些参数，如<code>python -m SimpleHTTPServer 8080</code>启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">flag参数</th><th style="text-align:center">有效值</th></tr></thead><tbody><tr><td style="text-align:center">字符串flag</td><td style="text-align:center">合法字符串</td></tr><tr><td style="text-align:center">整数flag</td><td style="text-align:center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td style="text-align:center">浮点数flag</td><td style="text-align:center">合法浮点数</td></tr><tr><td style="text-align:center">bool类型flag</td><td style="text-align:center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td style="text-align:center">时间段flag</td><td style="text-align:center">任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” /“µs”、“ms”、“s”、“m”、“h”。</td></tr></tbody></table></div><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a><code>flag.Type()</code></h3><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age := flag.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married := flag.Bool(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a><code>flag.TypeVar()</code></h3><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a><code>flag.Parse()</code></h3><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>遇到第一个非选项参数（即不是以<code>-</code>和<code>--</code>开头的）或终止符<code>--</code>，解析停止。</p><hr><p>总结一下，使用<code>flag</code>库的一般步骤：</p><ul><li>定义一些全局变量存储选项的值;</li><li>在<code>init</code>方法中使用<code>flag.TypeVar</code>方法定义选项，这里的<code>Type</code>可以为基本类型<code>Int/Uint/Float64/Bool</code>，还可以是时间间隔<code>time.Duration</code>。定义时传入变量的地址、选项名、默认值和帮助信息；</li><li>在<code>main</code>方法中调用<code>flag.Parse</code>从<code>os.Args[1:]</code>中解析选项。因为<code>os.Args[0]</code>为可执行程序路径，会被剔除。</li></ul><p>注意点：</p><p><code>flag.Parse</code>方法必须在所有选项都定义之后调用，且<code>flag.Parse</code>调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为<code>init</code>在所有代码之前执行，将选项定义都放在<code>init</code>中，<code>main</code>函数中执行<code>flag.Parse</code>时所有选项都已经定义了。</p><h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a><code>flag</code>其他函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="定义短选项"><a href="#定义短选项" class="headerlink" title="定义短选项"></a>定义短选项</h3><p><code>flag</code>库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有<strong>相同的默认值</strong>。否则不传该选项时，行为是不确定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    defaultLogLevel = <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">    usage = <span class="string">&quot;set log level value&quot;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;log_type&quot;</span>, defaultLogLevel, usage)</span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;l&quot;</span>, defaultLogLevel, usage + <span class="string">&quot;(shorthand)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;log level:&quot;</span>, logLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>除了使用<code>flag</code>库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interval []time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(*i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> Set(value <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(*i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;interval flag already set&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, dt := <span class="keyword">range</span> strings.Split(value, <span class="string">&quot;,&quot;</span>) &#123;</span><br><span class="line">    duration, err := time.ParseDuration(dt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    *i = <span class="built_in">append</span>(*i, duration)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  intervalFlag interval</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Var(&amp;intervalFlag, <span class="string">&quot;deltaT&quot;</span>, <span class="string">&quot;comma-seperated list of intervals to use between events&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(intervalFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个新类型，这里定义类型<code>interval</code>。</p><p>新类型必须实现<code>flag.Value</code>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="type">string</span></span><br><span class="line">  Set(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>String</code>方法格式化该类型的值，<code>flag.Parse</code>方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的<code>Set</code>方法。 这里将以<code>,</code>分隔的时间间隔解析出来存入一个切片中。</p><p>自定义类型选项的定义必须使用<code>flag.Var</code>方法。</p><h3 id="解析程序中的字符串"><a href="#解析程序中的字符串" class="headerlink" title="解析程序中的字符串"></a>解析程序中的字符串</h3><p>有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用<code>flag.FlagSet</code>结构的相关方法来解析这些选项。</p><p>实际上，我们前面调用的<code>flag</code>库的方法，都会间接调用<code>FlagSet</code>结构的方法。<code>flag</code>库中定义了一个<code>FlagSet</code>类型的全局变量<code>CommandLine</code>专门用于解析命令行选项。 前面调用的<code>flag</code>库的方法只是为了提供便利，它们内部都是调用的<code>CommandLine</code>的相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">var</span> CommandLine = NewFlagSet(os.Args[<span class="number">0</span>], ExitOnError)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  CommandLine.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntVar</span><span class="params">(p *<span class="type">int</span>, name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  CommandLine.Var(newIntValue(value, p), name, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Int(name, value, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NFlag</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.actual) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Arg</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Arg(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NArg</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.args) &#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以自己创建<code>FlagSet</code>类型变量来解析选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := []<span class="type">string</span>&#123;<span class="string">&quot;-intflag&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;-stringflag&quot;</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> intflag <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> boolflag <span class="type">bool</span></span><br><span class="line">  <span class="keyword">var</span> stringflag <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  fs := flag.NewFlagSet(<span class="string">&quot;MyFlagSet&quot;</span>, flag.ContinueOnError)</span><br><span class="line">  fs.IntVar(&amp;intflag, <span class="string">&quot;intflag&quot;</span>, <span class="number">0</span>, <span class="string">&quot;int flag value&quot;</span>)</span><br><span class="line">  fs.BoolVar(&amp;boolflag, <span class="string">&quot;boolflag&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;bool flag value&quot;</span>)</span><br><span class="line">  fs.StringVar(&amp;stringflag, <span class="string">&quot;stringflag&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;string flag value&quot;</span>)</span><br><span class="line"></span><br><span class="line">  fs.Parse(args)</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">&quot;int flag:&quot;</span>, intflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;bool flag:&quot;</span>, boolflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;string flag:&quot;</span>, stringflag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewFlagSet</code>方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：</p><ul><li><code>ContinueOnError</code>：发生错误后继续解析，<code>CommandLine</code>就是使用这个选项；</li><li><code>ExitOnError</code>：出错时调用<code>os.Exit(2)</code>退出程序；</li><li><code>PanicOnError</code>：出错时产生 panic。</li></ul><p>随便看一眼<code>flag</code>库中的相关代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlagSet)</span></span> Parse(arguments []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  f.parsed = <span class="literal">true</span></span><br><span class="line">  f.args = arguments</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    seen, err := f.parseOne()</span><br><span class="line">    <span class="keyword">if</span> seen &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> f.errorHandling &#123;</span><br><span class="line">    <span class="keyword">case</span> ContinueOnError:</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> ExitOnError:</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> PanicOnError:</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与直接使用<code>flag</code>库的方法有一点不同，<code>FlagSet</code>调用<code>Parse</code>方法时需要显示传入字符串切片作为参数。因为<code>flag.Parse</code>在内部调用了<code>CommandLine.Parse(os.Args[1:])</code>。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，本项目的解析配置文件功能已经基本完成了，该功能先是使用 flag 库来解析命令行中的内容，当命令行内容不为空时，则使用输入值来进行配置；若为空，则通过解析原有的配置文件来实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.liwenzhou.com/posts/Go/flag/">李文周的博客</a></li><li><a href="https://darjun.github.io/2020/01/10/godailylib/flag/">Go每日一库之 flag</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用&lt;code&gt;Set&lt;/code&gt;显示设置的 &amp;gt; 命令行选项 &amp;gt; 环境变量 &amp;gt; 配置文件 &amp;gt; 默认值。&lt;/p&gt;
&lt;p&gt;在实际项目开发中一般不会直接 &lt;cod</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go语言配置管理神器——Viper</title>
    <link href="http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/"/>
    <id>http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/</id>
    <published>2024-05-23T11:39:34.000Z</published>
    <updated>2024-05-23T12:24:48.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——<code>Viper</code>。</p><p>在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 <strong>Viper</strong>。关于 Viper，我也已经不是第一次使用了，但之前确实是没有去了解过，所以要从头开始学习。</p><h1 id="Viper-是什么"><a href="#Viper-是什么" class="headerlink" title="Viper 是什么"></a>Viper 是什么</h1><p>XXX是什么？这是我们去学习一个东西想到的第一个问题。那么 Viper是 什么，详细内容如下：</p><p>viper 是一个配置解决方案，拥有丰富的特性：</p><ul><li>支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；</li><li>可以设置监听配置文件的修改，修改时自动加载新的配置；</li><li>从环境变量、命令行选项和<code>io.Reader</code>中读取配置；</li><li>从远程配置系统中读取和监听修改，如 etcd/Consul；</li><li>代码逻辑中显示设置键值。</li></ul><h2 id="为什么选择-Viper-？"><a href="#为什么选择-Viper-？" class="headerlink" title="为什么选择 Viper ？"></a>为什么选择 Viper ？</h2><p>在构建现代应用程序时，你无需担心配置文件格式；你想要专注于构建出色的软件。Viper的出现就是为了在这方面帮助你的。</p><p>Viper能够为你执行下列操作：</p><ol><li>查找、加载和反序列化<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>INI</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件。</li><li>提供一种机制为你的不同配置选项设置默认值。</li><li>提供一种机制来通过命令行参数覆盖指定选项的值。</li><li>提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。</li><li>当用户提供了与默认值相同的命令行或配置文件时，可以很容易地分辨出它们之间的区别。</li></ol><p>Viper会按照下面的优先级。每个项目的优先级都高于它下面的项目:</p><ul><li>显示调用<code>Set</code>设置值</li><li>命令行参数（flag）</li><li>环境变量</li><li>配置文件</li><li>key/value存储</li><li>默认值</li></ul><p><strong>重要：</strong> 目前Viper配置的键（Key）是大小写不敏感的。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>Viper 的使用非常简单，它需要很少的设置。设置文件名（<code>SetConfigName</code>）、配置类型（<code>SetConfigType</code>）、和搜索路径（<code>AddConfigPath</code>），然后调用<code>ReadInConfig</code>。viper 会自动根据类型来读取配置。使用时调用 <code>viper.Get</code> 方法获取键值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  viper.SetDefault(<span class="string">&quot;redis.port&quot;</span>, <span class="number">6381</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;app_name&quot;</span>))</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;log_level&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql ip: &quot;</span>, viper.Get(<span class="string">&quot;mysql.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql port: &quot;</span>, viper.Get(<span class="string">&quot;mysql.port&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql user: &quot;</span>, viper.Get(<span class="string">&quot;mysql.user&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql password: &quot;</span>, viper.Get(<span class="string">&quot;mysql.password&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql database: &quot;</span>, viper.Get(<span class="string">&quot;mysql.database&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis ip: &quot;</span>, viper.Get(<span class="string">&quot;redis.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.Get(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>设置文件名时不要带后缀；</li><li>搜索路径可以设置多个，viper 会根据设置顺序依次查找；</li><li>viper 获取值时使用<code>section.key</code>的形式，即传入嵌套的键名；</li><li>默认值可以调用<code>viper.SetDefault</code>设置。</li></ul><h2 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h2><p>viper 提供了多种形式的读取方法。在上面的例子中，我们看到了<code>Get</code>方法的用法。<code>Get</code>方法返回一个<code>interface&#123;&#125;</code>的值，使用有所不便。</p><p><code>GetType</code>系列方法可以返回指定类型的值。 其中，Type 可以为<code>Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice</code>。 但是请注意，<strong>如果指定的键不存在或类型不正确，<code>GetType</code>方法返回对应类型的零值</strong>。</p><p>如果要判断某个键是否存在，使用<code>IsSet</code>方法。 另外，<code>GetStringMap</code>和<code>GetStringMapString</code>直接以 map 返回某个键下面所有的键值对，前者返回<code>map[string]interface&#123;&#125;</code>，后者返回<code>map[string]string</code>。 <code>AllSettings</code>以<code>map[string]interface&#123;&#125;</code>返回所有设置。</p><h2 id="设置键值"><a href="#设置键值" class="headerlink" title="设置键值"></a>设置键值</h2><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><h3 id="viper-Set"><a href="#viper-Set" class="headerlink" title="viper.Set"></a>viper.Set</h3><p>如果某个键通过<code>viper.Set</code>设置了值，那么这个值的优先级最高。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`viper.Set(&quot;redis.port&quot;, 5381) `</span></span><br></pre></td></tr></table></figure><p>如果将上面这行代码放到程序中，运行程序，输出的<code>redis.port</code>将是 5381。</p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>如果一个键没有通过<code>viper.Set</code>显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在<code>init</code>方法中定义选项，并且调用<code>viper.BindPFlags</code>绑定选项到配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pflag.Int(<span class="string">&quot;redis.port&quot;</span>, <span class="number">8381</span>, <span class="string">&quot;Redis port to connect&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定命令行</span></span><br><span class="line">  viper.BindPFlags(pflag.CommandLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>main</code>方法开头处调用<code>pflag.Parse</code>解析选项。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。</p><p>在<code>init</code>方法中调用<code>AutomaticEnv</code>方法绑定全部环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.AutomaticEnv()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="string">&quot;GOPATH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以单独绑定环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;redis.port&quot;</span>)<span class="comment">//只传入一个参数，这个参数即表示键名，又表示环境变量名。</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;go.path&quot;</span>, <span class="string">&quot;GOPATH&quot;</span>)<span class="comment">//传入两个参数，第一个参数表示键名，第二个参数表示环境变量名。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;go path: &quot;</span>, viper.Get(<span class="string">&quot;go.path&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过<code>viper.SetEnvPrefix</code>方法设置环境变量前缀，这样一来，通过<code>AutomaticEnv</code>和一个参数的<code>BindEnv</code>绑定的环境变量， 在使用<code>Get</code>的时候，viper 会自动加上这个前缀再从环境变量中查找。</p><p>如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名<code>gopath</code>也能读取环境变量<code>GOPATH</code>的值。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果经过前面的途径都没能找到该键，viper 接下来会尝试从配置文件中查找。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>使用 <code>viper.SetDefault()</code> 来设置默认值，以供使用。</p><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><h3 id="从io-Reader中读取"><a href="#从io-Reader中读取" class="headerlink" title="从io.Reader中读取"></a>从<code>io.Reader</code>中读取</h3><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bytes&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  tomlConfig := []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">app_name = &quot;awesome web&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># possible values: DEBUG, INFO, WARNING, ERROR, FATAL</span></span><br><span class="line"><span class="string">log_level = &quot;DEBUG&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[mysql]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 3306</span></span><br><span class="line"><span class="string">user = &quot;dj&quot;</span></span><br><span class="line"><span class="string">password = 123456</span></span><br><span class="line"><span class="string">database = &quot;awesome&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[redis]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 7381</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.GetInt(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unmarshal"><a href="#Unmarshal" class="headerlink" title="Unmarshal"></a><code>Unmarshal</code></h3><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  AppName  <span class="type">string</span></span><br><span class="line">  LogLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  MySQL    MySQLConfig</span><br><span class="line">  Redis    RedisConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP       <span class="type">string</span></span><br><span class="line">  Port     <span class="type">int</span></span><br><span class="line">  User     <span class="type">string</span></span><br><span class="line">  Password <span class="type">string</span></span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP   <span class="type">string</span></span><br><span class="line">  Port <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c Config</span><br><span class="line">  viper.Unmarshal(&amp;c)</span><br><span class="line"></span><br><span class="line">  fmt.Println(c.MySQL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><p>有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！</p><ul><li><code>WriteConfig</code>：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖；</li><li><code>WriteConfigAs</code>：保存配置到指定路径，如果文件存在，则覆盖；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是入股配置文件存在，则不覆盖。</li></ul><h2 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h2><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><p>只需要调用<code>viper.WatchConfig</code>，viper 会自动监听配置修改。如果有修改，重新加载的配置。</p><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Config file:%s Op:%s\n&quot;</span>, e.Name, e.Op)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，在本项目中所用到的有关 Viper 的内容就记录完了。但是viper相关的设计还没结束，还有另外一个很重要的库 flag。那就再下一篇博客中记录吧，一些写太多容易猪脑过载。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://darjun.github.io/2020/01/18/godailylib/viper/">Go每日一库之 viper</a></li><li><a href="https://www.liwenzhou.com/posts/Go/viper/">李文周的博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——&lt;code&gt;Viper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 &lt;strong&gt;Viper&lt;/s</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go-vue-admin学习</title>
    <link href="http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-05-22T14:00:49.000Z</published>
    <updated>2024-05-25T12:15:57.405Z</updated>
    
    <content type="html"><![CDATA[<p>将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。</p><p>这里插一句，道心破了主要是因为在后面的几场面试里总是达不到想要的效果，说话磕磕巴巴，问项目就回答的含糊不清，也不怪面试官给我秒挂，太不自信了，再沉淀一段时间吧，只能寄希望于秋招了。</p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── deploy： 部署相关的文件</span><br><span class="line">├── docs： 项目文档</span><br><span class="line">├── server： 后端代码</span><br><span class="line">└── web： 前端代码</span><br></pre></td></tr></table></figure><p>项目分为两个部分，使用 vue 框架的前端部分和使用 gin 框架的后端部分，前端部分在<code>web</code> 目录下，后端部分在<code>server</code>目录下。由于我对前端的内容不是很了解，所以主要关注 <code>server</code> 后端部分。了解一下目前 github 排名第一的 golang admin 项目是怎么设计的。</p><h1 id="后端结构"><a href="#后端结构" class="headerlink" title="后端结构"></a>后端结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   └── v1: v1 版本的 api，相当于java中的 controller</span><br><span class="line">├── config: 配置类，包括数据库配置，jwt 配置，redis 配置等</span><br><span class="line">├── core</span><br><span class="line">│   └── internal: 服务启动方法</span><br><span class="line">├── docs: swagger 文档</span><br><span class="line">├── global: 全局对象</span><br><span class="line">├── initialize</span><br><span class="line">│   └── internal: 初始化方法，日志，数据库，redis，jwt，定时任务等</span><br><span class="line">├── middleware: 中间件,包括跨域，jwt，casbin，日志，全局异常处理等,使用了 gin.handleFunc 的特性</span><br><span class="line">├── model: 数据库模型，请求参数，响应参数</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── system</span><br><span class="line">├── packfile</span><br><span class="line">├── plugin:</span><br><span class="line">│   ├── email: email 插件，是个完整的小项目，里面结构和外部类似</span><br><span class="line">│   ├── plugin-tool:</span><br><span class="line">│   └── ws</span><br><span class="line">├── resource: 资源文件，包括自动生成代码的模板，页面模板，插件模板等</span><br><span class="line">│   ├── autocode_template: 代码模板，从结构体生成代码</span><br><span class="line">│   ├── page: 前端静态资源</span><br><span class="line">│   └── plug_template: 插件代码模板</span><br><span class="line">├── router:路由代码</span><br><span class="line">│   └── system:</span><br><span class="line">├── service: 业务代码，相当于 java 中的 service</span><br><span class="line">│   └── system</span><br><span class="line">├── source: 数据库的初始数据</span><br><span class="line">│   └── system</span><br><span class="line">└── utils: 公共的工具类</span><br><span class="line">    ├── captcha</span><br><span class="line">    ├── plugin</span><br><span class="line">    ├── timer</span><br><span class="line">    └── upload</span><br></pre></td></tr></table></figure><p>本文是总结篇，提前写是想要有条理一点。下面是代码的主函数，我计划从主函数开始，一行一行地写一遍完整的项目，实在找不到相关的教程，所以学习的过程应该会比较艰辛，希望自己能够坚持下来吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">global.GVA_VP = core.Viper() <span class="comment">// 初始化Viper</span></span><br><span class="line">initialize.OtherInit()</span><br><span class="line">global.GVA_LOG = core.Zap() <span class="comment">// 初始化zap日志库</span></span><br><span class="line">zap.ReplaceGlobals(global.GVA_LOG)</span><br><span class="line">global.GVA_DB = initialize.Gorm() <span class="comment">// gorm连接数据库</span></span><br><span class="line">initialize.Timer()</span><br><span class="line">initialize.DBList()</span><br><span class="line"><span class="keyword">if</span> global.GVA_DB != <span class="literal">nil</span> &#123;</span><br><span class="line">initialize.RegisterTables() <span class="comment">// 初始化表</span></span><br><span class="line"><span class="comment">// 程序结束前关闭数据库链接</span></span><br><span class="line">db, _ := global.GVA_DB.DB()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br><span class="line">core.RunWindowsServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h1><p>Go语言库：</p><ul><li><a href="https://zxh3032.github.io/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/">Viper</a></li><li><a href="https://zxh3032.github.io/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/">Flag</a></li><li><a href="https://zxh3032.github.io/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/">Zap</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。&lt;/p&gt;
&lt;p&gt;这里插一句</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学——语言特性</title>
    <link href="http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</id>
    <published>2024-04-20T15:40:43.000Z</published>
    <updated>2024-04-23T04:11:09.863Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在学过基础的 Go 语言语法后，我们就发现了 Go 和 C++ 最大的不同，那就是 Go 好像不支持面向对象。</p><p>这门编程语言里没有类（class）、继承（extends），难道真的不支持面向对象编程，难道它也知道我没有对象？完了，被监视了（狗头）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/40b80bdfcc42d53f0ab1bfc99fe1132.jpg" alt="40b80bdfcc42d53f0ab1bfc99fe1132"></p><p>你看，找工作给脑子找坏了吧。不必理会上面一段无脑发言，总结为玩原神玩的。那么 Go 到底支不支持面向对象，让我们一步一步地探寻。</p><h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><p>类（class）在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的特性和方法（via @维基百科）。</p><p>继承是面向对象软件技术当中的一个概念，如果一个类别 B “继承自”另一个类别 A，就把这个 B 称为 “A的子类”，而把 A 称为 “B的父类别” 也可以称 “A 是 B 的超类”（via @维基百科）。</p><p>继承有如下两个特性：</p><ul><li>子类具有父类别的各种属性和方法，不需要再次编写相同的代码。</li><li>子类别继承父类时，可以重新定义某些属性，并重写某些方法，使其获得与父类别不同的功能。</li></ul><h2 id="结构和组合"><a href="#结构和组合" class="headerlink" title="结构和组合"></a>结构和组合</h2><p>在 Go 里就比较 ”特别“ 了，因为没有传统的类，也没有继承。</p><p>取而代之的是结构和组合的方式。这也是业内对 Go 是否 OOP 争议最大的地方。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>我们可以在 Go 中通过结构体的方式来组织代码，达到类似类的方式。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>类的声明采取结构体的方式取代后，也可以配套使用 ”组合“ 来达到类似继承的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> man <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span></span> hello1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">man</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> hello2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">p := person&#123;name: name&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := newPerson(<span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">p.hello1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 man 和 person 两个结构体，并将 man 嵌入到 person 中，形成组合。</p><h2 id="Go-是面向对象的语言吗"><a href="#Go-是面向对象的语言吗" class="headerlink" title="Go 是面向对象的语言吗"></a>Go 是面向对象的语言吗</h2><p>“Go 语言是否一门面向对象的语言？”，这是一个日经话题。官方 FAQ 给出的答复是：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/go-faq-objects.png" alt="image"></p><p>是的，也不是。原因是：</p><ul><li>Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。</li><li>Go 中的 “接口 “概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。</li><li>Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、“未装箱的 “整数。它们并不局限于结构（类）。</li><li>Go 由于缺乏类型层次，Go 中的 “对象 “比 C++ 或 Java 等语言更轻巧。</li></ul><h1 id="函数重载和缺省参数"><a href="#函数重载和缺省参数" class="headerlink" title="函数重载和缺省参数"></a>函数重载和缺省参数</h1><p>Go 语言中并不支持函数重载和缺省参数，下面将会介绍这两个是什么。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载（function overloading），也叫方法重载。是某些编程语言（如 C++、C#、Java、Swift、Kotlin 等）具有的一项特性。</p><p>该特性<strong>允许创建多个具有不同实现的同名函数</strong>，对重载函数的调用会运行其适用于调用上下文的具体实现。</p><p>从功能上来讲，就是允许一个函数调用根据上下文执行不同的方法，达到调用同一个函数名，执行不同的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Volume</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;  <span class="comment">// 立方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> s * s * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Volume</span><span class="params">(<span class="type">double</span> r, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 圆柱体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.1415926</span> * r * r * <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Volume</span><span class="params">(<span class="type">long</span> l, <span class="type">int</span> b, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 长方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> l * b * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">2.5</span>, <span class="number">8</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">100l</span>, <span class="number">75</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值，又叫缺省参数。指的是允许程序员设定缺省参数并指定默认值，<strong>当调用该函数并未指定值时，该缺省参数将为缺省值来使用</strong>。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c=<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，函数 <code>my_func</code> 一共有 3 个变量，分别是：a、b、c。变量 c 设置了缺省值，也就是 12。</p><p>其调用方式可以为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在第一种方式中，就会正常的传入所有参数。在第二种方式，由于第三个参数 c 并没有传递，因此会直接使用缺省值 12。</p><p>这就是参数默认值，也叫缺省参数。</p><h2 id="为什么不支持"><a href="#为什么不支持" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>从上述的功能特性介绍来看，似乎非常的不错，能够节省很多功夫。像是 Go 语言的 context 库中的这些方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>要是有函数重载，直接就 WithXXX 就好了，只需要关注传入的参数类型，也不用 “记” 那么多个方法名了。</p><p>有同学说，有参数默认值。那就可以直接设置在上面，作为 “最佳实践” 给到使用函数的人，岂不美哉。那怎么 Go 语言就不支持呢？</p><h3 id="细思"><a href="#细思" class="headerlink" title="细思"></a>细思</h3><p>其实这和设计理念，和对程序的理解有关系。说白了，就是你喜欢 “显式”，还是 “隐喻”。</p><p>函数重载和参数默认值，其实是不好的行为。调用者只看函数名字，可能没法知道，你这个默认值，又或是入参不同，会调用的东西，会产生怎么样的后果？</p><p>你可以观察一下自己的行为。大部分人都会潜意识的追进去看代码，看看会调到哪，缺省值的作用是什么，以确保可控。</p><h3 id="敲定"><a href="#敲定" class="headerlink" title="敲定"></a>敲定</h3><p>这细思的可能，在 Go 语言中是不被允许的。Go 语言的<strong>设计理念就是 “显式大于隐喻”，追求明确，显式</strong>。</p><p>在 Go FAQ 《Why does Go not support overloading of methods and operators?》有相关的解释。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/func-overloading.png" alt="image"></p><p>官方有明确提到两个观点：</p><ul><li>函数重载：拥有各种同名但不同签名的方法有时是很有用的，但在实践中也可能是混乱和脆弱的。</li><li>参数默认值：操作符重载，似乎更像是一种便利，不是绝对的要求。没有它，程序会更简单。</li></ul><p>这就是为什么 Go 语言不支持的原因。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p><strong>Go 里的锁，竟然不支持可重入</strong>？</p><p>如果对已经上锁的普通互斥锁进行 “加锁” 操作，其结果要么失败，要么会阻塞至解锁。</p><p>可重入互斥锁是互斥锁的一种，同一线程对其多次加锁不会产生死锁，又或是导致阻塞。</p><ul><li>在加锁上：如果是可重入互斥锁，当前尝试加锁的线程如果就是持有该锁的线程时，加锁操作就会成功。</li><li>在解锁上：可重入互斥锁一般都会记录被加锁的次数，只有执行相同次数的解锁操作才会真正解锁。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="Go-设计原则"><a href="#Go-设计原则" class="headerlink" title="Go 设计原则"></a>Go 设计原则</h3><p>在工程中使用互斥的根本原因是：为了保护不变量，也可以用于保护内、外部的不变量。</p><p>基于此，Go 在互斥锁设计上会遵守这几个原则。如下：</p><ul><li>在调用 <code>mutex.Lock</code> 方法时，要保证这些变量的不变性保持，不会在后续的过程中被破坏。</li><li>在调用<code>mu.Unlock</code>方法时，要保证：<ul><li>程序不再需要依赖那些不变量。</li><li>如果程序在互斥锁加锁期间破坏了它们，则需要确保已经恢复了它们。</li></ul></li></ul><h3 id="不支持的原因"><a href="#不支持的原因" class="headerlink" title="不支持的原因"></a>不支持的原因</h3><p>讲了 Go 自己的设计原则后，那为什么不支持可重入呢？</p><p>其实 Russ Cox 于 2010 年在《<a href="https://groups.google.com/g/golang-nuts/c/XqW1qcuZgKg/m/Ui3nQkeLV80J">Experimenting with GO</a>》就给出了答复，认为递归（又称：重入）互斥是个坏主意，这个设计并不好。</p><h1 id="并发读写"><a href="#并发读写" class="headerlink" title="并发读写"></a>并发读写</h1><p>来不及惋惜 Redis 三兄弟了，接下来登场的是 Go 语言自己的三兄弟——垃圾回收机制、协程机制和为什么 <code>map</code> 和 <code>slice</code>是非线性的。</p><p>为什么在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？</p><h2 id="非线程安全的例子"><a href="#非线程安全的例子" class="headerlink" title="非线程安全的例子"></a>非线程安全的例子</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>我们使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;随便寻了 %d 个地方&quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一次执行</span><br><span class="line">随便寻了5790个地方</span><br><span class="line">// 第二次执行</span><br><span class="line">随便寻了7370个地方</span><br><span class="line">// 第三次执行</span><br><span class="line">随便寻了6792个地方</span><br></pre></td></tr></table></figure><p>每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式的问题。</p><p>这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>同样针对 map 也如法炮制一下，重复针对类型为 map 的变量进行写入，结果会直接出现报错，并且是 Go 源码调用 <code>throw</code> 方法所导致的致命错误，也就是说 Go 进程会中断。</p><h2 id="如何支持并发读写"><a href="#如何支持并发读写" class="headerlink" title="如何支持并发读写"></a>如何支持并发读写</h2><h3 id="对-map-上锁"><a href="#对-map-上锁" class="headerlink" title="对 map 上锁"></a>对 map 上锁</h3><p>实际上我们仍然会经过有并发 map 的诉求，因为 Go 语言中的 goroutine 实在是太方便了。像是一般写爬虫任务时，基本会用到多个 goroutine，获取到数据后再写入到 map 或者 slice 中去。</p><p>Go 官方在 Go maps in action 中提供了一种简单又便利的方式来实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>这条语句声明了一个变量，它是一个匿名结构（struct）体，包含一个原生和一个嵌入读写锁 <code>sync.RWMutex</code>。</p><h3 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h3><p>虽然有了 Map+Mutex 的极简方案，但是也仍然存在一定问题。那就是在 map 的数据量非常大时，只有一把锁（Mutex）就非常可怕了，一把锁会导致大量的争夺锁，导致各种冲突和性能低下。</p><p>常见的解决方案是分片化，将一个大 map 分成多个区间，各区间使用多个锁，这样子锁的粒度就大大降低了。不过该方案实现起来很复杂，很容易出错。因此 Go 团队到比较为止暂无推荐，而是采取了其他方案。</p><p>该方案就是在 Go1.9 起支持的 <code>sync.Map</code>，其支持并发读写 map，起到一个补充的作用。</p><p>Go 语言的 <code>sync.Map</code> 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex</span><br><span class="line">read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其是专门为 <code>append-only</code> 场景设计的，也就是适合读多写少的场景。这是他的优点之一。</p><p>若出现写多/并发多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。这是他的重大缺点。</p><p>提供了以下常用方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>Delete：删除某一个键的值。</li><li>Load：返回存储在 map 中的键的值，如果没有值，则返回 nil。ok 结果表示是否在 map 中找到了值。</li><li>LoadAndDelete：删除一个键的值，如果有的话返回之前的值。</li><li>LoadOrStore：如果存在的话，则返回键的现有值。否则，它存储并返回给定的值。如果值被加载，加载的结果为 true，如果被存储，则为 false。</li><li>Range：递归调用，对 map 中存在的每个键和值依次调用闭包函数 <code>f</code>。如果 <code>f</code> 返回 false 就停止迭代。</li><li>Store：存储并设置一个键的值。</li></ul><h2 id="为什么不支持-1"><a href="#为什么不支持-1" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>Go Slice 的话，主要还是索引位覆写问题，这个就不需要纠结了，势必是程序逻辑在编写上有明显缺陷，自行改之就好。</p><p>但 Go map 就不大一样了，很多人以为是默认支持的，一个不小心就翻车，这么的常见。那凭什么 Go 官方还不支持，难不成太复杂了，性能太差了，到底是为什么？</p><p>原因如下（via @go faq）：</p><ul><li>典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。</li><li>非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。</li><li>性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。</li></ul><p>汇总来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在学习所谓的 Go 语言哲学时并不会有很多知识上的收获，要去探讨为什么设计师要这么设计某一个功能其实就是在揣测别人的心思，或许并没有什么原因，他只是喜欢。</p><p>那为什么还会有这种 XX 语言哲学的存在呢，我觉得是为了让学习者能够更快地抓住语言特性，也会给未来使用其进行开发带来深远的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……&lt;/p&gt;
&lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言2——反射与unsafe</title>
    <link href="http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/"/>
    <id>http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/</id>
    <published>2024-04-20T15:36:56.000Z</published>
    <updated>2024-04-21T08:37:58.487Z</updated>
    
    <content type="html"><![CDATA[<p>又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在计算机科学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。（来自wikipedia）</p><p>反射是程序审查自身结构的能力，并能对程序做出一定的修改。</p><p>对于人来说，审查自身或过往事情的能力，叫 “反思” 或 “反省”。</p><h2 id="Go-中的反射包：reflect介绍"><a href="#Go-中的反射包：reflect介绍" class="headerlink" title="Go 中的反射包：reflect介绍"></a>Go 中的反射包：reflect介绍</h2><p>同 Java 语言一样，Go 语言也有运行时反射，这为我们提供了一种可以在运行时操作任意类型对象的能力。比如查看一个接口变量的具体类型、看看一个结构体又多少字段、修改某个字段的值等。</p><p>Go语言是静态编译类语言，比如在定义一个变量的时候，已经知道了它是什么类型，那么为什么还需要反射呢？这是因为有些事情只有在运行时才知道。比如你定义了一个函数，它有一个 interface｛｝类型的参数，这也就意味着调用者可以传递任何类型的参数给这个函数。在这种情况下，如果你想知道调用者传递的是什么类型的参数，就需要用到反射。如果你想知道一个结构体有哪些字段和方法，也需要反射。</p><p>Go 中的反射是建立在类型系统之上，它与空接口 interface{} 密切相关。</p><p>每个 interface{} 类型的变量包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</p><blockquote><p>所以 nil != nil </p></blockquote><ul><li>获取 2 种类型信息的方法：</li></ul><blockquote><p><code>reflect.TypeOf()</code> 获取类型信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/type.go;l=39">Type</a> 类型；</p><p><code>reflect.ValueOf()</code> 获取数据信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/value.go;l=39">Value</a> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421145232856.png" alt="image-20240421145232856"></p><ul><li>2 个方法部分源码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> ，经过中间变量 <code>interface&#123;&#125;</code>，把一个普通的变量转换为反射包中类型对象： Type 和 Value 2 个类型，然后再用 reflect 包中的方法对它们进行各种操作。</p><blockquote><p>步骤：Go 变量 -&gt; interface{} -&gt; 反射包的反射类型对象</p></blockquote><p>反射包 reflect 中所有方法基本都是围绕 Type 和 Value 这 2 个类型设计和操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303885-113976386.png" alt="image-20230220180637118"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303895-169946680.png" alt="image-20230220180651792"></p><h2 id="reflect-简单使用"><a href="#reflect-简单使用" class="headerlink" title="reflect 简单使用"></a>reflect 简单使用</h2><p>从上面可以看出 TypeOf() 返回的是一个反射包中的 Type 类型，ValueOf() 返回的是一个反射包中的 Value 类型。</p><h3 id="float-反射实例"><a href="#float-反射实例" class="headerlink" title="float 反射实例"></a>float 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==TypeOf==&quot;</span>) <span class="comment">//TypeOf</span></span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>, t) <span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, t.Kind())<span class="comment">//kind: float64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==ValueOf==&quot;</span>)<span class="comment">//ValueOf</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>, v)<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())<span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind())<span class="comment">//kind: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(v.Interface())<span class="comment">//1.2345</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value is %5.2e\n&quot;</span>, v.Interface())<span class="comment">//value is 1.23e+00</span></span><br><span class="line"></span><br><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)<span class="comment">//1.2345</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;===kind===&quot;</span>)<span class="comment">//=kind=</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v = reflect.ValueOf(m)</span><br><span class="line">    fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind()) <span class="comment">// kind: int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type()) <span class="comment">// type: main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，reflect 包中 <code>reflect.TypeOf()</code> 返回 Type 和 <code>reflect.ValueOf()</code> 返回 Value 类型 都有一个 <code>Kind()</code> 方法，<code>Kind()</code> 返回一个底层的数据类型，如 Unit，Float64，Slice, Int 等。</p><p><strong>reflect.ValueOf() 返回的 Value 类型</strong>：</p><ul><li>它有一个 Type() 方法，返回的是 reflect.Value 的 Type</li><li>它有获取 Value 类型值的方法<ul><li>如果我们知道是 <code>float</code> 类型，所以直接用 <code>Float()</code> 方法。</li><li>如果不知道具体类型呢？由上面例子可知用 <code>Interface()</code> 方法，然后在进行类型断言 <code>v.Interface().(float64)</code> 来判断获取值</li></ul></li></ul><p><strong>v.Kind() 和 v.Type() 区别</strong>：</p><ul><li>在 Go 中，可以用 type 关键字定义自定义类型，<code>Kind()</code> 方法返回底层类型。</li><li>比如还有结构体，指针等类型用 type 定义的，那么 <code>Kind()</code> 方法就可以获取这些类型的底层类型。</li></ul><h3 id="struct-反射实例"><a href="#struct-反射实例" class="headerlink" title="struct 反射实例"></a>struct 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot; id:&quot;1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := student&#123;</span><br><span class="line">Name: <span class="string">&quot;hangmeimei&quot;</span>,</span><br><span class="line">Age:  <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueOfStu := reflect.ValueOf(stu)</span><br><span class="line"><span class="comment">// 获取struct字段数量</span></span><br><span class="line">fmt.Println(<span class="string">&quot;NumFields: &quot;</span>, valueOfStu.NumField()) <span class="comment">//NumFields:  2</span></span><br><span class="line"><span class="comment">// 获取字段 Name 的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name value: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).String(), <span class="string">&quot;, &quot;</span>, valueOfStu.FieldByName(<span class="string">&quot;Name&quot;</span>).String()) <span class="comment">//Name value:  hangmeimei ,  hangmeimei</span></span><br><span class="line"><span class="comment">// 字段类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name type: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).Type()) <span class="comment">//Name type:  string</span></span><br><span class="line"></span><br><span class="line">typeOfStu := reflect.TypeOf(stu)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfStu.NumField(); i++ &#123;</span><br><span class="line"><span class="comment">// 获取字段名</span></span><br><span class="line">name := typeOfStu.Field(i).Name</span><br><span class="line">fmt.Println(<span class="string">&quot;Field Name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tag</span></span><br><span class="line"><span class="keyword">if</span> fieldName, ok := typeOfStu.FieldByName(name); ok &#123;</span><br><span class="line">tag := fieldName.Tag</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;tag-&quot;</span>, tag, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;json:&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), <span class="string">&quot;, id&quot;</span>, tag.Get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//循环输出结果</span></span><br><span class="line">    <span class="comment">//Field Name:  Name</span></span><br><span class="line"><span class="comment">//tag- json:&quot;name&quot; ,  json: name , id</span></span><br><span class="line"><span class="comment">//Field Name:  Age</span></span><br><span class="line">    <span class="comment">//tag- json:&quot;age&quot; id:&quot;1&quot; ,  json: age , id 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 struct 信息的一些方法：</p><ul><li><code>NumField()</code> 获取结构体字段数量</li><li><code>Field(i)</code> 可以通过 i 字段索引来获取结构体字段信息，比如 Field(i).Name 获取字段名</li><li><code>FieldByName(name)</code> 通过 name 获取字段信息</li></ul><h2 id="三大定理"><a href="#三大定理" class="headerlink" title="三大定理"></a>三大定理</h2><p>在 Go 官方博客文章 <a href="https://go.dev/blog/laws-of-reflection">laws-of-reflection</a> 中，叙述了反射的 3 定律：</p><ul><li>第一定律：从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>第二定律：从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>第三定律：要修改反射对象，其值必须可设置；</li></ul><h3 id="第一定律"><a href="#第一定律" class="headerlink" title="第一定律"></a>第一定律</h3><p>反射的第一定律是我们能将 Go 语言的 <code>interface&#123;&#125;</code> 变量转换成反射对象。为什么是从 <code>interface&#123;&#125;</code> 变量到反射对象？</p><blockquote><p>当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://draveness.me/golang/tree/reflect.TypeOf"><code>reflect.TypeOf</code></a>、<a href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface&#123;&#125;</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface&#123;&#125;</code> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151203850.png" alt="image-20240421151203850"></p><h3 id="第二定律"><a href="#第二定律" class="headerlink" title="第二定律"></a>第二定律</h3><p>反射的第二定律是我们可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code>中的 <code>reflect.Value.Interface</code>就能完成这项工作：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151429967.png" alt="image-20240421151429967"></p><p>不过调用 <code>reflect.Value.Interface</code>方法只能获得 <code>interface&#123;&#125;</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p><ul><li>从接口值到反射对象：<ul><li>从基本类型到接口类型的类型转换；</li><li>从接口类型到反射对象的转换；</li></ul></li><li>从反射对象到接口值：<ul><li>反射对象转换成接口类型；</li><li>通过显式类型转换变成原始类型；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151704589.png" alt="image-20240421151704589"></p><h3 id="第三定律"><a href="#第三定律" class="headerlink" title="第三定律"></a>第三定律</h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的。</p><p>看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>这个问题并不是 7.1 不可寻址，而是这个 x 不可设置。</p><p>可设置性是反射值的一个属性，并不是所有的反射值有这个属性。</p><p>Value 的 <code>CanSet</code> 方法可以获取值是否可设置，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>为什么有可设置性？</p><blockquote><p>因为 reflect.ValueOf(x) 这个 x 传递的是一个原数据的副本，上面代码 <code>v.SetFloat(7.1)</code> 如果设置成功，那么更新的是副本值，原始值 x 并没有更新。这就会造成原值和新值的混乱，可设置属性就是避免这个问题。</p></blockquote><p>那怎么办？</p><p>传递的是一个副本，而不是值本身。如果希望能直接修改 x，那么必须把 x 的地址传递给函数，即指向 x 的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet())</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copytype of p:</span> <span class="meta">*float64</span></span><br><span class="line"><span class="attr">settability of p:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>还是 <code>false</code>，为什么？</p><p>反射对象 p 不可设置，它并不是我们要设置的 p，它实际上是 <em>p。为了得到 p 所指向的东西，我们需要调用 Value 的 <code>Elem</code> 方法，通过指针进行简介<em>*寻址</em></em>，然后将结果保存在一个名为 v 的反射 Value 中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyv := p.<span class="built_in">Elem</span>()</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;settability of v:&quot;</span>, v.<span class="built_in">CanSet</span>())</span><br></pre></td></tr></table></figure><p>现在 v 是一个可设置的反射对象，输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后我们可以用 <code>v.SetFloat()</code> 设置值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyv<span class="selector-class">.SetFloat</span>(<span class="number">7.1</span>)</span><br><span class="line">fmt<span class="selector-class">.Println</span>(v.Interface())</span><br><span class="line">fmt<span class="selector-class">.Println</span>(x)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy7.1</span><br><span class="line">7.1</span><br></pre></td></tr></table></figure><blockquote><p>说明：请记住，修改反射值需要值的地址，以便修改他们的真正值。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以根据条件灵活的调用函数。最大一个优点就是灵活。</li></ul><p>比如函数参数的数据类型不确定，这时可以根据反射来判断数据类型，在调用适当的函数。</p><p>还有比如根据某些条件来调用哪个函数。</p><p>需要根据动态需要来调用函数，可以用反射。</p><blockquote><p>使用反射的 2 个典型场景：1、操作数据库的 ORM 框架 ，2、依赖注入</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>用反射编写的代码比较难以阅读和理解</li><li>反射是在运行时才执行，所以编译期间比较难以发现错误</li><li>反射对性能的影响，比一般正常运行代码慢一到两个数量级。</li></ul><h1 id="不安全但高效的-unsafe"><a href="#不安全但高效的-unsafe" class="headerlink" title="不安全但高效的 unsafe"></a>不安全但高效的 unsafe</h1><p>Go的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<strong>强类型的静态语言</strong>。强类型意味着一旦定义了，类型就不能改变；静态意味着在运行前就做了类型检查。同时出于安全考虑，Go语言是不允许两个指针类型进行转换的。</p><p>我们一般使用 <code>*T</code> 作为一个指针类型，表示一个指向类型 <code>T</code> 变量的指针。基于安全考虑，两个不同的指针类型不能相互转换，比如 <em>int 不能转为 </em>float64。</p><p>go官方是不推荐使用unsafe的操作因为它是不安全的，它绕过了golang的内存安全原则，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。但是在很多地方却是很实用。在一些go底层的包中unsafe包被很频繁的使用。</p><h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"><span class="comment">//ArbitraryType仅用于文档目的，实际上并不是unsafe包的一部分,它表示任意Go表达式的类型。</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="comment">//任意类型的指针，类似于C的*void</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"><span class="comment">//确定结构在内存中占用的确切大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的对其值（字节对齐的原因）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>官方中定义了四个描述：</p><ol><li>任何类型的指针都可以被转化为Pointer</li><li>Pointer可以被转化为任何类型的指针</li><li>uintptr可以被转化为Pointer</li><li>Pointer可以被转化为uintptr</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421155246421.png" alt="image-20240421155246421"></p><h2 id="uintptr-指针类型"><a href="#uintptr-指针类型" class="headerlink" title="uintptr 指针类型"></a>uintptr 指针类型</h2><p>uintptr 也是一种指针类型，它足够大，可以表示任何指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">uintptr</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>既然已经有了 <code>unsafe.Pointer</code>，为什么还要设计 <code>uintptr</code> 类型呢？</p><p>通常<code>Pointer</code>不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，<code>Pointer</code> 是不能做这个运算的，那么谁可以呢？这里要靠 <code>uintptr</code> 类型了，只有将 <code>Pointer</code> 类型先转换成 <code>uintptr</code> 类型，做完地址加减法运算后，再转换成 <code>Pointer</code> 类型，通过*操作达到取值、修改值的目的。</p><p><code>uintptr</code> 是 Go 语言的内置类型，是能存储指针的整型， <code>uintptr</code> 的底层类型是int，它和 <code>unsafe.Pointer</code> 可相互转换。</p><p><code>uintptr</code> 和 <code>unsafe.Pointer</code> 的区别就是：</p><ul><li><code>unsafe.Pointer</code> 只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li><li>而<code>uintptr</code>是用于指针运算的，GC 不把 <code>uintptr</code> 当指针，也就是说 <code>uintptr</code> 无法持有对象， <code>uintptr</code> 类型的目标会被回收；</li><li><code>unsafe.Pointer</code> 可以和 普通指针 进行相互转换；</li><li><code>unsafe.Pointer</code> 可以和 <code>uintptr</code> 进行相互转换。</li></ul><h1 id="slice-为何如此高效"><a href="#slice-为何如此高效" class="headerlink" title="slice 为何如此高效"></a>slice 为何如此高效</h1><p><code>slice</code> 是 <code>Go</code> 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 <code>Go</code> 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 <code>Go</code> 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 <code>slice</code> 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在讲 slice的原理之前，我先来介绍一下数组。几乎所有的编程语言里都存在数组，Go也不例外。那么为什么 Go语言除了数组之外又设计了 slice 呢？要想解答这个问题，我们先来了解数组的局限性。</p><p>一个数组由两部分构成：数组的<strong>大小</strong>和数组内的<strong>元素类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组结构伪代码表示</span></span><br><span class="line">array&#123;</span><br><span class="line"><span class="number">1</span>en</span><br><span class="line">    item <span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个数组被声明，它的大小和内部元素就不能改变，你不能随意地向数组添加任意多个元素。这是数组的<strong>第一个限制</strong>。<br>既然数组的大小是固定的，如果需要使用数组存储大量的数据，就需要提前指定一个合适的大小，比如 100000，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a10：= [<span class="number">100000</span>]<span class="type">string</span>｛<span class="string">&quot;随便寻个地方&quot;</span>｝</span><br></pre></td></tr></table></figure><p>这样虽然可以解决问题，但又带来了另外的问题，那就是内存占用。因为在Go语言中，函数间的传参是值传递的，数组作为参数在各个函数之间被传递的时候，同样的内容就会被一遍遍地复制，这就会造成大量的内存浪费，这是数组的<strong>第二个限制</strong>。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>在上面，我们已经了解到了数组的限制，为了解决这些限制，Go 语言创造了 slice，也就是<strong>切片</strong>。</p><p>切片是对数组的抽象和封装，它的底层是一个数组，存储所有的元素，但是它可以动态地添加元素，容量不足时还可以自动扩容，你完全可以把切片理解为动态数组。在Go语言中，除了长度固定的类型需要使用数组外，大多数情况下都是使用切片。</p><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>通过内置的 <code>append</code> 方法，可以向一个切片中追加任意多个元素，这就可以解决数组的第一个限制了。</p><p>当通过 <code>append</code> 追加元素时，如果切片的容量不够，<code>append</code> 函数会自动扩容。</p><p><code>append</code> 自动扩容的原理是新创建一个底层数组，把原来切片内的元素拷贝到新数组中，然后再返回一个指向新数组的切片。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-3708315c909a8a8a327b733597e66938_720w.webp" alt="img"></p><p>底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><p>切片的本质就是 <code>sliceHeader</code>，又因为函数的参数是值传递，所以传递的是 <code>SliceHteader</code>的副本、而不是底层数组的副本。这时候切片的优势就体现出来了，因为 <code>SiceHteader</code> 的副本内存占用非常少，即使是一个非常大的切片（底层数组有很多元素），也顶多占用24字节的内存，这就解决了大数组在传参时内存浪费的问题。</p><blockquote><p>SliceHeader 的三个字段的类型分别是 uintptr、int 和 int，在64位的机器上，这三个字段最多也就是 int64 类型，一个int64 占8字节，三个int64 占24字节肉存。</p></blockquote><h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><p>如果从集合类型的角度考虑，数组、切片和 map 都是集合类型，因为它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是连续的内存操作，通过索引就可以快速地找到元素存储的地址。</p><p>进一步对比，在数组和切片中，切片又更高效，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 <code>SliceHleader</code> 的三个字段就可以了，共用的还是同一个底层数组。</p><p>切片的高效还体现在 <code>for tange</code> 循环中，因为循环得到的临时变量也是个值拷贝，所以在遍历大的数组时，切片的效率更高。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本周所学基础知识就是上面的三大块内容，额，了解 Go 语言的底层设计就会发现其设计的巧妙性，初学数组和切片时认为单独设计这两个明明差不多的东西有点多此一举。看了它的底层逻辑，有了解了其设计哲学才发现好像是有道理的。</p><p>其实可以回答一个面试官很爱问的问题——为什么要学习 Go 这门语言？</p><p>其实这个问题我已经不止一次地在博客中写了，最开始学习的原因是因为舍友说这门语言有着严格的语法和结构要求，所以每个人写出来的代码都没有太大的区别，所以出于规划自己的代码风格以及缩小自己与大佬的差距，我选择学习Go 语言。</p><p>在开始做 Go 语言项目时，发现这个语言要比 C++ 或者 Python 好用很多，简单的语法、高并发等特性吸引着我去继续做项目。</p><p>现在也已经做了不少关于 Go 语言开发的内容，代码量也有几万行了，也开始关注其设计哲学和底层代码，更是被其严谨性所折服。所有设计出来的东西好像都是必须要有的，既不会多出一些无关紧要的设计，也没有什么必不可少的功能。</p><blockquote><p>不过 Go 语言确实不适合用来刷题，不仅仅是在设计输入输出的时候很麻烦，实现一些功能也是不方便。仅代表个人观点。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>反射：<ul><li><a href="https://www.cnblogs.com/jiujuan/p/17142703.html">https://www.cnblogs.com/jiujuan/p/17142703.html</a></li><li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93">https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93</a></li></ul></li><li>unsafe：<ul><li><a href="https://segmentfault.com/a/1190000021625500">https://segmentfault.com/a/1190000021625500</a></li><li><a href="https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html">https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html</a></li><li><a href="https://xie.infoq.cn/article/6513f7a056774b47c63535fae">https://xie.infoq.cn/article/6513f7a056774b47c63535fae</a></li></ul></li><li>slice：<ul><li><a href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html">https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/61121325">https://zhuanlan.zhihu.com/p/61121325</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。&lt;/p&gt;
&lt;h1 id=&quot;反射&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>聊天室</title>
    <link href="http://example.com/2024/04/20/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>http://example.com/2024/04/20/%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2024-04-20T15:33:55.000Z</published>
    <updated>2024-04-25T08:47:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>这次真成全栈工程师了。第三个 Go 语言项目，简单地实现了一个基于 TCP 连接的聊天室。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425124404153.png" alt="image-20240425124404153"></p><p>实现功能也比较简单，用户输入昵称进入聊天室，进入聊天室后会向其他用户广播，用户可以看到聊天室的所有聊天记录和当前在线人数，支持@其他人，支持敏感词检测。</p><p>由于本项目也是基于书籍中的教程进行的开发，所以在此还是大概记录一下完成该项目学到的东西。</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>本项目最重要的组成之一，本项目便是基于 <code>WebSocket</code> 进行开发的。</p><p> <code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，用于在 <code>Web</code> 应用程序中创建实时、双向的通信通道。</p><p>传统的 <code>HTTP</code> 请求通常是一次请求、一次相应，而 <code>WebSocket</code> 则可以建立一个持久连接，允许服务器即时向客户端推送数据，同时也可以接受客户端发送的数据。 <code>WebSocket</code> 相比于传统的轮询或长轮询方式，能够显著减少网络流量和延迟，提高数据传输的效率和速度。它对实时 <code>Web</code> 应用程序和在线游戏的开发非常有用。</p><p> <code>WebSocket</code> 可以在浏览器和服务器之间建立一条<strong>双向通信</strong>的通道，实现服务器主动向浏览器推送消息，而无需浏览器向服务器不断发送请求。其原理是在浏览器和服务器之间建立一个 “套接字”，通过 “握手” 的方式进行数据传输。由于该协议需要浏览器和服务器都支持，因此需要在应用程序中对其进行判断和处理。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-2070.png" alt="WebSocket 是什么"></p><p>WebSocket 是 HTML5 开始推出的基于 TCP 协议的双向通信协议，其优势在于与 HTTP 协议兼容、开销小、通信高效。WebSocket 让客户端和服务器之间建立连接，并通过这个持久连接实时地进行双向数据传输。</p><p>其实 WebSocket 最主要的特点就是建立了一个可持久化的 TCP 连接，这个连接会一直保留，直到客户端或者服务器发起中断请求为止。WebSocket 通过 HTTP/1.1 协议中的 Upgrade 头信息来告诉服务器，希望协议从 HTTP/1.1 升级到 WebSocket 协议。</p><p>WebSocket 建立在 HTTP 协议之上，所有的 WebSocket 请求都会通过普通的 HTTP 协议发送出去，然后在服务器端根据 HTTP 协议识别特定的头信息 Upgrade，服务端也会判断请求信息中 Upgrade 是否存在。 这里面 HTTP 是必不可少的，不然 WebSocket 根本无法建立。特别的，WebSocket 在握手时采用了 Sec-WebSocket-Key 加密处理，并采用 SHA-1 签名。</p><p>一旦建立了 WebSocket 连接，客户端和服务器端就可以互相发送二进制流或 Unicode 字符串。所有的数据都是经过 mask 处理过的，mask 的值是由服务器端随机生成的。在数据进行发送之前，必须先进行 mask 处理，这样可以有效防止数据被第三方恶意篡改。</p><p>最后需要说明一下的是，WebSocket 的通信协议是基于帧（数据包）的。在数据发送时，一个完整的数据包可以分为多个帧进行发送，而每一个帧都包含了数据的一部分，同时还包含了帧头信息。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="WebSocket-和-HTTP"><a href="#WebSocket-和-HTTP" class="headerlink" title="WebSocket 和 HTTP"></a>WebSocket 和 HTTP</h3><p><code>HTTP</code> 是一个无状态的协议，使客户端向服务器请求资源，并从服务器接受响应。客户端使用 HTTP 请求/响应语法，即请求发送到服务器之后，服务器向客户端返回 HTML 文件、图像和其他媒体内容。</p><p>WebSocket 通信协议尝试在较大范围内改进 Web 实时通信和插件技术，并提供<strong>全双工</strong>、<strong>基于事件</strong>的通信而无需采用低效的轮询方式。开发人员可以从 Web 浏览器的 JS 端轻松地创建 WebSocket 连接并发送数据，进而实现应用程序的实时数据传输的实现。</p><p>由于 WebSocket 是面向消息的，因此它更加适用于实时通信，而 HTTP 更适用于请求和服务器-客户端通信的响应。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/blog_05_11_17_01.png" alt="img"></p><h4 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a><strong>区别总结</strong></h4><ul><li><strong>连接方式不同：</strong> HTTP 是一种单向请求-响应协议，每次请求需要重新建立连接，而 WebSocket 是一种双向通信协议，使用长连接实现数据实时推送。</li><li><strong>数据传输方式不同：</strong> HTTP 协议中的数据传输是文本格式的，而 WebSocket 可以传输文本和二进制数据。</li><li><strong>通信类型不同：</strong> HTTP 主要用于客户端和服务器之间的请求和响应，如浏览器请求网页和服务器返回网页的 HTML 文件。WebSocket 可以实现双向通信，常常用于实时通信场景。</li><li><strong>性能方面不同：</strong> 由于 HTTP 的每次请求都需要建立连接和断开连接，而 WebSocket 可以在一次连接上进行多次通信，WebSocket 在性能上比 HTTP 有优势。</li></ul><h3 id="WebSocket-和-TCP"><a href="#WebSocket-和-TCP" class="headerlink" title="WebSocket 和 TCP"></a>WebSocket 和 TCP</h3><p>WebSocket 和 HTTP 都是基于 TCP 协议的应用层协议。</p><ul><li><strong>层次结构：</strong> WebSocket 是应用层协议，而 TCP 是传输层协议。</li><li><strong>协议特点：</strong> TCP 是一种面向连接的协议，使用三次握手建立连接，提供可靠的数据传输。而 WebSocket 是一种无状态的协议，使用 HTTP 协议建立连接，可以进行双向通信，WebSocket 的数据传输比 TCP 更加轻量级。</li><li><strong>数据格式：</strong> TCP 传输的数据需要自定义数据格式，而 WebSocket 可以支持多种数据格式，如 JSON、XML、二进制等。WebSocket 数据格式化可以更好的支持 Web 应用开发。</li></ul><p><strong>连接方式：</strong> TCP 连接的是物理地址和端口号，而 WebSocket 连接的是 URL 地址和端口号。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-2278.png" alt="img"></p><h3 id="WebSocket-和-Socket"><a href="#WebSocket-和-Socket" class="headerlink" title="WebSocket 和 Socket"></a>WebSocket 和 Socket</h3><h4 id="协议不同"><a href="#协议不同" class="headerlink" title="协议不同"></a><strong>协议不同</strong></h4><p>Socket 是基于传输层 TCP 协议的，而 Websocket 是基于 HTTP 协议的。Socket 通信是通过 Socket 套接字来实现的，而 Websocket 通信是通过 HTTP 的握手过程实现的。</p><h4 id="持久化连接"><a href="#持久化连接" class="headerlink" title="持久化连接"></a><strong>持久化连接</strong></h4><p>传统的 Socket 通信是基于短连接的，通信完成后即断开连接。而 Websocket 将 HTTP 协议升级后，实现了长连接，即建立连接后可以持续通信，避免了客户端与服务端频繁连接和断开连接的过程。</p><h4 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a><strong>双向通信</strong></h4><p>传统的 Socket 通信只支持单向通信，即客户端向服务端发送请求，服务端进行响应。而 Websocket 可以实现双向通信，即客户端和服务端都可以发起消息，实时通信效果更佳。</p><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a><strong>效率</strong></h4><p>Socket 通信具有高效性和实时性，因为传输数据时没有 HTTP 协议的头信息，而 Websocket 除了HTTP协议头之外，还需要发送额外的数据，因此通信效率相对较低。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><p>Socket 适用于实时传输数据，例如在线游戏、聊天室等需要快速交换数据的场景。而 Websocket 适用于需要长时间保持连接的场景，例如在线音视频、远程控制等。</p><h1 id="基础代码框架"><a href="#基础代码框架" class="headerlink" title="基础代码框架"></a>基础代码框架</h1><p>在基本了解 <code>WebSocket</code> 之后，尝试去使用 TCP 和 WebSocket 分别来写一个简单的聊天室。具体代码就不在这里赘述了，可以去下面的参考文献中找一下。</p><p>OK，在基本学习了如何使用 WebSocket 来完成一个聊天室的设计之后，我们来正式开启项目的设计。基础框架和流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/chatroom-design.png" alt="image"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── chatroom</span><br><span class="line">│       └── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── logic</span><br><span class="line">│   ├── broadcast.go</span><br><span class="line">│   ├── message.go</span><br><span class="line">│   └── user.go</span><br><span class="line">├── server</span><br><span class="line">│   ├── handle.go</span><br><span class="line">│   ├── home.go</span><br><span class="line">│   └── websocket.go</span><br><span class="line">└── template</span><br><span class="line">    └── home.html</span><br></pre></td></tr></table></figure><p>相关目录说明如下：</p><ul><li>cmd：该目录几乎是 Go 圈约定俗成的，Go 官方以及开源界推荐的方式，用于存放 main.main；</li><li>logic：用于存放项目核心业务逻辑代码，和 service 目录是类似的作用；</li><li>server：存放 server 相关代码，虽然这是 WebSocket 项目，但也可以看成是 Web 项目，因此可以理解成存放类似 controller 的代码；</li><li>template：存放静态模板文件；</li></ul><h2 id="四个类型"><a href="#四个类型" class="headerlink" title="四个类型"></a>四个类型</h2><p>User：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">UID            <span class="type">int</span>           <span class="string">`json:&quot;uid&quot;`</span></span><br><span class="line">NickName       <span class="type">string</span>        <span class="string">`json:&quot;nickname&quot;`</span></span><br><span class="line">EnterAt        time.Time     <span class="string">`json:&quot;enter_at&quot;`</span></span><br><span class="line">Addr           <span class="type">string</span>        <span class="string">`json:&quot;addr&quot;`</span></span><br><span class="line">MessageChannel <span class="keyword">chan</span> *Message <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">Token          <span class="type">string</span>        <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line"></span><br><span class="line">conn *websocket.Conn</span><br><span class="line"></span><br><span class="line">isNew <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>broadcaster：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcaster 广播器</span></span><br><span class="line"><span class="keyword">type</span> broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 所有聊天室用户</span></span><br><span class="line">users <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 channel 统一管理，可以避免外部乱用</span></span><br><span class="line"></span><br><span class="line">enteringChannel <span class="keyword">chan</span> *User</span><br><span class="line">leavingChannel  <span class="keyword">chan</span> *User</span><br><span class="line">messageChannel  <span class="keyword">chan</span> *Message</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该昵称用户是否可进入聊天室（重复与否）：true 能，false 不能</span></span><br><span class="line">checkUserChannel      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">checkUserCanInChannel <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户列表</span></span><br><span class="line">requestUsersChannel <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">usersChannel        <span class="keyword">chan</span> []*User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给用户发送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 哪个用户发送的消息</span></span><br><span class="line">User    *User     <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">Type    <span class="type">int</span>       <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">Content <span class="type">string</span>    <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">MsgTime time.Time <span class="string">`json:&quot;msg_time&quot;`</span></span><br><span class="line"></span><br><span class="line">ClientSendTime time.Time <span class="string">`json:&quot;client_send_time&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息 @ 了谁</span></span><br><span class="line">Ats []<span class="type">string</span> <span class="string">`json:&quot;ats&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>offlineProcessor：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> offlineProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存所有用户最近的 n 条消息</span></span><br><span class="line">recentRing *ring.Ring</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存某个用户离线消息（一样 n 条）</span></span><br><span class="line">userRing <span class="keyword">map</span>[<span class="type">string</span>]*ring.Ring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>本项目的核心流程分为两个部分，一个是前端的设计，另一个是后端的 API 开发。有关前端的部分我想可能还得一段时间才会去学习，所以这一部分就只写后端的内容。</p><h2 id="新用户来了"><a href="#新用户来了" class="headerlink" title="新用户来了"></a>新用户来了</h2><p>由于在第二个项目中已经把注册登录功能实现的很好了，所以在本聊天室中并未设置注册登录功能，为了方便识别用户，我们简单地要求用户输入昵称。</p><p>昵称在建立 WebSocket 连接时，通过 HTTP 协议传递，因此可以通过 http.Request 获取到。虽然没有注册功能，但依然要解决昵称重复的问题。这里必须引出 Broadcaster 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 所有聊天室用户</span></span><br><span class="line">users <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 channel 统一管理，可以避免外部乱用</span></span><br><span class="line"></span><br><span class="line">enteringChannel <span class="keyword">chan</span> *User</span><br><span class="line">leavingChannel  <span class="keyword">chan</span> *User</span><br><span class="line">messageChannel  <span class="keyword">chan</span> *Message</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该昵称用户是否可进入聊天室（重复与否）：true 能，false 不能</span></span><br><span class="line">checkUserChannel      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">checkUserCanInChannel <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Broadcaster.Broadcast() 在一个单独的 goroutine 中运行，按照 Go 语言的原则，应该通过通信来共享内存。因此，我们定义了 5 个 channel，用于和其他 goroutine 进行通信。</p><ul><li>enteringChannel：用户进入聊天室时，通过该 channel 告知 Broadcaster，即将该用户加入 Broadcaster 的 users 中；</li><li>leavingChannel：用户离开聊天室时，通过该 channel 告知 Broadcaster，即将该用户从 Broadcaster 的 users 中删除，同时需要关闭该用户对应的 messageChannel，避免 goroutine 泄露，后文会讲到；</li><li>messageChannel：用户发送的消息，通过该 channel 告知 Broadcaster，之后 Broadcaster 将它发送给 users 中的用户；</li><li>checkUserChannel：用来接收用户昵称，方便 Broadcaster 所在 goroutine 能够无锁判断昵称是否存在；</li><li>checkUserCanInChannel：用来回传该用户昵称是否已经存在；</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/user-exists-goroutine.png" alt="image"></p><p>两个 goroutine 通过两个 channel 进行通讯，因为 conn goroutine（代表用户连接 goroutine）可能很多，通过这种方式，避免了使用锁。</p><p>如果用户已存在，连接会断开；否则创建该用户的实例（新建 <code>User</code> 类型）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := logic.NewUser(conn, nickname, req.RemoteAddr)</span><br></pre></td></tr></table></figure><p>至此，用户算是进入了聊天室，新用户进入，一方面给 TA 发送欢迎的消息，另一方面需要通知聊天室的其他人，有新用户进来了（新建 <code>Message</code> 类型）。</p><p>接下来看看发送消息的过程，发送消息分两情况，它们的处理方式有些差异：</p><ul><li>给单个用户（当前）用户发送消息</li><li>给聊天室其他用户广播消息</li></ul><p>给当前用户发送消息的情况比较简单：conn goroutine 通过用户实例（User）的字段 MessageChannel 将 Message 发送给 write goroutine。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/send-message-single.png" alt="image"></p><p>给聊天室其他用户广播消息自然需要通过 broadcaster goroutine 来实现：conn goroutine 通过 Broadcaster 的 MessageChannel 将 Message 发送出去，broadcaster goroutine 遍历自己维护的聊天室用户列表，通过 User 实例的 MessageChannel 将消息发送给 write goroutine。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/send-message-broadcast.png" alt="image"></p><h2 id="用户走了"><a href="#用户走了" class="headerlink" title="用户走了"></a>用户走了</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 用户离开</span></span><br><span class="line">logic.Broadcaster.UserLeaving(user)</span><br><span class="line">msg = logic.NewNoticeMessage(user.NickName + <span class="string">&quot; 离开了聊天室&quot;</span>)</span><br><span class="line">logic.Broadcaster.Broadcast(msg)</span><br><span class="line">log.Println(<span class="string">&quot;user:&quot;</span>, nickname, <span class="string">&quot;leaves chat&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据读取时的错误执行不同的 Close</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  conn.Close(websocket.StatusNormalClosure, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;read from client error:&quot;</span>, err)</span><br><span class="line">  conn.Close(websocket.StatusTryAgainLater, <span class="string">&quot;Read from client error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了三件事情：</p><ul><li>在 Broadcaster 中注销该用户；</li><li>给聊天室中其他还在线的用户发送通知，告知该用户已离开；</li><li>根据 err 处理不同的 Close 行为。关于 Close 的 Status 可以参考 rfc6455 的 第 7.4 节；</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>Go 不是完全面向对象的语言，只支持部分面向对象的特性。面向对象中的单例模式是一个常见、简单的模式。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该模式规定一个类只允许有一个实例，而且自行实例化并向整个系统提供这个实例。因此单例模式的要点有：</p><ol><li>只有一个实例；</li><li>必须自行创建；</li><li>必须自行向整个系统提供这个实例。</li></ol><p>单例模式主要避免一个全局使用的类频繁地创建与销毁。当你想控制实例的数量，或有时候不允许存在多实例时，单例模式就派上用场了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/singleton.png" alt="image"></p><p>通过该类图我们可以看出，实现一个单例模式有如下要求：</p><ul><li>私有、静态的类实例变量；</li><li>构造函数私有化；</li><li>静态工厂方法，返回此类的唯一实例；</li></ul><p>根据实例化的时机，单例模式一般分成饿汉式和懒汉式。</p><ul><li>饿汉式：在定义 instance 时直接实例化，private static Singleton instance = new Singleton();</li><li>懒汉式：在 getInstance 方法中进行实例化；</li></ul><p>那两者有什么区别或优缺点？</p><ul><li>饿汉式单例类在自己被加载时就将自己实例化。即便加载器是静态的，饿汉式单例类被加载时仍会将自己实例化。单从资源利用率角度讲，这个比懒汉式单例类稍差些。从速度和反应时间角度讲，则比懒汉式单例类稍好些。</li><li>然而，懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器在实例化时必须涉及资源初始化，而资源初始化很有可能耗费时间。这意味着出现多线程同时首次引用此类的几率变得较大。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Instance = <span class="built_in">new</span>(singleton)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> Add() <span class="type">int</span> &#123;</span><br><span class="line">  s.count++</span><br><span class="line">  <span class="keyword">return</span> s.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line">c := singleton.Instance.Add()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  instance *singleton</span><br><span class="line">  mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">  mutex.Lock()</span><br><span class="line">  <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">    instance = <span class="built_in">new</span>(singleton)</span><br><span class="line">  &#125;</span><br><span class="line">  mutex.Unlock()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> Add() <span class="type">int</span> &#123;</span><br><span class="line">  s.count++</span><br><span class="line">  <span class="keyword">return</span> s.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><p>单例模式同时解决了两个问题， 所以违反了<strong>单一职责原则</strong>：</p><ol><li><p><strong>保证一个类只有一个实例</strong>。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p><p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p><p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/singleton-comic-1-zh.png" alt="一个对象的全局访问节点"></p><ol><li><p><strong>为该实例提供一个全局访问节点</strong>。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p><p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p><p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p></li></ol><h1 id="goroutine-泄露"><a href="#goroutine-泄露" class="headerlink" title="goroutine 泄露"></a>goroutine 泄露</h1><p>在 Go 中，goroutine 的创建成本低廉且调度效率高。Go 运行时能很好的支持具有成千上万个 goroutine 的程序运行，数十万个也并不意外。但是，goroutine 在内存占用方面却需要谨慎，内存资源是有限的，因此你不能创建无限的 goroutine。</p><p>每当你在程序中使用 go 关键字启动 goroutine 时，你必须知道该 goroutine 将在何时何地退出。如果你不知道答案，那可能会内存泄漏。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>造成goroutine泄露的几个原因：</p><ul><li><ol><li>从 channel 里读，但是同时没有写入操作</li></ol></li><li><ol><li>向 无缓冲 channel 里写，但是同时没有读操作</li></ol></li><li><ol><li>向已满的 有缓冲 channel 里写，但是同时没有读操作</li></ol></li><li><ol><li>select操作在所有case上都阻塞()</li></ol></li><li><ol><li>goroutine进入死循环，一直结束不了</li></ol></li></ul><p>可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。</p><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><h3 id="生产者消费者场景"><a href="#生产者消费者场景" class="headerlink" title="生产者消费者场景"></a>生产者消费者场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;newRandStream closure exited.&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"><span class="comment">// 死循环：不断向channel中放数据，直到阻塞</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">randStream &lt;- rand.Int()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">randStream := newRandStream()</span><br><span class="line">fmt.Println(<span class="string">&quot;3 random ints:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只消耗3个数据，然后去做其他的事情，此时生产者阻塞，</span></span><br><span class="line"><span class="comment">// 若主goroutine不处理生产者goroutine，则就产生了泄露</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %d\n&quot;</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产协程进入死循环，不断产生数据。消费协程，也就是主协程只消费期中的 3 个值，然后主协程就再也不消费 <code>channel</code> 中的数据，去做其他事情了。此时生产协程放了一个数据到 <code>channel</code> 中，但已经不会有协程消费该数据，所以生产协程阻塞。此时，若没有人再消费 <code>channel</code> 中的数据，生产协程是被泄露的协程</p><p><strong>解决方法：</strong></p><p>总的来说，要解决channel引起的goroutine leak问题，主要是看在channel阻塞goroutine时，该goroutine的阻塞是正常的，还是可能导致协程永远没有机会执行。若可能导致协程永远没有机会执行，则可能会导致协程泄露。 所以，在创建协程时就要考虑到它该如何终止。</p><p>解决一般问题的办法就是，当主线程结束时，告知生产线程，生产线程得到通知后，进行清理工作：或退出，或做一些清理环境的工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;newRandStream closure exited.&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> randStream &lt;- rand.Int():</span><br><span class="line"><span class="keyword">case</span> &lt;-done:  <span class="comment">// 得到通知，结束自己</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">randStream := newRandStream(done)</span><br><span class="line">fmt.Println(<span class="string">&quot;3 random ints:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %d\n&quot;</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知子协程结束自己</span></span><br><span class="line">    <span class="comment">// done &lt;- struct&#123;&#125;&#123;&#125;</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line"><span class="comment">// Simulate ongoing work</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，协程通过一个channel来得到结束的通知，这样它就可以清理现场。防止协程泄露。 通知协程结束的方式，可以是发送一个空的struct，更加简单的方式是直接close channel。如上图所示。</p><h3 id="master-work-场景"><a href="#master-work-场景" class="headerlink" title="master work 场景"></a>master work 场景</h3><p>在该场景下，我们一般是把工作划分成多个子工作，把每个子工作交给每个goroutine来完成。此时若处理不当，也是有可能发生goroutine泄漏的。我们来看一下实际的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function to add an array of numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker_adder</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// writes the sum to the go routines.</span></span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// spin up a goroutine.</span></span><br><span class="line"><span class="keyword">go</span> worker_adder(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c1)</span><br><span class="line"><span class="comment">// spin up a goroutine.</span></span><br><span class="line"><span class="keyword">go</span> worker_adder(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//x, y := &lt;-c1, &lt;-c2 // receive from c1 aND C2</span></span><br><span class="line">x, _:= &lt;-c1</span><br><span class="line"><span class="comment">// 输出从channel获取到的值</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在主协程中，把一个数组分成两个部分，分别交给两个worker协程来计算其值，这两个协程通过channel把结果传回给主协程。 但，在以上代码中，我们只接收了一个channel的数据，导致另一个协程在写channel时阻塞，再也没有执行的机会。 要是我们把这段代码放入一个常驻服务中，看的更加明显：</p><h3 id="http-server-场景"><a href="#http-server-场景" class="headerlink" title="http server 场景"></a>http server 场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数组s中的数字加起来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumInt</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP handler for /sum</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumConcurrent2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sumInt(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c1)</span><br><span class="line"><span class="keyword">go</span> sumInt(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里故意不在c2中读取数据，导致向c2写数据的协程阻塞。</span></span><br><span class="line">x := &lt;-c1</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the response.</span></span><br><span class="line">fmt.Fprintf(w, strconv.Itoa(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">StasticGroutine := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">total := runtime.NumGoroutine()</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> StasticGroutine()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/sum&quot;</span>, sumConcurrent2)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:8001&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行以上程序，并在浏览器中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8001/sum</span><br></pre></td></tr></table></figure><p>并不断刷新浏览器，来不断发送请求，可以看到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>这个输出是我们的http server的协程数量，可以看到：每请求一次，协程数就增加一个，而且不会减少。说明已经发生了协程泄露(goroutine leak)。</p><p><strong>解决方法：</strong></p><p>解决的办法就是不管在任何情况下，都必须要有协程能够读写channel，让协程不会阻塞。 </p><h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMessage</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle `s`</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Minute):</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在标准库 time.After 的文档中有一段说明：</p><blockquote><p>等待持续时间过去，然后在返回的 channel 上发送当前时间。它等效于 NewTimer().C。在计时器触发之前，计时器不会被垃圾收集器回收。</p></blockquote><p>所以，如果还没有到 5 分钟，该函数返回了，计时器就不会被 GC 回收，因此出现了内存泄露。因此大家使用 time.After 时一定要仔细，一般建议不用它，而是使用 time.NewTimer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMessage</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">idleDuration := <span class="number">5</span> * time.Minute</span><br><span class="line">idleDelay := time.NewTimer(idleDuration)</span><br><span class="line">  <span class="comment">// 这句必须的</span></span><br><span class="line"><span class="keyword">defer</span> idleDelay.Stop()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">idleDelay.Reset(idleDuration)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle `s`</span></span><br><span class="line"><span class="keyword">case</span> &lt;-idleDelay.C:</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="敏感词处理"><a href="#敏感词处理" class="headerlink" title="敏感词处理"></a>敏感词处理</h1><p>任何由用户产生内容的公开软件，都必须做好敏感词的处理。作为一个聊天室，当然要处理敏感词。</p><p>其实敏感词（包括广告）检测一直以来都是让人头疼的话题，很多大厂，比如微信、微博、头条等，每天产生大量内容，它们在处理敏感词这块，会投入很多资源。所以，这不是一个简单的问题，本书不可能深入探讨，但尽可能多涉及一些相关内容。</p><p>一般来说，目前敏感词处理有如下方法：</p><ul><li>简单替换或正则替换</li><li>DFA（Deterministic Finite Automaton，确定性有穷自动机算法）</li><li>基于朴素贝叶斯分类算法</li></ul><h2 id="简单替换或正则替换"><a href="#简单替换或正则替换" class="headerlink" title="简单替换或正则替换"></a>简单替换或正则替换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. strings.Replace</span></span><br><span class="line">keywords := []<span class="type">string</span>&#123;<span class="string">&quot;坏蛋&quot;</span>, <span class="string">&quot;坏人&quot;</span>, <span class="string">&quot;发票&quot;</span>, <span class="string">&quot;傻子&quot;</span>, <span class="string">&quot;傻大个&quot;</span>, <span class="string">&quot;傻人&quot;</span>&#125;</span><br><span class="line">content := <span class="string">&quot;不要发票，你就是一个傻子，只会发呆&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, keyword := <span class="keyword">range</span> keywords &#123;</span><br><span class="line">  content = strings.ReplaceAll(content, keyword, <span class="string">&quot;**&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. strings.Replacer</span></span><br><span class="line">replacer := strings.NewReplacer(<span class="string">&quot;坏蛋&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;坏人&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;发票&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻子&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻大个&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻人&quot;</span>, <span class="string">&quot;**&quot;</span>)</span><br><span class="line">fmt.Println(replacer.Replace(<span class="string">&quot;不要发票，你就是一个傻子，只会发呆&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: 不要**，你就是一个**，只会发呆</span></span><br></pre></td></tr></table></figure><p>类似于上面的代码（两种代码类似），我们会使用一个敏感词列表（坏蛋、发票、傻子、傻大个、傻人），来对目标字符串进行检测与替换。比较适合于敏感词列表和待检测目标字符串都比较小的场景，否则性能会有较大影响。（正则替换和这个是类似的）</p><h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>DFA全称为：Deterministic Finite Automaton,即确定有穷自动机。其特征为：有一个有限状态集合和一些从一个状态通向另一个状态的边，每条边上标记有一个符号，其中一个状态是初态，某些状态是终态。但不同于不确定的有限自动机，DFA中不会有从同一状态出发的两条边标志有相同的符号。</p><p>敏感词过滤很适合用DFA算法，用户每次输入都是状态的切换，如果出现敏感词，既是终态，就可以结束判断。</p><p>我们把数组形式的敏感词整理为一个树状结构，准确的说是一个森林。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sensitive-tree.png" alt="image"></p><p>这样查找敏感词就变成了一个查找路径的问题，如果用户输入的内容中包含一个从根节点到叶子节点的完整路径，就说明包含敏感词。</p><p>算法实现逻辑是循环用户输入的字符串，依次查找每个字符是否出现在树的节点上，比如用户输入“你是傻大个”，从第一个字开始判断，“你”不在树的根节点上，进入下一步，“是”也不在根节点上，进入下一步，“傻”出现在了根节点上，这时状态切换，下一步的查找范围变为“傻”的子节点；“大”出现在子节点中，状态再次切换为“大”的子节点；“个”出现在子节点中，并且为叶子节点，所以包含敏感词。</p><h2 id="基于朴素贝叶斯分类算法"><a href="#基于朴素贝叶斯分类算法" class="headerlink" title="基于朴素贝叶斯分类算法"></a>基于朴素贝叶斯分类算法</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。这是一种“半学习”形式的方法，它的准确性依赖于先验概率的准确性。</p><p><strong>敏感词检测步骤：</strong></p><ol><li>分词：对获取的评论进行分词处理，采用的是jieba分词</li><li>去除无意义词：采用的是哈工大的词表，遍历每一条评论，判断是否在无用词表（这里主要包含特殊字符，标点符号，感叹词等）中，从而达到去除无意词的效果</li><li>通过评论建立自己的词库，采用并集处理，达到词库中词的唯一性</li><li>建立向量：将去除无意词后的评论装换成稀疏矩阵，采用的是多项式模型，这里考虑到评论一般都比较短小，相对来说，几乎每一个词都会影响到最终的判断，所以采用多项式模型，而没有采用伯努利模型</li><li>划分训练集和测试集：采用random.shuffle()函数将数据随机排序，然后再通过切片处理划分数据，为了保证每条评论与其对应的标签保持一致，采用zip()函数将评论和标签绑定在一起</li><li>调用sklearn里面内置的贝叶斯算法接口</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里本项目也已经基本完成了，就行文章开始写的那样，这并不是一片详细的教程，只是用来记录一下完成这个项目所学到的东西。</p><p>总的来说，这个项目的教程写的也不是很详细，很多函数的实现还是要自己去完成，但是核心的内容作者都会很详细地解释，而且重要的内容其实都可以搜到。</p><p>现在我知道为什么这个项目是基于 TCP，而不是 UDP 的了。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>WebSocket：</p><ul><li><a href="https://apifox.com/apiskills/what-is-websocket/">https://apifox.com/apiskills/what-is-websocket/</a></li><li><a href="https://apifox.com/apiskills/websocket-socket-tcp-http/">https://apifox.com/apiskills/websocket-socket-tcp-http/</a></li><li><a href="https://xie.infoq.cn/article/1b9128d59e2538604e441bc53">https://xie.infoq.cn/article/1b9128d59e2538604e441bc53</a></li></ul><p>单例模式：</p><ul><li><a href="https://refactoringguru.cn/design-patterns/singleton">https://refactoringguru.cn/design-patterns/singleton</a></li></ul><p>goroutine 泄露：</p><ul><li><a href="https://hoverzheng.github.io/post/technology-blog/go/goroutine-leak%E5%92%8C%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/">https://hoverzheng.github.io/post/technology-blog/go/goroutine-leak%E5%92%8C%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/</a></li><li><a href="https://segmentfault.com/a/1190000040161853">https://segmentfault.com/a/1190000040161853</a></li></ul><p>敏感词检测：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/505941559">https://zhuanlan.zhihu.com/p/505941559</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次真成全栈工程师了。第三个 Go 语言项目，简单地实现了一个基于 TCP 连接的聊天室。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-2024042512</summary>
      
    
    
    
    <category term="聊天室" scheme="http://example.com/categories/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub——日志</title>
    <link href="http://example.com/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-18T14:50:36.000Z</published>
    <updated>2024-04-20T15:32:58.411Z</updated>
    
    <content type="html"><![CDATA[<p>正经人谁写日记啊？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image" alt="img"></p><p>欸欸欸，不好意思，来错片场了（手动狗头）。今天介绍的是项目中必不可少的一部分——日志。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>虽然正经人不写日记，但是正经项目一定要记录日志。总所周知啊，Gohub 就是一个非常正经的项目，虽然还没有到企业级这么高的层次，但是也差不多了。</p><p>在 Gohub 中，我们使用日志来记录整个系统的运行情况，可能但不限于：</p><ul><li>HTTP 请求数据</li><li>数据库 SQL 请求日志</li><li>Panic/Error 错误日志</li><li>请求第三方接口日志（发送短信、发送邮件等）</li><li>……</li></ul><p>好了，是时候掏出祖传的几个问题了，什么是日志？该怎么设置日志？下面将会一一解答。</p><h2 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h2><p>日志系统是一种记录系统活动、事件或消息的工具或机制。在计算机领域，日志系统通常用于记录应用程序、操作系统或者其他软件系统的运行时信息。这些信息可以包括错误、警告、调试信息、用户操作记录等等。</p><p>日志系统的主要目的是帮助开发人员或管理员了解系统的状态和运行情况，以便进行故障排除、性能优化、安全审计等工作。通过分析日志，可以追踪问题的根源，监视系统的健康状况，并且可以在系统发生故障或异常时进行及时的响应和处理。</p><p>日志系统通常具有以下特点：</p><ol><li><strong>可配置性：</strong> 可以根据需求配置日志记录的级别、格式、存储位置等参数。</li><li><strong>实时性：</strong> 能够实时记录系统的运行状态，以便及时发现问题。</li><li><strong>可扩展性：</strong> 能够处理大量的日志数据，并支持水平扩展以应对不断增长的系统负载。</li><li><strong>安全性：</strong> 对日志数据进行安全存储和访问控制，以防止未经授权的访问或篡改。</li><li><strong>分析性：</strong> 提供日志分析工具或接口，帮助用户对日志数据进行搜索、过滤、统计、可视化等操作。</li></ol><p>常见的日志系统包括开源项目如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk、Fluentd等，以及云服务提供商提供的日志管理服务。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>本地开发</strong></p><p>本地开发时，虽然我们可以很方便地使用 Debuger 来调试程序，但是日志将会是我们最廉价】最便捷地作物定位工具。</p><p><strong>线上环境</strong></p><p>日志是程序在生产环境下的健康监控。当程序出错时，或者某块业务逻辑出现问题，我们将依赖日志来知道具体哪一行代码出了问题。</p><p><strong>如何记录？</strong></p><div class="table-container"><table><thead><tr><th>使用环境</th><th>记录的载体</th><th>说明</th></tr></thead><tbody><tr><td>开发环境（local）</td><td>命令行终端</td><td>高亮、打印调用堆栈</td></tr><tr><td>线上环境（production）</td><td>记录到日志文件</td><td>JSON 格式，方便导入专业的日志工具</td></tr></tbody></table></div><p>日志系统在计算机领域有广泛的使用场景，以下是一些常见的应用场景：</p><ol><li><p><strong>故障排查与调试：</strong> 当系统出现错误或异常时，日志可以记录错误信息、异常堆栈跟踪等，帮助开发人员快速定位并修复问题。</p></li><li><p><strong>性能优化：</strong> 通过分析系统的性能日志，可以了解系统各个组件的性能瓶颈，从而进行优化，提升系统整体性能。</p></li><li><p><strong>安全审计与监控：</strong> 日志记录系统的操作、访问权限、安全事件等信息，有助于进行安全审计和监控，及时发现潜在的安全威胁。</p></li><li><p><strong>用户行为分析：</strong> 在网络应用或移动应用中，记录用户的操作行为可以帮助分析用户偏好、行为趋势，从而进行个性化推荐、用户体验优化等工作。</p></li><li><p><strong>合规性需求：</strong> 许多行业或政府监管机构要求企业记录和保留特定类型的数据，日志系统可以满足这些合规性需求，并提供必要的审计跟踪。</p></li><li><p><strong>容灾备份与恢复：</strong> 日志记录系统的备份和恢复功能可以帮助恢复因硬件故障、自然灾害或人为错误导致的数据丢失或损坏。</p></li><li><p><strong>业务分析与决策支持：</strong> 通过分析系统产生的日志数据，可以了解业务运营情况、用户行为趋势等，为业务决策提供数据支持。</p></li><li><p><strong>监控与警报：</strong> 基于日志数据设定监控规则，当系统出现异常或达到预定的阈值时，触发警报并通知相关人员进行处理。</p></li></ol><p>这些场景只是日志系统的一部分应用，实际上日志系统在各个领域都有着重要的作用，帮助保障系统的稳定性、安全性和可靠性。</p><h2 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h2><p>日志系统通常定义了不同的日志等级，用于标识和区分不同类型的日志信息，常见的日志等级包括：</p><div class="table-container"><table><thead><tr><th>日志等级</th><th>说明</th></tr></thead><tbody><tr><td><strong>debug</strong></td><td>信息量大，一般调试时打开。<strong>系统模块详细运行的日志</strong>，例如 HTTP 请求、数据库请求、发送邮件、发送短信</td></tr><tr><td><strong>info</strong></td><td><strong>业务级别的运行日志</strong>，如用户登录、用户退出、订单撤销。</td></tr><tr><td><strong>warn</strong></td><td><strong>感兴趣、需要引起关注的信息。</strong> 例如，调试时候打印调试信息（命令行输出会有高亮）。</td></tr><tr><td><strong>error</strong></td><td><strong>记录错误信息</strong>，用于记录程序发生的错误，这些错误可能导致程序无法正常工作，但不会使程序完全崩溃。Panic 或者 Error。如数据库连接错误、HTTP 端口被占用等。一般生产环境使用的等级。</td></tr></tbody></table></div><p><strong>日志等级规则：</strong></p><ul><li>日志等级在两个地方使用；<ul><li>配置信息（config）中可以配置日志等级；</li><li>代码中调用不同的方法（<code>Debug()</code>、<code>Info()</code>…）记录不同等级的日志。</li></ul></li><li>日志等级具备<strong>过滤信息</strong>的属性；</li><li>配置信息里设置为高等级时，低于这个等级的信息将忽略。如日志等级设为 <strong>warn</strong> ，只有 <code>Warn()</code> 和 <code>Error()</code> 方法记录的日志会有效，<code>Debug()</code> 和 <code>Info()</code> 方法记录的日志会被忽略；</li></ul><h2 id="日志过载"><a href="#日志过载" class="headerlink" title="日志过载"></a>日志过载</h2><p>日志过载是指日志系统产生的日志数量超出了处理能力或存储容量，导致系统无法有效地处理和存储所有的日志信息。这种情况可能会对系统的性能、稳定性和安全性造成负面影响。</p><p>日志过载可能出现在以下几种情况下：</p><ol><li><p><strong>异常情况爆发：</strong> 当系统遭遇大规模的异常或错误时，日志系统可能会产生大量的错误日志，导致日志系统过载。</p></li><li><p><strong>频繁的警告信息：</strong> 如果系统产生大量的警告信息，而这些警告信息又被记录在日志中，就会增加日志系统的负担。</p></li><li><p><strong>日志频率过高：</strong> 如果系统的日志频率过高，比如记录了过多的调试信息或者每个请求都生成了大量的日志记录，就会导致日志系统过载。</p></li><li><p><strong>存储容量不足：</strong> 如果日志系统的存储容量不足以存储所有的日志数据，就会导致部分日志被丢弃或被覆盖，从而丧失了一部分重要的信息。</p></li><li><p><strong>日志记录不当：</strong> 如果日志记录的内容过于冗长或者包含了大量的无关信息，会增加日志系统的负担，导致日志过载。</p></li></ol><p>日志过载可能会导致以下问题：</p><ul><li><strong>性能下降：</strong> 过多的日志记录会占用系统资源，降低系统的性能和响应速度。</li><li><strong>数据丢失：</strong> 如果日志系统无法处理所有的日志数据，部分重要的日志信息可能会被丢弃，导致问题的排查和分析变得困难。</li><li><strong>安全风险：</strong> 日志过载可能会导致系统无法及时记录和响应安全事件，增加系统遭受攻击的风险。</li></ul><p>为了避免日志过载，需要合理配置日志系统的参数，包括日志等级、存储策略、日志格式等，并定期清理和归档历史日志数据，确保日志系统能够有效地处理和存储日志信息。</p><p>记录日志的行为完全掌控在开发者手上。日志等级的错误使用，会导致<strong>日志信息过载</strong>，有违『快速定位问题』的设计初衷。</p><p>所以记录日志时，参与项目的开发者之间需要做好约定，或者说<strong>规范</strong>。</p><ul><li>功能模块的详细运行情况，使用 <code>Debug()</code> 方法，如 HTTP 请求日志、数据库 SQL 日志；</li><li>业务级别的运行日志，使用 <code>Info()</code>，如果信息量太大，例如说一个请求会记录十几条 <code>Info()</code> 日志，要改用 <code>Debug()</code>；</li><li>控制好记录日志的量，切勿滥用，滥用会导致日志信息过载；</li><li>开发调试时，使用 <code>Warn()</code> ，调试完成后记得删除调试信息；</li><li>保持 warn 及以上日志级别的干净；</li><li>线上环境开启 error 等级，接到错误反馈时，再开启 debug 进行调试，调试完成后重新设置为 error 等级，保持线上日志的干净；</li><li>系统运行出错，才能使用 <code>Error()</code> 记录，如数据库连接出错，或出现 500 错误。</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在开发 Go 项目时，我们的项目目录下经常会出现一些文件，例如编译文件、log 文件、编辑器配置文件、系统生成的一些文件，这些文件我们不希望提交到代码仓库中。</p><p>在任何当前工作的 Git 仓库中，每个文件都是这样的：</p><ul><li><strong>追踪的（tracked）</strong>- 这些是 Git 所知道的所有文件或目录。这些是新添加（用 <code>git add</code> 添加）和提交（用 <code>git commit</code> 提交）到主仓库的文件和目录。</li><li><strong>未被追踪的（untracked）</strong> - 这些是在工作目录中创建的，但还没有被暂存（或用 <code>git add</code> 命令添加）的任何新文件或目录。</li><li><strong>被忽略的（ignored）</strong> - 这些是 Git 知道的要全部排除、忽略或在 Git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 Git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。</li></ul><p>所有被忽略的文件都会被保存在一个 <code>.gitignore</code> 文件中。</p><p><code>.gitignore</code> 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。</p><p>在 <code>.gitignore</code> 中，可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。也可以用同样的方法告诉 Git 忽略多个文件或文件夹。</p><h2 id="配置信息的设置"><a href="#配置信息的设置" class="headerlink" title="配置信息的设置"></a>配置信息的设置</h2><p>在项目中，配置信息通常指的是一些参数、选项或设置，这些信息用于指导项目的行为、功能或外部依赖的配置。</p><p>Gohub 中的配置信息，将分为两个层级：</p><ul><li>env</li><li>config</li></ul><h3 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h3><p>一般来讲，项目会运行在多个环境下，例如：</p><ul><li>local —— 本地开发环境（我的机器上、其他开发同事的机器上）</li><li>testing —— 自动化测试环境</li><li>stage —— 接近线上环境的测试环境，方便其他成员访问和测试（编辑人员、产品经理、项目经理）</li><li>production —— 线上生产环境</li></ul><p>不同的环境下，我们将使用不同的配置。例如 local 环境里，发送短信使用的是测试账号，production 环境下，我们将使用验证了公司信息的发信账号。</p><p><code>.env</code> 文件通常用于存储环境变量和敏感配置信息，它的作用包括：</p><ol><li><strong>配置管理：</strong> <code>.env</code> 文件可以用来集中管理项目的配置信息，如数据库连接信息、API 密钥、密码、密钥等。将这些配置信息存储在 <code>.env</code> 文件中有助于统一管理，减少硬编码，提高项目的灵活性和可维护性。</li><li><strong>环境分离：</strong> 使用 <code>.env</code> 文件可以将不同环境（如开发环境、测试环境和生产环境）的配置信息分离开来，避免在代码中硬编码不同环境下的配置，提高代码的可移植性和可重用性。</li><li><strong>安全性：</strong> <code>.env</code> 文件通常位于项目根目录之外，并且可以通过 <code>.gitignore</code> 文件排除在版本控制系统中，从而保护敏感信息不被泄露到公共代码仓库中，提高项目的安全性。</li><li><strong>便捷性：</strong> 通过 <code>.env</code> 文件，可以方便地修改和管理项目的配置信息，无需修改源代码，减少了部署和维护的复杂性。</li><li><strong>跨平台兼容性：</strong> <code>.env</code> 文件的格式通常是简单的键值对格式，易于解析和处理，可以跨多种编程语言和操作系统使用。</li></ol><hr><p>单独的 .env 的设计，是满足一台机器一套环境变量的需求。<strong>多个 .env 文件是满足一台机器上运行多套环境变量的需求</strong>。</p><p>开发时，除了 local 环境变量，很多时候还需要 testing 测试相关的环境变量，testing 的配置有别于 local 。例如测试时，一般需要使用不同的数据库，这样才能不污染我们的开发数据库。</p><p>我们可以利用程序参数，在命令行运行主程序时，传参 <code>--env=testing</code> 的参数，程序接收到这个参数后会读取 <strong>.env.testing</strong> 文件，而不是 <code>.env</code> 文件。</p><p><code>--env</code> 的参数不需要限制值，取到以后直接读取对应的文件即可。以下是几个例子：</p><ul><li><code>--env=testing</code> 读取 <strong>.env.testing</strong> 文件，用以在测试环境使用不同的数据库</li><li><code>--env=production</code> 读取 <strong>.env.production</strong> 文件，用以在本地环境中调试线上的第三方服务配置信息（短信、邮件）</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 是将配置信息存放于 config 目录下，按照单独的逻辑区分单独的配置文件，例如数据库连接信息存放于 config/database.go 文件下。</p><p>config 里加载 .env 里的配置项，且可设置缺省值。</p><p><strong>既然有 .env 文件，为何还要 config 呢？</strong></p><p>config 可以提高配置方案灵活度。在 config 里，我们可以为每个配置项设置默认值。也可以做一些简单的数学运算，或者调用 Go 函数进行默认值的处理。我们甚至可以为配置项设置一个回调函数。</p><p>config 文件是要加入代码版本控制器中的，这些代码是固定的。如果要修改一个 config 配置项，就修改其对应的 .env 文件中的配置项即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文较短，主要记录了在 Gohub 开发设计日志时学到的相关的知识。其实在这个项目中用户使用的功能并没有什么太大的变化，即使增加了一些功能也都只是一种变式，核心并没有发生太大的变化，因此也就没有像之前一样逐个功能地去记录。那为什么还要去做新的项目呢，主要是因为舍友吧两个教程都买了，白嫖完了第一个肯定要继续白嫖第二个了。</p><p>做完第二个项目发现虽然一个叫 Gohub，一个叫 Goblog，两个看起来好像一样，但是实际开发地体验简直就是天上地下。Goblog 入门项目开发，学习怎么搭建 Web 应用；Gohub 才是真正的后端开发，更加专业，也让我学到了更多的东西。后悔啊，为什么上学期开始学 Go 的时候不好好写项目呢，要不然面试的时候也不会被拷打的那么惨了。不过这两个月确实还是学到了不少东西，比前两年半（没有玩梗，非常认真）加一起的都多了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>传统艺能了，每篇文章都像一个模子里刻出来的，不过本文并没有参考什么文章，只参考了教程和 ChatGPT的回答。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正经人谁写日记啊？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image&quot; alt=</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub——注册</title>
    <link href="http://example.com/2024/04/16/Gohub%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/"/>
    <id>http://example.com/2024/04/16/Gohub%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/</id>
    <published>2024-04-16T07:18:28.000Z</published>
    <updated>2024-04-18T15:00:18.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍新项目中第一部分的内容——身份验证接口的设计思路。</p><p>身份验证接口主要包括以下模块：</p><ul><li>注册</li><li>登录</li><li>找回密码</li></ul><p>基本流程为：</p><ol><li>填写手机号或者邮箱</li><li>填写图片验证码中的内容</li><li>填写数字验证码以完成身份验证</li><li>操作完成</li></ol><h1 id="双重验证"><a href="#双重验证" class="headerlink" title="双重验证"></a>双重验证</h1><p>在调用接口时，用户需要完成图片验证码 + 短信验证码，我们在日常使用相关的功能时也是采用这样的双重验证的策略。那我们为什么要用这么繁琐的验证方式呢？在了解为什么之前，我们先来看以下这两种验证码的作用。</p><ul><li>图片验证码 —— 区分机器人和正常用户</li><li>数字验证码——区分用户是否为手机号或邮箱的主人</li></ul><p>采用双重验证，主要还是考虑到开放注册登录接口所带来的安全隐患。在知道了这两种验证码的作用后，我们来看缺少了其中一种会带来什么样的安全隐患。</p><p>黑客容易利用的地方，大致可以分为两部分：</p><ul><li>滥用</li><li>暴力破解</li></ul><h2 id="滥用-轰炸机"><a href="#滥用-轰炸机" class="headerlink" title="滥用(轰炸机)"></a>滥用(轰炸机)</h2><p>删除图片验证，保留短信验证。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>短信验证码轰炸一般基于web方式，主要有两个模块组成：一个前端web网页，提供输入被攻击者手机号码的输入窗口；一个后台攻击页面(如PHP)，利用从各个网站上找到的动态短信URL 和前端输入的被攻击者手机号码，发送HTTP 请求，每次请求给用户发送一个动态短信。原理和实施过程如下：</p><ol><li><p>恶意攻击者在前端中输入被攻击者的手机号；</p></li><li><p>短信炸弹后台服务器，将该手机号与互联网收集的可不需要经过认证即可发送动态短信的URL 进行组合，形成可发送动态短信的URL 请求；</p></li><li>通过后台请求页面，伪造用户的请求发给不同的业务服务器；</li><li>业务服务器收到该请求后，发送动态短信到被攻击用户的手机上。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8ad9cb41-13ad-4bf7-aba9-dbec5c3e6d4c.jpg" alt="img"></p><p>GitHub 上也有一些轰炸机的项目，例如这个 <a href="https://github.com/shellvon/smsBomb/blob/master/config/sms.json">github.com/shellvon/smsBomb/blob/m…</a> ，门槛非常低。</p><p>轰炸机的配置示例：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/CcqRHrK7Fa.png!large" alt="身份验证接口设计"></p><h3 id="如何防治"><a href="#如何防治" class="headerlink" title="如何防治"></a>如何防治</h3><p>短信炸弹形成的原因是因为非授权的动态短信获取，由于在使用动态短信业务前系统并不能建立业务关联。因此，在未建立业务关联的情况下，需要进一步严格限制保证业务使用的安全性。可以采用增加<strong>图形验证码</strong>、<strong>限制单IP请求次数</strong>、<strong>限制用户短信请求间隔</strong>等方式，保护短信通道。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7bca2ddb-f4b1-44e6-b9c7-8d5b5e490a67.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/5b7d30bd-3ed2-4cde-b210-3d1ed5d78ba0.png" alt="img"></p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>用户使用密码登录时，很容易被黑客暴力破解。</p><p>所谓暴力破解，就是针对某个用户名，不断尝试可能出现的密码，直到最终成功登录。</p><p>互联网上有大量的常用密码词典，GitHub 上随便一搜就能找到如 <a href="https://github.com/TheKingOfDuck/fuzzDicts/blob/master/passwordDict/top1000.txt">这个</a> 和 <a href="https://github.com/berzerk0/Probable-Wordlists/blob/master/Real-Passwords/Top207-probable-v2.txt">这个</a> 。也极大的降低了黑客暴力破解的门槛。</p><p>防止暴力破解，是一个系统性工程。用户注册时候，我们会要求密码至少六位数（要求太严格也不好，影响用户体验）。</p><p>另外 API 也会加入限流措施，不会让黑客无止境的尝试，这也是现在主流的防范机制。</p><p>防止暴力破解，一个行之有效的方式，是使用图片验证码。</p><p>图片验证码的设计初衷，是用来区分人和机器的输入：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mNTpWgMD4R.png!large" alt="mNTpWgMD4R.png!large"></p><p>如果一个验证码很容易破解，我们还可以增加其难度：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/uDpbpHfEpb.png!large" alt="uDpbpHfEpb.png!large"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/X1wXrgsdWb.png!large" alt="X1wXrgsdWb.png!large"></p><p>另外，不止用户密码，有时候<strong>短信验证码和邮箱验证码</strong>，也很容易被破解，因为一般情况下我们只会提供六位数的数字。</p><p>六位数，意味着 999999 种可能性。虽然会加入过期时间，例如说 15 分钟内有效，但是如果接口不做限制的话，黑客写个程序，很容易就能在几分钟内尝试完所有的 999999 个可能性。最终短信验证码形同虚设，黑客可以很轻松的通过验证码来重置用户的密码。最终导致用户账号丢失。</p><h1 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h1><p>OK啊，也是好起来了，新项目用到了 Redis，第一次面试也有被面试官问过类似的问题。</p><p>用 Redis 来干吗呢，当然是用来存储图片验证码了，后续也会用 Redis 来完成友情链接的存储。</p><p>提到 Redis，相信找过工作的都知道，只要在简历上写了关于 Redis 的内容，就会触发面试官的被动技能，那就是提问 Redis 三兄弟。那么也来简单看一看关于 Redis 的内容吧。</p><hr><p>Redis 是 <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice 三个单词中加粗字母的组合，是一种基于键值对（key-value）的 NoSQL 数据库。</p><p>但比一般的键值对，Redis 中的 value 支持 string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数估算）、GEO（地理信息定位）等多种数据结构。</p><p>而且因为 Redis 的所有数据都存放在<strong>内存</strong>当中，所以它的<strong>读写性能非常出色</strong>。</p><p>不仅如此，Redis 还可以将内存数据持久化到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据并不会“丢失”。</p><p>除此之外，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 脚本等附加功能，是互联网技术领域中使用最广泛的缓存中间件。</p><h2 id="Redis-有什么用"><a href="#Redis-有什么用" class="headerlink" title="Redis 有什么用"></a>Redis 有什么用</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-b02e44b3-3299-450f-b767-4a862b5ac8ff.png" alt="三分恶面渣逆袭：Redis的作用"></p><ol><li>缓存</li></ol><p>Redis 最常见的用途就是作为缓存，由于所有数据都存储在内存中，所以 Redis 的读写速度非常快，远超基于磁盘存储的数据库。使用 Redis 缓存可以极大地提高应用的响应速度和吞吐量。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png" alt="三分恶面渣逆袭：Redis缓存"></p><ol><li>排行榜/计数器</li></ol><p>Redis 的 ZSet 非常适合用来实现排行榜的功能，同时 Redis 的原子递增操作可以用来实现计数器功能。</p><ol><li>分布式锁</li></ol><p>Redis 可以实现分布式锁，用来控制跨多个进程或服务器的资源访问。</p><p>实例：</p><ul><li>Redis 可以用来存储 Token：用户登录成功之后，使用 Redis 的 hash 存储 Token</li><li>使用 Redis 的 Zset 计数，登录失败超过一定次数，锁定账号</li><li>使用 Redisson 实现分布式环境下的登录、注册等操作</li></ul><h2 id="Redis-中的数据类型"><a href="#Redis-中的数据类型" class="headerlink" title="Redis 中的数据类型"></a>Redis 中的数据类型</h2><p>Redis 有五种基本数据类型，这五种数据类型分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、sorted set（有序集合，也叫 zset）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png" alt="三分恶面渣逆袭：Redis基本数据类型"></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串是最基础的数据类型，key 是一个字符串，不用多说，value 可以是：</p><ul><li>字符串（简单的字符串、复杂的字符串（例如 JSON、XML））</li><li>数字 （整数、浮点数）</li><li>甚至是二进制（图片、音频、视频），但最大不能超过 512MB。</li></ul><p>字符串主要有以下几个典型的使用场景：</p><ul><li>缓存功能</li><li>计数</li><li>共享 Session</li><li>限速</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>键值对集合，key 是字符串，value 是一个 Map 集合，比如说 <code>value = &#123;name: &#39;沉默王二&#39;, age: 18&#125;</code>，name 和 age 属于字段 field，沉默王二 和 18 属于值 value。</p><p>哈希主要有以下两个典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><p>来感受一下，用户字符串类型存储用户信息和用哈希类型存储用户信息的区别：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240315115713.png" alt="img"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 是一个简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表主要有以下两个使用场景：</p><ul><li>消息队列</li><li>文章列表</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>集合是字符串的无序集合，集合中的元素是唯一的，不允许重复。和 Java 集合框架中的 Set 有相似之处。</p><p>集合主要有以下两个使用场景：</p><ul><li>标签（tag）</li><li>共同关注</li></ul><h3 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h3><p>Zset，有序集合，比 set 多了一个排序属性 score（分值）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240315120652.png" alt="img"></p><p>主要应用场景有：</p><ul><li>用户点赞统计</li><li>用户排序</li></ul><h2 id="Redis-三兄弟"><a href="#Redis-三兄弟" class="headerlink" title="Redis 三兄弟"></a>Redis 三兄弟</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询不存在的数据，由于缓存没有命中（因为数据根本就不存在），请求每次都会穿过缓存去查询数据库。如果这种查询非常频繁，就会给数据库造成很大的压力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-029951e6-8b99-4364-a570-010853deb594.png" alt="三分恶面渣逆袭：缓存穿透"></p><p>缓存穿透意味着缓存失去了减轻数据压力的意义。</p><p>缓存穿透可能有两种原因：</p><ul><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ul><p>它主要有两种解决办法：</p><ol><li>缓存空值/默认值</li></ol><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-288af5a2-ae5a-427a-95e9-b4a658b01386.png" alt="三分恶面渣逆袭：缓存空值/默认值"></p><p>缓存空值有两大问题：</p><ul><li><p>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。</p></li></ul><p>例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。</p><p>这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。</p><ol><li>布隆过滤器</li></ol><p>除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。</p><p>布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-0e18ea40-a2e5-4fa6-989e-e771f6e4b0fc.png" alt="布隆过滤器"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-e8a382c9-4379-44ab-b1dc-fb598a228105.png" alt="缓存空对象核布隆过滤器方案对比"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指某一个或少数几个数据被高频访问，当这些数据在缓存中过期的那一刻，大量请求就会直接到达数据库，导致数据库瞬间压力过大。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-86579ee6-9dae-4274-a5cc-af6812f48da4.png" alt="三分恶面渣逆袭：缓存击穿"></p><p>解决⽅案：</p><ol><li>加锁更新，⽐如请求查询 A，发现缓存中没有，对 A 这个 key 加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cf63911a-8501-493e-a375-8b47a9f33358.png" alt="三分恶面渣逆袭：加锁更新"></p><ol><li>将过期时间组合写在 value 中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某一个时间点，由于大量的缓存数据同时过期或缓存服务器突然宕机了，导致所有的请求都落到了数据库上（比如 MySQL），从而对数据库造成巨大压力，甚至导致数据库崩溃的现象。</p><p>总之就是，崩了，崩的非常严重，就叫雪崩了（电影电视里应该看到过，非常夸张）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-1464fe22-c463-4850-8989-b899510cb10e.png" alt="三分恶面渣逆袭：缓存雪崩"></p><p>解决方案：</p><p>第一种：提高缓存可用性</p><ol><li><strong>集群部署</strong>：采用分布式缓存而不是单一缓存服务器，可以降低单点故障的风险。即使某个缓存节点发生故障，其他节点仍然可以提供服务，从而避免对数据库的大量直接访问。</li></ol><p>可以利用 Redis Cluster。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240326220634.png" alt="Rajat Pachauri：Redis Cluster"></p><p>或者第三方集群方案 Codis。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240326220408.png" alt="极客时间：Codis"></p><ol><li><strong>备份缓存</strong>：对于关键数据，除了在主缓存中存储，还可以在备用缓存中保存一份。当主缓存不可用时，可以快速切换到备用缓存，确保系统的稳定性和可用性。</li></ol><p>第二种：过期时间</p><p>对于缓存数据，设置不同的过期时间，避免大量缓存数据同时过期。可以通过在原有过期时间的基础上添加一个随机值来实现，这样可以分散缓存过期时间，减少同一时间对数据库的访问压力。</p><p>第三种：限流和降级</p><p>通过设置合理的系统限流策略，如令牌桶或漏斗算法，来控制访问流量，防止在缓存失效时数据库被打垮。</p><p>此外，系统可以实现降级策略，在缓存雪崩或系统压力过大时，暂时关闭一些非核心服务，确保核心服务的正常运行。</p><hr><p>本项目中对 Redis 的使用并不多，主要是用来存储一些不会经常发生变化的内容，所以更加深层次的内容会在后面继续学习，在这里就不再写了。</p><h1 id="JWT-授权"><a href="#JWT-授权" class="headerlink" title="JWT 授权"></a>JWT 授权</h1><p>互联网服务离不开用户认证。一般流程是下面这样。</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">  <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bg2018072304.jpg" alt="img"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p>写成一行，就是下面的样子。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bg2018072303.jpg" alt="img"></p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，JWT 默认是<strong>不加密</strong>的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 <strong>Header</strong> 里面指定的签名算法（默认是 <strong>HMAC SHA256</strong>），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h3><p>前面提到，<strong>Header</strong> 和 <strong>Payload</strong> 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h2><p>客户端收到服务器返回的 <strong>JWT</strong>，可以储存在 <strong>Cookie</strong> 里面，也可以储存在 <strong>localStorage</strong>。</p><p>此后，客户端每次与服务器通信，都要带上这个 <strong>JWT</strong>。你可以把它放在 <strong>Cookie</strong> 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><hr><p>说了这么多的基础内容，JWT 在本项目中又起到了什么作用呢。使用 JWT 主要用于产生 token，以此来进行授权，未被授权的用户不能执行相关操作，如 A 发布的话题，只有 A 才能对话题进行修改和删除，其他用户只能引用这个话题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录完上面的这三个问题，其实已经解决了我在做这个项目时的一大部分疑问了，因为项目主题其实很类似，这也是为什么后面会使用模板文件进行自动化生成模型、控制器、验证请求、请求授权等这些机制的原因。</p><p>当然，本文中所写到的也都只是相关技术的一些皮毛，后续的深入学习还会进行记录。关于本项目的还会有包括日志、命令行模式、make命令以及关于数据库方面的东西。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li><li><a href="https://javabetter.cn/sidebar/sanfene/redis.html">https://javabetter.cn/sidebar/sanfene/redis.html</a></li><li><a href="https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724">https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍新项目中第一部分的内容——身份验证接口的设计思路。&lt;/p&gt;
&lt;p&gt;身份验证接口主要包括以下模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册&lt;/li&gt;
&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;找回密码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;填写手机号或</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub开发</title>
    <link href="http://example.com/2024/04/15/Gohub%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/04/15/Gohub%E5%BC%80%E5%8F%91/</id>
    <published>2024-04-15T07:41:08.000Z</published>
    <updated>2024-04-18T14:55:42.144Z</updated>
    
    <content type="html"><![CDATA[<p>本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。</p><p>本项目主要设计一下三部分的知识点：</p><ul><li>API 开发</li><li>命令行开发</li><li>构建高效率的程序结构</li></ul><p>主要功能为：</p><ul><li>用户的注册和登录</li><li>安全验证码和图片验证码</li><li>JWT 授权</li><li>用户修改个人信息</li></ul><h1 id="项目统计"><a href="#项目统计" class="headerlink" title="项目统计"></a>项目统计</h1><h2 id="实现路由"><a href="#实现路由" class="headerlink" title="实现路由"></a>实现路由</h2><div class="table-container"><table><thead><tr><th>请求方法</th><th>API 地址</th><th>说明</th></tr></thead><tbody><tr><td>POST</td><td>/api/v1/auth/login/using-phone</td><td>短信 + 手机号登录</td></tr><tr><td>POST</td><td>/api/v1/auth/login/using-password</td><td>手机号、用户名、邮箱 + 密码</td></tr><tr><td>POST</td><td>/api/v1/auth/login/refresh-token</td><td>刷下 Token</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-email</td><td>邮件密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-phone</td><td>短信验证码密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-phone</td><td>使用手机号注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-email</td><td>使用邮箱注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/phone/exist</td><td>手机号是否已注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/email/exist</td><td>email 是否已支持</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/phone</td><td>发送短信验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/email</td><td>发送邮件验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/captcha</td><td>获取图片验证码</td></tr><tr><td>GET</td><td>/api/v1/user</td><td>获取当前用户</td></tr><tr><td>GET</td><td>/api/v1/users</td><td>用户列表</td></tr><tr><td>PUT</td><td>/api/v1/users</td><td>修改个人资料</td></tr><tr><td>PUT</td><td>/api/v1/users/email</td><td>修改邮箱</td></tr><tr><td>PUT</td><td>/api/v1/users/phone</td><td>修改手机号</td></tr><tr><td>PUT</td><td>/api/v1/users/password</td><td>修改密码</td></tr><tr><td>PUT</td><td>/api/v1/users/avatar</td><td>上传头像</td></tr><tr><td>GET</td><td>/api/v1/categories</td><td>分类列表</td></tr><tr><td>POST</td><td>/api/v1/categories</td><td>创建分类</td></tr><tr><td>PUT</td><td>/api/v1/categories/:id</td><td>更新分类</td></tr><tr><td>DELETE</td><td>/api/v1/categories/:id</td><td>删除分类</td></tr><tr><td>GET</td><td>/api/v1/topics</td><td>话题列表</td></tr><tr><td>POST</td><td>/api/v1/topics</td><td>创建话题</td></tr><tr><td>PUT</td><td>/api/v1/topics/:id</td><td>更新话题</td></tr><tr><td>DELETE</td><td>/api/v1/topics/:id</td><td>删除话题</td></tr><tr><td>GET</td><td>/api/v1/topics/:id</td><td>获取话题</td></tr><tr><td>GET</td><td>/api/v1/links</td><td>友情链接列表</td></tr></tbody></table></div><h2 id="第三方依赖"><a href="#第三方依赖" class="headerlink" title="第三方依赖"></a>第三方依赖</h2><p>使用到的开源库：</p><ul><li><a href="https://github.com/gin-gonic/gin">gin</a> —— 路由、路由组、中间件</li><li><a href="https://github.com/gin-contrib/zap">zap</a> —— 高性能日志方案</li><li><a href="https://github.com/go-gorm/gorm">gorm</a> —— ORM 数据操作</li><li><a href="https://github.com/spf13/cobra">cobra</a> —— 命令行结构</li><li><a href="https://github.com/spf13/viper">viper</a> —— 配置信息</li><li><a href="https://github.com/spf13/cast">cast</a> —— 类型转换</li><li><a href="https://github.com/go-redis/redis/v8">redis</a> —— Redis 操作</li><li><a href="https://github.com/golang-jwt/jwt">jwt</a> —— JWT 操作</li><li><a href="https://github.com/mojocn/base64Captcha">base64Captcha</a> —— 图片验证码</li><li><a href="https://github.com/thedevsaddam/govalidator">govalidator</a> —— 请求验证器</li><li><a href="https://github.com/ulule/limiter/v3">limiter</a> —— 限流器</li><li><a href="https://github.com/jordan-wright/email">email</a> —— SMTP 邮件发送</li><li><a href="https://github.com/KenmyZhang/aliyun-communicate">aliyun-communicate</a> —— 发送阿里云短信</li><li><a href="https://github.com/mgutz/ansi">ansi</a> —— 终端高亮输出</li><li><a href="https://github.com/iancoleman/strcase">strcase</a> —— 字符串大小写操作</li><li><a href="https://github.com/gertd/go-pluralize">pluralize</a> —— 英文字符单数复数处理</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/bxcodec/faker">faker</a> —— 假数据填充</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/disintegration/imaging">imaging</a> —— 图片裁切</li></ul><h2 id="自定义的包"><a href="#自定义的包" class="headerlink" title="自定义的包"></a>自定义的包</h2><p>现在来看下我们自建的库：</p><ul><li>app —— 应用对象</li><li>auth —— 用户授权</li><li>cache —— 缓存</li><li>captcha —— 图片验证码</li><li>config —— 配置信息</li><li>console —— 终端</li><li>database —— 数据库操作</li><li>file —— 文件处理</li><li>hash —— 哈希</li><li>helpers —— 辅助方法</li><li>jwt —— JWT 认证</li><li>limiter —— API 限流</li><li>logger —— 日志记录</li><li>mail —— 邮件发送</li><li>migrate —— 数据库迁移</li><li>paginator —— 分页器</li><li>redis —— Redis 数据库操作</li><li>response —— 响应处理</li><li>seed —— 数据填充</li><li>sms —— 发送短信</li><li>str —— 字符串处理</li><li>verifycode —— 数字验证码</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>配置信息（使用 Viper，支持 .env 和 config 目录 ）</li><li>API 版本</li><li>API 错误码</li><li>API 限流<ol><li>支持秒、分钟、小时、天级的请求限制</li><li>支持返回 API 请求量标头（限制数，剩余量、重置时间）</li></ol></li><li>注册登录<ol><li>注册<ol><li>判断手机是否注册</li><li>判断 Email 是否注册</li><li>支持手机 + 短信验证码进行注册</li><li>支持使用邮箱注册账号</li></ol></li><li>登录<ol><li>支持手机 + 短信进行登录</li><li>支持密码登录（手机号、Email、用户名任选）</li><li>支持更加安全的 Token Refresh 机制</li></ol></li><li>找回密码<ol><li>支持使用手机 + 短信验证码找回</li><li>支持使用邮箱 + 邮箱验证码找回</li></ol></li></ol></li><li>JWT 授权</li><li>整个应用使用命令行模式（默认运行 web 服务）</li><li>内置命令行（ cobra，对比 cli 和 cobra）<ol><li>key 命令生成 app key</li><li>make 命令<ul><li>make seeder —— 生成数据填充</li><li>make policy —— 生成授权文件</li><li>make apicontroller —— 生成 Restful API 控制器</li><li>make model —— 生成模型文件</li><li>make request —— 生成请求验证文件</li><li>make factory —— 生成模型工厂文件</li><li>make cmd —— 生成自定义命令文件</li><li>make migration —— 生成数据库迁移文件</li></ul></li><li>seed 数据填充<ul><li>seed 所有数据</li><li>seed 单条数据</li><li>支持使用 faker 填充假数据</li><li>支持模型工厂（ factory ）</li></ul></li><li>migrate 数据库迁移<ol><li>up —— 执行迁移</li><li>rollback (down) —— 回滚上一步执行的迁移</li><li>fresh —— 删除所有表，然后执行所有迁移</li><li>reset —— 回滚所有迁移</li><li>refresh —— 回滚所有迁移，然后再执行所有迁移</li></ol></li><li>cache 缓存处理<ul><li>cache clear —— 清除缓存</li><li>cache forget —— 忘记某个 KEY 对应的缓存</li></ul></li></ol></li><li>分页<ol><li>支持返回上下页链接，方便客户端调用</li></ol></li><li>Cache 缓存包<ol><li>支持 redis 缓存</li><li>使用 interface ，支持使用多驱动</li></ol></li><li>Redis 操作</li><li>安全验证码<ol><li>Email （发送邮箱，使用 Mailhog 进行测试）</li><li>手机验证码（发送手机短信）</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>图片验证码，防机器人滥用<ol><li>支持通过配置信息自定义复杂度</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>日志记录<ol><li>集成 zap 高性能日志库</li><li>支持命令行记录（方便开发时快速定位问题）</li><li>命令行日志高亮</li><li>支持文件记录（多文件和按日期分隔）</li><li>记录 gorm 的 query log</li><li>记录 HTTP 请求 log</li><li>Panic Recovery 中间件</li><li>合理的日志等级（debug, info, error, panic, fatal）</li></ol></li><li>Policy 授权策略结构</li><li>Request 请求验证方案<ol><li>支持 JSON 请求、表单请求、URL Query</li></ol></li><li>API 图片上传</li><li>图片裁切</li><li>数据库支持 mysql 和 sqlite</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于本项目是一个完全只涉及到 API 设计的内容，所以测试功能是否符合预期则是采用了 Postman 这款测试软件，有关 Redis 的可视化则是采用了 Another Redis Desktop Manager。</p><p>考虑到篇幅的问题，项目的知识点总结会分开来写。所以这篇文章是用来提醒我去学习的。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。&lt;/p&gt;
&lt;p&gt;本项目主要设计一下三部分的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 开发&lt;/li&gt;
&lt;li&gt;命令行开发&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>唉……</title>
    <link href="http://example.com/2024/04/14/%E5%94%89%E2%80%A6%E2%80%A6/"/>
    <id>http://example.com/2024/04/14/%E5%94%89%E2%80%A6%E2%80%A6/</id>
    <published>2024-04-14T09:21:21.000Z</published>
    <updated>2024-04-14T09:50:50.924Z</updated>
    
    <content type="html"><![CDATA[<p>文章是越写越慢，质量是越来越差，这周的甚至连标题都想不出来了，离谱。从标题也能看出来，这周应该是不太愉悦的，二面被挂就算了，还被另一个面试官给戏耍了。我懂了，找实习就一个字——摆。</p><h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>清明假期三天，每天都是两三个小时的做题时间，本周倒是没怎么做题。</p><p>原因是觉得刷了一个月的题了，还是在看到题目后几分钟就有思路了，但是不知道代码该怎么写，所以决定先沉淀几天。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>虽然最近几天算法进展不怎么样，项目进展还是不错的。</p><p>上周六开的新项目，其实还是这周才开始，项目内容和之前的项目好像没有什么太大的区别，一个是博客，一个是论坛。但是实际开发就是天差地别了，不仅仅将框架全部换了 <code>gin</code> ，还用上了 <code>redis</code>。是的，就是那个只要出现在简历上就会触发面试官被动的 <code>redis</code> ，当然，以防万一，我非常认真地背了 Redis 三兄弟。</p><p>项目中更加详细地内容还是等到下周专门来写吧，写在周报里好像不是很好记录。</p><h2 id="Go语言设计哲学"><a href="#Go语言设计哲学" class="headerlink" title="Go语言设计哲学"></a>Go语言设计哲学</h2><p>没想到这一块竟然还有后续，因为上一篇有些一些相关的内容，后续也有去了解 Go 和 C++ 的不同，也查了一些资料，感觉很有意思，后续应该会继续写相关的内容。</p><h2 id="找实习的进展"><a href="#找实习的进展" class="headerlink" title="找实习的进展"></a>找实习的进展</h2><p>有什么进展呢，最接近成功的也就是清明假期前的那次了，结果挂在了横向对比上，只能怪一面的时候回答的确实不怎么样。腾讯约了第三次面试，结果是个 KPI 面，一共就二十几分钟，面试官还迟到了，连自我介绍都没让做。</p><p>字节和小米都是简历直接就给挂了，其他的公司也看不上我的简历，只有等月底的华为喽。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，本周学的东西不算很多，因为考试加上心情不是很好，决定开摆一周，也没整理这周学的内容，所以周报也没什么好写的。那为什么还写呢，因为想找一个地方记录并发泄一下。</p><p>下周会把项目全部完成，调整后会继续刷题，那就期待着后续的博客更新吧。完成项目后会继续完善自己的简历，我想这个暑假应该是能找到实习的吧，希望是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章是越写越慢，质量是越来越差，这周的甚至连标题都想不出来了，离谱。从标题也能看出来，这周应该是不太愉悦的，二面被挂就算了，还被另一个面试官给戏耍了。我懂了，找实习就一个字——摆。&lt;/p&gt;
&lt;h1 id=&quot;学习内容&quot;&gt;&lt;a href=&quot;#学习内容&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学</title>
    <link href="http://example.com/2024/04/03/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
    <id>http://example.com/2024/04/03/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</id>
    <published>2024-04-03T13:16:08.000Z</published>
    <updated>2024-04-06T09:05:59.758Z</updated>
    
    <content type="html"><![CDATA[<p>实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。</p><p>在学习一门语言时，有没有考虑过这个语言的语法和格式为什么要这么设计？这个问题一听就是一个好的话题啊，为什么这么设计？为什么在已经有了那么多语言后，还要设计出Go语言？</p><p>那么好，闲话少说，这周的主要内容就改为Go语言的设计哲学。当然，文章内容并不是我原创的，更多的还是网上查到的资料。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Go 编程语言构思于 2007 年底，构思的目的是：为了解决在 Google 开发软件基础设施时遇到的一些问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b73ae4ab1b1ceb693aad4f978f1f2cc.jpg" alt="Go 语言之父"></p><p>图中的三位大佬就是 Go 语言最初的设计者，从左到右依次为：</p><ul><li>Robert Griesemer：参与过 Google V8 JavaScript 引擎和 Java HotSpot 虚拟机的研发。</li><li>Rob Pike：Unix 操作系统早期开发者之一，UTF-8 创始人之一，Go 语言吉祥物设计者是 Rob Pike 的媳妇。</li><li>Ken Thompson：图灵奖得主，Unix 操作系统早期开发者之一，UTF-8 创始人之一，C 语言（前身 B 语言）的设计者。</li></ul><p>那么好，我们来解释第一个问题，为什么这几个大佬要设计 Go 语言。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>曾经在早期的采访中，Google 大佬们反馈感觉 “编程” 太麻烦了，他们很不喜欢 C++，对于现在工作所用的语言和环境感觉比较沮丧，充满着许多不怎么好用的特性。</p><p>具体遭遇到的问题。如下：</p><ul><li>软件复杂：多核处理器、网络系统、大规模计算集群和网络编程模型所带来的问题只能暂时绕开，没法正面解决。</li><li>软件规模：软件规模也发生了变化，今天的服务器程序由数千万行代码组成，由数百甚至数千名程序员进行工作，而且每天都在更新（据闻 Go 就是在等编译的 45 分钟中想出来的）。</li><li>编译耗时：在大型编译集群中，构建时间也延长到了几分钟，甚至几小时。</li></ul><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>为了解决上述的问题，如果在既有语言上进行修改，需要解决很多根本性的问题，因此，他们决定重新设计一个语言。</p><p>这门新语言需要符合以下需求：</p><ul><li>目的：<strong>设计和开发 Go 是为了使在这种环境下能够提高工作效率</strong>。</li><li>设计：在 Go 的设计上，除了比较知名的方面：如内置并发和垃圾收集。还考虑到：严格的依赖性管理，随着系统的发展，软件架构的适应性，以及跨越组件之间边界的健壮性。</li></ul><p>这门新语言就是现在的 Go。</p><h1 id="Go-在-Google"><a href="#Go-在-Google" class="headerlink" title="Go 在 Google"></a>Go 在 Google</h1><p>Google 整体的应用软件很庞大，硬件也很庞大，有数百万行的软件，服务器主要是 C++ 语言，其他部分则是大量的 Java 和 Python。</p><p>数以千计的工程师在代码上工作，在一个由所有软件组成的单一树的 “头 “ 上工作，所以每天都会对该树的所有层次进行重大改变。一个大型的定制设计的分布式构建系统使得这种规模的开发是可行的，但它仍然很大。当然，所有这些软件都在几十亿台机器上运行，这些机器被视为数量不多的独立、联网的计算集群。</p><p>简而言之，Google 的开发规模很大，速度可能是缓慢的，而且往往是笨拙的。但它是有效的。</p><p>Go 项目的目标是：消除 Google 软件开发的缓慢和笨拙，从而使这个过程更富有成效和可扩展。<strong>这门语言是由编写、阅读、调试和维护大型软件系统的人设计的，也是为他们设计的</strong>。</p><p>因此 Go 的目的不是为了研究编程语言的设计，而是为了改善其设计者及其同事的工作环境。</p><h1 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h1><p>Go 的诞生，更多是为了方便程序员进行编程，而不是为了某项科学研究，这就是 Go 语言与其他编程语言的最大的不同。</p><p>当 Go 发布时，有些人声称它缺少被认为是现代语言的必要条件的特定功能或方法。在缺乏这些设施的情况下，Go怎么可能有价值？</p><p>我们的答案是：<strong>Go 所拥有的特性可以解决那些使大规模软件开发变得困难的问题。</strong></p><p>这些问题包括：</p><ul><li>构建速度缓慢。</li><li>不受控制的依赖关系。</li><li>每个程序员使用不同的语言子集。</li><li>对程序的理解不透彻（代码可读性差，文档不全等）。</li><li>工作的重复性。</li><li>更新的成本。</li><li>版本偏移（version skew）。</li><li>编写自动工具的难度。</li><li>跨语言的构建。</li></ul><p>纯粹一门语言的单个功能并不能解决这些问题，我们需要对软件工程有一个更大的看法。因此在 Go 的设计中，我们试图把重点放在这些问题的解决方案上。</p><h1 id="少即是多"><a href="#少即是多" class="headerlink" title="少即是多"></a>少即是多</h1><p>相信对 Go 语言有过了解的人都会经常听到诸如：less is more、少即是多、大道至简、大道不停地至简等黑话。</p><p>那么少即是多这种观点是谁提起的呢，正是 Go 语言之父的 Rob Pike。</p><p>Rob Pike 在多个场合提到过类似 “少即是多” 的观点，该观点广为流传。这种设计理念体现在 Go 语言的语法设计上，它的语法非常简洁，没有复杂的继承和泛型，也没有异常处理，但这并不影响它的功能性和表达力。</p><p>以下内容多为 Rob Pike 在一次演讲时提到的内容，对此感兴趣的可以去阅读一下 Rob Pike 的 <a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">Less is exponentially more</a> 演讲稿。</p><h2 id="Go-特性清单"><a href="#Go-特性清单" class="headerlink" title="Go 特性清单"></a>Go 特性清单</h2><ul><li>规范的语法（无需用于解析的符号表）。</li><li>垃圾收集（唯一）。</li><li>没有头文件。</li><li>明确依赖</li><li>无循环依赖。</li><li>常量只能为数字。</li><li>int 和 int32 是不同的类型。</li><li>字母大小写设定可见性。</li><li>任何类型都可以有方法（没有类）。</li><li>没有子类型继承（没有子类）。</li><li>包级别初始化和定义好的初始化顺序。</li><li>文件编译到一个包中。</li><li>包级别的全局表达与顺序无关。</li><li>没有算术转换（常量做了辅助处理）。</li><li>隐式的接口实现（无需“implements”定义）。</li><li>嵌入（没有向父类的升级）。</li><li>方法如同函数一样进行定义（没有特的别位置要求）。</li><li>方法就是函数。</li><li>接口仅仅包含方法（没有数据）。</li><li>方法仅通过名字匹配（而不是通过类型）。</li><li>没有构造或者析构方法。</li><li>后自增和后自减是语句，而不是表达式。</li><li>没有前自增或前自减。</li><li>赋值不是表达式。</li><li>按照赋值、函数调用定义时的顺序执行（没有“sequence point”）。</li><li>没有指针运算。</li><li>内存总是零值初始化。</li><li>对局部变量取地址合法。</li><li>方法没有“this”。</li><li>分段的堆栈。</li><li>没有静态或其他类型注解。</li><li>没有模板。</li><li>没有异常。</li><li>内建 string、slice、map。</li><li>数组边界检查。</li></ul><p>除了这个简化清单和一些未提及的琐碎内容，我相信，Go 相比 C 或者 C++ 是更加有表达力的。少既是多。</p><h2 id="无法想象没有泛型"><a href="#无法想象没有泛型" class="headerlink" title="无法想象没有泛型"></a>无法想象没有泛型</h2><p>当然明显缺少的是类型层次化。</p><p>在 Go 最初的版本中，有人告诉我他无法想像用一个没有泛型范型的语言来工作。就像之前在某些地方提到过的，我认为这绝对是神奇的评论。</p><p>公平的说，他可能正在用其自己的方式来表达非常喜欢 STL 在 C++ 中为他做的事情。在辩论的前提下，让我们先相信他的观点。</p><p>他说编写像 int 列表或 map string 这样的容器是一个无法忍受的负担。我觉得这是个神奇的观点。</p><p>即便是那些没有泛型范型的语言，我也只会花费很少的时间在这些问题上。</p><h2 id="面向对象的方式"><a href="#面向对象的方式" class="headerlink" title="面向对象的方式"></a>面向对象的方式</h2><p>但是更重要的是，他说类型是放下这些负担的解决途径。类型。不是函数多态，不是语言基础，或者其他协助，仅仅用类型。</p><p>这就是卡住我的细节问题。</p><p>从 C++ 和 Java 转过来 Go 的程序员怀念工作在类型上的编程方式，尤其是继承和子类，以及所有相关的内容。可能对于类型来说，我是门外汉，不过我真得从未发现这个模型十分具有表达力。</p><p>我已故的朋友 Alain Fournier 有一次告诉我说他认为学术的最低级形式就是分类。那么你知道吗？类型层次化就是分类。</p><p>你必须对哪块进哪个盒子作出决策，包括每个类型的父级，不论是 A 继承自 B，还是 B 继承自 A。</p><p>一个可排序的数组是一个排序过的数组还是一个数组表达的排序器？如果你坚信所有问题都是由类型驱动设计的，那么你就必须作出决策。</p><p>我相信这样思考编程是荒谬可笑的。核心不是东西之间的祖宗关系，而是它们可以为你做什么。</p><p>当然，这就是接口进入 Go 的地方。但是它们已经是蓝图的一部分，那是真正的 Go 哲学。</p><p>如果说 C++ 和 Java 是关于类型继承和类型分类的，Go 就是关于组合的。</p><p>Unix pipe 的最终发明人 Doug McIlroy 在 1964 (!) 这样写到：</p><blockquote><p>我们应当像连接花园里的龙头和软管一样，用某种方式一段一段的将消息数据连接起来。这同样是 IO 使用的办法。</p></blockquote><p>这也是 Go 使用的办法。Go 用了这个主意，并且将其向前推进了一大步。这是一个关于组合与连接的语言。</p><p>一个显而易见的例子就是接口为我们提供的组合元件的方式。只要它实现了方法 M，就可以放在合适的地方，而不关心它到底是什么东西。</p><p>另一个重要的例子是并发如何连接独立运行的计算。并且也有一个不同寻常（却非常简单）的类型组合模式：嵌入。</p><p>这就是 Go 特有的组合技术，滋味与 C++ 或 Java 程序完全不同。</p><h2 id="为什么-Go-不被-C-程序员喜欢"><a href="#为什么-Go-不被-C-程序员喜欢" class="headerlink" title="为什么 Go 不被 C++ 程序员喜欢"></a>为什么 Go 不被 C++ 程序员喜欢</h2><p>从上面的内容中，我们不难看出，Go 语言的设计者是十分不喜欢使用C++ 进行编程设计的。当然，在 Go 语言被设计并发布后，程序员没有了更多的选择。但是，相较于 C++ 程序员，其他语言的使用者好像更加喜欢 Go 语言。</p><p><strong>为什么 Go，一个被设计为用于摧毁 C++ 的语言，并为并未获得 C++ 程序员的芳心？</strong></p><p>这是因为 Go 和 C++ 有着完全不同的哲学。</p><p><strong>C++ 是让你的指尖解决所有的问题</strong>：</p><ul><li>C++ 与那些巨大增长的特别编写的手工代码相比，具有更加广泛的抽象，优雅、灵活并且零成本的表达能力。</li></ul><p><strong>Go 的主张更多考虑的是最小化程序员的工作量</strong>：</p><ul><li>Go 不是无所不包的。你无法通过内建获得所有东西。你无法精确控制每个细微的执行。</li><li><strong>你得到的是功能强大，但是容易理解的，容易用来构建一些用于连接组合解决问题的模块</strong>。</li><li>这可能最终不像你使用其他语言编写的解决方案那么快，那么精致，在思想体系上那么明确，但它确实会更加容易编写，容易阅读，容易理解，容易维护，并且更加安全。</li></ul><p>换句话说，当然，有些过于简单：</p><ul><li>Python 和 Ruby 程序员：转到 Go 是因为他们并未放弃太多的表达能力，但是获得了性能，并且与并发共舞。</li><li>C++ 程序员：无法转到 Go 是因为他们经过艰辛的战斗才获得对其语言的精确控制能力，而且也不想放弃任何已经获得的东西。对于他们，软件不仅仅是关于让工作完成，而是关于用一个确定的方式完成。</li></ul><h1 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h1><p>本段则是来自《<a href="https://www.youtube.com/watch?v=YXV7sa4oM4I">The Go Programming Language and Environment</a>》这篇演讲稿。</p><p>出身 Google 的 Go 语言严格意义上来说就是出身于名门望族了，那么十多年过去了，它发展地怎么样了？</p><h2 id="Go-怎么样了"><a href="#Go-怎么样了" class="headerlink" title="Go 怎么样了"></a>Go 怎么样了</h2><p>Rob Pike 表示其实 Go 目前还不能算做主流语言，但是在全世界的影响力和发展都大大的超出了预期。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/958c55da2ff41616a0ae6c88bade062a.png" alt="img"></p><p>像在国内的我们，能够很明显感知到，Go 在近 3~5 年的用户群体不断增大，一些大厂也已经开始转 Go ，甚至有的公司就是全部用 Go 语言来进行工作的。</p><p>Go 并不是那种非常 “有趣” 的语言，在技术上（语言理论、设计）几乎没有什么大进步。当然，这也不是 Go 核心团队的设计目标。</p><p>但就是这么一门语言，他主导了大部分 CNCF 中的项目，例如：K8s、Docker 等，特别牛。<strong>Go 是云基础设施的语言，这是怎么发生的</strong>？</p><h2 id="Go-为什么成功"><a href="#Go-为什么成功" class="headerlink" title="Go 为什么成功"></a>Go 为什么成功</h2><p>Go 从一门无人问津的语言，到现在承担了各云基础设施的核心，变得很重要，也是一种成功实践。</p><p>Rob Pike 认为成功的因素有如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/408cea989ce5e27baff2038e2c99377b.png" alt="img"></p><p>核心观点：<strong>一门编程语言的成功取决于其他很多方面，Go 语言是面向软件开发的，而不仅仅只是编程</strong>。</p><p>为此，Go 就是为了解决软件开发而生，而非只是编程，这是成功的关键因素。</p><h1 id="回答面试官的问题"><a href="#回答面试官的问题" class="headerlink" title="回答面试官的问题"></a>回答面试官的问题</h1><p>在最后<strong>回答一下面试官的问题</strong>，不知道还有没有机会了，就在自己的博客里写一下吧。</p><p>问：一个语言在设计时将其语法结构设计成某种特殊的样子，如 Go 语言中花括号必须要和语句在同一行、Python 中使用缩进来替代花括号，这样的设计有什么原因吗？</p><p>答：无论结构怎么设计，对于机器来说都是没有区别的，无论是花括号还是缩进，能影响的就是有人。那么对于设计者来说，设计语言的一些特性主要还是根据他的思路以及设计哲学。</p><p>Python使用缩进替代花括号的原因有以下几种：</p><ul><li>缩进语法，更加优雅</li><li>缩进语法，更加清晰</li><li>使用缩进，保持一致性，避免造成误读</li><li>使用缩进，代码更紧凑，便于浏览，没有累赘</li><li>使用缩进，已足够令解释器执行，没必要使用多余的符号</li><li>强制缩进，源自古老的 ABC 语言，Guido 是这门语言的设计者之一</li><li>其思想可能出自 Don Knuth(高德纳，著名计算机科学家，经典巨著《计算机程序设计艺术》的作者)，他在 1974 年提出，在当时是很时髦和前卫的思想</li><li>使用缩进，可以终结大括号放在函数名后面还是再换一行的终极争论(据说此话题能令不同派系的程序员大打出手！)</li></ul><p>从 Python 发布至今，关于缩进是不是其设计的败笔就一直被大家讨论，我只能说见仁见智。</p><hr><p>对了，还有一个问题，关于我的博客界面左上角一直显示的加载中的字样，已经修复好了。</p><p>至于是怎么修好的，其实到现在我都不知道是哪里出了问题，也找不到类似的情况和解决方法，就只能把前端的美化“恢复出厂设置”了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们大致了解了 Go 语言的开发背景和开发理念。</p><p>当然本文中的大多数内容都是我看到别人的文章以及 Go 语言之父的演讲稿。</p><p>关于更加细节的开发和设计理念，我还在学习当中，后续会根据学习的情况更新文章，Go语言最为重要的并发还没开始，这个系列就肯定不会结束。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://golang3.eddycjy.com/posts/started-go/">https://golang3.eddycjy.com/posts/started-go/</a></li><li><a href="https://zhuanlan.zhihu.com/p/645695890">https://zhuanlan.zhihu.com/p/645695890</a></li><li><a href="https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f">https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f</a></li><li><a href="https://blog.csdn.net/weixin_39915668/article/details/111451430">https://blog.csdn.net/weixin_39915668/article/details/111451430</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。&lt;/p&gt;
&lt;p&gt;在学习一门语言时，有没有考虑过这个语言的语法和格式为什么</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>操作数据库</title>
    <link href="http://example.com/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2024-03-26T06:34:52.000Z</published>
    <updated>2024-04-06T14:26:10.024Z</updated>
    
    <content type="html"><![CDATA[<p>目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。那么这一节我们就要开始学习如何将数据存入数据库。</p><h1 id="操作-MySQL-数据库"><a href="#操作-MySQL-数据库" class="headerlink" title="操作 MySQL 数据库"></a>操作 MySQL 数据库</h1><p>在本项目中所选用的数据库为<code>MySQL</code>，使用GO操作<code>MySQL</code>等数据库，一般有两种方法：</p><ul><li>一是利用 database/sql 接口，直接在代码里硬编码 sql 语句；</li><li>二是使用 ORM，具体一点是 GORM，以对象关系映射的方式在抽象地操作数据库。</li></ul><h2 id="database-sql"><a href="#database-sql" class="headerlink" title="database/sql"></a>database/sql</h2><p><code>database/sql</code> 包通过提供统一的编程接口，实现了对不同数据库驱动的抽象。</p><h3 id="大致原理"><a href="#大致原理" class="headerlink" title="大致原理"></a>大致原理</h3><ol><li><code>Driver</code> 接口定义：<code>database/sql/driver</code> 包中定义了一个 <code>Driver</code> 接口，该接口用于表示一个数据库驱动。驱动开发者需要实现该接口来提供与特定数据库的交互能力。</li><li><code>Driver</code> 注册：驱动开发者需要在程序初始化阶段，通过调用 <code>database/sql</code> 包提供的 <code>sql.Register()</code> 方法将自己的驱动注册到 <code>database/sql</code> 中。这样，<code>database/sql</code> 就能够识别和使用该驱动。</li><li>数据库连接池管理：<code>database/sql</code> 维护了一个数据库连接池，用于管理数据库连接。当通过 <code>sql.Open()</code> 打开一个数据库连接时，<code>database/sql</code> 会在合适的时机调用注册的驱动来创建一个具体的连接，并将其添加到连接池中。连接池会负责连接的复用、管理和维护工作，并且这是并发安全的。</li><li>统一的编程接口：<code>database/sql</code> 定义了一组统一的编程接口供用户使用，如 <code>Prepare()</code>、<code>Exec()</code> 和 <code>Query()</code> 等方法，用于准备 SQL 语句、执行 SQL 语句和执行查询等操作。这些方法会接收参数并调用底层驱动的相应方法来执行实际的数据库操作。</li><li>接口方法的实现：驱动开发者需要实现 <code>database/sql/driver</code> 中定义的一些接口方法，以此来支持上层 <code>database/sql</code> 包提供的 <code>Prepare()</code>、<code>Exec()</code> 和 <code>Query()</code> 等方法，以提供底层数据库的具体实现。当 <code>database/sql</code> 调用这些方法时，实际上会调用注册的驱动的相应方法来执行具体的数据库操作。</li></ol><p>通过以上的机制，<code>database/sql</code> 包能够实现对不同数据库驱动的统一封装和调用。用户可以使用相同的编程接口来进行数据库操作，无需关心底层驱动的具体细节。这种设计使得代码更具可移植性和灵活性，方便切换和适配不同的数据库。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><code>database/sql</code> 具有如下特点：</p><ul><li>统一的编程接口：<code>database/sql</code> 库提供了一组统一的接口，使得开发人员可以使用相同的方式操作不同的数据库，而不需要学习特定数据库的 API。</li><li>驱动支持：通过导入第三方数据库驱动程序，<code>database/sql</code> 可以与多种常见的关系型数据库系统进行交互，如 MySQL、PostgreSQL、SQLite 等。</li><li>预防 SQL 注入：<code>database/sql</code> 库通过使用预编译语句和参数化查询等技术，有效预防了 SQL 注入攻击。</li><li>支持事务：事务是一个优秀的 SQL 包必备功能。</li></ul><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>与数据库建立连接的代码非常简单，只需调用 <code>sql.Open()</code> 函数即可。它接收两个参数：</p><ul><li>驱动名称</li></ul><p>这里驱动名称为 <code>mysql</code>，<code>database/sql</code> 之所以能够识别这个驱动名称，是因为在匿名导入 <code>github.com/go-sql-driver/mysql</code> 时，这个库内部调用了 <code>sql.Register</code> 将其注册给了 <code>database/sql</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sql.Register(<span class="string">&quot;mysql&quot;</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言中，一个包的 <code>init</code> 方法会在导入时会被自动调用，这里完成了驱动程序的注册。这样在调用 <code>sql.Open()</code> 时才能找到 <code>mysql</code> 驱动。</p><ul><li>DSN</li></ul><p>第二个参数 DSN 全称 <code>Data Source Name</code>，数据库的源名称，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// [用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表</span><br><span class="line">[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</span><br></pre></td></tr></table></figure><p>为了更加直观，我们可以使用 <code>mysql.Config</code> 来创建连接信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据库连接信息</span></span><br><span class="line">config := mysql.Config&#123;</span><br><span class="line">    User:                 <span class="string">&quot;homestead&quot;</span>,</span><br><span class="line">    Passwd:               <span class="string">&quot;secret&quot;</span>,</span><br><span class="line">    Addr:                 <span class="string">&quot;127.0.0.1:3306&quot;</span>,</span><br><span class="line">    Net:                  <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    DBName:               <span class="string">&quot;goblog&quot;</span>,</span><br><span class="line">    AllowNativePasswords: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sql.Open()</code> 调用后将返回一个 <code>*sql.DB</code> 类型，可以用来操作数据库。</p><p>另外，我们调用 <code>defer db.Close()</code> 来释放数据库连接。其实这一步操作也可以不做，<code>database/sql</code> 底层连接池会帮我们处理。一旦关闭了连接，就不可以再继续使用这个 <code>db</code> 对象了。</p><p><code>*sql.DB</code> 的设计是用来作为长连接使用的，所以不需要频繁的进行 <code>Open</code> 和 <code>Close</code> 操作。如果我们需要连接多个数据库，则可以为每个不同的数据库创建一个 <code>*sql.DB</code> 对象，保持这些对象为 <code>Open</code> 状态，不必频繁使用 <code>Close</code> 来切换连接。</p><p>值得注意的是，其实 <code>sql.Open()</code> 并没有真正建立数据库连接，它只是准备好了一切，以备后续使用，连接将在第一次被使用时延迟建立。</p><p>这样的设计虽然合理，可也有些违反直觉，<code>sql.Open()</code> 甚至不会校验 DSN 参数的合法性。不过我们可以使用 <code>db.Ping()</code> 方法来主动检查连接是否能被正确建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连接池设置"><a href="#连接池设置" class="headerlink" title="连接池设置"></a>连接池设置</h4><p>使用 <code>sql.Open()</code> 并不会建立一个唯一的数据库连接，事实上，<code>database/sql</code> 会维护一个连接池。</p><p>我们可以通过如下方法，控制连接池的一些参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(<span class="number">5</span> * time.Minute)</span><br></pre></td></tr></table></figure><h5 id="SetMaxOpenConns-最大连接数"><a href="#SetMaxOpenConns-最大连接数" class="headerlink" title="SetMaxOpenConns 最大连接数"></a>SetMaxOpenConns 最大连接数</h5><p>设置连接池最大打开数据库连接数，&lt;= 0 表示无限制，默认为 0。</p><ul><li>应该设置多大？<ul><li>实验表明，在高并发的情况下，将值设为大于 10，可以获得比设置为 1 接近六倍的性能提升。而设置为 10 跟设置为 0（也就是无限制），在高并发的情况下，性能差距不明显。</li></ul></li><li>是否越大越好？<ul><li>需要考虑的是不要超出数据库系统设置的最大连接数。另外，还需要注意这个值是整个系统的，如有其他应用程序也在共享这个数据库，这个可以合理地控制小一点。</li></ul></li></ul><h5 id="SetMaxIdleConns-空闲连接数"><a href="#SetMaxIdleConns-空闲连接数" class="headerlink" title="SetMaxIdleConns 空闲连接数"></a>SetMaxIdleConns 空闲连接数</h5><p>设置连接池最大空闲数据库连接数，&lt;= 0 表示不设置空闲连接数，默认为 2。</p><ul><li>应该设置多大？<ul><li>实验表明，在高并发的情况下，将值设为大于 0，可以获得比设置为 0 <strong>超过 20 倍的性能提升</strong>。</li><li>这是因为设置为 0 的情况下，每一个 SQL 连接执行任务以后就销毁掉了，执行新任务时又需要重新建立连接。很明显，重新建立连接是很消耗资源的一个动作。</li><li>设置空闲连接数，当有新任务进来时，直接使用这些随时待命的连接传输数据，以此达到节约资源，提高执行效率的目的。</li></ul></li><li>是不是数值越大越好？<ul><li>首先此值不能大于 <code>SetMaxOpenConns</code> 的值，大于的情况下 mysql 驱动会自动将其纠正。</li><li>其次需要考虑的是，长时间打开大量的数据库连接需要占用系统的内存和 CPU 资源。</li><li>还有一个情况是 MySQL 会有一个 <code>wait_timeout</code> 的设置，连接超过这个时间就会被自动关闭，默认情况下是 8 个小时。当 MySQL 关闭连接时，sql.DB 请求到的就是一个坏的连接，虽然 sql 包里已经做了处理，当请求到坏连接时会自动重连。但是在这种情况下，单次请求相当于建立了两次连接，消耗比设置为 0 还大，得不偿失。</li><li>所以回答上面的问题，不是越大越好，应根据实际情况选择合理的值。</li></ul></li></ul><h5 id="SetConnMaxLifetime-过期时间"><a href="#SetConnMaxLifetime-过期时间" class="headerlink" title="SetConnMaxLifetime 过期时间"></a>SetConnMaxLifetime 过期时间</h5><p>设置连接池里每一个连接的过期时间，过期会自动关闭。理论上来讲，在并发的情况下，此值越小，连接就会越快被关闭，也意味着更多的连接会被创建。</p><ul><li>应该设置多大？<ul><li>设置的值不应该超过 MySQL 的 <code>wait_timeout</code> 设置项（默认情况下是 8 个小时）。</li><li>此值也不宜设置过短，关闭和创建都是极耗系统资源的操作。</li><li>设置此值时，需要特别注意 SetMaxIdleConns 空闲连接数的设置。假如设置了 100 个空闲连接，过期时间设置了 1 分钟，在没有任何应用的 SQL 操作情况下，数据库连接每 1.6 秒就销毁和新建一遍。</li><li>这里的推荐，比较保守的做法是设置五分钟</li></ul></li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>`*sq</p><p><code>l.DB</code> 提供了 <code>Exec</code> 方法来执行一条 SQL 命令，可以用来<strong>创建</strong>、<strong>更新</strong>、<strong>删除</strong>表数据等。</p><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Exec(<span class="string">`INSERT INTO user(name, email, age, birthday, salary) VALUES(?, ?, ?, ?, ?)`</span>, user.Name, user.Email, user.Age, user.Birthday, user.Salary)</span><br></pre></td></tr></table></figure><p>其中 <code>?</code> 作为参数占位符，不同数据库驱动程序的占位符可能不同，可以参考数据库驱动的文档。</p><p>我们将这 5 个参数顺序传递给 <code>db.Exec</code> 方法，即可完成用户的创建。</p><p><code>db.Exec</code> 方法调用后将返回 <code>sql.Result</code> 保存结果以及一个 <code>error</code> 来标记错误。</p><p><code>sql.Result</code> 是一个接口，它包含两个方法：</p><ul><li><code>LastInsertId() (int64, error)</code>：返回新插入的用户 ID。只用在 <code>INSERT</code> 语句且数据表有自增 ID 时才有返回自增 ID 值，否则返回 0。</li><li><code>RowsAffected() (int64, error)</code>：返回当前操作受影响的行数，我们以此来判断 <code>SQL</code> 语句是否执行成功。</li></ul><p>接口具体实现有数据库驱动程序来完成。</p><p>此外，<code>database/sql</code> 还提供了预处理方法 <code>*sql.DB.Prepare</code> 创建一个准备好的 SQL 语句，在循环中使用预处理，则可以减少与数据库的交互次数。</p><p>比如我们需要创建两个用户，则可以先使用 <code>db.Prepare</code> 创建一个 <code>*sql.Stmt</code> 对象，然后多次调用 <code>*sql.Stmt.Exec</code> 方法来插入数据。</p><p><code>db.Prepare</code> 是预先将一个数据库连接和一个条 SQL 语句绑定并返回 <code>*sql.Stmt</code> 结构体，它代表了这个绑定后的连接对象，是并发安全的。</p><p>通过使用预处理，可以避免在循环中执行多次完整的 SQL 语句，从而显著减少了数据库交互次数，这可以提高应用程序的性能和效率。</p><p>使用预处理，会在 <code>db.Prepare</code> 时从连接池获取一个连接，之后循环执行 <code>stmt.Exec</code>，最终释放连接。</p><p>如果使用 <code>db.Exec</code>，则每次循环时都需要：获取<strong>连接-执行 SQL-释放连接</strong>，这几个步骤，大大增加了与数据库的交互次数。</p><p>不要忘记调用 <code>stmt.Close()</code> 关闭连接，这个方法是密等的，可以多次调用。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在创建数据库并插入相应值后，我们就可以进行查询操作了。</p><p>因为 <code>Exec</code> 方法只会执行 SQL，不会返回结果，所以不适用于查询数据。<code>*sql.DB</code> 提供了 <code>Query</code> 方法执行查询操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>如下获取所有文章的例子：：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * from articles&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>Query()</code> 方法返回一个 <code>sql.Rows</code> 结构体，代表一个查询结果集。</p><blockquote><p>Query 和 Exec 都可以执行 SQL 语句，<strong>那他们的区别是什么呢？</strong></p><p>Exec 只会返回最后插入 ID 和影响行数，而 Query 会返回数据表里的内容（结果集）。</p><p>或者可以这么记：</p><p>Query 中文译为 <strong>查询</strong>，而 Exec 译为 <strong>执行</strong>。想查询数据，使用 Query。想执行命令，使用 Exec。</p></blockquote><ul><li><code>rows.Next()</code> 方法用来判断是否还有下一条结果，可以用于 <code>for</code> 循环，如果存在下一条结果，<code>rows.Next()</code> 将返回 <code>true</code>。</li><li><code>rows.Scan()</code> 方法可以将结果扫描到传递进来的指针对象。<code>rows.Scan()</code> 会将一行记录分别填入指定的变量中，并且会自动根据目标变量的类型处理类型转换的问题，比如数据库中是 <code>varchar</code> 类型，会映射成 Go 中的 <code>string</code>，但如果与之对应的目标变量是 <code>int</code>，那么转换失败就会返回 <code>error</code>。</li></ul><p>如果是读取一行数据，可以使用 <code>QueryRow()</code>，语法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><p>返回的是一个 <code>sql.Row</code> 对象，与其相关的调用有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Row)</span></span> Scan(dest ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure><p><code>sql.Row</code> 没有 <code>Close</code> 方法，当我们调用 <code>Scan()</code> 时就会自动关闭 SQL 连接。所以为了防止忘记关闭而浪费资源，一般需要养成连着调用 <code>Scan()</code> 习惯。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新操作同创建一样可以使用 <code>*sql.DB.Exec</code> 方法来实现，不过这里我们将使用 <code>*sql.DB.ExecContext</code> 方法来实现。</p><p><code>ExecContext</code> 方法与 <code>Exec</code> 方法在使用上没什么两样，只不过第一个参数需要接收一个 <code>context.Context</code>，它允许你控制和取消执行 SQL 语句的操作。使用上下文可以在需要的情况下设置超时时间、处理请求取消等操作。</p><p>三个常用的 SQL 请求方法都有其支持上下文的版本，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><p>支持 Context 上下文的方法传参标准库 context 里的 context.Context 对象实例。</p><p>在一些特殊场景里，我们需要 SQL 请求在执行还未完成时，我们可以取消他们（cancel），或者为请求设置最长执行时间（timeout），就会用到这些方法。</p><p>另外需要知道的是，所有的请求方法底层都是用其上下文版本的方法调用，且传入默认的上下文，例如 <code>Exec()</code> 的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.ExecContext(context.Background(), query, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层调用的是 <code>ExecContext()</code> 方法。<code>context.Background()</code> 是默认的上下文，这是一个空的 <code>context</code> ，我们无法对其进行取消、赋值、设置 deadline 等操作。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>同更新的语句是一样的，只需要把语句稍作更改即可。</p><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>如果没有开启事务，当其中某个语句执行错误，则前面已经执行的 SQL 语句无法回滚。对于一些要求比较严格的业务逻辑来说，如付款、转账等，应该在同一个事务中提交多条 SQL 语句，避免发生执行出错无法回滚事务的情况。</p><p>使用以下可以开启事务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin() (*Tx, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> BeginTx(ctx context.Context, opts *TxOptions) (*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Begin()</code> 和 <code>BeginTx()</code> 方法返回一个 <code>sql.Tx</code> 结构体，他支持以上我们提到过的几种查询方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预编译 Prepare</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Stmt(stmt *Stmt) *Stmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> StmtContext(ctx context.Context, stmt *Stmt) *Stmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> PrepareContext(ctx context.Context, query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>使用这同一个 <code>sql.Tx</code> 对数据库进行操作，就会在同一个事务中提交。</p><p>当使用 <code>sql.Tx</code> 的操作方式操作数据后，需要使用 <code>sql.Tx</code> 的 <code>Commit()</code> 方法提交事务，如果出错，则可以使用 <code>sql.Tx</code> 中的 <code>Rollback()</code> 方法回滚事务，保持数据的一致性，下面是这两个方法的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Commit() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Rollback() <span class="type">error</span></span><br></pre></td></tr></table></figure><p>下面是个简单的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Service)</span></span> DoSomething() (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建事务</span></span><br><span class="line">    tx, err := s.db.Begin()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果请求失败，就回滚所有 SQL 操作，否则提交</span></span><br><span class="line">    <span class="comment">//    defer 会在当前方法的最后执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        err = tx.Commit()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行各种请求</span></span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，所有 SQL 操作都必须使用 <code>tx</code> 来操作，才能支持事务，如果中间使用 <code>db.Exec()</code> 那这条语句是无法回滚的。</p><h2 id="集成-GORM"><a href="#集成-GORM" class="headerlink" title="集成 GORM"></a>集成 GORM</h2><h3 id="什么是-ORM-？"><a href="#什么是-ORM-？" class="headerlink" title="什么是 ORM ？"></a>什么是 ORM ？</h3><p>ORM 全称是：Object Relational Mapping (对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象（结构体），那就对应着一张表，这个对象的实例，就对应着表中的一条记录。</p><h3 id="为什么要使用-GORM？"><a href="#为什么要使用-GORM？" class="headerlink" title="为什么要使用 GORM？"></a>为什么要使用 GORM？</h3><p>本项目使用 GORM 的理由：</p><ol><li>现代化，面对对象</li><li>多数据库支持，为高负载做好准备</li><li>提高项目安全性</li><li>提升开发效率和项目的可维护性</li></ol><p>我们都知道，在正式环境中直接使用 SQL 来查询数据库是很危险的，处理不好就有被注入式攻击的风险。而且组装 SQL 语句也容易出错和减低代码的可维护性。所以需要一个工具来管理数据库语句的组装和操作。</p><p>GORM 是目前比较成熟的 Go 语言数据库管理库，它可以很方便的把 Go 的结构体和数据库表绑定，从而简化获取数据的操作。</p><p>GORM 功能包括下面：</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context，预编译模式，DryRun 模式</li><li>批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><p>以上列表熟悉下即可，后面的项目开发中使用到自然就会记住了，脱离实战记忆没有意义。</p><h3 id="连接数据库-1"><a href="#连接数据库-1" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>与<code>database/sql</code>操作类似，使用<code>gorm.Open()</code>函数即可，该函数同样有两个参数：</p><ul><li>驱动名称</li><li>DSN</li></ul><p><code>*gorm.DB</code> 对象有一个方法 <code>DB()</code> 可以直接获取到 database/sql 包里的 <code>*sql.DB</code> 对象。<strong>GORM 底层也是使用 database/sql 来管理连接池</strong>。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><code>db.Create</code>方法可以新建一条数据，传入的是一个表结构体指针，返回值是一个<code>gorm.DB</code>,即我们的数据库连接。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Create(&amp;ormdemo.UserInfo&#123;</span><br><span class="line">    Name:   <span class="string">&quot;jaylog&quot;</span>,</span><br><span class="line">    Gender: <span class="string">&quot;man&quot;</span>,</span><br><span class="line">    Hobby:  <span class="string">&quot;pingpong&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你想避免<code>ErrRecordNotFound</code>错误，你可以使用<code>Find</code>，比如<code>db.Limit(1).Find(&amp;user)</code>，<code>Find</code>方法可以接受struct和slice的数据。</p><p>对单个对象使用<code>Find</code>而不带limit，<code>db.Find(&amp;user)</code>将会查询整个表并且只返回第一个对象，这是性能不高并且不确定的。</p></blockquote><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p><code>Save</code> 会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br></pre></td></tr></table></figure><p>当使用 <code>Update</code> 更新单列时，需要有一些条件，否则将会引起<code>ErrMissingWhereClause</code> 错误，当使用 <code>Model</code> 方法，并且它有主键值时，主键将会被用于构建条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据条件更新</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User 的 ID 是 `111`</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件和 model 的值进行更新</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><p><code>Updates</code> 方法支持 <code>struct</code> 和 <code>map[string]interface&#123;&#125;</code> 参数。当使用 <code>struct</code> 更新时，默认情况下GORM 只会更新非零值的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 `struct` 更新属性，只会更新非零值的字段</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 `map` 更新属性</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>删除一条记录时，删除对象需要指定主键，否则会触发批量删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><p>GORM 允许通过主键(可以是复合主键)和内联条件来删除对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们已经完成地了解了如何使用两种不同方法来操作数据库。数据库的操作是本项目的重中之重，好好理解这一节的内容对面是有着不小的帮助，因为笔者的第一次面试就是挂在关于数据库的问题上的。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://gorm.io/zh_CN/docs/index.html">GORM</a></li><li><a href="https://xie.infoq.cn/article/6bd776b9af4f1996603ef0948">database/sql</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。那么这一节我们就要开始学习如何将数据存入数据库。&lt;/p&gt;
&lt;h1 id=&quot;操作-MySQL-数据库&quot;&gt;&lt;a href=&quot;#操作-MySQL-数据库&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>路由和中间件</title>
    <link href="http://example.com/2024/03/25/%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2024/03/25/%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2024-03-25T08:07:46.000Z</published>
    <updated>2024-04-06T14:26:04.873Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要用于介绍<code>GoBlog</code>项目中两个最为重要的部分——路由和中间件。这两个部分可以说是本项目的重要组成部分，下面我们会逐个进行学习和分析，并大概介绍其在项目中的作用。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>goblog 需要一款灵活的路由器来搭配 MVC 程序结构，恰巧Go Web 开发有各式各样的路由器可供选择。这个时候可能就有朋友要问了，什么是路由啊，路由有什么用呢？额……其实我在学的时候也有这样的问题，那就慢慢往下看吧。</p><h2 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h2><p>路由，<strong>就是URL地址到业务处理代码的映射</strong>。当用户输入一个<code>URL</code>地址时，服务器改知道要返回什么内容，一个 <code>URL</code> 到一个具体的处理函数之间的映射叫做一条路由。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/6decf088ea6d29afbee3c19acc63c4de.png" alt="img"></p><p>多条路由组成路由表，路由表主要用于路由查找，根据不同的路由表的组织形式，可以有不同的查找方法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e98393a4afcc24a509f1d169d8360fad.png" alt="img"></p><p>给定一个<code>URL</code>，找到对应的处理函数的过程叫做路由查找。路由器就是用来管理路由表并进行路由查找的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0bda1fefe4d9adbf3a91bc13466c85c0.png" alt="img"></p><p>所以，在<code>Web</code>系统中一个路由系统由路由、路由表和路由匹配三部分功能组成。</p><p>路由实现由三种方法，分别是基于映射表、正则表达式以及tries结构的路由实现，下面将会一一介绍。</p><h2 id="基于映射表的路由实现"><a href="#基于映射表的路由实现" class="headerlink" title="基于映射表的路由实现"></a>基于映射表的路由实现</h2><p><code>Go</code>内建标准包<code>bet/http</code>中路由的实现是基于映射表实现的，也是最简单的路由。</p><h3 id="http怎么处理请求"><a href="#http怎么处理请求" class="headerlink" title="http怎么处理请求"></a>http怎么处理请求</h3><p><code>Go</code> 语言中处理 <code>HTTP</code> 请求主要跟两个东西相关：<code>ServeMux</code> 和 <code>Handler</code>。</p><p><code>ServeMux</code> 本质上是一个 <strong>HTTP 请求路由器</strong>（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的<strong>处理器（Handler）</strong>。</p><p>下面来看 <code>HandleFunc</code>函数的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>pattern</code> 是 URI 的规则，例如 <code>/</code> 或者 <code>about</code></li><li><code>handler</code> 是供调用的函数</li></ul><p><code>http.HandleFunc()</code> 函数是对 <code>DefaultServeMux.HandleFunc()</code> 的封装，当 <code>http.ListenAndServe(addr string, handler Handler)</code> 的第二个参数为 <code>nil</code> 时，会使用<code>DefaultServeMux.HandleFunc()</code></p><h3 id="net-http包中路由的实现"><a href="#net-http包中路由的实现" class="headerlink" title="net/http包中路由的实现"></a>net/http包中路由的实现</h3><p>在<code>net/http</code>包中实现路由的机构提是<code>ServeMux</code>，其结构定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line"> mu    sync.RWMutex</span><br><span class="line"> m     <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line"> es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line"> hosts <span class="type">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段很简单，我们重点看m变量，是一个map类型，即key-value结构，就是我们所说的路由表。key就是路由的路径，value是一个<code>muxEntry</code>对象，<code>muxEntry</code>结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line"> h       Handler</span><br><span class="line"> pattern <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pattern</code>是对应的路径，<code>h</code>就是对应的处理函数。当我们进行路由注册时候，实质上就是将路径和<code>HomeHandler</code>对象构建成一个<code>muxEntry</code>对象，然后加入到<code>ServeMux</code>的<code>m</code>中。</p><p>接下来我们再看路<strong>由的查找</strong>，既然路由表是有map实现的，那么路由的查找过程自然就是通过路径从map中查找对应的<code>muxEntry</code>，然后获取对应的<code>handler</code>即可。</p><p>以上就是<code>net/http</code>包中自己路由的实现。非常简单，同时也意味着功能有限。</p><h3 id="http-ServeMux-的局限性"><a href="#http-ServeMux-的局限性" class="headerlink" title="http.ServeMux 的局限性"></a>http.ServeMux 的局限性</h3><p>http.ServeMux 在 goblog 中使用，会遇到以下几个问题：</p><ul><li>不支持 URI 路径参数</li><li>不支持请求方法过滤<ul><li>无法直接从路由上区分 POST 或者 GET 等 HTTP 请求方法，只能手动判断。</li></ul></li><li>不支持路由命名<ul><li>路由命名是一套允许我们快速修改页面里显示 URL 的机制。</li></ul></li></ul><p><strong>优点</strong></p><ul><li>标准库意味着随着 Go 打包安装，无需另行安装</li><li>测试充分</li><li>稳定、兼容性强</li><li>简单，高效</li></ul><p><strong>缺点</strong></p><ul><li>缺少 Web 开发常见的特性</li><li>在复杂的项目中使用，需要你写更多的代码</li></ul><h2 id="基于正则表达式的路由实现"><a href="#基于正则表达式的路由实现" class="headerlink" title="基于正则表达式的路由实现"></a>基于正则表达式的路由实现</h2><p>该包是基于正则表达式实现的路由。该路由支持分组、restful风格路径的定义、绑定路由请求的方法（GET、POST等）、限定路径使用http还是https协议等功能。在本项目中所使用到的路由就是这个。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>通过<code>mux.NewRouter()</code>方法返回了一个<code>Router</code>结构体对象。该结构体对象也实现了<code>ServeHTTP</code>方法，在该方法中<strong>实现了对路由的匹配和转发</strong>。所以覆盖作为<code>http.ListenAndServe</code>的第二个参数，替代了默认的路由分发对象<code>DefaultServeMux</code>。</p><p>在该包中<code>Router</code>的<code>ServeHTTP</code>方法对路由的匹配和分发部分，本质上是和默认的路由分发器DefaultServeMux的实现是一样的。不同的是路由的管理以及匹配上。</p><p>Router 结构体如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d03836d9ccfb7e93bba1e54793c04908.png" alt="img"></p><p>这里我们只列出来核心的字段，省略了一些辅助字段。这里有几个主要的字段：</p><ul><li><strong>Router</strong>中的routes：Route切片类型，角色是路由表，存储所有的路由。</li><li><strong>Route</strong>：一个具体的路由，handler字段存储的是具体的处理函数，同时每个路由的路径是在最后的routeRegexp结构体中的。</li><li><strong>matchers</strong>字段：切片类型，存储了该路由下的所有要匹配的规则。matchers的类型是一个matcher接口，定义了Match方法。其中routeRegexp结构体实现了该方法，所以一个routeRegexp实例就是一个matcher。</li><li><strong>routeRegexp</strong>结构体：该结构体代表了路由中具体的路径的匹配规则。将路由中的路径转换成对应的正则表达式，存储与regexp字段中。</li></ul><p><strong>routeRegexp</strong>结构体中的主要字段分别如下：</p><ul><li><strong>template</strong>：保存的是路由的路径模版。比如<code>r.HandleFunc(&quot;/product/&#123;id:[0-9]+&#125;&quot;, ProductHandler)</code>中，则是<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code></li><li><strong>regexpType</strong>：正则类型，目前支持regexpTypePath、regexpTypeHost、regexpTypePrefix、regexpTypeQuery四种类型。比如<code>r.HandleFunc(&quot;/product/&#123;id:[0-9]+&#125;&quot;, ProductHandler)</code>就是路径匹配regexpTypePath。而<code>r.Host(&quot;www.example.com&quot;)</code>就是域名匹配regexpTypeHost。稍后我们会一一介绍。</li><li><strong>regexp</strong>：是根据路由中的模版路径构造出来的正则表达式。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，最终构造的正则表达式是 <code>^/product/(?P&lt;v0&gt;[0-9]+)$�</code><br>reverse：</li><li><strong>varsN</strong>：是路径模式中花括号{}中的变量个数。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，varsN则等于[]{“id”}。</li><li><strong>varsR</strong>：是路径模式中每个花括号{}对应的正则表达式。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，varsR则等于<code>[]&#123;&quot;^[0-9]+$&quot;&#125;</code>。如果路由中是设置<code>r.HandleFunc(&quot;/product/&#123;id&#125;&quot;, ProductHandler)</code>，varsR的元素则是<code>[]&#123;&quot;^[^/]+�&quot;&#125;</code>的正则表达式。</li></ul><p>根据路由表及路由的结构，具体的路由匹配查找基本过程如下：第一步，从 Router.routes 开始依次循环第二步，从每个路由中的 matchers 中循环，看请求的路径是否符合 matchers 中的每一项规则，如果都匹配，则说明找到了该路由，否则继续步骤 1。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4f13aaad7c30f54713ae1a2d6246335a.png" alt="img"></p><h3 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h3><ul><li>匹配特定的域名或子域名</li><li>给路径增加前缀</li><li>限制路由的请求方法（GET、POST等）</li><li>支持路由分组</li><li>支持中间件</li></ul><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p>gorilla/mux 的路由解析采用的是 <strong>精准匹配</strong> 规则，而 net/http 包使用的是 <strong>长度优先匹配</strong> 规则。</p><ul><li><strong>精准匹配</strong> 指路由只会匹配准确指定的规则，这个比较好理解，也是较常见的匹配方式。</li><li><strong>长度优先匹配</strong> 一般用在静态路由上（不支持动态元素如正则和 URL 路径参数），优先匹配字符数较多的规则。</li></ul><p>一般 <strong>长度优先匹配</strong> 规则用在静态内容处理上比较合适，动态内容，例如我们的 goblog 这种动态网站，使用 <strong>精准匹配</strong> 会比较方便。</p><h2 id="基于-tries-结构的路由实现"><a href="#基于-tries-结构的路由实现" class="headerlink" title="基于 tries 结构的路由实现"></a>基于 tries 结构的路由实现</h2><h3 id="gin-框架中的路由"><a href="#gin-框架中的路由" class="headerlink" title="gin 框架中的路由"></a>gin 框架中的路由</h3><p>大名鼎鼎的 gin 框架采用的就是前缀树结构实现的路由。我们先来看一下 gin 框架中路由是如何定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  g := gin.New()</span><br><span class="line">  </span><br><span class="line">  g.POST(<span class="string">&quot;/abc/info&quot;</span>, InfoHandler)</span><br><span class="line">  g.POST(<span class="string">&quot;/abc/info/detail&quot;</span>, InfoHandler)</span><br><span class="line">  g.POST(<span class="string">&quot;/abc/list&quot;</span>, HomeHandler)</span><br><span class="line">  g.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HomeHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.Writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, this is Home page&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InfoHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.Writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, this is info&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，首先通过 gin.New()初始化一个 gin 对象 g，然后通过 g.POST 或 g.GET 等方法就可以注册路由。很明显，路由注册过程也限制了请求的方法。</p><p>当然，还有一个方法是允许任何请求方法都能访问该路径的，就是 Any：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.Any(<span class="string">&quot;/&quot;</span>, HomeHandler)</span><br></pre></td></tr></table></figure><p>Any 方法本质上是定义了一组方法名，然后依次调用对应的方法将该路由进行注册，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  anyMethods = []<span class="type">string</span>&#123;</span><br><span class="line">    http.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,</span><br><span class="line">    http.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,</span><br><span class="line">    http.MethodTrace,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any registers a route that matches all the HTTP methods.</span></span><br><span class="line"><span class="comment">// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Any(relativePath <span class="type">string</span>, handlers ...HandlerFunc) IRoutes &#123;</span><br><span class="line">  <span class="keyword">for</span> _, method := <span class="keyword">range</span> anyMethods &#123;</span><br><span class="line">    group.handle(method, relativePath, handlers)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>相比较 map/hash 字典实现的优点：利用字符串公共前缀来减少查询时间，减少无谓的字符串比较。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ad3c820a8c6cbb62704d59796bf40927.png" alt="img"></p><p>上述示例中的<code>g.POST(&quot;/abc/info&quot;, InfoHandler)</code>路由，只会注册到 POST 方法的路由树中。若通过 GET 方法请求该路径，则在搜索的时候，在 GET 方法的路由树中就找不到该路由。这样就起到了通过路由限制请求方法的作用。</p><h4 id="路由树节点的数据结构"><a href="#路由树节点的数据结构" class="headerlink" title="路由树节点的数据结构"></a>路由树节点的数据结构</h4><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b147889ed160783df17d31acea619d57.png" alt="img"></p><p>前缀树中的路由都是基于这个 node 数据结构来进行构建的。其中包含了一个路由中的基本元素：路径 fullPath、对应的处理函数 handlers。其中 handlers 包含了中间件处理函数，因此这里使用一个 handlersChain 表示。</p><p>另外一个关键字段是 children，具有相同路径前缀的子节点通过 children 节点来构成父、子关系。</p><h3 id="路由树的构建"><a href="#路由树的构建" class="headerlink" title="路由树的构建"></a>路由树的构建</h3><p>第一个路由的注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/info&quot;</span>, InfoHandler)</span><br></pre></td></tr></table></figure><p>因为是第一个路由注册，路由树是空的。所以直接构建一个 node 节点，然后将该 node 节点作为 POST 方法路由树的根节点插入即可。如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ab2cd3446fec7cc526bed195a8f7c771.png" alt="img"></p><p>接着注册第二个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/info/detail&quot;</span>, DetailHandler)</span><br></pre></td></tr></table></figure><p>这个路由的特点是和路由”/abc/info”有共同的前缀，所以会将该路由作为第一个路由的子节点放到 children 中。如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/652ef39044e3f6dde0f9740c0e0593fd.png" alt="img"></p><p>这里主要有三个变化：</p><ul><li>一个是根节点的 priority 由 1 变成了 2；</li><li>一个是 children 中多了一个子节点路由；</li><li>最后一个是 indices 字段的值变成了”/“，这个是第一个子节点的 path 字段的第一个字符，用于匹配时索引使用。</li></ul><p>在子节点中，要注意的是 path 的值，因为前缀是”/abc/info”了，所以这里 path 是”/detail”。但 fullPath 依然是注册时完整的路径。</p><p>接下来，再注册第三个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/list&quot;</span>, ListHandler)</span><br></pre></td></tr></table></figure><p>这个路由的特点是和前两个路由有共同的前缀”/abc/“，所以首先会将现在的根节点进行拆分，拆分成”/abc/“ 和”info”。而 info 和原来的”/abc/info/detail” 又有共同的前缀 info，所以原来的”/abc/info/detail”就变成了 info 的子节点。而”/abc/list”除去前缀”/abc/“后，剩余”list”子节点，作为”/abc/“的子节点。如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba55d2e6246676bf96c1175a9d4038ef.png" alt="img"></p><p>那么，按节点组成的路由树就如下所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d4917411671d346791c6ccddf86f9278.png" alt="img"></p><p>这里，首先看根节点的变化：</p><ul><li>handlers 变为 nil。因为该节点不是一个具体的路径，只是一个前缀，所以具体的 handler 下移到了子节点 info 节点。</li><li>path 变为了前缀”/abc/“。</li><li>indices 字段值变为了”il”，其中 i 是第一个子节点中 path 字段的第一个字符，l 是第二个子节点中 path 字段的第一个字符。</li><li>priority 字段变成 3：代表从自身开始及子节点共有 4 个。</li><li>children 字段变成了两个直接子节点。</li><li>fullPath 字段变为了”/abc/“。</li></ul><p>其次，是从原根节点中拆分出一个 info 节点。最后是 detail 节点成为 info 节点的子节点。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件是一种计算机软件，可为操作系统提供的软件应用程序提供服务，以便于各个软件之间的沟通，特别是系统软件和应用软件。广泛用于web应用和面向服务的体系结构等。</p><p>纵观GO语言，中间件应用比较普遍，主要应用：</p><ul><li>记录对服务器发送的请求（request）</li><li>处理服务器响应（response ）</li><li>请求和处理之间做一个权限认证工作</li><li>远程调用</li><li>安全</li><li>等等</li></ul><p><strong>中间件处理程序</strong>是简单的<code>http.Handler</code>，它包装另一个<code>http.Handler</code>做请求的一些预处理和/或后处理。它被称为“中间件”，因为它位于Go Web服务器和实际处理程序之间的中间位置。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1460000018819807" alt="img"></p><h3 id="在gin框架下实现中间件"><a href="#在gin框架下实现中间件" class="headerlink" title="在gin框架下实现中间件"></a>在gin框架下实现中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default() 创建带有默认中间件的路由，默认是包含logger和recovery中间件的</span><br><span class="line">r :=gin.<span class="built_in">new</span>()      创建带有没有中间件的路由</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们就大致了解了路由和中间件。在本项目中，路由和中间件实现了大多数功能，因此深刻地理解这两个概念能够帮助我更好的理解代码。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://xie.infoq.cn/article/0c2d65a7c72147dc457af5007">路由</a></li><li><a href="https://segmentfault.com/a/1190000018819804">中间件</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要用于介绍&lt;code&gt;GoBlog&lt;/code&gt;项目中两个最为重要的部分——路由和中间件。这两个部分可以说是本项目的重要组成部分，下面我们会逐个进行学习和分析，并大概介绍其在项目中的作用。&lt;/p&gt;
&lt;h1 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;he</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>GoBlog，启动！</title>
    <link href="http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/"/>
    <id>http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/</id>
    <published>2024-03-23T12:52:50.000Z</published>
    <updated>2024-03-23T12:38:48.272Z</updated>
    
    <content type="html"><![CDATA[<p>喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直到需要找实习才发现自己简历上能写的东西寥寥无几。说来奇怪，上了几年大学发现自己好像什么都没学到，这应该就是一种清醒的堕落吧。</p><p>我对这个项目的了解就像我对Go语言的了解一样，来自我那个神奇的舍友。他花钱买了教程之后，我就可以蹭一下了，很难想象没有我亲爱的舍友，我的大学生活会变成什么样子。</p><h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p>废话少说，为什么要用Go来开发一个博客系统呢？答案很简单，Go语言本身就非常适用于开发Web应用程序，而且我们在学习的过程中也不难发现好像很多大佬都有自己的博客，那不如把这两个结合一下，这样在设计具体功能的时候也能找到一些可以借鉴的地方。</p><p>开发Web应用要涉及到的知识：</p><ul><li>表单验证</li><li>注册登录</li><li>授权验证</li><li>共享数据库连接</li><li>密码哈希</li><li>路由和中间件</li><li>代码组织（MVC/RESTful）</li><li>打包静态文件和模板文件</li><li>项目部署等</li></ul><p>这些内容会在后面的博客中一一介绍，这个项目并不是一个玩具项目，后续的文章中也会解决一些会在实际生产环境中出现的问题。</p><p>本书源码：<a href="https://github.com/summerblue/goblog">github.com/summerblue/goblog</a></p><p>本项目并不是笔者自己开发的，是跟着社区的教程完成的。</p><h1 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h1><p>作为实战项目，遇到程序报错是很正常的情况，多解决报错能帮助我们学到不少东西。</p><p>在遇到一些很抽象的报错时，不要怀疑机器有问题，99%的概率问题在自己，即使代码都是复制的。</p><p>当然如果实在是找不到，可以利用源码来排除错误。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>Windows11</li><li>Go1.21.1</li><li>编译器Visual studio code</li></ul><h1 id="通过本项目学到了什么"><a href="#通过本项目学到了什么" class="headerlink" title="通过本项目学到了什么"></a>通过本项目学到了什么</h1><ul><li>数据库使用</li><li>模板使用</li><li>基础测试</li><li>项目开发流程</li><li>Go 项目结构选择</li></ul><h1 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240323203506135.png" alt="image-20240323203506135"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的Go Web程序</title>
    <link href="http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-03-22T14:27:49.000Z</published>
    <updated>2024-04-06T14:25:37.038Z</updated>
    
    <content type="html"><![CDATA[<p>在Go中，搭建一个http server简单到令人难以置信。只需要引入net/http包，写几行代码，一个http服务器就可以正常运行并接受访问请求。因此，在正式开启项目开发之前，先来看一段简短的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">&quot;&lt;h1&gt;Hello, 这里是 goblog&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handlerFunc)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这段代码就能够构成一个Web程序，其中最为主要的内容基本上都与一个包有关—— <code>net/http</code>，那就先学习一下有关这个包的内容吧。 </p><h1 id="初识net-http"><a href="#初识net-http" class="headerlink" title="初识net/http"></a>初识net/http</h1><p>在net/http源代码中，我们可以深深体会到Go语言的结构体（以及自定义类型）、接口、方法简单组合的设计哲学。这个包最主要的文件有4个，分别是： <code>client.go</code> <code>server.go</code> <code>request.go</code> <code>response.go</code>。</p><p>这四个文件也分别代表了HTTP中最重要的4个部分，<code>http Request</code> 请求、 <code>http Response</code> 响应、<code>http Client</code>客户端和<code>http Server</code> 服务端，所以我们先从这四个方面来了解<code>net/http</code>包：</p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>http Request</code>请求是由<strong>客户端发出</strong>的消息, 用来使<strong>服务器执行</strong>动作.发出的消息包括起始行, Headers, Body。</p><p>一般使用 <code>http.NewRequest</code>来构造一个<code>http Request</code>请求，可能包括<code>http Headers</code>信息，<code>cookies</code>信息等，然后发给服务端。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><code>http Response</code>响应是由<code>http Server</code>服务端发出的消息，用来响应<code>http Client</code>端发出的<code>http Request</code>请求。发出的消息包括起始行, Headers, Body。</p><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p><code>http Client</code>客户端主要用来发送<code>http Request</code>请求给<code>http Server</code>服务端，比如以<code>Do</code>方法，<code>Get</code>方法以及<code>Post</code>或<code>PostForm</code>方法发送<code>http Request</code>请求。</p><p><code>http.NewRequest</code>可以灵活的对<code>http Request</code>进行配置，然后再使用<code>http.Client</code>的<code>Do</code>方法发送这个<code>http Request</code>请求。</p><ul><li>如果使用<code>Post</code>或者<code>PostForm</code>方法，是不能使用<code>http.NewRequest</code>配置请求的，只有<code>Do</code>方法可以定制<code>http.NewRequest</code>。</li></ul><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><code>http Server</code>服务端用来接收并响应<code>http Client</code>端发出的<code>http Request</code>请求，是<code>net/http</code>包中非常重要和关键的一个功能。我们在Go语言中简单就能搭建<code>HTTP</code>服务器，就是因为它的存在。</p><p>关于以上四部分的详细内容，可以看<a href="https://wizardforcel.gitbooks.io/go42/content/content/42_36_http.html">这篇文章</a>，里面有更加详细的函数解释。</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>大概了解关于<code>net/http</code> 包之后，我们再回头看开篇的那段代码，或许已经能看懂个大概了。</p><h3 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h3><p><code>http.ListenAndServe</code> 用以监听本地 3000 端口以提供服务，标准的 HTTP 端口是 80 端口，如 <code>baidu.com:80</code>，另一个 Web 常用是 HTTPS 的 443 端口，如 <code>baidu.com:443</code>。</p><p>当我们监听本地端口时，可使用 <code>localhost</code> 加上端口号来访问。运行上面的程序，可以通过<a href="http://localhost:3000/">localhost:3000/</a> 进行访问。</p><h3 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h3><p><code>http.HandleFunc</code> 用以指定处理 HTTP 请求的函数，此函数允许我们只写一个 handler，请求会通过参数传递进来，使用者只需与 <code>http.Request</code> 和 <code>http.ResponseWriter</code> 两个对象交互即可。</p><p>在实例代码中，我们利用 <code>fmt.Fprint</code> 将 <code>&lt;h1&gt;Hello, 这里是 goblog&lt;/h1&gt;</code> 子串写入 <code>http.ResponseWriter</code>，即可响应用户请求。</p><h3 id="http-Request"><a href="#http-Request" class="headerlink" title="http.Request"></a>http.Request</h3><p><code>http.Request</code> 是用户的请求信息，一般用 <code>r</code> 作为简写。</p><p>一些常见的操作如：</p><ul><li><code>r.URL.Query()</code> 获取用户参数</li><li>获取客户端信息 <code>r.Header.Get(&quot;User-Agent&quot;)</code></li></ul><h3 id="http-ResponseWriter"><a href="#http-ResponseWriter" class="headerlink" title="http.ResponseWriter"></a>http.ResponseWriter</h3><p><code>http.ResponseWriter</code> 是返回用户的响应，一般用 <code>w</code> 作为简写。</p><p>常见操作如：</p><ul><li>返回 500 状态码 <code>w.WriteHeader(http.StatusInternalServerError)</code></li><li>设置返回标头 <code>w.Header().Set(&quot;name&quot;, &quot;my name is smallsoup&quot;)</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于Web程序我们就完成了简单的了解。我们通过<code>http.ListenAndServe</code>来对本地的端口进行监听，等待用户的操作。使用<code>http.HandleFunc</code>来完成当用户做出指定操作时的动作。<code>handlerFunc</code>函数则是我们自己定义的一系列动作，等待<code>HandleFunc</code>调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go中，搭建一个http server简单到令人难以置信。只需要引入net/http包，写几行代码，一个http服务器就可以正常运行并接受访问请求。因此，在正式开启项目开发之前，先来看一段简短的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>腾讯面试——血与泪的教训</title>
    <link href="http://example.com/2024/03/21/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD/"/>
    <id>http://example.com/2024/03/21/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD/</id>
    <published>2024-03-21T13:39:57.000Z</published>
    <updated>2024-03-22T05:48:23.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又到了一周一度的学习总结了，本周可以算得上是非常神奇的一周了。从标题也不难看出，神奇之处就在于本周是笔者第一次参加一场面试，可谓是非常的紧张。经过一场面试也让我深刻地感受到闭门造车是行不通的，在面试之前总觉得自己把什么都准备好了，结果在两个小时的面试过程中，被面试官牵着鼻子走（狗头）。所以本周的总结主要集中在对面试的复盘方面，希望在完成这次周报之后能对我以后的学习有一定的帮助吧。</p><h1 id="面试复盘"><a href="#面试复盘" class="headerlink" title="面试复盘"></a>面试复盘</h1><h2 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h2><ol><li><p>首先就是面试官介绍自己的部门和我的自我介绍。</p><p>从舍友的评价来看，自我介绍环节就已经十分紧张了，说话也是结结巴巴，十分的不自信。</p></li><li><p>三道算法题。</p><p>题目倒不是很难，也不需要能够完全正确，只需要自己的思路对就OK了。</p></li><li><p>拷打项目，也是本次面试中笔者表现的最呆瓜的一个环节了。</p><p>面试官问我为什么要选择MySQL来作为数据库来存储信息。我竟然脑抽到回答说我只会MySQL。</p></li><li><p>除了拷打项目，就是一些比较简单的八股了，还是有待加强。</p></li></ol><h2 id="项目拷打总结"><a href="#项目拷打总结" class="headerlink" title="项目拷打总结"></a>项目拷打总结</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>是否支持上传图片？图片是怎样进行存储的？怎么把图片和对应的文章正确地显示出来？</p><p>显然，对于并没有完全准备好的我来说，这三个问题已经足够干掉我了。</p><ol><li>已经实现了上传和显示图片的功能。</li><li>应该将图片存储在对应的服务器中，现阶段的存储方式为把用户上传的图片放到一个专门的文件夹中。</li><li>由于图片存储为在固定的文件夹中，那么只需要将文件的路径放在文章的正确位置即可，这样在进行页面展示时，可以将图片进行正确的显示。</li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如果用户量太大，每个人都往其中存储文章，导致表中内容过多，该怎么解决？</p><p>在实际的应用开发中，数据量过大的MySQL表会导致查询的性能下降。解决方法如下：</p><ol><li>分表分库</li></ol><p>​    将单张数据量过大的表拆分成多个较小的表，每个表只存储一部分数据，以此来提高查询效率。</p><ol><li>垂直拆分</li></ol><p>​    如果单表的列比较多，但是并不是所有列都会频繁地使用，可以考虑将一些少用的列拆分到新的表中，从而减少单个表的数据量，减少磁盘空间的使用。</p><ol><li>建立合适的索引</li></ol><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>上一个问题提到，当数据量过大时可以采用分表策略，那要怎么进行文章的定位呢？</p><p>水平切分后同一张表会出现在多个数据库或表中，每个库和表的内容不同，对于水平分表后分库后，如何知道哪条数据在哪个库里或表里，则需要路由算法进行计算，这个算法会引入一定的复杂性。</p><ul><li>范围路由</li></ul><p>选取有序的数据列，如时间戳作为路由的条件，不同分段分散到不同的数据库表中，以最常见的用户ID为例，路由算法可以按照1000000的范围大小进行分段，1 ~ 9999999放到数据库1的表中，10000000~199999999放到数据库2的表中，以此累推。<br>  范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多增加维护复杂度，分段太大可能会导致单表依然存在性能问题，按一般大老们的经验，分段大小100W至2000W之间，具体需要根据业务选 取合适的分段大小。</p><ul><li>范围路由的优点<ul><li>可以随着数据的增加平滑地扩充新的表或库，原有的数据不需要动。</li><li>单表大小可控</li><li>使用分片字段进行范围查找时，连续分片可快速定位查询，有效避免分片查询的问题。</li></ul></li><li><p>热点数据成为性能瓶颈，连续分片可能存在数据热点，例如按时单字段分片，有些分片存储最近时间内的数据，可能会被频繁读写，而有些历史数据则很少被查询。</p></li><li><p>hash算法</p></li></ul><p>  选取某个列或几个列的值进行hash运算，然后根据hash的结果分散到不同的数据库表中，以用ID为例，假如我们一开始就规划10个数据库表，路由算法可以简单地用id % 10的值来表示数据所属的数据库编号，ID为985的用户放到编号为5的子表中。ID为10086编号放到编号为6的表中。<br>  Hash路由设计的复杂点主要体现 在初始表数量的选取上，表数量太多维护比较麻烦，表数量太小又可能导致单表性能存在问题。而用Hash路由后，增加字表数量是非常麻烦的，所有数据都要重新分布。<br>  Hash路由的优缺点与范围路由相反，Hash路由的优点是表分布比较均匀，缺点是扩容时很麻烦，所有数据均需要重新分布。</p><ul><li>路由配置</li></ul><p>  配置路由就是路由表，用一张独立的表来记录路由信息。同样以用户ID为例，我们新增一张ROUTER表，这个表包含table_Id两列，根据user_id就可以查询对应的修改路由表就可以了。<br>配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。<br>其缺点就是必须多查询一次，会影响整体性能，而且路由表本身如果太大，性能会成为瓶颈点，如果我们再将路由表分库分表，则又面临一个死循环。</p><h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>如果实行分表，如何确保自增的文章ID不出现重复。或者有什么其他解决方案。</p><p>在本人的测试过程中发现，给ID设置为自增并不会影响用户自己设置ID。</p><p>关于分表后ID自增又会从1开始，我的解决方案是在需要进行分表时可以先获取前一个表的最后一篇文章，在得到这个文章的ID后，将新建的文章ID设置为上一篇文章的ID+1。</p><p>其他解决方案：如果采用hash算法进行分表的话，可以将设置文章ID和插入表分为两步操作，先根据自增将wenzhangID设置出来，再进行插入表的操作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，经过此次面试还是返现了学习上的不少漏洞，本篇文章只解决了在项目拷打环节的一些提问，关于八股文和一些算法方面的内容我想还是要分开来写。最后面试官也有提醒到项目还是可以增加一些功能。可问的点有很多，还是得把项目吃透。</p><p>从面试官所问的问题也不难看出，有关到项目的内容他们更想听到的是在实际中的各种情况和解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;又到了一周一度的学习总结了，本周可以算得上是非常神奇的一周了。从标题也不难看出，神奇之处就在于本周是笔者第一次参加一场面试，可谓是非常的紧张</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言——内存</title>
    <link href="http://example.com/2024/03/12/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2024/03/12/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</id>
    <published>2024-03-12T12:51:19.000Z</published>
    <updated>2024-03-15T05:54:16.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于内存部分的内容，是正在读的书中的第三部分，这一部分讲的是Go语言中的指针相关的知识，由于书中花费了一定篇幅去讲过于内存的问题，所以本周的总结报告命题为”内存“。</p><p>这并不是第三周全部学到的东西，只是开始，由于我现在还不能把学到的东西随手记录下来，所以选择先写一篇学习总结。我详细一篇应该是关于项目实战的。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>提到指针，我们并不陌生，从开始学习程序设计就已经接触到了指针。对我来说，指针是一个既熟悉又陌生的东西。熟悉是因为在最开始的学习时，我和同学不止一次地讨论过指针也进行了一定的学习。陌生是因为我确实不是很喜欢学习C语言，以至于其真正的核心内容我学的都不扎实，学了就忘。</p><hr><p>在Go语言中，由于变量分为<strong>值类型</strong>和<strong>引用类型</strong>，使得指针在函数传参的时候有了用处。对于<strong>值类型的变量</strong>而言，当函数的参数是指针类型时，函数对该参数的修改才会影响到该参数本身。</p><h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>对于是否使用指针类型作为接收者，有以下几点参考：</p><ol><li>如果接收者类型是 map、slice、channel 这类引用类型，不使用指针。</li><li>如果需要修改接收者，那么需要使用指针。</li><li>如果接收者是比较大的类型，可以考虑使用指针，因为内存拷员廉价，所以效率高。</li></ol><h3 id="什么情况下使用指针"><a href="#什么情况下使用指针" class="headerlink" title="什么情况下使用指针"></a>什么情况下使用指针</h3><p>从以上指针的详细分析中，我们可以总结出指针的两大好处：</p><ol><li>可以修改所指向数据的值。</li><li>在变量复制、参数传值的时候可以节省内存。</li></ol><p>不过.Go语言作为一种高级语言，在指针的使用上还是比较克制的。它在设计的时候就对指针进行了诸多限制，比如指针不支持运算，也不能取常量的指针。所以在思考是各使用时，我们也要保持克制的心态。<br>根据实战经验我总结了以下几点使用指针的建议，供你参考：</p><ol><li>不要对map、slice、channel 这类引用类型使用指针。</li><li>如果需要修改方法接收者内部的数据或者状态时，需要使用指针。</li><li>如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数。</li><li>如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针。</li><li>像 int、bool 这样的小数据类型没必要使用指针。</li><li>如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全。</li><li>指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然Go语言允许这么做，但是这会使你的代码变得异常复杂。</li></ol><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>指向接口的指针是否实现了该接口？为什么？</p><p>答：虽然指向具体类型的指针可以实现一个接口，但是指向接口的指针永远不可能实现该接口。</p><h2 id="值类型？指针类型？引用类型？"><a href="#值类型？指针类型？引用类型？" class="headerlink" title="值类型？指针类型？引用类型？"></a>值类型？指针类型？引用类型？</h2><p>初次看到这三个名词，我似懂非懂。值、指针、引用，为什么几个我认识的字放在一起，我就不太能分得清这些都是什么了。在上面的内容中有提到，Go语言中的变量分为两种，值类型和引用类型。那这个指针类型又是什么，和其他两种有什么关系呢。</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型包括：整型、浮点型、字符串、布尔、数组和 struct 。</p><p>认真观察过这些类型，我们不难发现，当这些类型作为函数参数时，在函数内部对其进行修改并不会影响到其原来的值。这就是值类型的特点。原因如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240312223328702.png" alt="image-20240312223328702"></p><p>观察上面的示意图不难得出，当 <code>main</code> 函数调用函数 <code>modifyPerson</code> 时，程序将变量 P 进行了一次复制，所以在函数 <code>modifyPerson</code> 试图修改变量 P 时，修改的是 P 的副本。值类型的变量在函数中均是如此。因此，在函数试图修改值类型的参数时，实际的参数并不会被修改。</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型保存的值就是数据对应的内存地址，所以在函数传参采用值传递的原则下，拷贝的值也是内存地址。因此当函数想要对参数进行修改时，即使修改的是参数的副本，其内容仍是需要修改变量的地址。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型包括：切片、map、函数、chan和接口</p><p>对于引用类型，在参数传递时仍然是<strong>值传递</strong>，但其传递的值为指针，并不是其他编程语言中所谓的引用传递。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240312231609318.png" alt="image-20240312231609318"></p><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>在声明一个变量时，常常会使用到的是 <code>var</code> 关键字和 <code>:=</code> 这两种方法。当我们尝试着去指针类型的变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sp *<span class="type">string</span></span><br><span class="line">*sp = “内存地址”</span><br><span class="line">fmt.Println(*sp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行上面的代码时，编译器会报错。</p><p>这是因为指针类型的变量如果没有分配内存，其默认值为 <code>nil</code>，因为它没有指向的内存，所以无法使用，强行使用就会出现 <code>nil</code> 指针的报错。</p><p>一个变量必须要经过<strong>声明</strong>、<strong>内存分配</strong>才能赋值，才能进行初始化。对于值类型，Go语言会在声明时就为它分配内存，以便后续的赋值操作。对于指针类型，Go语言并没有自动分配内存，所以不能对其进行赋值操作。</p><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>正是因为上面情况，<code>new</code>函数派上了用场。</p><p><code>new</code> 函数的作用就是根据传入的类型申请一块内存，然后返回指向这块内存的指针，指针指向的数据就是该类型的<strong>零值</strong></p><h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><p>关于<code>make</code>函数，最常使用的场景就是 map、slice 和 chan 这三种类型的初始化。</p><p>make 函数就是上述三种类型的工厂函数，用于<strong>创建和初始化</strong>这几种类型。</p><h3 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h3><p><code>make</code> 和 <code>new</code> 是两个⽤于分配内存的内建函数, 在使⽤场景和返回值类型上有明显的区别。</p><ul><li><code>make</code> ⽤于创建并初始化切⽚、映射和通道等引⽤类型。它返回的是被初始化的⾮零值（⾮nil）的引⽤类型。</li><li><code>new</code> ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的零值的指针。</li></ul><p>总结：</p><ul><li><code>new</code>只⽤于分配内存，返回⼀个指向地址的<strong>指针</strong>。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li><li><code>make</code>只可⽤于 <strong>slice, map, channel</strong> 的初始化,返回的是<strong>引⽤</strong></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结一下，本周好像有一点懈怠了，做题和做项目的时候都有点心不在焉的。不过本周学到的东西还是不少的。</p><ul><li>算法题已经完成了数组、双指针、滑动窗口和区间四个部分了。</li><li>项目目前完成了一半左右，希望下一周能全部搞完，再完成一篇博客。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于内存部分的内容，是正在读的书中的第三部分，这一部分讲的是Go语言中的指针相关的知识，由于书中花费了一定篇幅去讲过于内存的问题，所以本周的</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言进阶——并发</title>
    <link href="http://example.com/2024/03/08/Go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2024/03/08/Go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/</id>
    <published>2024-03-08T05:21:04.000Z</published>
    <updated>2024-04-06T14:25:47.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本周是正式系统性学习整理Go语言的第二周，上周把基础知识学过后，这周开始学习进阶知识。说到Go语言的特性，那就是高并发，所以进阶学习的第一部分只是就是关于并发的。总结内容和之前一样，并不会过多的记录书本里的东西，更多的是这一周学习的困难和解决的过程。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><p>本周学习内容主要有两个部分，并发基础和算法，学习这些的原因是因为最近开始找实习了，发现确实落下了太多东西。</p><h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>第一次了解并发是在学习计算机系统的时候，不再只让计算机做完一件事之后再开始做另外一件事，而是让计算机同时做多件事情，这就是并发。</p><p>说到并发就一定绕不开两个概念——进程和线程。</p><ul><li>在启动一个软件的时候，操作系统会为这个软件创建一个<strong>进程</strong>，这个进程就是该软件的工作空间，它包含了软件运行所需的所有资源。</li><li><strong>线程</strong>是进程的执行空间，一个进程可以有多个线程，线程被操作系统调度执行。</li></ul><p>一个程序启动就会有一个进程被创建，同时进程也会启动一个线程，这个线程被称为主线程，如果主线程结束，那么整个程序就退出了。有了主线程，就可以从主线程里启动很多其他线程，也就有了<strong>多线程的并发</strong>。</p><hr><p>在Go语言中并没有线程的概念，只有<strong>协程</strong>，也成为 <strong><code>goroutine</code></strong> 先比线程来说，协程更加轻量，一个程序可以随意启功成千上万个协程。</p><p><code>goroutine</code> 被 <code>Go routime</code>所调度，也就是说，Go语言的并发是由Go自己调度的，这对于开发者来说完全透明。</p><h2 id="如何通信"><a href="#如何通信" class="headerlink" title="如何通信"></a>如何通信</h2><p>当我们同时启动了多个 goroutine 时，它们之间要怎么通信？</p><p>Go语言提供了用于通信的<strong>管道</strong>—— <code>channel</code></p><ul><li>当需要从管道中接受值时，如果管道为空，那么会阻塞等待，知道管道中有值可以接受为之。</li></ul><p>管道分类：</p><ul><li><strong>无缓冲管道</strong>：容量为0，只起到传输数据的作用，又被称为<strong>同步管道</strong>；</li><li><strong>有缓冲管道</strong>：类似于一个可阻塞的对列，内部元素先进先出</li></ul><p>可以通过 <code>select + channel</code> 来实现多路复用的效果。</p><p>在Go语言中，提倡通过通信来共享内存，而不是通过共享内存来通信，所以在数据流动、传递的场景中要优先使用 channel，它是并发安全的。</p><hr><p>思考题：channel是如何实现并发安全的？</p><p>channel内部使用了互斥锁来保证并发的安全。</p><h2 id="并发中的Map是否安全"><a href="#并发中的Map是否安全" class="headerlink" title="并发中的Map是否安全"></a>并发中的Map是否安全</h2><p>Go 中的标准 <code>map</code> 类型是非并发安全的，这意味着在多个 <code>Goroutine</code> 中并发读写同一个 map 可能导致数据竞争和不确定的行为。为了在并发环境中使用  map，Go 提供了  <code>sync</code> 包中的 <code>sync.Map</code> 类型，它是一种并发安全的映射。</p><p>无须初始化，直接声明即可。<br>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。<br>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</p><p><strong>sync.Map提供的常用方法有如下七个</strong>:</p><ul><li>Load：通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</li><li>Store：该方法相当于对sync.Map的更新或新增，参数是键值对。</li><li>LoadOrStore：该方法的参数为key和value。该方法会先根据参数key查找对应的value，如果找到则不修改原来的值并通过actual返回，并且loaded为true；如果通过key无法查找到对应的value，则存储key-value并且将存储的value通过actual返回，loaded为false。</li><li>Delete：通过key删除键值对。</li><li>LoadAndDelete：通过key删除键的值，如果有，则返回上一个值。</li><li>Range：遍历sync.Map的元素，注意for…range map是对内置map类型的用法，sync.Map需要使用单独的Range方法。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明sync.Map</span></span><br><span class="line"><span class="keyword">var</span> syncmap sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store方法将键值对保存到sync.Map</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">97</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;lisi&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadOrStore key不存在</span></span><br><span class="line">    v, ok := syncmap.LoadOrStore(<span class="string">&quot;three&quot;</span>,<span class="number">3</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// 3 false</span></span><br><span class="line">    <span class="comment">// LoadOrStore key存在</span></span><br><span class="line">    v, ok = syncmap.LoadOrStore(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// 200 ture</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load方法获取sync.Map 键所对应的值</span></span><br><span class="line">    fmt.Println(syncmap.Load(<span class="string">&quot;lisi&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete方法键删除对应的键值对</span></span><br><span class="line">    syncmap.Delete(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> syncmap sync.Map</span><br><span class="line">    <span class="comment">// LoadAndDelete key不存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// &lt;nil&gt; false</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;xiaomi&quot;</span>, <span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    <span class="comment">// LoadAndDelete key存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// xiaomi true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Range遍历所有sync.Map中的键值对</span></span><br><span class="line">    syncmap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明 score，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</li><li>将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</li><li>Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</li><li>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</li></ul><h1 id="刷题思考"><a href="#刷题思考" class="headerlink" title="刷题思考"></a>刷题思考</h1><p>已经连续五天的刷题生活或许并没有给我带来什么真正有意义的思考，但还是想要记录一下。</p><p>毕竟从大一下学完数据结构之后就基本没怎么做过算法题了，所以刚开始这几天还是在找做题的感觉，有一种在高三备战高考的感觉，有时候也会觉得很折磨，看着别人想出来的完美算法，就会觉得自己和别人的差距太大了，只能一步一步来了。</p><p>这一周都只做了关于数组方面的题目，更多看到的题目标签是贪心、动态规划等等熟悉又陌生的字眼。</p><p>总之在做了几天题之后，发现自己的思维确实变慢了不少，还有就是把自然语言转换成代码语言的能力不行。</p><p>菜就多练喽！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本周学习内容主要是并发和算法，在Go语言项目上并没有投入什么精力，认真学习过并发之后就会正式开始学习做一些小项目来补充一下这方面的空白。</p><p>算法方面就希望下周能够找到做题的感觉，希望自己的小脑袋瓜赶紧转起来吧，继续积累经验。</p><p>关于Go语言八股文也确实应该腾出更多的时间来看了，希望下周能够完成计划吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本周是正式系统性学习整理Go语言的第二周，上周把基础知识学过后，这周开始学习进阶知识。说到Go语言的特性，那就是高并发，所以进阶学习的第一部</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>打开Go语言之门</title>
    <link href="http://example.com/2024/03/01/%E6%89%93%E5%BC%80GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%A8/"/>
    <id>http://example.com/2024/03/01/%E6%89%93%E5%BC%80GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%A8/</id>
    <published>2024-03-01T07:10:04.000Z</published>
    <updated>2024-03-08T05:21:27.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始学习Go语言已经差不多半年了，这是第一次正式写下一篇学习总结。又恰逢新学期开始，就把这篇当作新学期的第一篇周报吧。</p><p>本周主要是把半年来稀稀拉拉学到的Go语言基础知识有系统性地看了一遍。我对Go语言的了解更多还是从我的舍友，也正是受到他的影响我才会开始学习Go语言并进行记录。</p><p>这一周的学习内容就像本文的标签一样，Go语言基础。因为已经学习了很久，所以基础知识就不再本文中赘述。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><p>关于Go语言的学习，笔者已经看了四五本不同的基础书籍了，每本书的开头都是以Go语言的优点来开篇，那2024年的第一篇博客也从这个问题开始吧。</p><h2 id="Go语言好在哪？"><a href="#Go语言好在哪？" class="headerlink" title="Go语言好在哪？"></a>Go语言好在哪？</h2><p>说到Go语言的好处，想必都能想到什么简洁、高效等等。而真正吸引我开始学习Go语言的，还是我的舍友告诉我Go语言的代码有着严格的格式要求，不同人写的代码排版风格几乎一致，这一下就激起我学习Go语言的兴趣。因为笔者在刚开始学习编程的时候并没有养成良好的代码习惯，导致我的代码在很长一段时间里都只有我自己看得懂，于是迫切找到一个大家代码风格都差不多的语言重新开始学习。随着后来对Go的学习，我也了解到它更多的优点。接下来我们来看一下Go语言到底好在哪？</p><h3 id="语法简洁"><a href="#语法简洁" class="headerlink" title="语法简洁"></a>语法简洁</h3><p>Go语言相对于其他语言更容易上手，开发效率更高。这意味着Go易于学习、易于使用并且易于其他开发人员阅读。Go 没有大量的功能集，尤其是与 C++ 等语言相比。Go 的语法让人想起 C，这使得长期 C 开发人员学习起来相对容易。</p><p>从学术的角度讲Go语言其实非常平庸，不支持许多高级的语言特性；但从工程的角度讲，Go的设计是非常优秀的：规范足够简单灵活，有其他语言基础的程序员都能迅速上手。更重要的是Go自带完善的工具链，大大提高了团队协作的一致性。比如gofmt自动排版Go代码，很大程度上杜绝了不一致的问题。</p><h3 id="自带垃圾回收功能"><a href="#自带垃圾回收功能" class="headerlink" title="自带垃圾回收功能"></a>自带垃圾回收功能</h3><p>对比其他语言，Go语言的优势显著。比如Java虽然也具备垃圾回收功能，但它是解释型语言，需要安装JVM才能运行；C语言虽然不用解释，可以直接编译运行，但是它不具备垃圾回收功能，需要开发者自己管理内存的申请和释放，容易出问题。而Go语言具有两者的优势。</p><h3 id="并发性良好"><a href="#并发性良好" class="headerlink" title="并发性良好"></a>并发性良好</h3><p>Go语言就是为了并发而生的，其在设计时的创新就是 <strong>goroutines</strong> 和<strong>通道</strong>。</p><p><strong>Goroutines</strong> 是 Go 面向<strong>线程</strong>的轻量级方法，而通道是 goroutines 之间通信的优先方式。创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。</p><p>Goroutines的轻便主要体现在以下两个方面：</p><ul><li><strong>上下文切换代价小</strong>：Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；</li><li><strong>内存占用少</strong>：线程栈空间通常是 2M，Goroutine 栈空间最小 2K；</li></ul><p>关于Go语言的调度机制，可以看一下这篇文章——<a href="https://www.zhihu.com/question/21409296/answer/1040884859">https://www.zhihu.com/question/21409296/answer/1040884859</a></p><p>除了以上的三个优点以外，Go语言还有如强大的生态系统、支持跨平台操作以及拥有强大的标准库等优点。</p><h2 id="什么是静态语言"><a href="#什么是静态语言" class="headerlink" title="什么是静态语言"></a>什么是静态语言</h2><p>在打开任何一本关于Go语言基础的书籍时，首先映入眼帘的就是Go语言是一个静态语言，那么什么是静态语言，Go语言为什么会设计成静态语言，静态语言和动态语言又有什么区别。这些问题困扰了我很久，接下来将会解释以上问题。</p><p><strong>静态语言</strong>是一种编程语言，其特征是在编译时进行类型检查和绑定。在编写代码时，变量的类型需要明确指定，而且在编译阶段这些类型信息是固定的，不会在运行时发生变化。其特征如下：</p><ul><li><strong>类型检查：</strong> 在编译阶段进行，变量类型需要在声明时明确，并且编译器会检查变量的使用是否符合类型规定。</li><li><strong>编译时绑定：</strong> 函数调用和变量引用在编译时就已经确定，生成对应的机器代码。</li><li><strong>性能优化：</strong> 静态类型信息允许编译器进行更多的优化，生成更高效的代码。</li><li><strong>严格的错误检查：</strong> 由于类型信息在编译时就已知，因此静态语言通常有较为严格的类型检查，编译器可以在编译阶段捕获许多潜在的错误。</li></ul><p>静态语言主要有：Java、C、C++、C#、Swift 和 Go</p><hr><p><strong>动态语言</strong>是一种编程语言，其特征是在运行时进行类型检查和绑定。在编写代码时，变量的类型通常不需要显式指定，而是在运行时根据上下文动态确定。其特征如下：</p><ul><li><strong>类型检查：</strong> 在运行时进行，变量的类型可以在代码执行期间改变。</li><li><strong>运行时绑定：</strong> 函数调用和变量引用在运行时确定，这允许更大的灵活性和动态性。</li><li><strong>较少的编译时优化：</strong> 缺乏静态类型信息会减少编译器进行某些优化的能力。</li><li><strong>更灵活：</strong> 相对于静态语言，动态语言通常更灵活，适用于快速开发和迭代。</li></ul><p>动态语言主要有：Python、JavaScript、Ruby、PHP</p><hr><p>静态语言与动态语言的区别：</p><ul><li><strong>类型检查时机：</strong> 静态语言在编译时进行类型检查，而动态语言在运行时进行类型检查。</li><li><strong>类型灵活性：</strong> 静态语言要求在编写代码时明确指定变量的类型，而动态语言允许变量在运行时根据上下文动态确定类型。</li><li><strong>编译时绑定 vs. 运行时绑定：</strong> 静态语言的函数调用和变量引用在编译时绑定，而动态语言在运行时绑定，允许更大的灵活性。</li><li><strong>性能优化：</strong> 静态语言由于在编译阶段有更多的类型信息，通常可以进行更多的编译时优化，因此在一些性能方面具有优势。动态语言通常在运行时进行解释，因此可能在性能上略逊于静态语言。</li><li><strong>错误检查：</strong> 由于在编译时进行类型检查，静态语言通常能够在更早的阶段捕获潜在的错误，而动态语言在运行时才能发现。</li></ul><hr><p>Go语言被设计成静态语言的主要原因涉及到一系列的设计目标和哲学，其中一些因素包括：</p><ol><li><p><strong>性能优化：</strong> 静态语言通常在编译阶段进行类型检查，这使得编译器可以在生成机器代码时进行更多的优化。Go语言的设计目标之一是提供出色的性能，静态类型信息允许编译器在编译时对代码进行更多的优化，提高程序的执行效率。</p></li><li><p><strong>并发支持：</strong> Go语言的并发模型以及轻量级线程（goroutines）的概念需要在编译时对程序的结构有清晰的了解。静态类型信息使编译器能够更好地理解并发代码，减少在运行时发生竞争条件和死锁的可能性。</p></li><li><p><strong>简单性和可读性：</strong> Go语言的设计注重简单性和可读性，静态类型系统可以帮助开发者更容易理解代码。类型信息作为一种文档形式，使得代码更加自解释，减少了理解代码所需的认知负担。</p></li><li><p><strong>错误检查：</strong> 静态类型检查可以在编译时捕获潜在的类型错误，提高代码的可靠性。这有助于减少在运行时因为类型错误引起的 bug，提高了代码的稳定性。</p></li><li><p><strong>团队协作：</strong> 在大型项目和团队中，静态类型系统可以提供更好的协作支持。类型信息可以帮助开发者了解函数和变量的用法，使得团队成员之间更容易沟通和协作。</p></li><li><p><strong>编程工具的支持：</strong> 静态类型信息为IDE（集成开发环境）和其他编程工具提供了更多的信息，从而提供更强大的代码分析和自动补全功能，提高了开发效率。</p></li></ol><p>总的来说，Go语言之所以选择静态类型，是为了在性能、并发性、可读性和团队协作等方面达到一种平衡，使得开发者能够更容易地编写高性能、可维护和并发安全的代码。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，本周的学习总结也就完成了，内容较少，原因是还有一些更复杂的东西想留着专门来写。所以本文就只是写了在学了Go语言的基础语法，即打开了Go语言之门之后，我的疑问和相对应的解答。除了解语法之外，我也在尝试着跟着大佬来完成一些项目，详细的就等完成之后的总结吧。</p><p>下周的学习目标是更深层次地学习Go语言的进阶语法并推动项目进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开始学习Go语言已经差不多半年了，这是第一次正式写下一篇学习总结。又恰逢新学期开始，就把这篇当作新学期的第一篇周报吧。&lt;/p&gt;
&lt;p&gt;本周主</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
