<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-26T08:31:34.957Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作数据库</title>
    <link href="http://example.com/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2024-03-26T06:34:52.000Z</published>
    <updated>2024-03-26T08:31:34.957Z</updated>
    
    <content type="html"><![CDATA[<p>目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。那么这一节我们就要开始学习如何将数据存入数据库。</p><h1 id="操作-MySQL-数据库"><a href="#操作-MySQL-数据库" class="headerlink" title="操作 MySQL 数据库"></a>操作 MySQL 数据库</h1><p>在本项目中所选用的数据库为<code>MySQL</code>，使用GO操作<code>MySQL</code>等数据库，一般有两种方法：</p><ul><li>一是利用 database/sql 接口，直接在代码里硬编码 sql 语句；</li><li>二是使用 ORM，具体一点是 GORM，以对象关系映射的方式在抽象地操作数据库。</li></ul><h2 id="database-sql"><a href="#database-sql" class="headerlink" title="database/sql"></a>database/sql</h2><p><code>database/sql</code> 包通过提供统一的编程接口，实现了对不同数据库驱动的抽象。</p><h3 id="大致原理"><a href="#大致原理" class="headerlink" title="大致原理"></a>大致原理</h3><ol><li><code>Driver</code> 接口定义：<code>database/sql/driver</code> 包中定义了一个 <code>Driver</code> 接口，该接口用于表示一个数据库驱动。驱动开发者需要实现该接口来提供与特定数据库的交互能力。</li><li><code>Driver</code> 注册：驱动开发者需要在程序初始化阶段，通过调用 <code>database/sql</code> 包提供的 <code>sql.Register()</code> 方法将自己的驱动注册到 <code>database/sql</code> 中。这样，<code>database/sql</code> 就能够识别和使用该驱动。</li><li>数据库连接池管理：<code>database/sql</code> 维护了一个数据库连接池，用于管理数据库连接。当通过 <code>sql.Open()</code> 打开一个数据库连接时，<code>database/sql</code> 会在合适的时机调用注册的驱动来创建一个具体的连接，并将其添加到连接池中。连接池会负责连接的复用、管理和维护工作，并且这是并发安全的。</li><li>统一的编程接口：<code>database/sql</code> 定义了一组统一的编程接口供用户使用，如 <code>Prepare()</code>、<code>Exec()</code> 和 <code>Query()</code> 等方法，用于准备 SQL 语句、执行 SQL 语句和执行查询等操作。这些方法会接收参数并调用底层驱动的相应方法来执行实际的数据库操作。</li><li>接口方法的实现：驱动开发者需要实现 <code>database/sql/driver</code> 中定义的一些接口方法，以此来支持上层 <code>database/sql</code> 包提供的 <code>Prepare()</code>、<code>Exec()</code> 和 <code>Query()</code> 等方法，以提供底层数据库的具体实现。当 <code>database/sql</code> 调用这些方法时，实际上会调用注册的驱动的相应方法来执行具体的数据库操作。</li></ol><p>通过以上的机制，<code>database/sql</code> 包能够实现对不同数据库驱动的统一封装和调用。用户可以使用相同的编程接口来进行数据库操作，无需关心底层驱动的具体细节。这种设计使得代码更具可移植性和灵活性，方便切换和适配不同的数据库。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><code>database/sql</code> 具有如下特点：</p><ul><li>统一的编程接口：<code>database/sql</code> 库提供了一组统一的接口，使得开发人员可以使用相同的方式操作不同的数据库，而不需要学习特定数据库的 API。</li><li>驱动支持：通过导入第三方数据库驱动程序，<code>database/sql</code> 可以与多种常见的关系型数据库系统进行交互，如 MySQL、PostgreSQL、SQLite 等。</li><li>预防 SQL 注入：<code>database/sql</code> 库通过使用预编译语句和参数化查询等技术，有效预防了 SQL 注入攻击。</li><li>支持事务：事务是一个优秀的 SQL 包必备功能。</li></ul><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>与数据库建立连接的代码非常简单，只需调用 <code>sql.Open()</code> 函数即可。它接收两个参数：</p><ul><li>驱动名称</li></ul><p>这里驱动名称为 <code>mysql</code>，<code>database/sql</code> 之所以能够识别这个驱动名称，是因为在匿名导入 <code>github.com/go-sql-driver/mysql</code> 时，这个库内部调用了 <code>sql.Register</code> 将其注册给了 <code>database/sql</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sql.Register(<span class="string">&quot;mysql&quot;</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言中，一个包的 <code>init</code> 方法会在导入时会被自动调用，这里完成了驱动程序的注册。这样在调用 <code>sql.Open()</code> 时才能找到 <code>mysql</code> 驱动。</p><ul><li>DSN</li></ul><p>第二个参数 DSN 全称 <code>Data Source Name</code>，数据库的源名称，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// [用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表</span><br><span class="line">[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</span><br></pre></td></tr></table></figure><p>为了更加直观，我们可以使用 <code>mysql.Config</code> 来创建连接信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据库连接信息</span></span><br><span class="line">config := mysql.Config&#123;</span><br><span class="line">    User:                 <span class="string">&quot;homestead&quot;</span>,</span><br><span class="line">    Passwd:               <span class="string">&quot;secret&quot;</span>,</span><br><span class="line">    Addr:                 <span class="string">&quot;127.0.0.1:3306&quot;</span>,</span><br><span class="line">    Net:                  <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    DBName:               <span class="string">&quot;goblog&quot;</span>,</span><br><span class="line">    AllowNativePasswords: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sql.Open()</code> 调用后将返回一个 <code>*sql.DB</code> 类型，可以用来操作数据库。</p><p>另外，我们调用 <code>defer db.Close()</code> 来释放数据库连接。其实这一步操作也可以不做，<code>database/sql</code> 底层连接池会帮我们处理。一旦关闭了连接，就不可以再继续使用这个 <code>db</code> 对象了。</p><p><code>*sql.DB</code> 的设计是用来作为长连接使用的，所以不需要频繁的进行 <code>Open</code> 和 <code>Close</code> 操作。如果我们需要连接多个数据库，则可以为每个不同的数据库创建一个 <code>*sql.DB</code> 对象，保持这些对象为 <code>Open</code> 状态，不必频繁使用 <code>Close</code> 来切换连接。</p><p>值得注意的是，其实 <code>sql.Open()</code> 并没有真正建立数据库连接，它只是准备好了一切，以备后续使用，连接将在第一次被使用时延迟建立。</p><p>这样的设计虽然合理，可也有些违反直觉，<code>sql.Open()</code> 甚至不会校验 DSN 参数的合法性。不过我们可以使用 <code>db.Ping()</code> 方法来主动检查连接是否能被正确建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连接池设置"><a href="#连接池设置" class="headerlink" title="连接池设置"></a>连接池设置</h4><p>使用 <code>sql.Open()</code> 并不会建立一个唯一的数据库连接，事实上，<code>database/sql</code> 会维护一个连接池。</p><p>我们可以通过如下方法，控制连接池的一些参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(<span class="number">5</span> * time.Minute)</span><br></pre></td></tr></table></figure><h5 id="SetMaxOpenConns-最大连接数"><a href="#SetMaxOpenConns-最大连接数" class="headerlink" title="SetMaxOpenConns 最大连接数"></a>SetMaxOpenConns 最大连接数</h5><p>设置连接池最大打开数据库连接数，&lt;= 0 表示无限制，默认为 0。</p><ul><li>应该设置多大？<ul><li>实验表明，在高并发的情况下，将值设为大于 10，可以获得比设置为 1 接近六倍的性能提升。而设置为 10 跟设置为 0（也就是无限制），在高并发的情况下，性能差距不明显。</li></ul></li><li>是否越大越好？<ul><li>需要考虑的是不要超出数据库系统设置的最大连接数。另外，还需要注意这个值是整个系统的，如有其他应用程序也在共享这个数据库，这个可以合理地控制小一点。</li></ul></li></ul><h5 id="SetMaxIdleConns-空闲连接数"><a href="#SetMaxIdleConns-空闲连接数" class="headerlink" title="SetMaxIdleConns 空闲连接数"></a>SetMaxIdleConns 空闲连接数</h5><p>设置连接池最大空闲数据库连接数，&lt;= 0 表示不设置空闲连接数，默认为 2。</p><ul><li>应该设置多大？<ul><li>实验表明，在高并发的情况下，将值设为大于 0，可以获得比设置为 0 <strong>超过 20 倍的性能提升</strong>。</li><li>这是因为设置为 0 的情况下，每一个 SQL 连接执行任务以后就销毁掉了，执行新任务时又需要重新建立连接。很明显，重新建立连接是很消耗资源的一个动作。</li><li>设置空闲连接数，当有新任务进来时，直接使用这些随时待命的连接传输数据，以此达到节约资源，提高执行效率的目的。</li></ul></li><li>是不是数值越大越好？<ul><li>首先此值不能大于 <code>SetMaxOpenConns</code> 的值，大于的情况下 mysql 驱动会自动将其纠正。</li><li>其次需要考虑的是，长时间打开大量的数据库连接需要占用系统的内存和 CPU 资源。</li><li>还有一个情况是 MySQL 会有一个 <code>wait_timeout</code> 的设置，连接超过这个时间就会被自动关闭，默认情况下是 8 个小时。当 MySQL 关闭连接时，sql.DB 请求到的就是一个坏的连接，虽然 sql 包里已经做了处理，当请求到坏连接时会自动重连。但是在这种情况下，单次请求相当于建立了两次连接，消耗比设置为 0 还大，得不偿失。</li><li>所以回答上面的问题，不是越大越好，应根据实际情况选择合理的值。</li></ul></li></ul><h5 id="SetConnMaxLifetime-过期时间"><a href="#SetConnMaxLifetime-过期时间" class="headerlink" title="SetConnMaxLifetime 过期时间"></a>SetConnMaxLifetime 过期时间</h5><p>设置连接池里每一个连接的过期时间，过期会自动关闭。理论上来讲，在并发的情况下，此值越小，连接就会越快被关闭，也意味着更多的连接会被创建。</p><ul><li>应该设置多大？<ul><li>设置的值不应该超过 MySQL 的 <code>wait_timeout</code> 设置项（默认情况下是 8 个小时）。</li><li>此值也不宜设置过短，关闭和创建都是极耗系统资源的操作。</li><li>设置此值时，需要特别注意 SetMaxIdleConns 空闲连接数的设置。假如设置了 100 个空闲连接，过期时间设置了 1 分钟，在没有任何应用的 SQL 操作情况下，数据库连接每 1.6 秒就销毁和新建一遍。</li><li>这里的推荐，比较保守的做法是设置五分钟</li></ul></li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>`*sq</p><p><code>l.DB</code> 提供了 <code>Exec</code> 方法来执行一条 SQL 命令，可以用来<strong>创建</strong>、<strong>更新</strong>、<strong>删除</strong>表数据等。</p><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Exec(<span class="string">`INSERT INTO user(name, email, age, birthday, salary) VALUES(?, ?, ?, ?, ?)`</span>, user.Name, user.Email, user.Age, user.Birthday, user.Salary)</span><br></pre></td></tr></table></figure><p>其中 <code>?</code> 作为参数占位符，不同数据库驱动程序的占位符可能不同，可以参考数据库驱动的文档。</p><p>我们将这 5 个参数顺序传递给 <code>db.Exec</code> 方法，即可完成用户的创建。</p><p><code>db.Exec</code> 方法调用后将返回 <code>sql.Result</code> 保存结果以及一个 <code>error</code> 来标记错误。</p><p><code>sql.Result</code> 是一个接口，它包含两个方法：</p><ul><li><code>LastInsertId() (int64, error)</code>：返回新插入的用户 ID。只用在 <code>INSERT</code> 语句且数据表有自增 ID 时才有返回自增 ID 值，否则返回 0。</li><li><code>RowsAffected() (int64, error)</code>：返回当前操作受影响的行数，我们以此来判断 <code>SQL</code> 语句是否执行成功。</li></ul><p>接口具体实现有数据库驱动程序来完成。</p><p>此外，<code>database/sql</code> 还提供了预处理方法 <code>*sql.DB.Prepare</code> 创建一个准备好的 SQL 语句，在循环中使用预处理，则可以减少与数据库的交互次数。</p><p>比如我们需要创建两个用户，则可以先使用 <code>db.Prepare</code> 创建一个 <code>*sql.Stmt</code> 对象，然后多次调用 <code>*sql.Stmt.Exec</code> 方法来插入数据。</p><p><code>db.Prepare</code> 是预先将一个数据库连接和一个条 SQL 语句绑定并返回 <code>*sql.Stmt</code> 结构体，它代表了这个绑定后的连接对象，是并发安全的。</p><p>通过使用预处理，可以避免在循环中执行多次完整的 SQL 语句，从而显著减少了数据库交互次数，这可以提高应用程序的性能和效率。</p><p>使用预处理，会在 <code>db.Prepare</code> 时从连接池获取一个连接，之后循环执行 <code>stmt.Exec</code>，最终释放连接。</p><p>如果使用 <code>db.Exec</code>，则每次循环时都需要：获取<strong>连接-执行 SQL-释放连接</strong>，这几个步骤，大大增加了与数据库的交互次数。</p><p>不要忘记调用 <code>stmt.Close()</code> 关闭连接，这个方法是密等的，可以多次调用。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在创建数据库并插入相应值后，我们就可以进行查询操作了。</p><p>因为 <code>Exec</code> 方法只会执行 SQL，不会返回结果，所以不适用于查询数据。<code>*sql.DB</code> 提供了 <code>Query</code> 方法执行查询操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>如下获取所有文章的例子：：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * from articles&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>Query()</code> 方法返回一个 <code>sql.Rows</code> 结构体，代表一个查询结果集。</p><blockquote><p>Query 和 Exec 都可以执行 SQL 语句，<strong>那他们的区别是什么呢？</strong></p><p>Exec 只会返回最后插入 ID 和影响行数，而 Query 会返回数据表里的内容（结果集）。</p><p>或者可以这么记：</p><p>Query 中文译为 <strong>查询</strong>，而 Exec 译为 <strong>执行</strong>。想查询数据，使用 Query。想执行命令，使用 Exec。</p></blockquote><ul><li><code>rows.Next()</code> 方法用来判断是否还有下一条结果，可以用于 <code>for</code> 循环，如果存在下一条结果，<code>rows.Next()</code> 将返回 <code>true</code>。</li><li><code>rows.Scan()</code> 方法可以将结果扫描到传递进来的指针对象。<code>rows.Scan()</code> 会将一行记录分别填入指定的变量中，并且会自动根据目标变量的类型处理类型转换的问题，比如数据库中是 <code>varchar</code> 类型，会映射成 Go 中的 <code>string</code>，但如果与之对应的目标变量是 <code>int</code>，那么转换失败就会返回 <code>error</code>。</li></ul><p>如果是读取一行数据，可以使用 <code>QueryRow()</code>，语法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><p>返回的是一个 <code>sql.Row</code> 对象，与其相关的调用有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Row)</span></span> Scan(dest ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure><p><code>sql.Row</code> 没有 <code>Close</code> 方法，当我们调用 <code>Scan()</code> 时就会自动关闭 SQL 连接。所以为了防止忘记关闭而浪费资源，一般需要养成连着调用 <code>Scan()</code> 习惯。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新操作同创建一样可以使用 <code>*sql.DB.Exec</code> 方法来实现，不过这里我们将使用 <code>*sql.DB.ExecContext</code> 方法来实现。</p><p><code>ExecContext</code> 方法与 <code>Exec</code> 方法在使用上没什么两样，只不过第一个参数需要接收一个 <code>context.Context</code>，它允许你控制和取消执行 SQL 语句的操作。使用上下文可以在需要的情况下设置超时时间、处理请求取消等操作。</p><p>三个常用的 SQL 请求方法都有其支持上下文的版本，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><p>支持 Context 上下文的方法传参标准库 context 里的 context.Context 对象实例。</p><p>在一些特殊场景里，我们需要 SQL 请求在执行还未完成时，我们可以取消他们（cancel），或者为请求设置最长执行时间（timeout），就会用到这些方法。</p><p>另外需要知道的是，所有的请求方法底层都是用其上下文版本的方法调用，且传入默认的上下文，例如 <code>Exec()</code> 的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.ExecContext(context.Background(), query, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层调用的是 <code>ExecContext()</code> 方法。<code>context.Background()</code> 是默认的上下文，这是一个空的 <code>context</code> ，我们无法对其进行取消、赋值、设置 deadline 等操作。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>同更新的语句是一样的，只需要把语句稍作更改即可。</p><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>如果没有开启事务，当其中某个语句执行错误，则前面已经执行的 SQL 语句无法回滚。对于一些要求比较严格的业务逻辑来说，如付款、转账等，应该在同一个事务中提交多条 SQL 语句，避免发生执行出错无法回滚事务的情况。</p><p>使用以下可以开启事务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin() (*Tx, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> BeginTx(ctx context.Context, opts *TxOptions) (*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Begin()</code> 和 <code>BeginTx()</code> 方法返回一个 <code>sql.Tx</code> 结构体，他支持以上我们提到过的几种查询方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预编译 Prepare</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Stmt(stmt *Stmt) *Stmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> StmtContext(ctx context.Context, stmt *Stmt) *Stmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> PrepareContext(ctx context.Context, query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>使用这同一个 <code>sql.Tx</code> 对数据库进行操作，就会在同一个事务中提交。</p><p>当使用 <code>sql.Tx</code> 的操作方式操作数据后，需要使用 <code>sql.Tx</code> 的 <code>Commit()</code> 方法提交事务，如果出错，则可以使用 <code>sql.Tx</code> 中的 <code>Rollback()</code> 方法回滚事务，保持数据的一致性，下面是这两个方法的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Commit() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Rollback() <span class="type">error</span></span><br></pre></td></tr></table></figure><p>下面是个简单的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Service)</span></span> DoSomething() (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建事务</span></span><br><span class="line">    tx, err := s.db.Begin()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果请求失败，就回滚所有 SQL 操作，否则提交</span></span><br><span class="line">    <span class="comment">//    defer 会在当前方法的最后执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        err = tx.Commit()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行各种请求</span></span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，所有 SQL 操作都必须使用 <code>tx</code> 来操作，才能支持事务，如果中间使用 <code>db.Exec()</code> 那这条语句是无法回滚的。</p><h2 id="集成-GORM"><a href="#集成-GORM" class="headerlink" title="集成 GORM"></a>集成 GORM</h2><h3 id="什么是-ORM-？"><a href="#什么是-ORM-？" class="headerlink" title="什么是 ORM ？"></a>什么是 ORM ？</h3><p>ORM 全称是：Object Relational Mapping (对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象（结构体），那就对应着一张表，这个对象的实例，就对应着表中的一条记录。</p><h3 id="为什么要使用-GORM？"><a href="#为什么要使用-GORM？" class="headerlink" title="为什么要使用 GORM？"></a>为什么要使用 GORM？</h3><p>本项目使用 GORM 的理由：</p><ol><li>现代化，面对对象</li><li>多数据库支持，为高负载做好准备</li><li>提高项目安全性</li><li>提升开发效率和项目的可维护性</li></ol><p>我们都知道，在正式环境中直接使用 SQL 来查询数据库是很危险的，处理不好就有被注入式攻击的风险。而且组装 SQL 语句也容易出错和减低代码的可维护性。所以需要一个工具来管理数据库语句的组装和操作。</p><p>GORM 是目前比较成熟的 Go 语言数据库管理库，它可以很方便的把 Go 的结构体和数据库表绑定，从而简化获取数据的操作。</p><p>GORM 功能包括下面：</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context，预编译模式，DryRun 模式</li><li>批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><p>以上列表熟悉下即可，后面的项目开发中使用到自然就会记住了，脱离实战记忆没有意义。</p><h3 id="连接数据库-1"><a href="#连接数据库-1" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>与<code>database/sql</code>操作类似，使用<code>gorm.Open()</code>函数即可，该函数同样有两个参数：</p><ul><li>驱动名称</li><li>DSN</li></ul><p><code>*gorm.DB</code> 对象有一个方法 <code>DB()</code> 可以直接获取到 database/sql 包里的 <code>*sql.DB</code> 对象。<strong>GORM 底层也是使用 database/sql 来管理连接池</strong>。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><code>db.Create</code>方法可以新建一条数据，传入的是一个表结构体指针，返回值是一个<code>gorm.DB</code>,即我们的数据库连接。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Create(&amp;ormdemo.UserInfo&#123;</span><br><span class="line">    Name:   <span class="string">&quot;jaylog&quot;</span>,</span><br><span class="line">    Gender: <span class="string">&quot;man&quot;</span>,</span><br><span class="line">    Hobby:  <span class="string">&quot;pingpong&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你想避免<code>ErrRecordNotFound</code>错误，你可以使用<code>Find</code>，比如<code>db.Limit(1).Find(&amp;user)</code>，<code>Find</code>方法可以接受struct和slice的数据。</p><p>对单个对象使用<code>Find</code>而不带limit，<code>db.Find(&amp;user)</code>将会查询整个表并且只返回第一个对象，这是性能不高并且不确定的。</p></blockquote><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p><code>Save</code> 会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br></pre></td></tr></table></figure><p>当使用 <code>Update</code> 更新单列时，需要有一些条件，否则将会引起<code>ErrMissingWhereClause</code> 错误，当使用 <code>Model</code> 方法，并且它有主键值时，主键将会被用于构建条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据条件更新</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User 的 ID 是 `111`</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件和 model 的值进行更新</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><p><code>Updates</code> 方法支持 <code>struct</code> 和 <code>map[string]interface&#123;&#125;</code> 参数。当使用 <code>struct</code> 更新时，默认情况下GORM 只会更新非零值的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 `struct` 更新属性，只会更新非零值的字段</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 `map` 更新属性</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>删除一条记录时，删除对象需要指定主键，否则会触发批量删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><p>GORM 允许通过主键(可以是复合主键)和内联条件来删除对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们已经完成地了解了如何使用两种不同方法来操作数据库。数据库的操作是本项目的重中之重，好好理解这一节的内容对面是有着不小的帮助，因为笔者的第一次面试就是挂在关于数据库的问题上的。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://gorm.io/zh_CN/docs/index.html">GORM</a></li><li><a href="https://xie.infoq.cn/article/6bd776b9af4f1996603ef0948">database/sql</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。那么这一节我们就要开始学习如何将数据存入数据库。&lt;/p&gt;
&lt;h1 id=&quot;操作-MySQL-数据库&quot;&gt;&lt;a href=&quot;#操作-MySQL-数据库&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>路由和中间件</title>
    <link href="http://example.com/2024/03/25/%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2024/03/25/%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2024-03-25T08:07:46.000Z</published>
    <updated>2024-03-25T10:10:53.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要用于介绍<code>GoBlog</code>项目中两个最为重要的部分——路由和中间件。这两个部分可以说是本项目的重要组成部分，下面我们会逐个进行学习和分析，并大概介绍其在项目中的作用。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>goblog 需要一款灵活的路由器来搭配 MVC 程序结构，恰巧Go Web 开发有各式各样的路由器可供选择。这个时候可能就有朋友要问了，什么是路由啊，路由有什么用呢？额……其实我在学的时候也有这样的问题，那就慢慢往下看吧。</p><h2 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h2><p>路由，<strong>就是URL地址到业务处理代码的映射</strong>。当用户输入一个<code>URL</code>地址时，服务器改知道要返回什么内容，一个 <code>URL</code> 到一个具体的处理函数之间的映射叫做一条路由。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/6decf088ea6d29afbee3c19acc63c4de.png" alt="img"></p><p>多条路由组成路由表，路由表主要用于路由查找，根据不同的路由表的组织形式，可以有不同的查找方法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e98393a4afcc24a509f1d169d8360fad.png" alt="img"></p><p>给定一个<code>URL</code>，找到对应的处理函数的过程叫做路由查找。路由器就是用来管理路由表并进行路由查找的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0bda1fefe4d9adbf3a91bc13466c85c0.png" alt="img"></p><p>所以，在<code>Web</code>系统中一个路由系统由路由、路由表和路由匹配三部分功能组成。</p><p>路由实现由三种方法，分别是基于映射表、正则表达式以及tries结构的路由实现，下面将会一一介绍。</p><h2 id="基于映射表的路由实现"><a href="#基于映射表的路由实现" class="headerlink" title="基于映射表的路由实现"></a>基于映射表的路由实现</h2><p><code>Go</code>内建标准包<code>bet/http</code>中路由的实现是基于映射表实现的，也是最简单的路由。</p><h3 id="http怎么处理请求"><a href="#http怎么处理请求" class="headerlink" title="http怎么处理请求"></a>http怎么处理请求</h3><p><code>Go</code> 语言中处理 <code>HTTP</code> 请求主要跟两个东西相关：<code>ServeMux</code> 和 <code>Handler</code>。</p><p><code>ServeMux</code> 本质上是一个 <strong>HTTP 请求路由器</strong>（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的<strong>处理器（Handler）</strong>。</p><p>下面来看 <code>HandleFunc</code>函数的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>pattern</code> 是 URI 的规则，例如 <code>/</code> 或者 <code>about</code></li><li><code>handler</code> 是供调用的函数</li></ul><p><code>http.HandleFunc()</code> 函数是对 <code>DefaultServeMux.HandleFunc()</code> 的封装，当 <code>http.ListenAndServe(addr string, handler Handler)</code> 的第二个参数为 <code>nil</code> 时，会使用<code>DefaultServeMux.HandleFunc()</code></p><h3 id="net-http包中路由的实现"><a href="#net-http包中路由的实现" class="headerlink" title="net/http包中路由的实现"></a>net/http包中路由的实现</h3><p>在<code>net/http</code>包中实现路由的机构提是<code>ServeMux</code>，其结构定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line"> mu    sync.RWMutex</span><br><span class="line"> m     <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line"> es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line"> hosts <span class="type">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段很简单，我们重点看m变量，是一个map类型，即key-value结构，就是我们所说的路由表。key就是路由的路径，value是一个<code>muxEntry</code>对象，<code>muxEntry</code>结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line"> h       Handler</span><br><span class="line"> pattern <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pattern</code>是对应的路径，<code>h</code>就是对应的处理函数。当我们进行路由注册时候，实质上就是将路径和<code>HomeHandler</code>对象构建成一个<code>muxEntry</code>对象，然后加入到<code>ServeMux</code>的<code>m</code>中。</p><p>接下来我们再看路<strong>由的查找</strong>，既然路由表是有map实现的，那么路由的查找过程自然就是通过路径从map中查找对应的<code>muxEntry</code>，然后获取对应的<code>handler</code>即可。</p><p>以上就是<code>net/http</code>包中自己路由的实现。非常简单，同时也意味着功能有限。</p><h3 id="http-ServeMux-的局限性"><a href="#http-ServeMux-的局限性" class="headerlink" title="http.ServeMux 的局限性"></a>http.ServeMux 的局限性</h3><p>http.ServeMux 在 goblog 中使用，会遇到以下几个问题：</p><ul><li>不支持 URI 路径参数</li><li>不支持请求方法过滤<ul><li>无法直接从路由上区分 POST 或者 GET 等 HTTP 请求方法，只能手动判断。</li></ul></li><li>不支持路由命名<ul><li>路由命名是一套允许我们快速修改页面里显示 URL 的机制。</li></ul></li></ul><p><strong>优点</strong></p><ul><li>标准库意味着随着 Go 打包安装，无需另行安装</li><li>测试充分</li><li>稳定、兼容性强</li><li>简单，高效</li></ul><p><strong>缺点</strong></p><ul><li>缺少 Web 开发常见的特性</li><li>在复杂的项目中使用，需要你写更多的代码</li></ul><h2 id="基于正则表达式的路由实现"><a href="#基于正则表达式的路由实现" class="headerlink" title="基于正则表达式的路由实现"></a>基于正则表达式的路由实现</h2><p>该包是基于正则表达式实现的路由。该路由支持分组、restful风格路径的定义、绑定路由请求的方法（GET、POST等）、限定路径使用http还是https协议等功能。在本项目中所使用到的路由就是这个。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>通过<code>mux.NewRouter()</code>方法返回了一个<code>Router</code>结构体对象。该结构体对象也实现了<code>ServeHTTP</code>方法，在该方法中<strong>实现了对路由的匹配和转发</strong>。所以覆盖作为<code>http.ListenAndServe</code>的第二个参数，替代了默认的路由分发对象<code>DefaultServeMux</code>。</p><p>在该包中<code>Router</code>的<code>ServeHTTP</code>方法对路由的匹配和分发部分，本质上是和默认的路由分发器DefaultServeMux的实现是一样的。不同的是路由的管理以及匹配上。</p><p>Router 结构体如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d03836d9ccfb7e93bba1e54793c04908.png" alt="img"></p><p>这里我们只列出来核心的字段，省略了一些辅助字段。这里有几个主要的字段：</p><ul><li><strong>Router</strong>中的routes：Route切片类型，角色是路由表，存储所有的路由。</li><li><strong>Route</strong>：一个具体的路由，handler字段存储的是具体的处理函数，同时每个路由的路径是在最后的routeRegexp结构体中的。</li><li><strong>matchers</strong>字段：切片类型，存储了该路由下的所有要匹配的规则。matchers的类型是一个matcher接口，定义了Match方法。其中routeRegexp结构体实现了该方法，所以一个routeRegexp实例就是一个matcher。</li><li><strong>routeRegexp</strong>结构体：该结构体代表了路由中具体的路径的匹配规则。将路由中的路径转换成对应的正则表达式，存储与regexp字段中。</li></ul><p><strong>routeRegexp</strong>结构体中的主要字段分别如下：</p><ul><li><strong>template</strong>：保存的是路由的路径模版。比如<code>r.HandleFunc(&quot;/product/&#123;id:[0-9]+&#125;&quot;, ProductHandler)</code>中，则是<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code></li><li><strong>regexpType</strong>：正则类型，目前支持regexpTypePath、regexpTypeHost、regexpTypePrefix、regexpTypeQuery四种类型。比如<code>r.HandleFunc(&quot;/product/&#123;id:[0-9]+&#125;&quot;, ProductHandler)</code>就是路径匹配regexpTypePath。而<code>r.Host(&quot;www.example.com&quot;)</code>就是域名匹配regexpTypeHost。稍后我们会一一介绍。</li><li><strong>regexp</strong>：是根据路由中的模版路径构造出来的正则表达式。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，最终构造的正则表达式是 <code>^/product/(?P&lt;v0&gt;[0-9]+)$�</code><br>reverse：</li><li><strong>varsN</strong>：是路径模式中花括号{}中的变量个数。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，varsN则等于[]{“id”}。</li><li><strong>varsR</strong>：是路径模式中每个花括号{}对应的正则表达式。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，varsR则等于<code>[]&#123;&quot;^[0-9]+$&quot;&#125;</code>。如果路由中是设置<code>r.HandleFunc(&quot;/product/&#123;id&#125;&quot;, ProductHandler)</code>，varsR的元素则是<code>[]&#123;&quot;^[^/]+�&quot;&#125;</code>的正则表达式。</li></ul><p>根据路由表及路由的结构，具体的路由匹配查找基本过程如下：第一步，从 Router.routes 开始依次循环第二步，从每个路由中的 matchers 中循环，看请求的路径是否符合 matchers 中的每一项规则，如果都匹配，则说明找到了该路由，否则继续步骤 1。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4f13aaad7c30f54713ae1a2d6246335a.png" alt="img"></p><h3 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h3><ul><li>匹配特定的域名或子域名</li><li>给路径增加前缀</li><li>限制路由的请求方法（GET、POST等）</li><li>支持路由分组</li><li>支持中间件</li></ul><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p>gorilla/mux 的路由解析采用的是 <strong>精准匹配</strong> 规则，而 net/http 包使用的是 <strong>长度优先匹配</strong> 规则。</p><ul><li><strong>精准匹配</strong> 指路由只会匹配准确指定的规则，这个比较好理解，也是较常见的匹配方式。</li><li><strong>长度优先匹配</strong> 一般用在静态路由上（不支持动态元素如正则和 URL 路径参数），优先匹配字符数较多的规则。</li></ul><p>一般 <strong>长度优先匹配</strong> 规则用在静态内容处理上比较合适，动态内容，例如我们的 goblog 这种动态网站，使用 <strong>精准匹配</strong> 会比较方便。</p><h2 id="基于-tries-结构的路由实现"><a href="#基于-tries-结构的路由实现" class="headerlink" title="基于 tries 结构的路由实现"></a>基于 tries 结构的路由实现</h2><h3 id="gin-框架中的路由"><a href="#gin-框架中的路由" class="headerlink" title="gin 框架中的路由"></a>gin 框架中的路由</h3><p>大名鼎鼎的 gin 框架采用的就是前缀树结构实现的路由。我们先来看一下 gin 框架中路由是如何定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  g := gin.New()</span><br><span class="line">  </span><br><span class="line">  g.POST(<span class="string">&quot;/abc/info&quot;</span>, InfoHandler)</span><br><span class="line">  g.POST(<span class="string">&quot;/abc/info/detail&quot;</span>, InfoHandler)</span><br><span class="line">  g.POST(<span class="string">&quot;/abc/list&quot;</span>, HomeHandler)</span><br><span class="line">  g.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HomeHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.Writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, this is Home page&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InfoHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.Writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, this is info&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，首先通过 gin.New()初始化一个 gin 对象 g，然后通过 g.POST 或 g.GET 等方法就可以注册路由。很明显，路由注册过程也限制了请求的方法。</p><p>当然，还有一个方法是允许任何请求方法都能访问该路径的，就是 Any：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.Any(<span class="string">&quot;/&quot;</span>, HomeHandler)</span><br></pre></td></tr></table></figure><p>Any 方法本质上是定义了一组方法名，然后依次调用对应的方法将该路由进行注册，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  anyMethods = []<span class="type">string</span>&#123;</span><br><span class="line">    http.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,</span><br><span class="line">    http.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,</span><br><span class="line">    http.MethodTrace,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any registers a route that matches all the HTTP methods.</span></span><br><span class="line"><span class="comment">// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Any(relativePath <span class="type">string</span>, handlers ...HandlerFunc) IRoutes &#123;</span><br><span class="line">  <span class="keyword">for</span> _, method := <span class="keyword">range</span> anyMethods &#123;</span><br><span class="line">    group.handle(method, relativePath, handlers)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>相比较 map/hash 字典实现的优点：利用字符串公共前缀来减少查询时间，减少无谓的字符串比较。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ad3c820a8c6cbb62704d59796bf40927.png" alt="img"></p><p>上述示例中的<code>g.POST(&quot;/abc/info&quot;, InfoHandler)</code>路由，只会注册到 POST 方法的路由树中。若通过 GET 方法请求该路径，则在搜索的时候，在 GET 方法的路由树中就找不到该路由。这样就起到了通过路由限制请求方法的作用。</p><h4 id="路由树节点的数据结构"><a href="#路由树节点的数据结构" class="headerlink" title="路由树节点的数据结构"></a>路由树节点的数据结构</h4><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b147889ed160783df17d31acea619d57.png" alt="img"></p><p>前缀树中的路由都是基于这个 node 数据结构来进行构建的。其中包含了一个路由中的基本元素：路径 fullPath、对应的处理函数 handlers。其中 handlers 包含了中间件处理函数，因此这里使用一个 handlersChain 表示。</p><p>另外一个关键字段是 children，具有相同路径前缀的子节点通过 children 节点来构成父、子关系。</p><h3 id="路由树的构建"><a href="#路由树的构建" class="headerlink" title="路由树的构建"></a>路由树的构建</h3><p>第一个路由的注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/info&quot;</span>, InfoHandler)</span><br></pre></td></tr></table></figure><p>因为是第一个路由注册，路由树是空的。所以直接构建一个 node 节点，然后将该 node 节点作为 POST 方法路由树的根节点插入即可。如下图：</p><p><img src="https://static001.geekbang.org/infoq/ab/ab2cd3446fec7cc526bed195a8f7c771.png" alt="img"></p><p>接着注册第二个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/info/detail&quot;</span>, DetailHandler)</span><br></pre></td></tr></table></figure><p>这个路由的特点是和路由”/abc/info”有共同的前缀，所以会将该路由作为第一个路由的子节点放到 children 中。如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/652ef39044e3f6dde0f9740c0e0593fd.png" alt="img"></p><p>这里主要有三个变化：</p><ul><li>一个是根节点的 priority 由 1 变成了 2；</li><li>一个是 children 中多了一个子节点路由；</li><li>最后一个是 indices 字段的值变成了”/“，这个是第一个子节点的 path 字段的第一个字符，用于匹配时索引使用。</li></ul><p>在子节点中，要注意的是 path 的值，因为前缀是”/abc/info”了，所以这里 path 是”/detail”。但 fullPath 依然是注册时完整的路径。</p><p>接下来，再注册第三个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/list&quot;</span>, ListHandler)</span><br></pre></td></tr></table></figure><p>这个路由的特点是和前两个路由有共同的前缀”/abc/“，所以首先会将现在的根节点进行拆分，拆分成”/abc/“ 和”info”。而 info 和原来的”/abc/info/detail” 又有共同的前缀 info，所以原来的”/abc/info/detail”就变成了 info 的子节点。而”/abc/list”除去前缀”/abc/“后，剩余”list”子节点，作为”/abc/“的子节点。如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba55d2e6246676bf96c1175a9d4038ef.png" alt="img"></p><p>那么，按节点组成的路由树就如下所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d4917411671d346791c6ccddf86f9278.png" alt="img"></p><p>这里，首先看根节点的变化：</p><ul><li>handlers 变为 nil。因为该节点不是一个具体的路径，只是一个前缀，所以具体的 handler 下移到了子节点 info 节点。</li><li>path 变为了前缀”/abc/“。</li><li>indices 字段值变为了”il”，其中 i 是第一个子节点中 path 字段的第一个字符，l 是第二个子节点中 path 字段的第一个字符。</li><li>priority 字段变成 3：代表从自身开始及子节点共有 4 个。</li><li>children 字段变成了两个直接子节点。</li><li>fullPath 字段变为了”/abc/“。</li></ul><p>其次，是从原根节点中拆分出一个 info 节点。最后是 detail 节点成为 info 节点的子节点。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件是一种计算机软件，可为操作系统提供的软件应用程序提供服务，以便于各个软件之间的沟通，特别是系统软件和应用软件。广泛用于web应用和面向服务的体系结构等。</p><p>纵观GO语言，中间件应用比较普遍，主要应用：</p><ul><li>记录对服务器发送的请求（request）</li><li>处理服务器响应（response ）</li><li>请求和处理之间做一个权限认证工作</li><li>远程调用</li><li>安全</li><li>等等</li></ul><p><strong>中间件处理程序</strong>是简单的<code>http.Handler</code>，它包装另一个<code>http.Handler</code>做请求的一些预处理和/或后处理。它被称为“中间件”，因为它位于Go Web服务器和实际处理程序之间的中间位置。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1460000018819807" alt="img"></p><h3 id="在gin框架下实现中间件"><a href="#在gin框架下实现中间件" class="headerlink" title="在gin框架下实现中间件"></a>在gin框架下实现中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default() 创建带有默认中间件的路由，默认是包含logger和recovery中间件的</span><br><span class="line">r :=gin.<span class="built_in">new</span>()      创建带有没有中间件的路由</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们就大致了解了路由和中间件。在本项目中，路由和中间件实现了大多数功能，因此深刻地理解这两个概念能够帮助我更好的理解代码。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://xie.infoq.cn/article/0c2d65a7c72147dc457af5007">路由</a></li><li><a href="https://segmentfault.com/a/1190000018819804">中间件</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要用于介绍&lt;code&gt;GoBlog&lt;/code&gt;项目中两个最为重要的部分——路由和中间件。这两个部分可以说是本项目的重要组成部分，下面我们会逐个进行学习和分析，并大概介绍其在项目中的作用。&lt;/p&gt;
&lt;h1 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;he</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="Web程序" scheme="http://example.com/tags/Web%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>GoBlog，启动！</title>
    <link href="http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/"/>
    <id>http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/</id>
    <published>2024-03-23T12:52:50.000Z</published>
    <updated>2024-03-23T12:38:48.272Z</updated>
    
    <content type="html"><![CDATA[<p>喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直到需要找实习才发现自己简历上能写的东西寥寥无几。说来奇怪，上了几年大学发现自己好像什么都没学到，这应该就是一种清醒的堕落吧。</p><p>我对这个项目的了解就像我对Go语言的了解一样，来自我那个神奇的舍友。他花钱买了教程之后，我就可以蹭一下了，很难想象没有我亲爱的舍友，我的大学生活会变成什么样子。</p><h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p>废话少说，为什么要用Go来开发一个博客系统呢？答案很简单，Go语言本身就非常适用于开发Web应用程序，而且我们在学习的过程中也不难发现好像很多大佬都有自己的博客，那不如把这两个结合一下，这样在设计具体功能的时候也能找到一些可以借鉴的地方。</p><p>开发Web应用要涉及到的知识：</p><ul><li>表单验证</li><li>注册登录</li><li>授权验证</li><li>共享数据库连接</li><li>密码哈希</li><li>路由和中间件</li><li>代码组织（MVC/RESTful）</li><li>打包静态文件和模板文件</li><li>项目部署等</li></ul><p>这些内容会在后面的博客中一一介绍，这个项目并不是一个玩具项目，后续的文章中也会解决一些会在实际生产环境中出现的问题。</p><p>本书源码：<a href="https://github.com/summerblue/goblog">github.com/summerblue/goblog</a></p><p>本项目并不是笔者自己开发的，是跟着社区的教程完成的。</p><h1 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h1><p>作为实战项目，遇到程序报错是很正常的情况，多解决报错能帮助我们学到不少东西。</p><p>在遇到一些很抽象的报错时，不要怀疑机器有问题，99%的概率问题在自己，即使代码都是复制的。</p><p>当然如果实在是找不到，可以利用源码来排除错误。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>Windows11</li><li>Go1.21.1</li><li>编译器Visual studio code</li></ul><h1 id="通过本项目学到了什么"><a href="#通过本项目学到了什么" class="headerlink" title="通过本项目学到了什么"></a>通过本项目学到了什么</h1><ul><li>数据库使用</li><li>模板使用</li><li>基础测试</li><li>项目开发流程</li><li>Go 项目结构选择</li></ul><h1 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240323203506135.png" alt="image-20240323203506135"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的Go Web程序</title>
    <link href="http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-03-22T14:27:49.000Z</published>
    <updated>2024-03-24T11:19:49.996Z</updated>
    
    <content type="html"><![CDATA[<p>在Go中，搭建一个http server简单到令人难以置信。只需要引入net/http包，写几行代码，一个http服务器就可以正常运行并接受访问请求。因此，在正式开启项目开发之前，先来看一段简短的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">&quot;&lt;h1&gt;Hello, 这里是 goblog&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handlerFunc)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这段代码就能够构成一个Web程序，其中最为主要的内容基本上都与一个包有关—— <code>net/http</code>，那就先学习一下有关这个包的内容吧。 </p><h1 id="初识net-http"><a href="#初识net-http" class="headerlink" title="初识net/http"></a>初识net/http</h1><p>在net/http源代码中，我们可以深深体会到Go语言的结构体（以及自定义类型）、接口、方法简单组合的设计哲学。这个包最主要的文件有4个，分别是： <code>client.go</code> <code>server.go</code> <code>request.go</code> <code>response.go</code>。</p><p>这四个文件也分别代表了HTTP中最重要的4个部分，<code>http Request</code> 请求、 <code>http Response</code> 响应、<code>http Client</code>客户端和<code>http Server</code> 服务端，所以我们先从这四个方面来了解<code>net/http</code>包：</p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>http Request</code>请求是由<strong>客户端发出</strong>的消息, 用来使<strong>服务器执行</strong>动作.发出的消息包括起始行, Headers, Body。</p><p>一般使用 <code>http.NewRequest</code>来构造一个<code>http Request</code>请求，可能包括<code>http Headers</code>信息，<code>cookies</code>信息等，然后发给服务端。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><code>http Response</code>响应是由<code>http Server</code>服务端发出的消息，用来响应<code>http Client</code>端发出的<code>http Request</code>请求。发出的消息包括起始行, Headers, Body。</p><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p><code>http Client</code>客户端主要用来发送<code>http Request</code>请求给<code>http Server</code>服务端，比如以<code>Do</code>方法，<code>Get</code>方法以及<code>Post</code>或<code>PostForm</code>方法发送<code>http Request</code>请求。</p><p><code>http.NewRequest</code>可以灵活的对<code>http Request</code>进行配置，然后再使用<code>http.Client</code>的<code>Do</code>方法发送这个<code>http Request</code>请求。</p><ul><li>如果使用<code>Post</code>或者<code>PostForm</code>方法，是不能使用<code>http.NewRequest</code>配置请求的，只有<code>Do</code>方法可以定制<code>http.NewRequest</code>。</li></ul><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><code>http Server</code>服务端用来接收并响应<code>http Client</code>端发出的<code>http Request</code>请求，是<code>net/http</code>包中非常重要和关键的一个功能。我们在Go语言中简单就能搭建<code>HTTP</code>服务器，就是因为它的存在。</p><p>关于以上四部分的详细内容，可以看<a href="https://wizardforcel.gitbooks.io/go42/content/content/42_36_http.html">这篇文章</a>，里面有更加详细的函数解释。</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>大概了解关于<code>net/http</code> 包之后，我们再回头看开篇的那段代码，或许已经能看懂个大概了。</p><h3 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h3><p><code>http.ListenAndServe</code> 用以监听本地 3000 端口以提供服务，标准的 HTTP 端口是 80 端口，如 <code>baidu.com:80</code>，另一个 Web 常用是 HTTPS 的 443 端口，如 <code>baidu.com:443</code>。</p><p>当我们监听本地端口时，可使用 <code>localhost</code> 加上端口号来访问。运行上面的程序，可以通过<a href="http://localhost:3000/">localhost:3000/</a> 进行访问。</p><h3 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h3><p><code>http.HandleFunc</code> 用以指定处理 HTTP 请求的函数，此函数允许我们只写一个 handler，请求会通过参数传递进来，使用者只需与 <code>http.Request</code> 和 <code>http.ResponseWriter</code> 两个对象交互即可。</p><p>在实例代码中，我们利用 <code>fmt.Fprint</code> 将 <code>&lt;h1&gt;Hello, 这里是 goblog&lt;/h1&gt;</code> 子串写入 <code>http.ResponseWriter</code>，即可响应用户请求。</p><h3 id="http-Request"><a href="#http-Request" class="headerlink" title="http.Request"></a>http.Request</h3><p><code>http.Request</code> 是用户的请求信息，一般用 <code>r</code> 作为简写。</p><p>一些常见的操作如：</p><ul><li><code>r.URL.Query()</code> 获取用户参数</li><li>获取客户端信息 <code>r.Header.Get(&quot;User-Agent&quot;)</code></li></ul><h3 id="http-ResponseWriter"><a href="#http-ResponseWriter" class="headerlink" title="http.ResponseWriter"></a>http.ResponseWriter</h3><p><code>http.ResponseWriter</code> 是返回用户的响应，一般用 <code>w</code> 作为简写。</p><p>常见操作如：</p><ul><li>返回 500 状态码 <code>w.WriteHeader(http.StatusInternalServerError)</code></li><li>设置返回标头 <code>w.Header().Set(&quot;name&quot;, &quot;my name is smallsoup&quot;)</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于Web程序我们就完成了简单的了解。我们通过<code>http.ListenAndServe</code>来对本地的端口进行监听，等待用户的操作。使用<code>http.HandleFunc</code>来完成当用户做出指定操作时的动作。<code>handlerFunc</code>函数则是我们自己定义的一系列动作，等待<code>HandleFunc</code>调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go中，搭建一个http server简单到令人难以置信。只需要引入net/http包，写几行代码，一个http服务器就可以正常运行并接受访问请求。因此，在正式开启项目开发之前，先来看一段简短的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="Web程序" scheme="http://example.com/tags/Web%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>腾讯面试——血与泪的教训</title>
    <link href="http://example.com/2024/03/21/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD/"/>
    <id>http://example.com/2024/03/21/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD/</id>
    <published>2024-03-21T13:39:57.000Z</published>
    <updated>2024-03-22T05:48:23.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又到了一周一度的学习总结了，本周可以算得上是非常神奇的一周了。从标题也不难看出，神奇之处就在于本周是笔者第一次参加一场面试，可谓是非常的紧张。经过一场面试也让我深刻地感受到闭门造车是行不通的，在面试之前总觉得自己把什么都准备好了，结果在两个小时的面试过程中，被面试官牵着鼻子走（狗头）。所以本周的总结主要集中在对面试的复盘方面，希望在完成这次周报之后能对我以后的学习有一定的帮助吧。</p><h1 id="面试复盘"><a href="#面试复盘" class="headerlink" title="面试复盘"></a>面试复盘</h1><h2 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h2><ol><li><p>首先就是面试官介绍自己的部门和我的自我介绍。</p><p>从舍友的评价来看，自我介绍环节就已经十分紧张了，说话也是结结巴巴，十分的不自信。</p></li><li><p>三道算法题。</p><p>题目倒不是很难，也不需要能够完全正确，只需要自己的思路对就OK了。</p></li><li><p>拷打项目，也是本次面试中笔者表现的最呆瓜的一个环节了。</p><p>面试官问我为什么要选择MySQL来作为数据库来存储信息。我竟然脑抽到回答说我只会MySQL。</p></li><li><p>除了拷打项目，就是一些比较简单的八股了，还是有待加强。</p></li></ol><h2 id="项目拷打总结"><a href="#项目拷打总结" class="headerlink" title="项目拷打总结"></a>项目拷打总结</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>是否支持上传图片？图片是怎样进行存储的？怎么把图片和对应的文章正确地显示出来？</p><p>显然，对于并没有完全准备好的我来说，这三个问题已经足够干掉我了。</p><ol><li>已经实现了上传和显示图片的功能。</li><li>应该将图片存储在对应的服务器中，现阶段的存储方式为把用户上传的图片放到一个专门的文件夹中。</li><li>由于图片存储为在固定的文件夹中，那么只需要将文件的路径放在文章的正确位置即可，这样在进行页面展示时，可以将图片进行正确的显示。</li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如果用户量太大，每个人都往其中存储文章，导致表中内容过多，该怎么解决？</p><p>在实际的应用开发中，数据量过大的MySQL表会导致查询的性能下降。解决方法如下：</p><ol><li>分表分库</li></ol><p>​    将单张数据量过大的表拆分成多个较小的表，每个表只存储一部分数据，以此来提高查询效率。</p><ol><li>垂直拆分</li></ol><p>​    如果单表的列比较多，但是并不是所有列都会频繁地使用，可以考虑将一些少用的列拆分到新的表中，从而减少单个表的数据量，减少磁盘空间的使用。</p><ol><li>建立合适的索引</li></ol><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>上一个问题提到，当数据量过大时可以采用分表策略，那要怎么进行文章的定位呢？</p><p>水平切分后同一张表会出现在多个数据库或表中，每个库和表的内容不同，对于水平分表后分库后，如何知道哪条数据在哪个库里或表里，则需要路由算法进行计算，这个算法会引入一定的复杂性。</p><ul><li>范围路由</li></ul><p>选取有序的数据列，如时间戳作为路由的条件，不同分段分散到不同的数据库表中，以最常见的用户ID为例，路由算法可以按照1000000的范围大小进行分段，1 ~ 9999999放到数据库1的表中，10000000~199999999放到数据库2的表中，以此累推。<br>  范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多增加维护复杂度，分段太大可能会导致单表依然存在性能问题，按一般大老们的经验，分段大小100W至2000W之间，具体需要根据业务选 取合适的分段大小。</p><ul><li>范围路由的优点<ul><li>可以随着数据的增加平滑地扩充新的表或库，原有的数据不需要动。</li><li>单表大小可控</li><li>使用分片字段进行范围查找时，连续分片可快速定位查询，有效避免分片查询的问题。</li></ul></li><li><p>热点数据成为性能瓶颈，连续分片可能存在数据热点，例如按时单字段分片，有些分片存储最近时间内的数据，可能会被频繁读写，而有些历史数据则很少被查询。</p></li><li><p>hash算法</p></li></ul><p>  选取某个列或几个列的值进行hash运算，然后根据hash的结果分散到不同的数据库表中，以用ID为例，假如我们一开始就规划10个数据库表，路由算法可以简单地用id % 10的值来表示数据所属的数据库编号，ID为985的用户放到编号为5的子表中。ID为10086编号放到编号为6的表中。<br>  Hash路由设计的复杂点主要体现 在初始表数量的选取上，表数量太多维护比较麻烦，表数量太小又可能导致单表性能存在问题。而用Hash路由后，增加字表数量是非常麻烦的，所有数据都要重新分布。<br>  Hash路由的优缺点与范围路由相反，Hash路由的优点是表分布比较均匀，缺点是扩容时很麻烦，所有数据均需要重新分布。</p><ul><li>路由配置</li></ul><p>  配置路由就是路由表，用一张独立的表来记录路由信息。同样以用户ID为例，我们新增一张ROUTER表，这个表包含table_Id两列，根据user_id就可以查询对应的修改路由表就可以了。<br>配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。<br>其缺点就是必须多查询一次，会影响整体性能，而且路由表本身如果太大，性能会成为瓶颈点，如果我们再将路由表分库分表，则又面临一个死循环。</p><h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>如果实行分表，如何确保自增的文章ID不出现重复。或者有什么其他解决方案。</p><p>在本人的测试过程中发现，给ID设置为自增并不会影响用户自己设置ID。</p><p>关于分表后ID自增又会从1开始，我的解决方案是在需要进行分表时可以先获取前一个表的最后一篇文章，在得到这个文章的ID后，将新建的文章ID设置为上一篇文章的ID+1。</p><p>其他解决方案：如果采用hash算法进行分表的话，可以将设置文章ID和插入表分为两步操作，先根据自增将wenzhangID设置出来，再进行插入表的操作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，经过此次面试还是返现了学习上的不少漏洞，本篇文章只解决了在项目拷打环节的一些提问，关于八股文和一些算法方面的内容我想还是要分开来写。最后面试官也有提醒到项目还是可以增加一些功能。可问的点有很多，还是得把项目吃透。</p><p>从面试官所问的问题也不难看出，有关到项目的内容他们更想听到的是在实际中的各种情况和解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;又到了一周一度的学习总结了，本周可以算得上是非常神奇的一周了。从标题也不难看出，神奇之处就在于本周是笔者第一次参加一场面试，可谓是非常的紧张</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言——内存</title>
    <link href="http://example.com/2024/03/12/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2024/03/12/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</id>
    <published>2024-03-12T12:51:19.000Z</published>
    <updated>2024-03-15T05:54:16.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于内存部分的内容，是正在读的书中的第三部分，这一部分讲的是Go语言中的指针相关的知识，由于书中花费了一定篇幅去讲过于内存的问题，所以本周的总结报告命题为”内存“。</p><p>这并不是第三周全部学到的东西，只是开始，由于我现在还不能把学到的东西随手记录下来，所以选择先写一篇学习总结。我详细一篇应该是关于项目实战的。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>提到指针，我们并不陌生，从开始学习程序设计就已经接触到了指针。对我来说，指针是一个既熟悉又陌生的东西。熟悉是因为在最开始的学习时，我和同学不止一次地讨论过指针也进行了一定的学习。陌生是因为我确实不是很喜欢学习C语言，以至于其真正的核心内容我学的都不扎实，学了就忘。</p><hr><p>在Go语言中，由于变量分为<strong>值类型</strong>和<strong>引用类型</strong>，使得指针在函数传参的时候有了用处。对于<strong>值类型的变量</strong>而言，当函数的参数是指针类型时，函数对该参数的修改才会影响到该参数本身。</p><h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>对于是否使用指针类型作为接收者，有以下几点参考：</p><ol><li>如果接收者类型是 map、slice、channel 这类引用类型，不使用指针。</li><li>如果需要修改接收者，那么需要使用指针。</li><li>如果接收者是比较大的类型，可以考虑使用指针，因为内存拷员廉价，所以效率高。</li></ol><h3 id="什么情况下使用指针"><a href="#什么情况下使用指针" class="headerlink" title="什么情况下使用指针"></a>什么情况下使用指针</h3><p>从以上指针的详细分析中，我们可以总结出指针的两大好处：</p><ol><li>可以修改所指向数据的值。</li><li>在变量复制、参数传值的时候可以节省内存。</li></ol><p>不过.Go语言作为一种高级语言，在指针的使用上还是比较克制的。它在设计的时候就对指针进行了诸多限制，比如指针不支持运算，也不能取常量的指针。所以在思考是各使用时，我们也要保持克制的心态。<br>根据实战经验我总结了以下几点使用指针的建议，供你参考：</p><ol><li>不要对map、slice、channel 这类引用类型使用指针。</li><li>如果需要修改方法接收者内部的数据或者状态时，需要使用指针。</li><li>如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数。</li><li>如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针。</li><li>像 int、bool 这样的小数据类型没必要使用指针。</li><li>如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全。</li><li>指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然Go语言允许这么做，但是这会使你的代码变得异常复杂。</li></ol><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>指向接口的指针是否实现了该接口？为什么？</p><p>答：虽然指向具体类型的指针可以实现一个接口，但是指向接口的指针永远不可能实现该接口。</p><h2 id="值类型？指针类型？引用类型？"><a href="#值类型？指针类型？引用类型？" class="headerlink" title="值类型？指针类型？引用类型？"></a>值类型？指针类型？引用类型？</h2><p>初次看到这三个名词，我似懂非懂。值、指针、引用，为什么几个我认识的字放在一起，我就不太能分得清这些都是什么了。在上面的内容中有提到，Go语言中的变量分为两种，值类型和引用类型。那这个指针类型又是什么，和其他两种有什么关系呢。</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型包括：整型、浮点型、字符串、布尔、数组和 struct 。</p><p>认真观察过这些类型，我们不难发现，当这些类型作为函数参数时，在函数内部对其进行修改并不会影响到其原来的值。这就是值类型的特点。原因如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240312223328702.png" alt="image-20240312223328702"></p><p>观察上面的示意图不难得出，当 <code>main</code> 函数调用函数 <code>modifyPerson</code> 时，程序将变量 P 进行了一次复制，所以在函数 <code>modifyPerson</code> 试图修改变量 P 时，修改的是 P 的副本。值类型的变量在函数中均是如此。因此，在函数试图修改值类型的参数时，实际的参数并不会被修改。</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型保存的值就是数据对应的内存地址，所以在函数传参采用值传递的原则下，拷贝的值也是内存地址。因此当函数想要对参数进行修改时，即使修改的是参数的副本，其内容仍是需要修改变量的地址。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型包括：切片、map、函数、chan和接口</p><p>对于引用类型，在参数传递时仍然是<strong>值传递</strong>，但其传递的值为指针，并不是其他编程语言中所谓的引用传递。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240312231609318.png" alt="image-20240312231609318"></p><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>在声明一个变量时，常常会使用到的是 <code>var</code> 关键字和 <code>:=</code> 这两种方法。当我们尝试着去指针类型的变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sp *<span class="type">string</span></span><br><span class="line">*sp = “内存地址”</span><br><span class="line">fmt.Println(*sp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行上面的代码时，编译器会报错。</p><p>这是因为指针类型的变量如果没有分配内存，其默认值为 <code>nil</code>，因为它没有指向的内存，所以无法使用，强行使用就会出现 <code>nil</code> 指针的报错。</p><p>一个变量必须要经过<strong>声明</strong>、<strong>内存分配</strong>才能赋值，才能进行初始化。对于值类型，Go语言会在声明时就为它分配内存，以便后续的赋值操作。对于指针类型，Go语言并没有自动分配内存，所以不能对其进行赋值操作。</p><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>正是因为上面情况，<code>new</code>函数派上了用场。</p><p><code>new</code> 函数的作用就是根据传入的类型申请一块内存，然后返回指向这块内存的指针，指针指向的数据就是该类型的<strong>零值</strong></p><h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><p>关于<code>make</code>函数，最常使用的场景就是 map、slice 和 chan 这三种类型的初始化。</p><p>make 函数就是上述三种类型的工厂函数，用于<strong>创建和初始化</strong>这几种类型。</p><h3 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h3><p><code>make</code> 和 <code>new</code> 是两个⽤于分配内存的内建函数, 在使⽤场景和返回值类型上有明显的区别。</p><ul><li><code>make</code> ⽤于创建并初始化切⽚、映射和通道等引⽤类型。它返回的是被初始化的⾮零值（⾮nil）的引⽤类型。</li><li><code>new</code> ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的零值的指针。</li></ul><p>总结：</p><ul><li><code>new</code>只⽤于分配内存，返回⼀个指向地址的<strong>指针</strong>。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li><li><code>make</code>只可⽤于 <strong>slice, map, channel</strong> 的初始化,返回的是<strong>引⽤</strong></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结一下，本周好像有一点懈怠了，做题和做项目的时候都有点心不在焉的。不过本周学到的东西还是不少的。</p><ul><li>算法题已经完成了数组、双指针、滑动窗口和区间四个部分了。</li><li>项目目前完成了一半左右，希望下一周能全部搞完，再完成一篇博客。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于内存部分的内容，是正在读的书中的第三部分，这一部分讲的是Go语言中的指针相关的知识，由于书中花费了一定篇幅去讲过于内存的问题，所以本周的</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言进阶——并发</title>
    <link href="http://example.com/2024/03/08/Go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2024/03/08/Go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/</id>
    <published>2024-03-08T05:21:04.000Z</published>
    <updated>2024-03-08T06:40:09.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本周是正式系统性学习整理Go语言的第二周，上周把基础知识学过后，这周开始学习进阶知识。说到Go语言的特性，那就是高并发，所以进阶学习的第一部分只是就是关于并发的。总结内容和之前一样，并不会过多的记录书本里的东西，更多的是这一周学习的困难和解决的过程。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><p>本周学习内容主要有两个部分，并发基础和算法，学习这些的原因是因为最近开始找实习了，发现确实落下了太多东西。</p><h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>第一次了解并发是在学习计算机系统的时候，不再只让计算机做完一件事之后再开始做另外一件事，而是让计算机同时做多件事情，这就是并发。</p><p>说到并发就一定绕不开两个概念——进程和线程。</p><ul><li>在启动一个软件的时候，操作系统会为这个软件创建一个<strong>进程</strong>，这个进程就是该软件的工作空间，它包含了软件运行所需的所有资源。</li><li><strong>线程</strong>是进程的执行空间，一个进程可以有多个线程，线程被操作系统调度执行。</li></ul><p>一个程序启动就会有一个进程被创建，同时进程也会启动一个线程，这个线程被称为主线程，如果主线程结束，那么整个程序就退出了。有了主线程，就可以从主线程里启动很多其他线程，也就有了<strong>多线程的并发</strong>。</p><hr><p>在Go语言中并没有线程的概念，只有<strong>协程</strong>，也成为 <strong><code>goroutine</code></strong> 先比线程来说，协程更加轻量，一个程序可以随意启功成千上万个协程。</p><p><code>goroutine</code> 被 <code>Go routime</code>所调度，也就是说，Go语言的并发是由Go自己调度的，这对于开发者来说完全透明。</p><h2 id="如何通信"><a href="#如何通信" class="headerlink" title="如何通信"></a>如何通信</h2><p>当我们同时启动了多个 goroutine 时，它们之间要怎么通信？</p><p>Go语言提供了用于通信的<strong>管道</strong>—— <code>channel</code></p><ul><li>当需要从管道中接受值时，如果管道为空，那么会阻塞等待，知道管道中有值可以接受为之。</li></ul><p>管道分类：</p><ul><li><strong>无缓冲管道</strong>：容量为0，只起到传输数据的作用，又被称为<strong>同步管道</strong>；</li><li><strong>有缓冲管道</strong>：类似于一个可阻塞的对列，内部元素先进先出</li></ul><p>可以通过 <code>select + channel</code> 来实现多路复用的效果。</p><p>在Go语言中，提倡通过通信来共享内存，而不是通过共享内存来通信，所以在数据流动、传递的场景中要优先使用 channel，它是并发安全的。</p><hr><p>思考题：channel是如何实现并发安全的？</p><p>channel内部使用了互斥锁来保证并发的安全。</p><h2 id="并发中的Map是否安全"><a href="#并发中的Map是否安全" class="headerlink" title="并发中的Map是否安全"></a>并发中的Map是否安全</h2><p>Go 中的标准 <code>map</code> 类型是非并发安全的，这意味着在多个 <code>Goroutine</code> 中并发读写同一个 map 可能导致数据竞争和不确定的行为。为了在并发环境中使用  map，Go 提供了  <code>sync</code> 包中的 <code>sync.Map</code> 类型，它是一种并发安全的映射。</p><p>无须初始化，直接声明即可。<br>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。<br>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</p><p><strong>sync.Map提供的常用方法有如下七个</strong>:</p><ul><li>Load：通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</li><li>Store：该方法相当于对sync.Map的更新或新增，参数是键值对。</li><li>LoadOrStore：该方法的参数为key和value。该方法会先根据参数key查找对应的value，如果找到则不修改原来的值并通过actual返回，并且loaded为true；如果通过key无法查找到对应的value，则存储key-value并且将存储的value通过actual返回，loaded为false。</li><li>Delete：通过key删除键值对。</li><li>LoadAndDelete：通过key删除键的值，如果有，则返回上一个值。</li><li>Range：遍历sync.Map的元素，注意for…range map是对内置map类型的用法，sync.Map需要使用单独的Range方法。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明sync.Map</span></span><br><span class="line"><span class="keyword">var</span> syncmap sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store方法将键值对保存到sync.Map</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">97</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;lisi&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadOrStore key不存在</span></span><br><span class="line">    v, ok := syncmap.LoadOrStore(<span class="string">&quot;three&quot;</span>,<span class="number">3</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// 3 false</span></span><br><span class="line">    <span class="comment">// LoadOrStore key存在</span></span><br><span class="line">    v, ok = syncmap.LoadOrStore(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// 200 ture</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load方法获取sync.Map 键所对应的值</span></span><br><span class="line">    fmt.Println(syncmap.Load(<span class="string">&quot;lisi&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete方法键删除对应的键值对</span></span><br><span class="line">    syncmap.Delete(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> syncmap sync.Map</span><br><span class="line">    <span class="comment">// LoadAndDelete key不存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// &lt;nil&gt; false</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;xiaomi&quot;</span>, <span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    <span class="comment">// LoadAndDelete key存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// xiaomi true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Range遍历所有sync.Map中的键值对</span></span><br><span class="line">    syncmap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明 score，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</li><li>将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</li><li>Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</li><li>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</li></ul><h1 id="刷题思考"><a href="#刷题思考" class="headerlink" title="刷题思考"></a>刷题思考</h1><p>已经连续五天的刷题生活或许并没有给我带来什么真正有意义的思考，但还是想要记录一下。</p><p>毕竟从大一下学完数据结构之后就基本没怎么做过算法题了，所以刚开始这几天还是在找做题的感觉，有一种在高三备战高考的感觉，有时候也会觉得很折磨，看着别人想出来的完美算法，就会觉得自己和别人的差距太大了，只能一步一步来了。</p><p>这一周都只做了关于数组方面的题目，更多看到的题目标签是贪心、动态规划等等熟悉又陌生的字眼。</p><p>总之在做了几天题之后，发现自己的思维确实变慢了不少，还有就是把自然语言转换成代码语言的能力不行。</p><p>菜就多练喽！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本周学习内容主要是并发和算法，在Go语言项目上并没有投入什么精力，认真学习过并发之后就会正式开始学习做一些小项目来补充一下这方面的空白。</p><p>算法方面就希望下周能够找到做题的感觉，希望自己的小脑袋瓜赶紧转起来吧，继续积累经验。</p><p>关于Go语言八股文也确实应该腾出更多的时间来看了，希望下周能够完成计划吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本周是正式系统性学习整理Go语言的第二周，上周把基础知识学过后，这周开始学习进阶知识。说到Go语言的特性，那就是高并发，所以进阶学习的第一部</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言、并发" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E3%80%81%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>打开Go语言之门</title>
    <link href="http://example.com/2024/03/01/%E6%89%93%E5%BC%80GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%A8/"/>
    <id>http://example.com/2024/03/01/%E6%89%93%E5%BC%80GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%A8/</id>
    <published>2024-03-01T07:10:04.000Z</published>
    <updated>2024-03-08T05:21:27.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始学习Go语言已经差不多半年了，这是第一次正式写下一篇学习总结。又恰逢新学期开始，就把这篇当作新学期的第一篇周报吧。</p><p>本周主要是把半年来稀稀拉拉学到的Go语言基础知识有系统性地看了一遍。我对Go语言的了解更多还是从我的舍友，也正是受到他的影响我才会开始学习Go语言并进行记录。</p><p>这一周的学习内容就像本文的标签一样，Go语言基础。因为已经学习了很久，所以基础知识就不再本文中赘述。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><p>关于Go语言的学习，笔者已经看了四五本不同的基础书籍了，每本书的开头都是以Go语言的优点来开篇，那2024年的第一篇博客也从这个问题开始吧。</p><h2 id="Go语言好在哪？"><a href="#Go语言好在哪？" class="headerlink" title="Go语言好在哪？"></a>Go语言好在哪？</h2><p>说到Go语言的好处，想必都能想到什么简洁、高效等等。而真正吸引我开始学习Go语言的，还是我的舍友告诉我Go语言的代码有着严格的格式要求，不同人写的代码排版风格几乎一致，这一下就激起我学习Go语言的兴趣。因为笔者在刚开始学习编程的时候并没有养成良好的代码习惯，导致我的代码在很长一段时间里都只有我自己看得懂，于是迫切找到一个大家代码风格都差不多的语言重新开始学习。随着后来对Go的学习，我也了解到它更多的优点。接下来我们来看一下Go语言到底好在哪？</p><h3 id="语法简洁"><a href="#语法简洁" class="headerlink" title="语法简洁"></a>语法简洁</h3><p>Go语言相对于其他语言更容易上手，开发效率更高。这意味着Go易于学习、易于使用并且易于其他开发人员阅读。Go 没有大量的功能集，尤其是与 C++ 等语言相比。Go 的语法让人想起 C，这使得长期 C 开发人员学习起来相对容易。</p><p>从学术的角度讲Go语言其实非常平庸，不支持许多高级的语言特性；但从工程的角度讲，Go的设计是非常优秀的：规范足够简单灵活，有其他语言基础的程序员都能迅速上手。更重要的是Go自带完善的工具链，大大提高了团队协作的一致性。比如gofmt自动排版Go代码，很大程度上杜绝了不一致的问题。</p><h3 id="自带垃圾回收功能"><a href="#自带垃圾回收功能" class="headerlink" title="自带垃圾回收功能"></a>自带垃圾回收功能</h3><p>对比其他语言，Go语言的优势显著。比如Java虽然也具备垃圾回收功能，但它是解释型语言，需要安装JVM才能运行；C语言虽然不用解释，可以直接编译运行，但是它不具备垃圾回收功能，需要开发者自己管理内存的申请和释放，容易出问题。而Go语言具有两者的优势。</p><h3 id="并发性良好"><a href="#并发性良好" class="headerlink" title="并发性良好"></a>并发性良好</h3><p>Go语言就是为了并发而生的，其在设计时的创新就是 <strong>goroutines</strong> 和<strong>通道</strong>。</p><p><strong>Goroutines</strong> 是 Go 面向<strong>线程</strong>的轻量级方法，而通道是 goroutines 之间通信的优先方式。创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。</p><p>Goroutines的轻便主要体现在以下两个方面：</p><ul><li><strong>上下文切换代价小</strong>：Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；</li><li><strong>内存占用少</strong>：线程栈空间通常是 2M，Goroutine 栈空间最小 2K；</li></ul><p>关于Go语言的调度机制，可以看一下这篇文章——<a href="https://www.zhihu.com/question/21409296/answer/1040884859">https://www.zhihu.com/question/21409296/answer/1040884859</a></p><p>除了以上的三个优点以外，Go语言还有如强大的生态系统、支持跨平台操作以及拥有强大的标准库等优点。</p><h2 id="什么是静态语言"><a href="#什么是静态语言" class="headerlink" title="什么是静态语言"></a>什么是静态语言</h2><p>在打开任何一本关于Go语言基础的书籍时，首先映入眼帘的就是Go语言是一个静态语言，那么什么是静态语言，Go语言为什么会设计成静态语言，静态语言和动态语言又有什么区别。这些问题困扰了我很久，接下来将会解释以上问题。</p><p><strong>静态语言</strong>是一种编程语言，其特征是在编译时进行类型检查和绑定。在编写代码时，变量的类型需要明确指定，而且在编译阶段这些类型信息是固定的，不会在运行时发生变化。其特征如下：</p><ul><li><strong>类型检查：</strong> 在编译阶段进行，变量类型需要在声明时明确，并且编译器会检查变量的使用是否符合类型规定。</li><li><strong>编译时绑定：</strong> 函数调用和变量引用在编译时就已经确定，生成对应的机器代码。</li><li><strong>性能优化：</strong> 静态类型信息允许编译器进行更多的优化，生成更高效的代码。</li><li><strong>严格的错误检查：</strong> 由于类型信息在编译时就已知，因此静态语言通常有较为严格的类型检查，编译器可以在编译阶段捕获许多潜在的错误。</li></ul><p>静态语言主要有：Java、C、C++、C#、Swift 和 Go</p><hr><p><strong>动态语言</strong>是一种编程语言，其特征是在运行时进行类型检查和绑定。在编写代码时，变量的类型通常不需要显式指定，而是在运行时根据上下文动态确定。其特征如下：</p><ul><li><strong>类型检查：</strong> 在运行时进行，变量的类型可以在代码执行期间改变。</li><li><strong>运行时绑定：</strong> 函数调用和变量引用在运行时确定，这允许更大的灵活性和动态性。</li><li><strong>较少的编译时优化：</strong> 缺乏静态类型信息会减少编译器进行某些优化的能力。</li><li><strong>更灵活：</strong> 相对于静态语言，动态语言通常更灵活，适用于快速开发和迭代。</li></ul><p>动态语言主要有：Python、JavaScript、Ruby、PHP</p><hr><p>静态语言与动态语言的区别：</p><ul><li><strong>类型检查时机：</strong> 静态语言在编译时进行类型检查，而动态语言在运行时进行类型检查。</li><li><strong>类型灵活性：</strong> 静态语言要求在编写代码时明确指定变量的类型，而动态语言允许变量在运行时根据上下文动态确定类型。</li><li><strong>编译时绑定 vs. 运行时绑定：</strong> 静态语言的函数调用和变量引用在编译时绑定，而动态语言在运行时绑定，允许更大的灵活性。</li><li><strong>性能优化：</strong> 静态语言由于在编译阶段有更多的类型信息，通常可以进行更多的编译时优化，因此在一些性能方面具有优势。动态语言通常在运行时进行解释，因此可能在性能上略逊于静态语言。</li><li><strong>错误检查：</strong> 由于在编译时进行类型检查，静态语言通常能够在更早的阶段捕获潜在的错误，而动态语言在运行时才能发现。</li></ul><hr><p>Go语言被设计成静态语言的主要原因涉及到一系列的设计目标和哲学，其中一些因素包括：</p><ol><li><p><strong>性能优化：</strong> 静态语言通常在编译阶段进行类型检查，这使得编译器可以在生成机器代码时进行更多的优化。Go语言的设计目标之一是提供出色的性能，静态类型信息允许编译器在编译时对代码进行更多的优化，提高程序的执行效率。</p></li><li><p><strong>并发支持：</strong> Go语言的并发模型以及轻量级线程（goroutines）的概念需要在编译时对程序的结构有清晰的了解。静态类型信息使编译器能够更好地理解并发代码，减少在运行时发生竞争条件和死锁的可能性。</p></li><li><p><strong>简单性和可读性：</strong> Go语言的设计注重简单性和可读性，静态类型系统可以帮助开发者更容易理解代码。类型信息作为一种文档形式，使得代码更加自解释，减少了理解代码所需的认知负担。</p></li><li><p><strong>错误检查：</strong> 静态类型检查可以在编译时捕获潜在的类型错误，提高代码的可靠性。这有助于减少在运行时因为类型错误引起的 bug，提高了代码的稳定性。</p></li><li><p><strong>团队协作：</strong> 在大型项目和团队中，静态类型系统可以提供更好的协作支持。类型信息可以帮助开发者了解函数和变量的用法，使得团队成员之间更容易沟通和协作。</p></li><li><p><strong>编程工具的支持：</strong> 静态类型信息为IDE（集成开发环境）和其他编程工具提供了更多的信息，从而提供更强大的代码分析和自动补全功能，提高了开发效率。</p></li></ol><p>总的来说，Go语言之所以选择静态类型，是为了在性能、并发性、可读性和团队协作等方面达到一种平衡，使得开发者能够更容易地编写高性能、可维护和并发安全的代码。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，本周的学习总结也就完成了，内容较少，原因是还有一些更复杂的东西想留着专门来写。所以本文就只是写了在学了Go语言的基础语法，即打开了Go语言之门之后，我的疑问和相对应的解答。除了解语法之外，我也在尝试着跟着大佬来完成一些项目，详细的就等完成之后的总结吧。</p><p>下周的学习目标是更深层次地学习Go语言的进阶语法并推动项目进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开始学习Go语言已经差不多半年了，这是第一次正式写下一篇学习总结。又恰逢新学期开始，就把这篇当作新学期的第一篇周报吧。&lt;/p&gt;
&lt;p&gt;本周主</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是命名空间（namespace）</title>
    <link href="http://example.com/2023/07/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89/"/>
    <id>http://example.com/2023/07/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89/</id>
    <published>2023-07-31T12:02:01.000Z</published>
    <updated>2024-03-01T09:04:47.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想必大家在初学C++时就已经发现了这样一个现象：一些代码前面要加上 <code>std::</code> 或者在头文件后用 <code>using namespce std;</code>来代替。已经学习C++两年的我在最开始发现这一问题时选择了最简单的方法来理解这一现象，那就是“记住就好了，就应该是这样的”。</p><p>直到最近在阅读《程序员的自我修养》这本书的时候又一次看到了 <code>namespace</code> 这一词，这次它以一个全新的名字出现在我的眼前——命名空间。在查询了资料过后，才解开了这个困惑。</p><h1 id="什么是命名空间"><a href="#什么是命名空间" class="headerlink" title="什么是命名空间"></a>什么是命名空间</h1><p>命名空间（Namespace）是编程语言中用于标识符（变量、函数、类、对象等）命名的一种机制，它可以防止命名冲突和提供更好的代码组织方式。在不同的上下文中，同一个名字可能会被用来表示不同的实体，这时候通过命名空间可以区分它们，避免混淆。</p><blockquote><p>我们假设一个C++文件是一个城市，在这个城市里有很多人都叫“张伟”，如果我们除了他们的名字以外对他们没有任何了解，那么当我们叫张伟这个名字时，编译器并不知道是哪一个张伟。更何况我们叫的这个名字，在别的城市（引入的其他头文件）也有。</p><p>为了更好分清楚他们，我们将收集更多关于这些人的个人信息，如家庭住址、年龄、身高、长相等。</p><p>由此引入命名空间这个概念，我们给每一个这样的人限定一定的空间范围，在每次使用时到提前声明他的空间范围是什么，这样编译器就可以分清楚我们要的是哪一个。本质上，命名空间就是定义了一个范围。</p></blockquote><h2 id="如何声明并使用命名空间"><a href="#如何声明并使用命名空间" class="headerlink" title="如何声明并使用命名空间"></a>如何声明并使用命名空间</h2><p>具体示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="comment">// 声明或定义变量、函数、类等实体</span></span><br><span class="line">    <span class="type">int</span> myVariable = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">        <span class="comment">// 类定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名空间中的实体</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyNamespace::<span class="built_in">myFunction</span>();</span><br><span class="line">    <span class="type">int</span> value = MyNamespace::myVariable;</span><br><span class="line">    MyNamespace::MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std;"></a>using namespace std;</h1><p>相信看到这里，一部分人就已经明白这一条代码是什么意思了。这是一个使用命名空间的声明，它的作用是告诉编译器在当前代码范围内使用标准 <strong>C++ 库（std）</strong>的所有实体，而无需在每个标识符前加上 <code>std::</code> 前缀。</p><p>在 C++ 中，<code>std</code> 是标准 C++ 库（Standard Library）的命名空间，它包含了许多有用的函数、类和对象，用于完成各种常见的任务，如输入输出、容器操作、算法处理、字符串处理等等。标准 C++ 库是 C++ 语言的一部分，提供了广泛的功能，使得开发者可以更加高效地编写 C++ 程序。</p><p><code>std</code> 是 C++ 标准库的命名空间，因此库中的所有实体（函数、类、对象等）都被放在这个命名空间下，以避免与用户代码中的其他实体发生命名冲突。</p><p>下面分别展示使用命名空间以及不使用命名空间的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用了std命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的名字：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的名字：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，在代码教程的情况下，使用 <code>using namespace std;</code> 可以少写很多代码。</p><h2 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a>using指令</h2><p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果为：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230731204222913.png" alt="image-20230731204222913"></p><p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p><h2 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h2><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p><p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h2><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123;   <span class="comment">// 代码声明   </span></span><br><span class="line"><span class="keyword">namespace</span> namespace_name2 &#123;      </span><br><span class="line"><span class="comment">// 代码声明   </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过使用 <strong>::</strong> 运算符来访问嵌套的命名空间中的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 namespace_name2 中的成员 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1::namespace_name2;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 namespace_name1 中的成员 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1;</span><br></pre></td></tr></table></figure><p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 第二个命名空间</span></span><br><span class="line">   <span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space::second_space;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>以上便是笔者解决自己疑惑所学到的内容，其中主要内容来自于<a href="https://www.runoob.com/cplusplus/cpp-namespaces.html">菜鸟教程</a>和ChatGPT的回答。本文仅作为笔者自己地思考笔记，希望对你有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想必大家在初学C++时就已经发现了这样一个现象：一些代码前面要加上 &lt;code&gt;std::&lt;/code&gt; 或者在头文件后用 &lt;code&gt;us</summary>
      
    
    
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Bomb Lab</title>
    <link href="http://example.com/2023/04/18/Bomb-Lab/"/>
    <id>http://example.com/2023/04/18/Bomb-Lab/</id>
    <published>2023-04-18T12:52:18.000Z</published>
    <updated>2024-03-01T09:04:59.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是HNU计算机系统课程的第三次实验，实验要求是给一个用C语言编写的可执行文件bomb，你可以看到它主函数的C语言代码，除此之外，一概不知，实验分为六个阶段，每个阶段需要输入一串字符，以此来破译炸弹的密码，如果六次输入的密码都是正确的，则炸弹拆除，否则炸弹爆炸（退出并打印爆炸信息）。为了防止学生互相借鉴，HNU采用了最传统的防作弊方式——让每个学生做不同的题目。这次实验好行并没有什么评分标准，所以可以不断测试自己的答案。</p><h2 id="C语言源代码"><a href="#C语言源代码" class="headerlink" title="C语言源代码"></a>C语言源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 邪恶博士公司(PerPETRATOR)在此授予您(受害者)明确的许可来使用这个炸弹(the BOMB)。</span></span><br><span class="line"><span class="comment"> * 这是一个有时间限制的许可，在受害者死亡后失效。</span></span><br><span class="line"><span class="comment"> * 对于受害者的损害、挫折、精神错乱、虫眼、腕管综合症、失眠或其他伤害，PerPETRATOR不承担任何责任。 </span></span><br><span class="line"><span class="comment"> * 除非 &quot;保护者 &quot;想邀功，也就是说。受害者不得将此炸弹的源代码分发给PERPETRATOR的任何敌人。</span></span><br><span class="line"><span class="comment"> * 受害者不得调试、逆向工程、运行 &quot;字符串&quot;、反编译、解密或使用任何其他技术来获得对炸弹的了解和拆除炸弹。 </span></span><br><span class="line"><span class="comment"> * 在处理本程序时，不得穿戴防弹衣。</span></span><br><span class="line"><span class="comment"> * PERPETRATOR不会为PERPETRATOR的不良幽默感道歉。</span></span><br><span class="line"><span class="comment"> * 在法律禁止使用BOMB的地方，本许可是无效的。</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> * 自我注意： 记得删除这个文件，这样我的受害者就不会知道发生了什么事，</span></span><br><span class="line"><span class="comment"> * 而且他们都会在一场可怕的魔鬼爆炸中被炸死。-- 邪恶博士</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. </span></span><br><span class="line"><span class="comment">     请注意：记得把这个炸弹移植到Windows上，并给它装上一个奇妙的GUI。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. </span></span><br><span class="line"><span class="comment">     当运行时没有参数，炸弹从标准输入中读取其输入行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. </span></span><br><span class="line"><span class="comment">     * 当运行时有一个参数&lt;file&gt;，炸弹从&lt;file&gt;读取，直到EOF，然后切换到标准输入。</span></span><br><span class="line"><span class="comment">     * 因此，当你拆除每个阶段的炸弹时，你可以将其拆除的字符串添加到&lt;file&gt;中，避免重新输入。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. </span></span><br><span class="line"><span class="comment">    你不能用1个以上的命令行参数调用炸弹。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. </span></span><br><span class="line"><span class="comment">    做各种秘密的事情，使炸弹更难拆除。*/</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! </span></span><br><span class="line"><span class="comment">    嗯...  六个阶段一定比一个阶段更安全！！*/</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input       获取输入            */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase        运行阶段      */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!糟了!  他们发现了!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. 让我知道他们是如何做到的。*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">    第二阶段更难。 没有人能够弄清楚</span></span><br><span class="line"><span class="comment">     * how to defuse this... </span></span><br><span class="line"><span class="comment">     如何化解这...*/</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. </span></span><br><span class="line"><span class="comment">     我想到目前为止这太容易了。 一些更复杂的代码会使人们感到困惑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! </span></span><br><span class="line"><span class="comment">    哦，是吗？ 那么，你的数学水平如何？ 试试这个俏皮的问题吧!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! </span></span><br><span class="line"><span class="comment">    我们在记忆中绕来绕去，我们在哪里停下来，炸弹就在哪里爆炸!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. </span></span><br><span class="line"><span class="comment">     这个阶段将永远不会被使用，因为没有人会通过前面的阶段。 </span></span><br><span class="line"><span class="comment">     但为了以防万一，要把这个阶段变得特别难。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! </span></span><br><span class="line"><span class="comment">     哇，他们得到了它!  但是不是有什么东西......不见了？ 也许他们忽略了什么？ Mua ha ha ha!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>本实验使用 WSL2 以及 Ubuntu 20.4 完成，编译器为 VS code。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于实验所给的文件中只有一个bomb.c 和一个可执行文件，而bomb.c 并不能直接编译，因此我们只能通过给出的可执行文件来进行分析。将可执行文件通过反汇编得到完整程序的汇编代码，操作如下：</p><p>建议创建一个文件，并将反汇编出的代码输入到该文件中，方便后续查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; objdump -d &gt; objdump.txt</span><br></pre></td></tr></table></figure><h2 id="实验解析"><a href="#实验解析" class="headerlink" title="实验解析"></a>实验解析</h2><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p><strong>密钥</strong>：The moon unit will be divided into two divisions.</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">08048b60 &lt;phase_1&gt;:</span><br><span class="line"> 8048b60:83 ec 1c             sub    $0x1c,%esp</span><br><span class="line"> 8048b63:c7 44 24 04 c4 a1 04 movl   $0x804a1c4,0x4(%esp)</span><br><span class="line"> 8048b6a:08 </span><br><span class="line"> 8048b6b:8b 44 24 20          mov    0x20(%esp),%eax</span><br><span class="line"> 8048b6f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048b72:e8 6d 04 00 00       call   8048fe4 &lt;strings_not_equal&gt; </span><br><span class="line"> 8048b77:85 c0                test   %eax,%eax</span><br><span class="line"> 8048b79:74 05                je     8048b80 &lt;phase_1+0x20&gt;</span><br><span class="line"> 8048b7b:e8 76 05 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048b80:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048b83:c3                   ret    </span><br></pre></td></tr></table></figure><p><strong>分析如下：</strong></p><p>结合源代码可以得出 <code>0x20(%esp)</code> 对应的是 bomb.c 中 <code>read_line</code>读入的字符串的首地址。</p><p>阅读phase_1的第 2 到第 6行 ，观察到数据 <code>$0x804a1c4</code> 和 <code>0x20(%esp)</code> 均被作为参数传入栈帧中，结合第 7 行的调用 <code>strings_not_equal</code> 函数，可以推测， <code>$0x804a1c4</code> 处存储的也是一个字符串的首地址，并且要与之前读入的字符串进行比较。</p><p>查看 <code>strings_not_equal</code> 函数的汇编代码，得知该函数是用于比较两个字符串是否相等的，若相等则返回0，不相等则返回1，返回值均保存在 <code>%eax</code> 中。</p><p>继续查看下面的汇编代码，其中第 8 到第 10 行可以得出：当 <code>%eax</code> 为 0 时，跳转到 <code>&lt;phase_1+0x20&gt;</code> 处（即跳过炸弹爆炸）；当 <code>%eax</code> 为 1 时，不会发生跳转，此时炸弹爆炸。</p><p>因此我们可以得出结论，当我们输入的字符串与 <code>$0x804a1c4</code> 处存储的字符串<strong>相等</strong>时，就能通过phase_1。</p><p>通过 gdb 调试查看 <code>$0x804a1c4</code> 处存储的字符串：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230417093216100.png" alt="image-20230417093216100"></p><p>通过 gdb 中的 print 命令，打印出来phase_1的通关密钥。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p><strong>密钥：</strong>1 2 4 8 16 32</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">08048b84 &lt;phase_2&gt;:</span><br><span class="line"> 8048b84:56                   push   %esi</span><br><span class="line"> 8048b85:53                   push   %ebx</span><br><span class="line"> 8048b86:83 ec 34             sub    $0x34,%esp</span><br><span class="line"> 8048b89:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048b8d:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048b91:8b 44 24 40          mov    0x40(%esp),%eax</span><br><span class="line"> 8048b95:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048b98:e8 8e 06 00 00       call   804922b &lt;read_six_numbers&gt;</span><br><span class="line"> 8048b9d:83 7c 24 18 01       cmpl   $0x1,0x18(%esp) //0x18(%esp)为第一个数字，且必须为1</span><br><span class="line"> 8048ba2:74 05                je     8048ba9 &lt;phase_2+0x25&gt;</span><br><span class="line"> 8048ba4:e8 4d 05 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ba9:8d 5c 24 1c          lea    0x1c(%esp),%ebx</span><br><span class="line"> 8048bad:8d 74 24 30          lea    0x30(%esp),%esi</span><br><span class="line"> 8048bb1:8b 43 fc             mov    -0x4(%ebx),%eax</span><br><span class="line"> 8048bb4:01 c0                add    %eax,%eax //上一个数字的两倍</span><br><span class="line"> 8048bb6:39 03                cmp    %eax,(%ebx) //第二个数字是第一个数字的两倍，2</span><br><span class="line"> 8048bb8:74 05                je     8048bbf &lt;phase_2+0x3b&gt;</span><br><span class="line"> 8048bba:e8 37 05 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048bbf:83 c3 04             add    $0x4,%ebx</span><br><span class="line"> 8048bc2:39 f3                cmp    %esi,%ebx</span><br><span class="line"> 8048bc4:75 eb                jne    8048bb1 &lt;phase_2+0x2d&gt; //如果当前这个数的下一个数是第6个输入的值，跳出循环</span><br><span class="line"> 8048bc6:83 c4 34             add    $0x34,%esp</span><br><span class="line"> 8048bc9:5b                   pop    %ebx</span><br><span class="line"> 8048bca:5e                   pop    %esi</span><br><span class="line"> 8048bcb:c3                   ret </span><br></pre></td></tr></table></figure><p>可以看到phase_2中调用了一个交 <code>read_six_numbers</code> 的函数，反汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0804922b &lt;read_six_numbers&gt;:</span><br><span class="line"> 804922b:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 804922e:8b 44 24 34          mov    0x34(%esp),%eax</span><br><span class="line"> 8049232:8d 50 14             lea    0x14(%eax),%edx</span><br><span class="line"> 8049235:89 54 24 1c          mov    %edx,0x1c(%esp)</span><br><span class="line"> 8049239:8d 50 10             lea    0x10(%eax),%edx</span><br><span class="line"> 804923c:89 54 24 18          mov    %edx,0x18(%esp)</span><br><span class="line"> 8049240:8d 50 0c             lea    0xc(%eax),%edx</span><br><span class="line"> 8049243:89 54 24 14          mov    %edx,0x14(%esp)</span><br><span class="line"> 8049247:8d 50 08             lea    0x8(%eax),%edx</span><br><span class="line"> 804924a:89 54 24 10          mov    %edx,0x10(%esp)</span><br><span class="line"> 804924e:8d 50 04             lea    0x4(%eax),%edx</span><br><span class="line"> 8049251:89 54 24 0c          mov    %edx,0xc(%esp)</span><br><span class="line"> 8049255:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8049259:c7 44 24 04 d7 a3 04 movl   $0x804a3d7,0x4(%esp)</span><br><span class="line"> 8049260:08 </span><br><span class="line"> 8049261:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8049265:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8049268:e8 03 f6 ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 804926d:83 f8 05             cmp    $0x5,%eax</span><br><span class="line"> 8049270:7f 05                jg     8049277 &lt;read_six_numbers+0x4c&gt;</span><br><span class="line"> 8049272:e8 7f fe ff ff       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8049277:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 804927a:c3                   ret    </span><br></pre></td></tr></table></figure><p>从函数的名字我们也不难猜出该函数的作用，读取 6 个数字。注意到 <code>8049259</code> 这一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8049259:c7 44 24 04 d7 a3 04 movl   $0x804a3d7,0x4(%esp)</span><br></pre></td></tr></table></figure><p>这里在 <code>0x4(%esp)</code> 里存了一个地址，输出一下看看是什么。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230417094147134.png" alt="image-20230417094147134"></p><p>想来这个就是输入函数 sscanf 的格式了，果不其然是输入6个数字。</p><p>已知 <code>read_six_numbers</code> 函数的作用，我们再次回到 phase_2的汇编代码中。第 10 行的 <code>cmpl   $0x1,0x18(%esp)</code>表明第一个数字必须为 1，否则炸弹直接爆炸。</p><p>由第 13 行到第 22 行，我们可以看出，每次将下一个数字的地址给到寄存器 <code>%ebx</code>，将当前数字给到寄存器 <code>%eax</code> ，再将 <code>%eax</code> 中的值做乘 2 处理，最后将  <code>%ebx</code> 地址处的值与 <code>%eax</code> 中的值作比较，相等则继续循环，不等则炸弹爆炸。循环结束的条件是 6 个数字全部比较结束。</p><p>因此输入的 6 个数字应该为：<code>1 2 4 8 16 32</code></p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p><strong>密钥：</strong>0 -418 或 1 -906 或 2 -536 或 3 -639 或 4 0 或 5 -639</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">08048bcc &lt;phase_3&gt;:</span><br><span class="line"> 8048bcc:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048bcf:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048bd3:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048bd7:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048bdb:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048bdf:c7 44 24 04 e3 a3 04 movl   $0x804a3e3,0x4(%esp) //该处地址内容为 &quot;%d %d&quot;，说明调用下一步的函数要输入两个整形</span><br><span class="line"> 8048be6:08 </span><br><span class="line"> 8048be7:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048beb:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048bee:e8 7d fc ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt; //返回值为输入参数的个数，小于2则炸弹爆炸</span><br><span class="line"> 8048bf3:83 f8 01             cmp    $0x1,%eax</span><br><span class="line"> 8048bf6:7f 05                jg     8048bfd &lt;phase_3+0x31&gt;</span><br><span class="line"> 8048bf8:e8 f9 04 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048bfd:83 7c 24 18 07       cmpl   $0x7,0x18(%esp) </span><br><span class="line"> 8048c02:77 64                ja     8048c68 &lt;phase_3+0x9c&gt; //如果第一个参数超过 7 ，则爆炸</span><br><span class="line"> 8048c04:8b 44 24 18          mov    0x18(%esp),%eax</span><br><span class="line"> 8048c08:ff 24 85 20 a2 04 08 jmp    *0x804a220(,%eax,4)</span><br><span class="line"> 8048c0f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c14:eb 05                jmp    8048c1b &lt;phase_3+0x4f&gt;</span><br><span class="line"> 8048c16:b8 e8 01 00 00       mov    $0x1e8,%eax</span><br><span class="line"> 8048c1b:2d 72 01 00 00       sub    $0x172,%eax减172</span><br><span class="line"> 8048c20:eb 05                jmp    8048c27 &lt;phase_3+0x5b&gt;</span><br><span class="line"> 8048c22:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c27:83 c0 67             add    $0x67,%eax加67</span><br><span class="line"> 8048c2a:eb 05                jmp    8048c31 &lt;phase_3+0x65&gt;</span><br><span class="line"> 8048c2c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c31:2d 7f 02 00 00       sub    $0x27f,%eax减27f</span><br><span class="line"> 8048c36:eb 05                jmp    8048c3d &lt;phase_3+0x71&gt;</span><br><span class="line"> 8048c38:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c3d:05 7f 02 00 00       add    $0x27f,%eax加27f</span><br><span class="line"> 8048c42:eb 05                jmp    8048c49 &lt;phase_3+0x7d&gt;</span><br><span class="line"> 8048c44:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c49:2d 7f 02 00 00       sub    $0x27f,%eax减27f</span><br><span class="line"> 8048c4e:eb 05                jmp    8048c55 &lt;phase_3+0x89&gt;</span><br><span class="line"> 8048c50:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c55:05 7f 02 00 00       add    $0x27f,%eax加27f</span><br><span class="line"> 8048c5a:eb 05                jmp    8048c61 &lt;phase_3+0x95&gt;</span><br><span class="line"> 8048c5c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c61:2d 7f 02 00 00       sub    $0x27f,%eax减27f</span><br><span class="line"> 8048c66:eb 0a                jmp    8048c72 &lt;phase_3+0xa6&gt;</span><br><span class="line"> 8048c68:e8 89 04 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c6d:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c72:83 7c 24 18 05       cmpl   $0x5,0x18(%esp) //第一个参数的取值范围为 【0， 5】</span><br><span class="line"> 8048c77:7f 06                jg     8048c7f &lt;phase_3+0xb3&gt;</span><br><span class="line"> 8048c79:3b 44 24 1c          cmp    0x1c(%esp),%eax //第二个参数与 eax作比较，</span><br><span class="line"> 8048c7d:74 05                je     8048c84 &lt;phase_3+0xb8&gt; //相等结束，否则爆炸</span><br><span class="line"> 8048c7f:e8 72 04 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c84:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048c87:c3                   ret    </span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>第 3 ~ 11 行是为scanf函数配置参数以及执行scanf函数的过程，用 print 查看<code>0x804a3e3</code> 中的内容，发现是 <code>&quot;%d %d&quot;</code> ，说明 scanf 读取的是两个整型数字，即密钥是由两个整数组成的。从第 12 行可以看出，当输入的参数个数小于 2 时，炸弹就会爆炸。</p><p>第15 ~ 16行，<code>0x18(%esp)</code>中存储的是输入的第一个数，<code>ja</code> 指令意味着无符号指令的大小比较，可以推断出第一个数的取值范围是[0,7]。</p><p>第 18 行代码是一个变址寻址的地址跳转，跳转的地址为<code>*(0x804a200+(%eax)*4)</code> ，使用 gdb 输出 <code>0x804a200</code> 地址处的 8 个值（因为输入的第一个参数为0~7，合理推测此处最多只有 8 个值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8wx 0x804a220</span><br><span class="line">0x804a220:      0x08048c16      0x08048c0f      0x08048c22      0x08048c2c</span><br><span class="line">0x804a230:      0x08048c38      0x08048c44      0x08048c50      0x08048c5c</span><br></pre></td></tr></table></figure><p>可以看出，<code>0x804a220</code>之后存储的 8 个值都是要跳转的地址。跳转后就会执行各种加或减的操作。一系列操作后，第44 ~ 45行代码又将第一个参数的取值范围缩小至[0,5]。第46 ~ 47行代码则是将操作后得到的数与我们输入的第二个参数相比较，相等则函数结束，不相等则炸弹爆炸。</p><p>因此要得出所有的答案，只需要在第18行跳转完成后计算出加减操作得到的最后的值，就是我们要输入的第二个数。</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p><strong>密钥：</strong>11 18</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">08048cf1 &lt;phase_4&gt;:</span><br><span class="line"> 8048cf1:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048cf4:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048cf8:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048cfc:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048d00:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d04:c7 44 24 04 e3 a3 04 movl   $0x804a3e3,0x4(%esp)</span><br><span class="line"> 8048d0b:08 </span><br><span class="line"> 8048d0c:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048d10:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048d13:e8 58 fb ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 8048d18:83 f8 02             cmp    $0x2,%eax</span><br><span class="line"> 8048d1b:75 0d                jne    8048d2a &lt;phase_4+0x39&gt; //输入参数不等于2时，炸弹爆炸</span><br><span class="line"> 8048d1d:8b 44 24 18          mov    0x18(%esp),%eax  //第一个参数</span><br><span class="line"> 8048d21:85 c0                test   %eax,%eax  //</span><br><span class="line"> 8048d23:78 05                js     8048d2a &lt;phase_4+0x39&gt; //第一个参数为负数时，炸弹爆炸</span><br><span class="line"> 8048d25:83 f8 0e             cmp    $0xe,%eax </span><br><span class="line"> 8048d28:7e 05                jle    8048d2f &lt;phase_4+0x3e&gt; //eax（第一个参数）应该小于等于 14，否则爆炸</span><br><span class="line"> 8048d2a:e8 c7 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d2f:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp) 调用函数func，第三个参数是 14，第二个参数是 0，第一个参数为输入的第一个值</span><br><span class="line"> 8048d36:00 </span><br><span class="line"> 8048d37:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp) </span><br><span class="line"> 8048d3e:00 </span><br><span class="line"> 8048d3f:8b 44 24 18          mov    0x18(%esp),%eax </span><br><span class="line"> 8048d43:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048d46:e8 3d ff ff ff       call   8048c88 &lt;func4&gt;</span><br><span class="line"> 8048d4b:83 f8 12             cmp    $0x12,%eax//比较返回值与18的大小，返回值不等于18，则炸弹爆炸</span><br><span class="line"> 8048d4e:75 07                jne    8048d57 &lt;phase_4+0x66&gt;</span><br><span class="line"> 8048d50:83 7c 24 1c 12       cmpl   $0x12,0x1c(%esp) //比较第二个输入值与18的大小，不等于则炸弹爆炸</span><br><span class="line"> 8048d55:74 05                je     8048d5c &lt;phase_4+0x6b&gt;</span><br><span class="line"> 8048d57:e8 9a 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d5c:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048d5f:c3                   ret </span><br></pre></td></tr></table></figure><p>有第 7 行的 <code>0x804a3e3</code>地址处所存的内容以及第 12 行将 scanf 函数的返回值与 2 作比较，可以得出输入的是两个参数，且参数类型为整形。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230422153859139.png" alt="image-20230422153859139"></p><p>由第 14 ~ 18 行分析可得，输入的第一个参数的取值范围应该是 [0, 14]。第 20 ~ 26 行，主函数调用 func4 函数，并将(x, 0, 14)作为函数的三个参数传入(x 表示我们输入的第一个参数)。以下是 <code>func4</code> 函数的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">08048c88 &lt;func4&gt;:A</span><br><span class="line"> 8048c88:83 ec 1c             sub    $0x1c,%esp</span><br><span class="line"> 8048c8b:89 5c 24 14          mov    %ebx,0x14(%esp)</span><br><span class="line"> 8048c8f:89 74 24 18          mov    %esi,0x18(%esp)</span><br><span class="line"> 8048c93:8b 44 24 20          mov    0x20(%esp),%eax//a = x</span><br><span class="line"> 8048c97:8b 54 24 24          mov    0x24(%esp),%edx//b = 0</span><br><span class="line"> 8048c9b:8b 74 24 28          mov    0x28(%esp),%esi//c = 14</span><br><span class="line"> 8048c9f:89 f1                mov    %esi,%ecx</span><br><span class="line"> 8048ca1:29 d1                sub    %edx,%ecx//d = c - b</span><br><span class="line"> 8048ca3:89 cb                mov    %ecx,%ebx</span><br><span class="line"> 8048ca5:c1 eb 1f             shr    $0x1f,%ebx//d进行逻辑右移31位，取出其符号位，e = d&gt;&gt;31</span><br><span class="line"> 8048ca8:01 d9                add    %ebx,%ecx//d = d + e </span><br><span class="line"> 8048caa:d1 f9                sar    %ecx//对d进行符号位拓展</span><br><span class="line"> 8048cac:8d 1c 11             lea    (%ecx,%edx,1),%ebx//f = (b + d)</span><br><span class="line"> 8048caf:39 c3                cmp    %eax,%ebx//比较f与a的大小</span><br><span class="line"> 8048cb1:7e 17                jle    8048cca &lt;func4+0x42&gt; //如果 f &lt;= a 则发生跳转</span><br><span class="line"> 8048cb3:8d 4b ff             lea    -0x1(%ebx),%ecx//f - 1 -&gt; ecx</span><br><span class="line"> 8048cb6:89 4c 24 08          mov    %ecx,0x8(%esp)//f-1 为第三个参数</span><br><span class="line"> 8048cba:89 54 24 04          mov    %edx,0x4(%esp)//b 为第二个参数</span><br><span class="line"> 8048cbe:89 04 24             mov    %eax,(%esp)//a 为第一个参数</span><br><span class="line"> 8048cc1:e8 c2 ff ff ff       call   8048c88 &lt;func4&gt;</span><br><span class="line"> 8048cc6:01 c3                add    %eax,%ebx//eax保存func4的返回值</span><br><span class="line"> 8048cc8:eb 19                jmp    8048ce3 &lt;func4+0x5b&gt;</span><br><span class="line"> 8048cca:39 c3                cmp    %eax,%ebx</span><br><span class="line"> 8048ccc:7d 15                jge    8048ce3 &lt;func4+0x5b&gt;//如果 f &gt;= a 发生跳转</span><br><span class="line"> 8048cce:89 74 24 08          mov    %esi,0x8(%esp)</span><br><span class="line"> 8048cd2:8d 53 01             lea    0x1(%ebx),%edx</span><br><span class="line"> 8048cd5:89 54 24 04          mov    %edx,0x4(%esp)</span><br><span class="line"> 8048cd9:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048cdc:e8 a7 ff ff ff       call   8048c88 &lt;func4&gt;</span><br><span class="line"> 8048ce1:01 c3                add    %eax,%ebx</span><br><span class="line"> 8048ce3:89 d8                mov    %ebx,%eax</span><br><span class="line"> 8048ce5:8b 5c 24 14          mov    0x14(%esp),%ebx</span><br><span class="line"> 8048ce9:8b 74 24 18          mov    0x18(%esp),%esi</span><br><span class="line"> 8048ced:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048cf0:c3                   ret</span><br></pre></td></tr></table></figure><p>这个函数有点绕，大概是做一个二分，具体的内容写在注释里，自己可以用笔模拟下这个函数在干嘛，可以推断出C语言代码大致如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line"><span class="type">int</span> d = c - b;</span><br><span class="line"><span class="type">int</span> e = (d &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">d = (d + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f = b + d;</span><br><span class="line"><span class="keyword">if</span>(a &lt; f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> g = func4(a, b, f<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> g = func4(a , f+<span class="number">1</span>, c);</span><br><span class="line"><span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>func4</code> 函数中返回后，第 27 行代码将函数的返回值与 <code>0x12</code> 作比较，不相等时炸弹直接爆炸，相等则继续下面的判断。第 29 行代码显示将输入的第二个值与 <code>0x12</code> 作比较，当不相等时发生爆炸，相等则安全退出函数。由推断出的 <code>func4</code> 的C语言代码可尝试在输入[0, 14]时，函数的不同返回值。只有当输入值为 11 时，返回值才是18，即与 <code>0x12</code> 相等。由此便可推出密钥为 <code>11 18</code>。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p><strong>密钥：</strong>bcejno 或 cdeijn 或 cejlmn（只列出了极少的情况，全部可能应该有几万种可能）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">08048d60 &lt;phase_5&gt;:</span><br><span class="line"> 8048d60:53                   push   %ebx</span><br><span class="line"> 8048d61:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048d64:8b 5c 24 20          mov    0x20(%esp),%ebx</span><br><span class="line"> 8048d68:89 1c 24             mov    %ebx,(%esp)</span><br><span class="line"> 8048d6b:e8 5b 02 00 00       call   8048fcb &lt;string_length&gt;//获取输入字符串的长度</span><br><span class="line"> 8048d70:83 f8 06             cmp    $0x6,%eax </span><br><span class="line"> 8048d73:74 05                je     8048d7a &lt;phase_5+0x1a&gt; //输入字符串的长度不等于 6 ，炸弹爆炸</span><br><span class="line"> 8048d75:e8 7c 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d7a:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line"> 8048d7f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048d84:0f be 0c 03          movsbl (%ebx,%eax,1),%ecx</span><br><span class="line"> 8048d88:83 e1 0f             and    $0xf,%ecx</span><br><span class="line"> 8048d8b:03 14 8d 40 a2 04 08 add    0x804a240(,%ecx,4),%edx</span><br><span class="line"> 8048d92:83 c0 01             add    $0x1,%eax</span><br><span class="line"> 8048d95:83 f8 06             cmp    $0x6,%eax</span><br><span class="line"> 8048d98:75 ea                jne    8048d84 &lt;phase_5+0x24&gt;</span><br><span class="line"> 8048d9a:83 fa 41             cmp    $0x41,%edx</span><br><span class="line"> 8048d9d:74 05                je     8048da4 &lt;phase_5+0x44&gt;</span><br><span class="line"> 8048d9f:e8 52 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048da4:83 c4 18             add    $0x18,%esp</span><br><span class="line"> 8048da7:5b                   pop    %ebx</span><br><span class="line"> 8048da8:c3                   ret</span><br></pre></td></tr></table></figure><p>分析前 8 行代码可知，输入值为一个字符串，且长度一定要是 6，否则炸弹直接爆炸。接下来就是一个循环结构，遍历输入的字符串，并将当前遍历的字节与 <code>oxf</code> 相与得到一个值，得到的值将作为首地址在 <code>0x804a240</code> 处的整数数组的下标，并将访问的值进行累加，若和为 <code>0x41</code> ，则该字符串就是密钥，否则炸弹爆炸。下面是该函数的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">6</span>] = 输入的字符串</span><br><span class="line"><span class="type">int</span> a[<span class="number">16</span>] = 首地址在<span class="number">0x804a220</span>处的数组，由于和<span class="number">0xf</span>相与，故下标最大值为<span class="number">15</span>，数组长度为<span class="number">16</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//累加和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos = (<span class="type">int</span>)s[i] &amp; <span class="number">0xf</span>;</span><br><span class="line">    sum += a[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum != <span class="number">0x41</span>)</span><br><span class="line">    explode_bomb();</span><br></pre></td></tr></table></figure><p>查看 <code>0x804a240</code> 地址处的长度为 16 的整数数组的全部值：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230409222538168.png" alt="image-20230409222538168"></p><p>每个整数值对应的字母大小写如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x804a240 &lt;array.2999&gt;: 2-p\P       10-a\q\A\Q      6-b\r\B\Q       1-c\s\C\S</span><br><span class="line">0x804a250 &lt;array.2999+16&gt;:      12-d\t\D\T      16-E\U\e\u      9-F\V\f\v       3-g\w\G\W</span><br><span class="line">0x804a260 &lt;array.2999+32&gt;:      4-H\X\h\x       7-I\Y\i\y       14-j\z\J\Z      5-k\K</span><br><span class="line">0x804a270 &lt;array.2999+48&gt;:      11-L\l      8-M\m       15-N\n      13-o\O</span><br></pre></td></tr></table></figure><p>全部不重复的情况如下（没有任何参考价值，尽量不要尝试算出所有的情况）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">[1, 6, 13, 14, 15, 16], </span><br><span class="line">[1, 7, 12, 14, 15, 16],</span><br><span class="line">[1, 8, 11, 14, 15, 16],</span><br><span class="line">[1, 8, 12, 13, 15, 16], </span><br><span class="line">[1, 9, 10, 14, 15, 16], </span><br><span class="line">[1, 9, 11, 13, 15, 16], </span><br><span class="line">[1, 9, 12, 13, 14, 16], </span><br><span class="line">[1, 10, 11, 12, 15, 16], </span><br><span class="line">[1, 10, 11, 13, 14, 16],</span><br><span class="line">[1, 10, 12, 13, 14, 15], </span><br><span class="line">[2, 5, 13, 14, 15, 16], </span><br><span class="line">[2, 6, 12, 14, 15, 16], </span><br><span class="line">[2, 7, 11, 14, 15, 16], </span><br><span class="line">[2, 7, 12, 13, 15, 16], </span><br><span class="line">[2, 8, 10, 14, 15, 16], </span><br><span class="line">[2, 8, 11, 13, 15, 16], </span><br><span class="line">[2, 8, 12, 13, 14, 16], </span><br><span class="line">[2, 9, 10, 13, 15, 16], </span><br><span class="line">[2, 9, 11, 12, 15, 16], </span><br><span class="line">[2, 9, 11, 13, 14, 16], </span><br><span class="line">[2, 9, 12, 13, 14, 15], </span><br><span class="line">[2, 10, 11, 12, 14, 16],</span><br><span class="line">[2, 10, 11, 13, 14, 15],</span><br><span class="line">[3, 4, 13, 14, 15, 16], </span><br><span class="line">[3, 5, 12, 14, 15, 16], </span><br><span class="line">[3, 6, 11, 14, 15, 16], </span><br><span class="line">[3, 6, 12, 13, 15, 16], </span><br><span class="line">[3, 7, 10, 14, 15, 16], </span><br><span class="line">[3, 7, 11, 13, 15, 16], </span><br><span class="line">[3, 7, 12, 13, 14, 16], </span><br><span class="line">[3, 8, 9, 14, 15, 16], </span><br><span class="line">[3, 8, 10, 13, 15, 16],</span><br><span class="line">[3, 8, 11, 12, 15, 16],</span><br><span class="line">[3, 8, 11, 13, 14, 16],</span><br><span class="line">[3, 8, 12, 13, 14, 15], </span><br><span class="line">[3, 9, 10, 12, 15, 16], </span><br><span class="line">[3, 9, 10, 13, 14, 16], </span><br><span class="line">[3, 9, 11, 12, 14, 16],</span><br><span class="line">[3, 9, 11, 13, 14, 15], </span><br><span class="line">[3, 10, 11, 12, 13, 16],</span><br><span class="line">[3, 10, 11, 12, 14, 15],</span><br><span class="line">[4, 5, 11, 14, 15, 16], </span><br><span class="line">[4, 5, 12, 13, 15, 16],</span><br><span class="line">[4, 6, 10, 14, 15, 16],</span><br><span class="line">[4, 6, 11, 13, 15, 16],</span><br><span class="line">[4, 6, 12, 13, 14, 16], </span><br><span class="line">[4, 7, 9, 14, 15, 16], </span><br><span class="line">[4, 7, 10, 13, 15, 16],</span><br><span class="line">[4, 7, 11, 12, 15, 16], </span><br><span class="line">[4, 7, 11, 13, 14, 16],</span><br><span class="line">[4, 7, 12, 13, 14, 15], </span><br><span class="line">[4, 8, 9, 13, 15, 16], </span><br><span class="line">[4, 8, 10, 12, 15, 16],</span><br><span class="line">[4, 8, 10, 13, 14, 16],</span><br><span class="line">[4, 8, 11, 12, 14, 16], </span><br><span class="line">[4, 8, 11, 13, 14, 15],</span><br><span class="line">[4, 9, 10, 11, 15, 16], </span><br><span class="line">[4, 9, 10, 12, 14, 16], </span><br><span class="line">[4, 9, 10, 13, 14, 15],</span><br><span class="line">[4, 9, 11, 12, 13, 16],</span><br><span class="line">[4, 9, 11, 12, 14, 15], </span><br><span class="line">[4, 10, 11, 12, 13, 15],</span><br><span class="line">[5, 6, 9, 14, 15, 16], </span><br><span class="line">[5, 6, 10, 13, 15, 16],</span><br><span class="line">[5, 6, 11, 12, 15, 16], </span><br><span class="line">[5, 6, 11, 13, 14, 16], </span><br><span class="line">[5, 6, 12, 13, 14, 15], </span><br><span class="line">[5, 7, 8, 14, 15, 16], </span><br><span class="line">[5, 7, 9, 13, 15, 16], </span><br><span class="line">[5, 7, 10, 12, 15, 16], </span><br><span class="line">[5, 7, 10, 13, 14, 16], </span><br><span class="line">[5, 7, 11, 12, 14, 16], </span><br><span class="line">[5, 7, 11, 13, 14, 15], </span><br><span class="line">[5, 8, 9, 12, 15, 16], </span><br><span class="line">[5, 8, 9, 13, 14, 16],</span><br><span class="line">[5, 8, 10, 11, 15, 16],</span><br><span class="line">[5, 8, 10, 12, 14, 16],</span><br><span class="line">[5, 8, 10, 13, 14, 15],</span><br><span class="line">[5, 8, 11, 12, 13, 16], </span><br><span class="line">[5, 8, 11, 12, 14, 15],</span><br><span class="line">[5, 9, 10, 11, 14, 16], </span><br><span class="line">[5, 9, 10, 12, 13, 16],</span><br><span class="line">[5, 9, 10, 12, 14, 15],</span><br><span class="line">[5, 9, 11, 12, 13, 15], </span><br><span class="line">[5, 10, 11, 12, 13, 14],</span><br><span class="line">[6, 7, 8, 13, 15, 16], </span><br><span class="line">[6, 7, 9, 12, 15, 16], </span><br><span class="line">[6, 7, 9, 13, 14, 16],</span><br><span class="line">[6, 7, 10, 11, 15, 16],</span><br><span class="line">[6, 7, 10, 12, 14, 16],</span><br><span class="line">[6, 7, 10, 13, 14, 15],</span><br><span class="line">[6, 7, 11, 12, 13, 16], </span><br><span class="line">[6, 7, 11, 12, 14, 15],</span><br><span class="line">[6, 8, 9, 11, 15, 16], </span><br><span class="line">[6, 8, 9, 12, 14, 16],</span><br><span class="line">[6, 8, 9, 13, 14, 15], </span><br><span class="line">[6, 8, 10, 11, 14, 16], </span><br><span class="line">[6, 8, 10, 12, 13, 16], </span><br><span class="line">[6, 8, 10, 12, 14, 15], </span><br><span class="line">[6, 8, 11, 12, 13, 15],</span><br><span class="line">[6, 9, 10, 11, 13, 16], </span><br><span class="line">[6, 9, 10, 11, 14, 15], </span><br><span class="line">[6, 9, 10, 12, 13, 15], </span><br><span class="line">[6, 9, 11, 12, 13, 14], </span><br><span class="line">[7, 8, 9, 10, 15, 16], </span><br><span class="line">[7, 8, 9, 11, 14, 16],</span><br><span class="line">[7, 8, 9, 12, 13, 16], </span><br><span class="line">[7, 8, 9, 12, 14, 15], </span><br><span class="line">[7, 8, 10, 11, 13, 16],</span><br><span class="line">[7, 8, 10, 11, 14, 15], </span><br><span class="line">[7, 8, 10, 12, 13, 15], </span><br><span class="line">[7, 8, 11, 12, 13, 14], </span><br><span class="line">[7, 9, 10, 11, 12, 16], </span><br><span class="line">[7, 9, 10, 11, 13, 15], </span><br><span class="line">[7, 9, 10, 12, 13, 14], </span><br><span class="line">[8, 9, 10, 11, 12, 15], </span><br><span class="line">[8, 9, 10, 11, 13, 14]</span><br><span class="line"></span><br><span class="line">一共有117种可能</span><br></pre></td></tr></table></figure><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p><strong>密钥：</strong>4 2 3 6 5 1 或 4 2 6 3 5 1</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">08048da9 &lt;phase_6&gt;:</span><br><span class="line"> 8048da9:56                   push   %esi</span><br><span class="line"> 8048daa:53                   push   %ebx</span><br><span class="line"> 8048dab:83 ec 44             sub    $0x44,%esp</span><br><span class="line"> 8048dae:8d 44 24 10          lea    0x10(%esp),%eax</span><br><span class="line"> 8048db2:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048db6:8b 44 24 50          mov    0x50(%esp),%eax</span><br><span class="line"> 8048dba:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048dbd:e8 69 04 00 00       call   804922b &lt;read_six_numbers&gt;</span><br><span class="line"> 8048dc2:be 00 00 00 00       mov    $0x0,%esi/* </span><br><span class="line"> 8048dc7:8b 44 b4 10          mov    0x10(%esp,%esi,4),%eax</span><br><span class="line"> 8048dcb:83 e8 01             sub    $0x1,%eax</span><br><span class="line"> 8048dce:83 f8 05             cmp    $0x5,%eax </span><br><span class="line"> 8048dd1:76 05                jbe    8048dd8 &lt;phase_6+0x2f&gt;</span><br><span class="line"> 8048dd3:e8 1e 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd8:83 c6 01             add    $0x1,%esi</span><br><span class="line"> 8048ddb:83 fe 06             cmp    $0x6,%esi</span><br><span class="line"> 8048dde:74 33                je     8048e13 &lt;phase_6+0x6a&gt; </span><br><span class="line"> 8048de0:89 f3                mov    %esi,%ebx</span><br><span class="line"> 8048de2:8b 44 9c 10          mov    0x10(%esp,%ebx,4),%eax6个数字都要小于等于6，并且大于等于1</span><br><span class="line"> 8048de6:39 44 b4 0c          cmp    %eax,0xc(%esp,%esi,4) 且不能两两相等</span><br><span class="line"> 8048dea:75 05                jne    8048df1 &lt;phase_6+0x48&gt;否则炸弹爆炸</span><br><span class="line"> 8048dec:e8 05 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048df1:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8048df4:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line"> 8048df7:7e e9                jle    8048de2 &lt;phase_6+0x39&gt; </span><br><span class="line"> 8048df9:eb cc                jmp    8048dc7 &lt;phase_6+0x1e&gt;*/</span><br><span class="line"> 8048dfb:8b 52 08             mov    0x8(%edx),%edx</span><br><span class="line"> 8048dfe:83 c0 01             add    $0x1,%eax</span><br><span class="line"> 8048e01:39 c8                cmp    %ecx,%eax//使ecx的值与输入值相等</span><br><span class="line"> 8048e03:75 f6                jne    8048dfb &lt;phase_6+0x52&gt;</span><br><span class="line"> 8048e05:89 54 b4 28          mov    %edx,0x28(%esp,%esi,4)</span><br><span class="line"> 8048e09:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8048e0c:83 fb 06             cmp    $0x6,%ebx</span><br><span class="line"> 8048e0f:75 07                jne    8048e18 &lt;phase_6+0x6f&gt;</span><br><span class="line"> 8048e11:eb 1c                jmp    8048e2f &lt;phase_6+0x86&gt;</span><br><span class="line"> 8048e13:bb 00 00 00 00       mov    $0x0,%ebx</span><br><span class="line"> 8048e18:89 de                mov    %ebx,%esi</span><br><span class="line"> 8048e1a:8b 4c 9c 10          mov    0x10(%esp,%ebx,4),%ecx</span><br><span class="line"> 8048e1e:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 8048e23:ba 3c c1 04 08       mov    $0x804c13c,%edx</span><br><span class="line"> 8048e28:83 f9 01             cmp    $0x1,%ecx //输入的数字大于 1 发生跳转</span><br><span class="line"> 8048e2b:7f ce                jg     8048dfb &lt;phase_6+0x52&gt;</span><br><span class="line"> 8048e2d:eb d6                jmp    8048e05 &lt;phase_6+0x5c&gt;</span><br><span class="line"> 8048e2f:8b 5c 24 28          mov    0x28(%esp),%ebx j0 -&gt; ebx</span><br><span class="line"> 8048e33:8b 44 24 2c          mov    0x2c(%esp),%eaxj1 -&gt; eax</span><br><span class="line"> 8048e37:89 43 08             mov    %eax,0x8(%ebx)j1 -&gt; ebx+8</span><br><span class="line"> 8048e3a:8b 54 24 30          mov    0x30(%esp),%edxj2 -&gt; edx</span><br><span class="line"> 8048e3e:89 50 08             mov    %edx,0x8(%eax)j2 -&gt; eax+8</span><br><span class="line"> 8048e41:8b 44 24 34          mov    0x34(%esp),%eaxj3 -&gt; eax</span><br><span class="line"> 8048e45:89 42 08             mov    %eax,0x8(%edx)j3 -&gt; edx+8</span><br><span class="line"> 8048e48:8b 54 24 38          mov    0x38(%esp),%edxj4 -&gt; edx</span><br><span class="line"> 8048e4c:89 50 08             mov    %edx,0x8(%eax)j4 -&gt; eax+8</span><br><span class="line"> 8048e4f:8b 44 24 3c          mov    0x3c(%esp),%eaxj5 -&gt; eax</span><br><span class="line"> 8048e53:89 42 08             mov    %eax,0x8(%edx)j5 -&gt; edx+8</span><br><span class="line"> 8048e56:c7 40 08 00 00 00 00 movl   $0x0,0x8(%eax)0 -&gt; eax+8</span><br><span class="line"> 8048e5d:be 05 00 00 00       mov    $0x5,%esiesi = 5</span><br><span class="line"> 8048e62:8b 43 08             mov    0x8(%ebx),%eaxeax = j1</span><br><span class="line"> 8048e65:8b 10                mov    (%eax),%edx </span><br><span class="line"> 8048e67:39 13                cmp    %edx,(%ebx)j1与j0比较 </span><br><span class="line"> 8048e69:7d 05                jge    8048e70 &lt;phase_6+0xc7&gt;</span><br><span class="line"> 8048e6b:e8 86 02 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e70:8b 5b 08             mov    0x8(%ebx),%ebx</span><br><span class="line"> 8048e73:83 ee 01             sub    $0x1,%esi</span><br><span class="line"> 8048e76:75 ea                jne    8048e62 &lt;phase_6+0xb9&gt;</span><br><span class="line"> 8048e78:83 c4 44             add    $0x44,%esp</span><br><span class="line"> 8048e7b:5b                   pop    %ebx</span><br><span class="line"> 8048e7c:5e                   pop    %esi</span><br><span class="line"> 8048e7d:c3                   ret </span><br></pre></td></tr></table></figure><p>由第 9 行代码可以得出我们一共输入 6 个整型数字。分析后面的代码可得，输入的 6 个值的取值范围为[1, 6]，且不能两两相等。第 28 ~ 44 行是一个循环结构，用于比较当前数字与后一个数字的大小，前一个数一定不能小于后一个数，否则炸弹直接爆炸。其中要进行比较的数组为以 <code>0x804c13c</code> 为首地址的数组。</p><p>但是在输出该地址的内容后，发现这并不是一个数组，而是一个结构体，每个结构体中有3个元素，一个记录数值、一个记录node编号，一个存放下一个node的地址（可以把node理解为链表），共占12个字节。</p><p>存储node的方式是：按照读入的6个数（假定为a[i]），将编号为a[i]的node存储到第i个位置。然后从栈帧中的存储的第一个node开始，每个node与其后一个node中的数值进行比较，若后大于前，则会引爆炸弹。以下是打印出的 6 个node的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x804c13c &lt;node1&gt;:    99      1       134529352       </span><br><span class="line">0x804c148 &lt;node2&gt;:    476  2       134529364       </span><br><span class="line">0x804c154 &lt;node3&gt;:    208     3  134529376       </span><br><span class="line">0x804c160 &lt;node4&gt;:    740     4       134529388  </span><br><span class="line">0x804c16c &lt;node5&gt;:  135     5       134529400       </span><br><span class="line">0x804c178 &lt;node6&gt;:    208  6                   </span><br></pre></td></tr></table></figure><p>由此可以的出密钥应该是 4 2 3 6 5 1 或 4 2 6 3 5 1（因为6 与 3中的值是相等的，所以可以调换顺序）。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>至此，我们以及得出了六个关卡的正确密钥，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The moon unit will be divided into two divisions.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">4 0</span><br><span class="line">11 18</span><br><span class="line">bcejno</span><br><span class="line">4 2 3 6 5 1</span><br></pre></td></tr></table></figure><p>输入以上六个密钥，便可拆除炸弹。</p><p>但是，不知道你有没有注意到在该程序的源代码中的结尾处有一行注释，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span><br><span class="line">     * something they overlooked?  Mua ha ha ha ha! </span><br><span class="line">     哇，他们得到了它!  但是不是有什么东西......不见了？ 也许他们忽略了什么？ Mua ha ha ha!</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><p>这就十分可疑，再结合源代码中每个关卡在输出正确答案提示之前都调用了同一个函数——<code>phase_defused();</code>，下面的这个部分就是探寻隐藏关卡的部分。</p><h3 id="隐藏关卡"><a href="#隐藏关卡" class="headerlink" title="隐藏关卡"></a>隐藏关卡</h3><p><strong>密钥：</strong> 107</p><p><code>phase_defused</code>函数的反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">0804927b &lt;phase_defused&gt;:</span><br><span class="line"> 804927b:81 ec 8c 00 00 00    sub    $0x8c,%esp</span><br><span class="line"> 8049281:65 a1 14 00 00 00    mov    %gs:0x14,%eax</span><br><span class="line"> 8049287:89 44 24 7c          mov    %eax,0x7c(%esp)</span><br><span class="line"> 804928b:31 c0                xor    %eax,%eax</span><br><span class="line"> 804928d:83 3d cc c3 04 08 06 cmpl   $0x6,0x804c3cc //该地址处存储的是通过的个数，如果没有全部通过，则不会进入隐藏关卡</span><br><span class="line"> 8049294:75 72                jne    8049308 &lt;phase_defused+0x8d&gt;</span><br><span class="line"> 8049296:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line"> 804929a:89 44 24 10          mov    %eax,0x10(%esp)//第一个参数</span><br><span class="line"> 804929e:8d 44 24 28          lea    0x28(%esp),%eax</span><br><span class="line"> 80492a2:89 44 24 0c          mov    %eax,0xc(%esp)//第二个参数</span><br><span class="line"> 80492a6:8d 44 24 24          lea    0x24(%esp),%eax</span><br><span class="line"> 80492aa:89 44 24 08          mov    %eax,0x8(%esp)//第三个参数</span><br><span class="line"> 80492ae:c7 44 24 04 e9 a3 04 movl   $0x804a3e9,0x4(%esp) //0x804a3e9 &quot;%d %d %s&quot;,输入参数为两个整形个一个字符串，只有第三关和第四关符合条件，测试后应该是在第四关输入特殊字符串，进入隐藏关卡</span><br><span class="line"> 80492b5:08 </span><br><span class="line"> 80492b6:c7 04 24 d0 c4 04 08 movl   $0x804c4d0,(%esp)</span><br><span class="line"> 80492bd:e8 ae f5 ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 80492c2:83 f8 03             cmp    $0x3,%eax//输入参数一定要是3个，否则退出函数</span><br><span class="line"> 80492c5:75 35                jne    80492fc &lt;phase_defused+0x81&gt;</span><br><span class="line"> 80492c7:c7 44 24 04 f2 a3 04 movl   $0x804a3f2,0x4(%esp) //0x804a3f2:      &quot;DrEvil&quot;</span><br><span class="line"> 80492ce:08 </span><br><span class="line"> 80492cf:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line"> 80492d3:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 80492d6:e8 09 fd ff ff       call   8048fe4 &lt;strings_not_equal&gt;//调用比较字符串的函数，说明该地址处的字符串有关键作用</span><br><span class="line"> 80492db:85 c0                test   %eax,%eax//eax为0表示两个字符串相等，否则不相等</span><br><span class="line"> 80492dd:75 1d                jne    80492fc &lt;phase_defused+0x81&gt;</span><br><span class="line"> 80492df:c7 04 24 b8 a2 04 08 movl   $0x804a2b8,(%esp) //0x804a2b8:      &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line"> 80492e6:e8 15 f5 ff ff       call   8048800 &lt;puts@plt&gt; //输出字符串</span><br><span class="line"> 80492eb:c7 04 24 e0 a2 04 08 movl   $0x804a2e0,(%esp) //0x804a2e0:      &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line"> 80492f2:e8 09 f5 ff ff       call   8048800 &lt;puts@plt&gt; //输出字符串</span><br><span class="line"> 80492f7:e8 d3 fb ff ff       call   8048ecf &lt;secret_phase&gt; //进入隐藏关卡</span><br><span class="line"> 80492fc:c7 04 24 18 a3 04 08 movl   $0x804a318,(%esp) //0x804a318:      &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line"> 8049303:e8 f8 f4 ff ff       call   8048800 &lt;puts@plt&gt;//输出字符串</span><br><span class="line"> 8049308:8b 44 24 7c          mov    0x7c(%esp),%eax</span><br><span class="line"> 804930c:65 33 05 14 00 00 00 xor    %gs:0x14,%eax</span><br><span class="line"> 8049313:74 05                je     804931a &lt;phase_defused+0x9f&gt;</span><br><span class="line"> 8049315:e8 b6 f4 ff ff       call   80487d0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> 804931a:81 c4 8c 00 00 00    add    $0x8c,%esp</span><br><span class="line"> 8049320:c3                   ret    </span><br><span class="line"> 8049321:90                   nop</span><br><span class="line"> 8049322:90                   nop</span><br><span class="line"> 8049323:90                   nop</span><br><span class="line"> 8049324:90                   nop</span><br><span class="line"> 8049325:90                   nop</span><br><span class="line"> 8049326:90                   nop</span><br><span class="line"> 8049327:90                   nop</span><br><span class="line"> 8049328:90                   nop</span><br><span class="line"> 8049329:90                   nop</span><br><span class="line"> 804932a:90                   nop</span><br><span class="line"> 804932b:90                   nop</span><br><span class="line"> 804932c:90                   nop</span><br><span class="line"> 804932d:90                   nop</span><br><span class="line"> 804932e:90                   nop</span><br><span class="line"> 804932f:90                   nop</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>在找到 <code>phase_defused</code> 函数的反汇编之后，不难找到几个有助于我们分析关键部分，如下：</p><ul><li>第 6 行将地址 <code>0x804c3cc</code> 处的值与 6 作比较；</li><li>第 8 ~ 18 行调用 <code>__isoc99_sscanf@plt</code> 函数，其中第 14 和第 18 行为分析的关键点；</li><li>第 20 行将 <code>0x804a3f2</code> 地址处的值传给寄存器；</li><li>第 24 行调用比较字符串函数；</li><li>第 27 ~ 30 行输出两次地址中的值；</li><li>第 31 行调用名为 <code>secret_phase</code> 的函数；</li><li>第 32 ~ 33 行输出地址 <code>0x804a318</code> 中的值。</li></ul><p>根据以上关键点，我们可以得出以下结论：</p><ul><li><p>第 6 行， 地址 <code>0x804c3cc</code> 中的值应该是当前通过的数目，只有通关数为 6 时才迈出了进入隐藏关卡的第一步；</p></li><li><p>第 8 ~ 18 行，调用输入函数，且由第 18 行得知输入的参数的个数应该是 3 个；由第 14 行可知，三个参数的类型为前两个是整形，第三个是字符串类型。</p><p>因为一共要输入两个整数和一个字符串，且每次在解决一个关卡后都会调用该函数。由此可得，前两个整数应该是某一个关卡的密钥。而在我们得出得答案中，只有第 3 关和第 4 关的密钥是两个整型数字，经过测试后，隐藏关卡的实际入口在第4关</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418194052316.png" alt="image-20230418194052316"></p></li><li><p>输出第 20 行地址处的值为：<code>DrEvil</code> ；</p></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418194200376.png" alt="image-20230418194200376"></p><ul><li>比较函数用于将第 20 行地址处的字符串与输入的第三个参数作比较，根据后面两行的代码可以分析出当输入值与设置值不相等时，会直接打印祝贺信息并退出该函数，只有当两个字符串相等时，我们操迈出了进入隐藏关卡的第二步。</li><li>第 27 ~ 30 行，一共输出了两个地址存储的值，打印出来后发现并没有什么实质价值，只是成功输入字符串的隐藏值。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418195114104.png" alt="image-20230418195114104"></p><ul><li>第 31 行，被调用的函数就是隐藏关卡，反汇编代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">08048ecf &lt;secret_phase&gt;:</span><br><span class="line"> 8048ecf:53                   push   %ebx</span><br><span class="line"> 8048ed0:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048ed3:e8 45 02 00 00       call   804911d &lt;read_line&gt;</span><br><span class="line"> 8048ed8:c7 44 24 08 0a 00 00 movl   $0xa,0x8(%esp) //第一个参数10</span><br><span class="line"> 8048edf:00 </span><br><span class="line"> 8048ee0:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp) //第二个参数0</span><br><span class="line"> 8048ee7:00 </span><br><span class="line"> 8048ee8:89 04 24             mov    %eax,(%esp) //第三个参数为输入值</span><br><span class="line"> 8048eeb:e8 f0 f9 ff ff       call   80488e0 &lt;strtol@plt&gt;//转化为十进制数</span><br><span class="line"> 8048ef0:89 c3                mov    %eax,%ebx</span><br><span class="line"> 8048ef2:8d 40 ff             lea    -0x1(%eax),%eax</span><br><span class="line"> 8048ef5:3d e8 03 00 00       cmp    $0x3e8,%eax</span><br><span class="line"> 8048efa:76 05                jbe    8048f01 &lt;secret_phase+0x32&gt; //输入值-1 小于等于 0x3e8的话跳转，炸弹不爆炸</span><br><span class="line"> 8048efc:e8 f5 01 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f01:89 5c 24 04          mov    %ebx,0x4(%esp)</span><br><span class="line"> 8048f05:c7 04 24 88 c0 04 08 movl   $0x804c088,(%esp)</span><br><span class="line"> 8048f0c:e8 6d ff ff ff       call   8048e7e &lt;fun7&gt;</span><br><span class="line"> 8048f11:83 f8 03             cmp    $0x3,%eax //函数fun7的返回值与 3 作比较，等于 3 炸弹不爆炸</span><br><span class="line"> 8048f14:74 05                je     8048f1b &lt;secret_phase+0x4c&gt;</span><br><span class="line"> 8048f16:e8 db 01 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f1b:c7 04 24 f8 a1 04 08 movl   $0x804a1f8,(%esp) //0x804a1f8:      &quot;Wow! You&#x27;ve defused the secret stage!&quot;</span><br><span class="line"> 8048f22:e8 d9 f8 ff ff       call   8048800 &lt;puts@plt&gt;//输出字符串</span><br><span class="line"> 8048f27:e8 4f 03 00 00       call   804927b &lt;phase_defused&gt; //返回调用函数</span><br><span class="line"> 8048f2c:83 c4 18             add    $0x18,%esp</span><br><span class="line"> 8048f2f:5b                   pop    %ebx</span><br><span class="line"> 8048f30:c3                   ret    </span><br><span class="line"> 8048f31:90                   nop</span><br><span class="line"> 8048f32:90                   nop</span><br><span class="line"> 8048f33:90                   nop</span><br><span class="line"> 8048f34:90                   nop</span><br><span class="line"> 8048f35:90                   nop</span><br><span class="line"> 8048f36:90                   nop</span><br><span class="line"> 8048f37:90                   nop</span><br><span class="line"> 8048f38:90                   nop</span><br><span class="line"> 8048f39:90                   nop</span><br><span class="line"> 8048f3a:90                   nop</span><br><span class="line"> 8048f3b:90                   nop</span><br><span class="line"> 8048f3c:90                   nop</span><br><span class="line"> 8048f3d:90                   nop</span><br><span class="line"> 8048f3e:90                   nop</span><br><span class="line"> 8048f3f:90                   nop</span><br></pre></td></tr></table></figure><p>进入secret_phase，函数先读取我们输入的密钥，然后调用了c语言的strtol函数，这个函数将字符串转为长整型数，其中参数0xa意味着将其转为十进制。接下来函数会比较经转换后的数自减1后与0x3e8（十进制为1000）的无符号数大小，这意味着我们输入的数必须在[1, 1001]中。接着，函数会调用一个递归函数func7，参数为0x804c088和我们输入的数，func7的伪代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func7</span><span class="params">(<span class="type">int</span>* k, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="type">int</span> kn = *k;</span><br><span class="line">       <span class="keyword">if</span>(kn == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(kn &lt; n) <span class="keyword">return</span> <span class="number">2</span>*func7(k+<span class="number">2</span>, n) + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*func7(k+<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又由以下两个指令知，<code>func7(, 我们输入的数)</code>的返回值必须为3，否则将引爆炸弹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8048ef2: 83 f8 03              cmp    $0x3,%eax</span><br><span class="line">8048ef5: 74 05                 je     8048efc &lt;secret_phase+0x4c&gt;</span><br></pre></td></tr></table></figure><p>观察内存中地址为0x804c088的内容，是一棵二叉树：第一个地址存储数据，第二、三个地址存储下子结点的地址。于是我们只要分析func7的行为，并根据0x804c088中的内容，即可确定要输入的数。</p><p>首先，函数要求func7最终返回3。要构造一个3，根据func7的特性，可以这样构造$2\cdot(2\cdot(0+1))+1$ ，这意味着，最后一次要返回 0，倒数第二次（或第二次）要返回 $2 \cdot func7(k+2, n) + 1$，倒数第三次（或第一次）要返回 $2 \cdot func7(k+2, n) + 1$ 。或者说，要返回的值是二叉树查找时比较的次数。要满足这样的关系，假如我们把第1~3次比较的数设为k1、k2、k3，那么，我们输入的数n要满足的条件是n &gt; k1且n &gt; k2且n == k3。要找到k3，查找0x804c088处的内存即可，经查找，为0x6b，转换为十进制为107，即为密钥。</p><p>打印 <code>0x804c088</code> 地址处的值可得：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418201622434.png" alt="image-20230418201622434"></p><p>所以，隐藏关卡的密钥为 <code>107</code> 。</p><p>下图为实验结果：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418205634637.png" alt="image-20230418205634637"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写到此处，我们的炸弹也就拆完了。在拆除炸弹之后，有关于x86-64的汇编指令以及gdb的一些调试方法我们都已经有所了解。总的来说，这个实验还是十分有趣的，通过剧情让我们了解汇编指令，值得自己独立研究一下，会有不小的收获。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bomb-Lab&quot;&gt;&lt;a href=&quot;#Bomb-Lab&quot; class=&quot;headerlink&quot; title=&quot;Bomb Lab&quot;&gt;&lt;/a&gt;Bomb Lab&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="《深入理解计算机系统》课程实验" scheme="http://example.com/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>小孔成像模型——坐标系转换</title>
    <link href="http://example.com/2023/03/28/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/03/28/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-03-28T14:37:07.000Z</published>
    <updated>2024-03-01T09:04:51.689Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。</p><p>本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。</p><h1 id="一、小孔成像模型与坐标系"><a href="#一、小孔成像模型与坐标系" class="headerlink" title="一、小孔成像模型与坐标系"></a>一、小孔成像模型与坐标系</h1><p>相机的拍摄过程可以简化为小孔成像的一种形式，利用这种形式很容易就能得到相机模型中的数学表达式。通过相机的成像方式及其数学表达式，可以看出三维场景和图像中每一个像素之间的映射关系。</p><p>相机的模型结构如下图所示，为了使其简单化，把成像的平面置于小孔前面，并且拍摄出来的图像也应该是正立的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230328224246218.png" alt="image-20230328224246218"></p><p>在小孔成像模型中，场景从三维空间投影到图片上的整个过程可以理解为<strong>三个步骤</strong>和<strong>四个坐标系</strong>。</p><p>具体流程如下：从世界坐标系转换到相机坐标系，再从相机坐标系转换到图像坐标系，最后从图像坐标系转换到像素坐标系。</p><p>四个坐标系的定义如下：</p><ul><li><strong>世界坐标系：</strong>一个客观的绝对存在，世界坐标系都需要<strong>预先确定</strong>，指定其<strong>原点</strong>和<strong>方向</strong>。在定义好的世界坐标系中可以放置任何物体。世界坐标系下的坐标通常用（Xw,Yw,Zw）来进行表示。</li><li><strong>相机坐标系：</strong>目前通用的定义方法是以一台<strong>相机的光心或者主点</strong>作为坐标系的<strong>原点。X轴和Y轴</strong>在拍摄画面时分别平行于图像的横轴和纵轴，<strong>Z轴</strong>为相机的焦距所指方向。相机坐标系下的坐标通常使用符号（Xc,Yc,Zc）来进行表示。</li><li><strong>图像坐标系：</strong>根据图像进行定义，以图象中心作为<strong>原点，</strong>X 轴和 Y 轴与相机的 X 轴和 Y 轴的方向保持一致。图像坐标是使用米、厘米等物理学单位来表示的坐标系。图像坐标系只有两个维度，没有Z轴。图像坐标系下通常使用符号（x, y）来表示。</li><li><strong>像素坐标系：</strong>以像素为单位的坐标系。像素坐标系也是二维坐标系，其 X 轴和 Y 轴的方向与图像坐标系一致。坐标原点位于二维图像的左上角。像素通用的表示形式为一个方块或者矩形，每个像素里面存放的信息为像素的强度和灰度值。</li></ul><h1 id="二、坐标系的转换"><a href="#二、坐标系的转换" class="headerlink" title="二、坐标系的转换"></a>二、坐标系的转换</h1><p>在第一小节中，已经定义了各个坐标系及其表示形式，在该小节中，将通过数学模型的形式，推导小孔成像的过程。整个过程分为三个步骤，其中<strong>世界坐标系</strong>到<strong>相机坐标系</strong>的变化过程涉及相机的<strong>外参</strong>，从<strong>相机的坐标系</strong>转换到<strong>图像坐标系</strong>再转换到像素坐标系的过程中都涉及到了相机的<strong>内参</strong>的使用。该小节通过相机内参以及外参的形式推导相机的投影过程。</p><h2 id="1-相机外参"><a href="#1-相机外参" class="headerlink" title="(1) 相机外参"></a>(1) 相机外参</h2><p>世界坐标系（Xw,Yw,Zw）与相机坐标系（Xc,Yc,Zc）的转换。</p><p>假设点 <strong>P </strong>是一个三维空间的点，其在相机坐标系下的位置为 <strong>Pc</strong> ，在世界坐标系下的位置为 <strong>Pw </strong>。Pw 和 Pc 可以通过一个变换矩阵相互转换，该变换矩阵可以细分为旋转矩阵(<strong>R</strong>)和平移矩阵(<strong>t</strong>).其数学表达式为：</p><script type="math/tex; mode=display">P_c=RP_w+t</script><p>其中 <strong>R</strong> 有三个自由度，是一个 3 * 3 的矩阵，表示相机在世界坐标系下的旋转。<strong>t</strong> 表示相机的原点（或者说相机开始时的坐标系的原点）相对于世界坐标系的变化，是一个 3 * 1的矩阵。上式可以展开为：</p><script type="math/tex; mode=display">\begin{bmatrix}X_c \\Y_c \\Z_c \\\end{bmatrix}=\begin{bmatrix}R_{11} & R_{12} & R_{13} \\R_{21} & R_{22} & R_{23} \\R_{31} & R_{32} & R_{33} \\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\\end{bmatrix}+\begin{bmatrix}t_1 \\t_2 \\t_3 \\\end{bmatrix}</script><p>其齐次方程表的形式可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}=\begin{bmatrix}R_{11} & R_{12} & R_{13} & t_1\\R_{21} & R_{22} & R_{23} & t_2\\R_{31} & R_{32} & R_{33} & t_3\\0 & 0 & 0 & 1 \\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\1 \\\end{bmatrix}</script><p>可以简化为：</p><script type="math/tex; mode=display">\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}=\begin{bmatrix}\mathbf{R} & \mathbf{t} \\\mathbf{0} & 1\\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\1 \\\end{bmatrix}</script><h2 id="2-相机内参"><a href="#2-相机内参" class="headerlink" title="(2) 相机内参"></a>(2) 相机内参</h2><p>相机坐标系(Xc, Yc, Zc)与图像坐标系(x, y)的转换：相机坐标系是一个三维坐标系，图像坐标系是二维坐标系，三维到二维有一个降维的过程，主要是丢掉了深度这一维度，坐标向量由三维转为二维。</p><p>如下图，相机坐标系下存在任一点<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933146776-b2fe3d6e-64aa-4cab-88f8-705b3a9fb774.png#averageHue=%23efeae5&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u5179f4c5&amp;originHeight=19&amp;originWidth=115&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua892299b-1bd1-4690-9d5d-c8a2f843b10&amp;title=" alt="">，图像上的坐标点<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933166386-71ef4c8e-e578-4f90-9760-798c4ac6f931.png#averageHue=%23f1ece6&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=ubed80338&amp;originHeight=19&amp;originWidth=74&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udd7cebd1-a63c-4dfb-8539-6a039ca807a&amp;title=" alt="">与该三维点对应。由于两个坐标系的 X轴、Y轴一致，因此可以增加一个维度 f，形成相机坐标系的坐标<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933257046-1968546c-8804-4c5b-9182-d7a23cf12a8a.png#averageHue=%23f1ece7&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u2cf93ccd&amp;originHeight=19&amp;originWidth=89&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf206efb3-1a8f-419a-bef2-00a905328c7&amp;title=" alt="">，其中 f 是相机的焦距。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230329001037658.png" alt="image-20230329001037658"></p><p>由相似三角形，可得以下公式：</p><script type="math/tex; mode=display">\frac{z_c}{f} = \frac{x_c}{f} = \frac{y_c}{f}</script><p>整理可得：</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}         x=f\frac{x_c}{z_c} \\         y=f\frac{y_c}{z_c} \\         z=f \\\end{array}\right.</script><p>转化为齐次坐标系下为：</p><script type="math/tex; mode=display">Z_c·\begin{bmatrix}x \\y \\1 \\\end{bmatrix}=\begin{bmatrix}f & 0 & 0 & 0\\0 & f & 0 & 0\\0 & 0 & 1 & 0\\\end{bmatrix}·\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}</script><p>至此推导出了相机坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933429538-567a3c43-bd16-423e-bd02-3d9a88f21858.png#averageHue=%23f3ece5&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u96cfe4a3&amp;originHeight=19&amp;originWidth=71&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u367f2754-ae6e-4ec8-a638-698f9b3ee07&amp;title=" alt=""> 与图像坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933430100-c27dca7d-3b2a-44b2-84af-744283fec0d4.png#averageHue=%23f7f1e9&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u604cffd6&amp;originHeight=19&amp;originWidth=37&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2e0543dc-2fbe-4c79-b46d-0b928187d72&amp;title=" alt=""> 的转换数学模型。</p><p>图像坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933491062-13bc7d4f-29c6-4ab2-b6ee-ac3d3c4dd186.png#averageHue=%23f7f1e9&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u01d320a8&amp;originHeight=19&amp;originWidth=37&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9cbc0ff2-554b-4e91-8233-a1ae3e89184&amp;title=" alt=""> 与像素坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933491053-986b9369-8da2-40be-aaa4-621c3a68362f.png#averageHue=%23f7f0e8&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u12316738&amp;originHeight=19&amp;originWidth=38&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8a74610e-7426-4bbf-81be-b7036151baf&amp;title=" alt=""> 的转换：这两个坐标系最核心的区别在于其单位不一致。</p><p>如下图：O为像素坐标系原点，O1为图像坐标系原点</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e9026b387f404269b42096669b62dd56.png" alt="img"></p><p>假设<strong>(u~0~, v~0~)</strong>为像素坐标系下的坐标，表示整个图像的中心。像素的表示形式通常为矩形 或是长方形，设像素的长宽分别为dx 、dy 。有对应关系可得：</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}         u=\frac{x}{dx}+u_0\\         v=\frac{y}{dy}+v_0 \\\end{array}\right.</script><p>转换到齐次坐标系得：</p><script type="math/tex; mode=display">\begin{bmatrix}u \\v \\1 \\\end{bmatrix}=\begin{bmatrix}\frac{1}{dx} & 0 & u_0 \\0 & \frac{1}{dy} & v_0 \\0 & 0 & 0 \\\end{bmatrix}\begin{bmatrix}x \\y \\1 \\\end{bmatrix}</script><p>到此为之，得到了图像坐标系（x, y）到像素坐标系（u, v）的转换的数学模型。</p><p>结合（7）、（9）得到一个三维空间中的点从相机坐标系到像素坐标系的整个投影过程，其数学表达式如下：</p><script type="math/tex; mode=display">Z_c·\begin{bmatrix}u \\v \\1 \\\end{bmatrix}=\begin{bmatrix}f_x & 0 & u_0 & 0\\0 & f_y & v_0 & 0\\0 & 0 & 1 & 0\\\end{bmatrix}·\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}</script><p>其中<img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230329002607626.png" alt="image-20230329002607626">被称为相机的内参矩阵，用<strong>K</strong>表示。</p><p>内参矩阵 <strong>K</strong> 有4个未知的数据，这四个数据与相机的构造相关。$f_x, f_y$ 为 $\frac{f}{dx}$, $\frac{f}{dy}$ 的简写形式，<strong>f</strong> 表示相机的焦距，$dx,dy$ 是单位像素的长和宽。$u_0, v_o$ 是像素坐标系下图像中间未知的坐标。</p><h2 id="（3-内外参数组合"><a href="#（3-内外参数组合" class="headerlink" title="（3) 内外参数组合"></a>（3) 内外参数组合</h2><p>通过相机的内参和外参，可以将相机模型中的四个坐标系之间的变换全部联系起来，其数学形式为：</p><script type="math/tex; mode=display">Z_c·\begin{bmatrix}u \\v \\1 \\\end{bmatrix}=\begin{bmatrix}f_x & 0 & u_0 & 0\\0 & f_y & v_0 & 0\\0 & 0 & 1 & 0\\\end{bmatrix}\begin{bmatrix}\mathbf{R} & \mathbf{t} \\\mathbf{0} & 1\\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\1 \\\end{bmatrix}</script><h1 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h1><p>主要参考：<a href="https://blog.csdn.net/TFZ941214/article/details/121235284">https://blog.csdn.net/TFZ941214/article/details/121235284</a></p><p>关于计算摄影学：<a href="https://zhuanlan.zhihu.com/p/570452119">https://zhuanlan.zhihu.com/p/570452119</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。&lt;/p&gt;
&lt;p&gt;本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。&lt;/p&gt;
&lt;h1 id=&quot;一、小孔成像模型与坐标系&quot;&gt;&lt;a href=&quot;#一、小孔成像模型与坐标系&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="数字图像处理" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
</feed>
