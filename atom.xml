<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-10T08:52:51.872Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis家族再添新成员：探索Bitmaps、HyperLogLog和Geo的魅力</title>
    <link href="http://example.com/2024/06/10/Redis%E5%AE%B6%E6%97%8F%E5%86%8D%E6%B7%BB%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%8E%A2%E7%B4%A2Bitmaps%E3%80%81HyperLogLog%E5%92%8CGeo%E7%9A%84%E9%AD%85%E5%8A%9B/"/>
    <id>http://example.com/2024/06/10/Redis%E5%AE%B6%E6%97%8F%E5%86%8D%E6%B7%BB%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%8E%A2%E7%B4%A2Bitmaps%E3%80%81HyperLogLog%E5%92%8CGeo%E7%9A%84%E9%AD%85%E5%8A%9B/</id>
    <published>2024-06-10T07:40:09.000Z</published>
    <updated>2024-06-10T08:52:51.872Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的博客中，我们已经学习了 Redis 中的五种基础数据结构和六种底层数据结构。随着 Redis 在江湖上的名气越来越大，又有不少的英雄豪杰加入了 Redis 这一大帮派。</p><p>这个家族又迎来了三位新的成员：Bitmaps、HyperLogLog 和 Geo，三者各怀绝技，进一步巩固了Redis在数据江湖中的地位。</p><p>接下来就让我们来看一下这三位的实力把。</p><h1 id="Bitmaps-：位操作的巧匠"><a href="#Bitmaps-：位操作的巧匠" class="headerlink" title="Bitmaps ：位操作的巧匠"></a>Bitmaps ：位操作的巧匠</h1><p>根据官网介绍：</p><blockquote><p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p><p>Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。</p></blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p><h2 id="用来解决什么问题？"><a href="#用来解决什么问题？" class="headerlink" title="用来解决什么问题？"></a>用来解决什么问题？</h2><p>思考一个问题，在一个场景下，我们需要存储大规模的布尔数据类型，比如用户的签到信息、用户是否在线、某个时间段用户是否观看了某个视频等等。使用传统的数据结构可能会消耗大量的内存。</p><p>那要怎么实现我们想要的功能？</p><p>使用 <code>Bitmaps</code> 。bitmap 最大的优势之一是存储信息时，它经常可以极大的节省空间。例如，一个用户的系统中，使用递增的 id 来表示不同的用户，这时候 bitmap 使用 512MB 内存就可以记录 40 亿用户的一个比特信息（例如，1是男生，0是女生，一个男生的id为19，那么这个 bitmap 的第 19 位就是 1）。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="img"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之前值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 …</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td></tr></tbody></table></div><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>查看某一天是否有打卡！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>统计操作，统计 打卡的天数！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p><ul><li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><h1 id="HyperLogLog：基数估计的神算"><a href="#HyperLogLog：基数估计的神算" class="headerlink" title="HyperLogLog：基数估计的神算"></a>HyperLogLog：基数估计的神算</h1><h2 id="为什么要使用-HyperLogLog"><a href="#为什么要使用-HyperLogLog" class="headerlink" title="为什么要使用 HyperLogLog"></a>为什么要使用 <code>HyperLogLog</code></h2><p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p><p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p><p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p><p>HLL 具有以下几个特点：</p><ul><li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li><li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li><li>误差可以被设置辅助计算因子进行降低。</li></ul><p>Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p><ul><li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element <span class="selector-attr">[element ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持添加一个或多个元素至 HLL 结构中。</p><h4 id="统计不重复的元素"><a href="#统计不重复的元素" class="headerlink" title="统计不重复的元素"></a><strong>统计不重复的元素</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持统计一个或多个 HLL 结构。</p><h4 id="合并一个或多个-HLL-至新结构"><a href="#合并一个或多个-HLL-至新结构" class="headerlink" title="合并一个或多个 HLL 至新结构"></a><strong>合并一个或多个 HLL 至新结构</strong></h4><p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd k &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd k2 &quot;redis&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge k3 k k2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount k3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey <span class="selector-attr">[sourcekey ...]</span></span><br></pre></td></tr></table></figure><p><strong>pfmerge 使用场景</strong></p><p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>接下来我们使用 Java 代码来实现 HLL 的三个基础功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HyperLogLogExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计元素</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印统计元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k：&quot;</span> + count);</span><br><span class="line">        <span class="comment">// 合并 HLL</span></span><br><span class="line">        jedis.pfmerge(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印新 HLL</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k2：&quot;</span> + jedis.pfcount(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k：2</span><br><span class="line">k2：2</span><br></pre></td></tr></table></figure><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>HyperLogLog 算法来源于论文 <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</em></a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p><p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p><ul><li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li><li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li><li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li></ul><p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p><p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p><p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p><blockquote><p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500‬ 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1⁄1000+1⁄100000)≈1998 元，显然此算法更符合实际平均数。</p></blockquote><p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文。</p><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p><ul><li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul><h1 id="Geo：地理位置的游侠"><a href="#Geo：地理位置的游侠" class="headerlink" title="Geo：地理位置的游侠"></a>Geo：地理位置的游侠</h1><p>受过高等教育的我们都知道，我们所处的任何位置都可以用经度和纬度来标识，经度的范围 -180 到 180，纬度的范围为 -90 到 90。纬度以赤道为界，赤道以南为负数，赤道以北为正数；经度以本初子午线（英国格林尼治天文台）为界，东边为正数，西边为负数。</p><p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，GEO 本质上是基于 ZSet 实现的。</p><p>关于 GEO 的命令不多，主要包含以下 6 个：</p><ol><li>geoadd：添加地理位置</li><li>geopos：查询位置信息</li><li>geodist：距离统计</li><li>georadius：查询某位置内的其他成员信息</li><li>geohash：查询位置的哈希值</li><li>zrem：删除地理位置</li></ol><p>下面我们分别来看这些命令的使用。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="添加地理位置"><a href="#添加地理位置" class="headerlink" title="添加地理位置"></a><strong>添加地理位置</strong></h3><p>我们先用百度地图提供的经纬度查询工具，地址：</p><blockquote><p><a href="http://api.map.baidu.com/lbsapi/getpoint/index.html">http://api.map.baidu.com/lbsapi/getpoint/index.html</a></p></blockquote><p>如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/assets/c91f60b0-63a2-11ea-99a6-09fef5109e7b" alt="百度经纬度查询工具.png"></p><p>找了以下 4 个地点，添加到 Redis 中：</p><ol><li>天安门：116.404269,39.913164</li><li>月坛公园：116.36,39.922461</li><li>北京欢乐谷：116.499705,39.874635</li><li>香山公园：116.193275,39.996348</li></ol><p>代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd site 116.404269 39.913164 tianan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.36 39.922461 yuetan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.499705 39.874635 huanle</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.193275 39.996348 xiangshan</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude <span class="keyword">member</span> [longitude latitude <span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>重点参数说明如下：</p><ul><li>longitude 表示经度</li><li>latitude 表示纬度</li><li>member 是为此经纬度起的名字</li></ul><p>此命令支持一次添加一个或多个位置信息。</p><h3 id="查询位置信息"><a href="#查询位置信息" class="headerlink" title="查询位置信息"></a><strong>查询位置信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos site tianan</span><br><span class="line">1) 1) &quot;116.40541702508926392&quot;</span><br><span class="line">   2) &quot;39.91316289865137179&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持查看一个或多个位置信息。</p><h3 id="距离统计"><a href="#距离统计" class="headerlink" title="距离统计"></a><strong>距离统计</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist site tianan yuetan km</span><br><span class="line">&quot;3.9153&quot;</span><br></pre></td></tr></table></figure><p>可以看出天安门距离月坛公园的直线距离大概是 3.9 km，我们打开地图使用工具测试一下咱们的统计结果是否准确，如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/assets/de8bb110-63a2-11ea-b997-6566d32f1735" alt="天安门到月坛公园距离统计图.png"></p><p>可以看出 Redis 的统计和使用地图工具统计的距离是完全吻合的。</p><blockquote><p>注意：此命令统计的距离为两个位置的直线距离。</p></blockquote><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 <span class="selector-attr">[unit]</span></span><br></pre></td></tr></table></figure><p>unit 参数表示统计单位，它可以设置以下值：</p><ul><li>m：以米为单位，默认单位；</li><li>km：以千米为单位；</li><li>mi：以英里为单位；</li><li>ft：以英尺为单位。</li></ul><h3 id="查询某位置内的其他成员信息"><a href="#查询某位置内的其他成员信息" class="headerlink" title="查询某位置内的其他成员信息"></a><strong>查询某位置内的其他成员信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>此命令的意思是查询天安门（116.405419,39.913164）附近 5 公里范围内的成员列表。</p><p>相关语法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">georadius</span> <span class="selector-tag">key</span> <span class="selector-tag">longitude</span> <span class="selector-tag">latitude</span> <span class="selector-tag">radius</span> <span class="selector-tag">m</span>|<span class="selector-tag">km</span>|<span class="selector-tag">ft</span>|<span class="selector-tag">mi</span> <span class="selector-attr">[WITHCOORD]</span> <span class="selector-attr">[WITHDIST]</span> <span class="selector-attr">[WITHHASH]</span> <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[ASC|DESC]</span></span><br></pre></td></tr></table></figure><p>可选参数说明如下。</p><p><strong>1. WITHCOORD</strong></p><p>说明：返回满足条件位置的经纬度信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withcoord</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) 1) &quot;116.40426903963088989&quot;</span><br><span class="line">      2) &quot;39.91316289865137179&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) 1) &quot;116.36000186204910278&quot;</span><br><span class="line">      2) &quot;39.92246025586381819&quot;</span><br></pre></td></tr></table></figure><p><strong>2. WITHDIST</strong></p><p>说明：返回满足条件位置与查询位置的直线距离。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br></pre></td></tr></table></figure><p><strong>3. WITHHASH</strong></p><p>说明：返回满足条件位置的哈希信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withhash</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) (integer) 4069885552230465</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) (integer) 4069879797297521</span><br></pre></td></tr></table></figure><p><strong>4. COUNT count</strong></p><p>说明：指定返回满足条件位置的个数。</p><p>例如，指定返回一条满足条件的信息，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km count 1</span><br><span class="line">1) &quot;tianan&quot;</span><br></pre></td></tr></table></figure><p><strong>5. ASC|DESC</strong></p><p>说明：从近到远|从远到近排序返回。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km desc</span><br><span class="line">1) &quot;yuetan&quot;</span><br><span class="line">2) &quot;tianan&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km asc</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>当然以上这些可选参数也可以一起使用，例如以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist desc</span><br><span class="line">1) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br><span class="line">2) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br></pre></td></tr></table></figure><p><strong>5. 查询哈希值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash site tianan</span><br><span class="line">1) &quot;wx4g0cgp000&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持查询一个或多个地址的哈希值。</p><p><strong>6. 删除地理位置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem site xiaoming</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个位置信息。</p><h2 id="代码实战-1"><a href="#代码实战-1" class="headerlink" title="代码实战"></a>代码实战</h2><p>下面我们用 Java 代码，来实现查询附近的人，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoCoordinate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoRadiusResponse;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoUnit;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeoHashExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, GeoCoordinate&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加小明的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoming&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.404269</span>, <span class="number">39.913164</span>));</span><br><span class="line">        <span class="comment">// 添加小红的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaohong&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.36</span>, <span class="number">39.922461</span>));</span><br><span class="line">        <span class="comment">// 添加小美的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaomei&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.499705</span>, <span class="number">39.874635</span>));</span><br><span class="line">        <span class="comment">// 添加小二</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoer&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.193275</span>, <span class="number">39.996348</span>));</span><br><span class="line">        jedis.geoadd(<span class="string">&quot;person&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询小明和小红的直线距离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小明和小红相距：&quot;</span> + jedis.geodist(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xiaohong&quot;</span>, GeoUnit.KM) + <span class="string">&quot; KM&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询小明附近 5 公里的人</span></span><br><span class="line">        List&lt;GeoRadiusResponse&gt; res = jedis.georadiusByMemberReadonly(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, GeoUnit.KM);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明附近的人：&quot;</span> + res.get(i).getMemberByString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明和小红相距：3.9153 KM</span><br><span class="line">小明附近的人：xiaohong</span><br></pre></td></tr></table></figure><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>Redis 中的 GEO 经典使用场景如下：</p><ol><li>查询附近的人、附近的地点等；</li><li>计算相关的距离信息。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是 Redis 后续新增的三种数据结构的介绍和基本使用方法。在实际开发中，我们要实现的很多功能其实都要用到这三种数据结构。其实博客项目看似好像是一个烂大街的玩具，但其实如果真的要开发一款能推向市场的博客系统，还是要费很大的功夫的。</p><p>越往深处学就会发现它们的应用就在我们身边，这可能就是计算机不好入行的原因吧，刚开始学的全是一些抽象的东西，想要去实现一个我们平常使用的功能基本是不可能的，只有在深入学习各种框架、技术之后才能更好地理解身边的技术实现。</p><p>今天写的这几篇博客其实都有一点抽象，主要是因为之前在学 Redis 时，因为刚入门，所以很多东西都要去深入学习，最近几天看到的内容都是一个功能的实现，没有深挖的内容，所以在记录博客时就直接照着别人的总结写了一遍。你说这有用吗，应该比直接看一遍有用。</p><p>这两天都在学 Java 的基础知识，感觉和 Go 差的太多了，很麻烦，东西很杂。昨晚想通了一个问题，既然决定直接备战秋招了，时间还有差不多两三个月，其实可以不用那么急躁，囫囵吞枣式的学习只会带来更快的遗忘。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%9f%a5%e8%af%a2%e9%99%84%e8%bf%91%e7%9a%84%e4%ba%ba%e2%80%94%e2%80%94GEO.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%9f%a5%e8%af%a2%e9%99%84%e8%bf%91%e7%9a%84%e4%ba%ba%e2%80%94%e2%80%94GEO.md</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e4%bc%98%e7%a7%80%e7%9a%84%e5%9f%ba%e6%95%b0%e7%bb%9f%e8%ae%a1%e7%ae%97%e6%b3%95%e2%80%94%e2%80%94HyperLogLog.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e4%bc%98%e7%a7%80%e7%9a%84%e5%9f%ba%e6%95%b0%e7%bb%9f%e8%ae%a1%e7%ae%97%e6%b3%95%e2%80%94%e2%80%94HyperLogLog.md</a></p><p><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">https://javaguide.cn/database/redis/redis-data-structures-02.html</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的博客中，我们已经学习了 Redis 中的五种基础数据结构和六种底层数据结构。随着 Redis 在江湖上的名气越来越大，又有不少的英雄豪杰加入了 Redis 这一大帮派。&lt;/p&gt;
&lt;p&gt;这个家族又迎来了三位新的成员：Bitmaps、HyperLogLog 和 Geo，</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>分页与过滤：Redis中的渐进式数据处理妙招</title>
    <link href="http://example.com/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/"/>
    <id>http://example.com/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/</id>
    <published>2024-06-10T07:35:36.000Z</published>
    <updated>2024-06-10T08:18:42.462Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容就先有一篇小故事来引出吧。</p><h1 id="一个问题引发的「血案」"><a href="#一个问题引发的「血案」" class="headerlink" title="一个问题引发的「血案」"></a>一个问题引发的「血案」</h1><p>曾经发生过这样一件事，我们的 Redis 服务器存储了海量的数据，其中登录用户信息是以 user_token_id 的形式存储的。运营人员想要当前所有的用户登录信息，然后悲剧就发生了：因为我们的工程师使用了 <code>keys user_token_*</code> 来查询对应的用户，结果导致 Redis 假死不可用，以至于影响到线上的其他业务接连发生问题，然后就收到了一堆的系统预警短信。并且这个假死的时间是和存储的数据成正比的，数据量越大假死的时间就越长，导致的故障时间也越长。</p><p>那如何避免这个问题呢？</p><h1 id="问题的解决方法"><a href="#问题的解决方法" class="headerlink" title="问题的解决方法"></a>问题的解决方法</h1><p>在 Redis 2.8 之前，我们只能使用 keys 命令来查询我们想要的数据，但这个命令存在两个缺点：</p><ol><li>此命令没有分页功能，我们只能一次性查询出所有符合条件的 key 值，如果查询结果非常巨大，那么得到的输出信息也会非常多；</li><li>keys 命令是遍历查询，因此它的查询时间复杂度是 o(n)，所以数据量越大查询时间就越长。</li></ol><p>然而，比较幸运的是在 Redis 2.8 时推出了 Scan，解决了我们这些问题，下面来看 Scan 的具体使用。</p><h1 id="Scan命令使用"><a href="#Scan命令使用" class="headerlink" title="Scan命令使用"></a><code>Scan</code>命令使用</h1><p>我们先来模拟海量数据，使用 Pipeline 添加 10w 条数据，Java 代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加 10w 条数据</span></span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100001</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;user_token_&quot;</span> + i, <span class="string">&quot;id&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据插入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来查询用户 id 为 9999* 的数据，Scan 命令使用如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match user_token_9999* count 10000</span><br><span class="line">1) &quot;127064&quot;</span><br><span class="line">2) 1) &quot;user_token_99997&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 127064 match user_token_9999* count 10000</span><br><span class="line">1) &quot;1740&quot;</span><br><span class="line">2) 1) &quot;user_token_9999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1740 match user_token_9999* count 10000</span><br><span class="line">1) &quot;21298&quot;</span><br><span class="line">2) 1) &quot;user_token_99996&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 21298 match user_token_9999* count 10000</span><br><span class="line">1) &quot;65382&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 65382 match user_token_9999* count 10000</span><br><span class="line">1) &quot;78081&quot;</span><br><span class="line">2) 1) &quot;user_token_99998&quot;</span><br><span class="line">   2) &quot;user_token_99992&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 78081 match user_token_9999* count 10000</span><br><span class="line">1) &quot;3993&quot;</span><br><span class="line">2) 1) &quot;user_token_99994&quot;</span><br><span class="line">   2) &quot;user_token_99993&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3993 match user_token_9999* count 10000</span><br><span class="line">1) &quot;13773&quot;</span><br><span class="line">2) 1) &quot;user_token_99995&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 13773 match user_token_9999* count 10000</span><br><span class="line">1) &quot;47923&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 47923 match user_token_9999* count 10000</span><br><span class="line">1) &quot;59751&quot;</span><br><span class="line">2) 1) &quot;user_token_99990&quot;</span><br><span class="line">   2) &quot;user_token_99991&quot;</span><br><span class="line">   3) &quot;user_token_99999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 59751 match user_token_9999* count 10000</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) (empty list or set)</span><br></pre></td></tr></table></figure><p>从以上的执行结果，我们看出两个问题：</p><ol><li>查询的结果为空，但游标值不为 0，表示遍历还没结束；</li><li>设置的是 count 10000，但每次返回的数量都不是 10000，且不固定，这是因为 count 只是限定服务器单次遍历的字典槽位数量（约等于），而不是规定返回结果的 count 值。</li></ol><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>cursor：光标位置，整数值，从 0 开始，到 0 结束，查询结果是空，但游标值不为 0，表示遍历还没结束；</li><li>match pattern：正则匹配字段；</li><li>count：限定服务器单次遍历的字典槽位数量（约等于），只是对增量式迭代命令的一种提示（hint），并不是查询结果返回的最大数量，它的默认值是 10。</li></ul><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>本文我们使用 Java 代码来实现 Scan 的查询功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanParams;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 定义 match 和 count 参数</span></span><br><span class="line">        <span class="type">ScanParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanParams</span>();</span><br><span class="line">        params.count(<span class="number">10000</span>);</span><br><span class="line">        params.match(<span class="string">&quot;user_token_9999*&quot;</span>);</span><br><span class="line">        <span class="comment">// 游标</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ScanResult&lt;String&gt; res = jedis.scan(cursor, params);</span><br><span class="line">            <span class="keyword">if</span> (res.getCursor().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 表示最后一条</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = res.getCursor(); <span class="comment">// 设置游标</span></span><br><span class="line">            <span class="keyword">for</span> (String item : res.getResult()) &#123;</span><br><span class="line">                <span class="comment">// 打印查询结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;查询结果：&quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询结果：user_token_99997</span><br><span class="line">查询结果：user_token_9999</span><br><span class="line">查询结果：user_token_99996</span><br><span class="line">查询结果：user_token_99998</span><br><span class="line">查询结果：user_token_99992</span><br><span class="line">查询结果：user_token_99994</span><br><span class="line">查询结果：user_token_99993</span><br><span class="line">查询结果：user_token_99995</span><br><span class="line">查询结果：user_token_99990</span><br><span class="line">查询结果：user_token_99991</span><br><span class="line">查询结果：user_token_99999</span><br></pre></td></tr></table></figure><h1 id="Scan-相关命令"><a href="#Scan-相关命令" class="headerlink" title="Scan 相关命令"></a>Scan 相关命令</h1><p>Scan 是一个系列指令，除了 Scan 之外，还有以下 3 个命令：</p><ol><li>HScan 遍历字典游标迭代器</li><li>SScan 遍历集合的游标迭代器</li><li>ZScan 遍历有序集合的游标迭代器</li></ol><p>来看这些命令的具体使用。</p><h2 id="HScan-使用"><a href="#HScan-使用" class="headerlink" title="HScan 使用"></a><strong>HScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan myhash 0 match k2* count 10</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;k2&quot;</span><br><span class="line">   2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h2 id="SScan-使用"><a href="#SScan-使用" class="headerlink" title="SScan 使用"></a><strong>SScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan myset 0 match v2* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h2 id="ZScan-使用"><a href="#ZScan-使用" class="headerlink" title="ZScan 使用"></a><strong>ZScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan zset 0 match red* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;redis&quot;</span><br><span class="line">   2) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h1 id="Scan-说明"><a href="#Scan-说明" class="headerlink" title="Scan 说明"></a>Scan 说明</h1><p>官方对 Scan 命令的描述信息如下。</p><h2 id="Scan-guarantees"><a href="#Scan-guarantees" class="headerlink" title="Scan guarantees"></a><strong>Scan guarantees</strong></h2><blockquote><p>The SCAN command, and the other commands in the SCAN family, are able to provide to the user a set of guarantees associated to full iterations.</p><ul><li>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point SCANreturned it to the user.</li><li>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, SCAN ensures that this element will never be returned.</li></ul><p>However because SCAN has very little state associated (just the cursor) it has the following drawbacks:</p><ul><li>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</li><li>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</li></ul></blockquote><p>官方文档地址：</p><blockquote><p><a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p></blockquote><p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p><ul><li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li><li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li></ul><p>然后，Scan 命令包含以下缺点：</p><ul><li>一个元素可能被返回多次，需要客户端来实现去重；</li><li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本文我们可以知道 Scan 包含以下四个指令：</p><ol><li>Scan：用于检索当前数据库中所有数据；</li><li>HScan：用于检索哈希类型的数据；</li><li>SScan：用于检索集合类型中的数据；</li><li>ZScan：由于检索有序集合中的数据。</li></ol><p>Scan 具备以下几个特点：</p><ol><li>Scan 可以实现 keys 的匹配功能；</li><li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li><li>Scan 提供了 count 参数，可以规定遍历的数量；</li><li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li><li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li><li>单次返回空值且游标不为 0，说明遍历还没结束；</li><li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li><li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li></ol><p>本文内容与上面那篇文章有着相同的情况，内容较少，所以只读了一篇文章，贴在上面。</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/21%20%e6%b8%b8%e6%a0%87%e8%bf%ad%e4%bb%a3%e5%99%a8%ef%bc%88%e8%bf%87%e6%bb%a4%e5%99%a8%ef%bc%89%e2%80%94%e2%80%94Scan.md">原文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文的主要内容就先有一篇小故事来引出吧。&lt;/p&gt;
&lt;h1 id=&quot;一个问题引发的「血案」&quot;&gt;&lt;a href=&quot;#一个问题引发的「血案」&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的「血案」&quot;&gt;&lt;/a&gt;一个问题引发的「血案」&lt;/h1&gt;&lt;p&gt;曾经发生过这</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>深入解析管道（Pipelining）：提升性能的利器</title>
    <link href="http://example.com/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/"/>
    <id>http://example.com/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/</id>
    <published>2024-06-10T07:35:11.000Z</published>
    <updated>2024-06-10T08:14:53.080Z</updated>
    
    <content type="html"><![CDATA[<p>管道技术 (Pipeline) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p><p>通常情况下 Redis 都是单行执行的，客户端先向服务期发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。但是当出现大批量请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p><p>普通命令模式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/30beb330-63a1-11ea-9c08-6f91e6eaabb6" alt="普通模式.png"></p><p>管道模式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b5d1f60-63a1-11ea-8be0-ebada4c42c48" alt="管道模式.png"></p><blockquote><p>小贴士：管道中命令越多，管道技术的作用就更大，相比于普通模式来说执行效率就越高。</p></blockquote><h1 id="管道解决了什么问题？"><a href="#管道解决了什么问题？" class="headerlink" title="管道解决了什么问题？"></a>管道解决了什么问题？</h1><p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><p>这里介绍使用采用Java语言。</p><p>首先先获取 Pipeline 对象，再为 Pipeline 对象设置需要执行的命令，最后再使用 sync() 方法或 syncAndReturnAll() 方法来统一执行这些命令，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            pipe.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：297毫秒</span><br></pre></td></tr></table></figure><p>如果要接收管道所有命令的执行结果，可使用 syncAndReturnAll() 方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令并返回结果</span></span><br><span class="line">        List&lt;Object&gt; res = pipe.syncAndReturnAll();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : res) &#123;</span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道技术-VS-普通命令"><a href="#管道技术-VS-普通命令" class="headerlink" title="管道技术 VS 普通命令"></a>管道技术 VS 普通命令</h3><p>上面使用管道技术执行一个 for 循环所用的时间为 297 毫秒，接下来我们用普通的命令执行此循环，看下程序的执行时间，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            jedis.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：17276毫秒</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>从上面的结果可以看出，管道的执行时间是 297 毫秒，而普通命令执行时间是 17276 毫秒，管道技术要比普通的执行快了 58 倍。</p><h3 id="管道技术需要注意的事项"><a href="#管道技术需要注意的事项" class="headerlink" title="管道技术需要注意的事项"></a>管道技术需要注意的事项</h3><p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p><ul><li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li><li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li><li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率，但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p><p>本文并非笔者自己所写，由于此知识点内容较少，没必要阅读过多资料，所以选择了一个内容不错的文章来学习。这里就把学习的文章的内容放进来了。</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/19%20Redis%20%e7%ae%a1%e9%81%93%e6%8a%80%e6%9c%af%e2%80%94%e2%80%94Pipeline.md">原文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;管道技术 (Pipeline) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。&lt;/p&gt;
&lt;p&gt;通常情况下 Redis 都是单行执行的，客户端先向服务期发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis为何快得飞起？解密闪电侠的内存魔法</title>
    <link href="http://example.com/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/"/>
    <id>http://example.com/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/</id>
    <published>2024-06-08T11:53:26.000Z</published>
    <updated>2024-06-08T12:28:35.348Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 为什么这么快，这是我在了解 Redis 之前最大的疑问，即使你只是刚刚听说 Redis，对 Redis 的查询速度想必也是有所耳闻。</p><p>在没有深入学习之前，我只会回答因为 Redis 是依赖于内存实现的，所以速度快的飞起。但是，仅仅依靠内存，是不是就把设计人员费的心思给浪费了呢。</p><p>在了解为什么之前，我们先来看一下到底有多快。</p><p> 官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W/每秒</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E6%80%A7%E8%83%BD.png" alt="img"></p><h1 id="内存存储：速度的基础"><a href="#内存存储：速度的基础" class="headerlink" title="内存存储：速度的基础"></a>内存存储：速度的基础</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1697359566311-83361749-be9b-4c5a-982c-50fc07424fa7-20231023132823501.png" alt="img"></p><p>Redis 是一个内存数据库，<strong>它的数据存储在内存中，而计算机访问内存比起磁盘读写要快出数个数量级</strong>。因此，相较其他需要从磁盘读取数据的传统数据库而言，Redis 的速度要快得多。内存存储使Redis天生就具备了高速基因，这只是它快速的基础。</p><p>此外，由于数据直接从内存进行读写，而不必过多考虑如何将它们高效地保存到磁盘上（只有将数据以 RDB 的方式持久化时才会面对这个问题），这也使得 Redis 可以直接使用高效的底层数据结构。</p><h1 id="单线程模型：化繁为简的极致"><a href="#单线程模型：化繁为简的极致" class="headerlink" title="单线程模型：化繁为简的极致"></a>单线程模型：化繁为简的极致</h1><p>Redis 是单线程，主要是指 Redis 的网络IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</p><p>多线程必然会面临对于共享资源的访问，这时候通常的做法就是加锁，虽然是多线程，这时候就会变成串行的访问。也就是多线程编程模式会面临的共享资源的并发访问控制问题。</p><p>同时多线程也会引入同步原语来保护共享资源的并发访问，代码的可维护性和易读性将会下降。</p><p>Redis 的线程模型在不同版本有所不同：</p><ul><li><strong>2.0 版本</strong>：Redis 使用单个线程在事件循环中处理网络请求与执行操作指令，然后其他的后台线程负责释放 RDB/AOF 过程生成的临时文件资源与刷盘；</li><li><strong>4.0 版本</strong>：Redis 添加了一个线程，用于异步执行<code>UNLINK(异步删除指定键)</code>、<code>FLUSHALL ASYNC(清空所有 DB)</code>和<code>FLUSHDB ASYNC(清空指定 DB)</code>这些比较重的删除指令；</li><li><strong>6.0 版本</strong>：Redis 允许通过修改 <code>io-threads</code> 和 <code>io-threads-do-reads</code> 修改 IO 线程数。</li></ul><p>另外一提，读写指令要保持单线程，这个设计的理由是因为 CPU 对内存的操作已经足够高效，因此性能瓶颈不大可能来自于 CPU ，而主要来自于内存和网络 IO，因此执行命令的线程有一个足矣。</p><h1 id="非阻塞I-O：高并发处理的法宝"><a href="#非阻塞I-O：高并发处理的法宝" class="headerlink" title="非阻塞I/O：高并发处理的法宝"></a>非阻塞I/O：高并发处理的法宝</h1><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用 就是为了解决这个问题而出现的。</p><p>Linux 中的IO多路复用机制是指一个线程处理多个IO流。多路是指网络连接，复用指的是同一个线程。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个IO流的效果。</p><p>文件事件是对连接 socket 操作的一个抽象。当端口监听 socket 准备 accept 新连接，或者连接 socket 准备好读取请求、写入响应、关闭时，就会产生一个文件事件。IO 多路复用程序负责同时监听多个 socket，当这些 socket 产生文件事件时，就会触发事件通知，文件分派器就会感知并获取到这些事件。</p><p>虽然多个文件事件可能会并发出现，但 IO 多路复用程序总会将所有产生事件的 socket 放入一个队列中，通过这个队列，有序的把这些文件事件通知给文件分派器。</p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个的函数，他们定义了这个事件发生时，服务器应该执行的动作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-multiple.png" alt="redis"></p><p>Redis 封装了 4 种多路复用程序，每种封装实现都提供了相同的 API 实现。编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，这 3 个多路复用函数都直接使用系统内核内部的结构，可以服务数十万的文件描述符。</p><p>如果当前编译环境没有上述函数，就会选择 select 作为底层实现方案。select 方案的性能较差，事件发生时，会扫描全部监听的描述符，事件复杂度是 O(n)，并且只能同时服务有限个文件描述符，32 位机默认是 1024 个，64 位机默认是 2048 个，所以一般情况下，并不会选择 select 作为线上运行方案。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-choose-multiple.png" alt="redis"></p><h2 id="单线程处理-I-O-请求的性能瓶颈"><a href="#单线程处理-I-O-请求的性能瓶颈" class="headerlink" title="单线程处理 I/O 请求的性能瓶颈"></a>单线程处理 I/O 请求的性能瓶颈</h2><p><strong>1、后台 Redis 通过监听处理事件队列中的消息来通过单线程处理命令，如果一个命令的执行时间很久，就会影响整个 server 的性能；</strong></p><p>耗时的操作命令有下面几种：</p><ol><li>操作 bigkey：bigkey 在写入和删除的时候，需要的时间都会很长；</li><li>使用复杂度过高的命令；</li><li>大量 key 集中过期：Redis 的过期机制也是在主线程中执行的，大量 key 集中过期会导致处理一个请求时，耗时都在删除过期 key，耗时变长；</li><li>淘汰策略：淘汰策略也是在主线程执行的，当内存超过 Redis 内存上限后，每次写入都需要淘汰一些 key，也会造成耗时变长；</li><li>AOF刷盘开启 always 机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢 Redis 的性能；</li><li>主从全量同步生成 RDB：虽然采用 fork 子进程生成数据快照，但 fork 这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</li></ol><p>上面的这几种问题，我们在写业务的时候需要去避免，对于 bigkey，Redis 在4.0推出了 lazy-free 机制，把 bigkey 释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</p><p><strong>2、并发量非常大时，单线程读写客户端 IO 数据存在性能瓶颈</strong></p><p>使用 Redis 时，几乎不存在 CPU 成为瓶颈的情况， Redis 主要受限于内存和网络。随着硬件水平的提升，Redis 中的性能慢慢主要出现在网络 IO 的读写上。虽然采用 I/O 多路复用机制，但是读写客户端数据依旧是同步 IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</p><p>为了提升网络 IO 的读写性能，Redis 在6.0推出了多线程，同过多线程的 IO 来处理网络请求。不过需要注意的是这里的多线程仅仅是针对客户端的读写是并行的，Redis 处理事件队列中的命令，还是单线程处理的。</p><h1 id="高效的数据结构：内功深厚"><a href="#高效的数据结构：内功深厚" class="headerlink" title="高效的数据结构：内功深厚"></a>高效的数据结构：内功深厚</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1697468144147-9007849c-3b9e-412c-98f7-0ba7ac873d04.png" alt="img"></p><p>Redis 的高速很大程度上依赖于它丰富而高效的数据结构，而它们<strong>在底层实现上，都针对不同的使用场景进行了精心的设计和优化</strong>。</p><p>在 <a href="https://zxh3032.github.io/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/">Redis数据结构五兄弟：数据江湖的武林盟主</a>这篇博客中我们详细地分析了 Redis 中的五种基础数据结构以及其底层数据结构，可以非常清楚地看到，为了尽可能地将 Redis 的查询速度提高到极致，每一个基础数据结构的底层都用了最快的解决方案。具体内容可以去看那篇博客，这里就不细致讨论了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Redis为什么这么快？除了依赖内存存储，它还采用了单线程模型、非阻塞I/O、高效的数据结构、智能压缩和优化、以及多种高级特性。这些技术手段结合在一起，使得Redis成为了数据库界的速度王者。如果你还没用过Redis，赶紧试试吧，让它来为你的项目提速，体验飞一般的感觉！</p><p>关于本文讨论的这个内容，其实是一个在面试时经常会被问到的问题，内容其实并不多，主要是 Redis 设计时的一些特性，需要好好理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nageoffer.com/pages/cfb429/">https://nageoffer.com/pages/cfb429/</a></p><p><a href="https://github.com/boilingfrog/Go-POINT/blob/master/redis/1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E5%BF%AB.md#redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%95%88%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87">https://github.com/boilingfrog/Go-POINT/blob/master/redis/1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E5%BF%AB.md#redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%95%88%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 为什么这么快，这是我在了解 Redis 之前最大的疑问，即使你只是刚刚听说 Redis，对 Redis 的查询速度想必也是有所耳闻。&lt;/p&gt;
&lt;p&gt;在没有深入学习之前，我只会回答因为 Redis 是依赖于内存实现的，所以速度快的飞起。但是，仅仅依靠内存，是不是就</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis的键值过期和内存淘汰机制：内存的游戏</title>
    <link href="http://example.com/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <id>http://example.com/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/</id>
    <published>2024-06-08T09:02:09.000Z</published>
    <updated>2024-06-08T11:11:53.416Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个 k-v 型数据库，我们所有的数据都是存放在内存中的，但是内存是有大小限制的，不可能无限制的增量。<br>想要把不需要的数据清理掉，一种办法是直接删除，这个咱们前面章节有详细说过；另外一种就是设置过期时间，缓存过期后，由Redis系统自行删除。<br>这边需要注意的是，缓存过期之后，并不是马上删除的，那Redis是怎么删除过期数据的呢？主要通过两个方式</p><ul><li>惰性删除</li><li>通过定时任务，定期选取部分数据删除</li></ul><p>但是无论是惰性删除还是定期删除，都可能存在删除不尽的情况，无法删除完全，还有就是 Redis 中的使用过程中，随着写数据的增加，Redis 中的内存不够用了，这时候就需要 Redis 的内存淘汰策略了。</p><p>Redis 的「内存淘汰策略」和「过期删除策略」，很容易混淆，这两个机制虽然都是做删除的操作，但是触发的条件和使用的策略都是不同的。</p><ul><li>Redis 过期策略指的是 Redis 使用那种策略，来删除已经过期的键值对；</li><li>Redis 内存淘汰机制指的是，当 Redis 运行内存已经超过 Redis 设置的最大内存之后，将采用什么策略来删除符合条件的键值对，以此来保障 Redis 高效的运行。</li></ul><p>下面还是来详细地看看这些内容以及实现原理吧。</p><h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><h2 id="如何设置过期时间？"><a href="#如何设置过期时间？" class="headerlink" title="如何设置过期时间？"></a>如何设置过期时间？</h2><p>先说一下对 key 设置过期时间的命令。 设置 key 过期时间的命令一共有 4 个：</p><ul><li><code>expire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期；</li><li><code>pexpire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。</li><li><code>expireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；</li><li><code>pexpireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）</li></ul><p>当然，在设置字符串时，也可以同时对 key 设置过期时间，共有 3 种命令：</p><ul><li><code>set &lt;key&gt; &lt;value&gt; ex &lt;n&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到秒）；</li><li><code>set &lt;key&gt; &lt;value&gt; px &lt;n&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到毫秒）；</li><li><code>setex &lt;key&gt; &lt;n&gt; &lt;valule&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到秒）。</li></ul><p>如果你想查看某个 key 剩余的存活时间，可以使用 <code>TTL &lt;key&gt;</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置键值对的时候，同时指定过期时间位 60 秒</span></span><br><span class="line">&gt; setex key1 60 value1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 key1 过期时间还剩多少</span></span><br><span class="line">&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br><span class="line">&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 52</span><br></pre></td></tr></table></figure><p>如果突然反悔，取消 key 的过期时间，则可以使用 <code>PERSIST &lt;key&gt;</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消 key1 的过期时间</span></span><br><span class="line">&gt; persist key1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用完 persist 命令之后，</span></span><br><span class="line"><span class="comment"># 查下 key1 的存活时间结果是 -1，表明 key1 永不过期 </span></span><br><span class="line">&gt; ttl key1 </span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h2 id="如何判定-key-是否过期？"><a href="#如何判定-key-是否过期？" class="headerlink" title="如何判定 key 是否过期？"></a>如何判定 key 是否过期？</h2><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>过期字典存储在 redisDb 结构中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;    <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    ....</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>过期字典数据结构结构如下：</p><ul><li>过期字典的 key 是一个指针，指向某个键对象；</li><li>过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；</li></ul><p>过期字典的数据结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="img"></p><p>字典实际上是<strong>哈希表</strong>，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>过期键判断流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E8%BF%87%E6%9C%9F%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h2 id="过期删除策略有哪些？"><a href="#过期删除策略有哪些？" class="headerlink" title="过期删除策略有哪些？"></a>过期删除策略有哪些？</h2><p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p><ul><li>定时删除；</li><li>惰性删除；</li><li>定期删除；</li></ul><p>接下来，分别分析它们的优缺点。</p><blockquote><p>定时删除策略是怎么样的？</p></blockquote><p>定时删除策略的做法是，<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></p><p>定时删除策略的<strong>优点</strong>：</p><ul><li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li></ul><p>定时删除策略的<strong>缺点</strong>：</p><ul><li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li></ul><blockquote><p>惰性删除策略是怎么样的？</p></blockquote><p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>惰性删除策略的<strong>优点</strong>：</p><ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul><p>惰性删除策略的<strong>缺点</strong>：</p><ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li></ul><blockquote><p>定期删除策略是怎么样的？</p></blockquote><p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>定期删除策略的<strong>优点</strong>：</p><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul><p>定期删除策略的<strong>缺点</strong>：</p><ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><h3 id="Redis-过期删除策略是什么？"><a href="#Redis-过期删除策略是什么？" class="headerlink" title="Redis 过期删除策略是什么？"></a>Redis 过期删除策略是什么？</h3><p>前面介绍了三种过期删除策略，每一种都有优缺点，仅使用某一个策略都不能满足实际需求。</p><p>所以， <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><blockquote><p>Redis 是怎么实现惰性删除的？</p></blockquote><p>Redis 的惰性删除策略由 db.c 文件中的 <code>expireIfNeeded</code> 函数实现，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p><ul><li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 <code>lazyfree_lazy_expire</code> 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li><li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端；</li></ul><p>惰性删除的流程图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4.jpg" alt="img"></p><blockquote><p>Redis 是怎么实现定期删除的？</p></blockquote><p>再回忆一下，定期删除策略的做法：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><ol><li><p>这个间隔检查的时间是多长呢？</p><p>在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p><p>特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 进行过期检查。</p></li><li><p>随机抽查的数量是多少呢？</p><p>我查了下源码，定期删除的实现在 expire.c 文件下的 <code>activeExpireCycle</code> 函数中，其中随机抽查的数量由 <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code> 定义的，它是写死在代码中的，数值是 20。</p><p>也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。</p></li></ol><p>接下来，详细说说 Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。</p><p>那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><p>针对定期删除的流程，我写了个伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//已过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//随机抽取的数量</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 从过期字典中随机抽取 1 个 key</span></span><br><span class="line">        <span class="comment">//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过时间限制则退出</span></span><br><span class="line">    <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>定期删除的流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h2 id="从库是否会脏读到主键创建地过期键"><a href="#从库是否会脏读到主键创建地过期键" class="headerlink" title="从库是否会脏读到主键创建地过期键"></a>从库是否会脏读到主键创建地过期键</h2><p>阅读惰性删除和定期删除的源码阅读中，我们可以发现，从库对于主库的过期键是不能主动进行删除的。如果一个主库创建的过期键值对，已经过期了，主库在进行定期删除的时候，没有及时的删除掉，这时候从库请求了这个键值对，当执行惰性删除的时候，因为是主库创建的键值对，这时候是不能在从库中删除的，那么是不是就意味着从库会读取到已经过期的数据呢？</p><p>答案肯定不是的。</p><blockquote><p><em>How Redis replication deals with expires on keys Redis expires allow keys to have a limited time to live. Such a feature depends on the ability of an instance to count the time, however Redis slaves correctly replicate keys with expires, even when such keys are altered using Lua scripts. To implement such a feature Redis cannot rely on the ability of the master and slave to have synchronized clocks, since this is a problem that cannot be solved and would result into race conditions and diverging data sets, so Redis uses three main techniques in order to make the replication of expired keys able to work: 1.Slaves don’t expire keys, instead they wait for masters to expire the keys. When a master expires a key (or evict it because of LRU), it synthesizes a DEL command which is transmitted to all the slaves. 2.However because of master-driven expire, sometimes slaves may still have in memory keys that are already logically expired, since the master was not able to provide the DEL command in time. In order to deal with that the slave uses its logical clock in order to report that a key does not exist only for read operations that don’t violate the consistency of the data set (as new commands from the master will arrive). In this way slaves avoid to report logically expired keys are still existing. In practical terms, an HTML fragments cache that uses slaves to scale will avoid returning items that are already older than the desired time to live. 3.During Lua scripts executions no keys expires are performed. As a Lua script runs, conceptually the time in the master is frozen, so that a given key will either exist or not for all the time the script runs. This prevents keys to expire in the middle of a script, and is needed in order to send the same script to the slave in a way that is guaranteed to have the same effects in the data set. Once a slave is promoted to a master it will start to expire keys independently, and will not require any help from its old master.</em></p></blockquote><p>上面是官方文档中针对这一问题的描述</p><p>大概意思就是从节点不会主动删除过期键，从节点会等待主节点触发键过期。当主节点触发键过期时，主节点会同步一个del命令给所有的从节点。</p><p>因为是主节点驱动删除的，所以从节点会获取到已经过期的键值对。从节点需要根据自己本地的逻辑时钟来判断减值是否过期，从而实现数据集合的一致性读操作。</p><p>我们知道 Redis 中的过期策略是惰性删除和定期删除，所以每个键值的操作，都会使用惰性删除来检查是否过期，然后判断是否可以进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/db.c#L1541</span></span><br><span class="line"><span class="comment">// 当访问到 key 的时候，会调用这个函数，因为有的 key 虽然已经过期了，但是还可能存在于内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 仍然有效，函数返回值为0，否则，如果 key 过期，函数返回1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从库的过期是主库控制的，是不会进行删除操作的</span></span><br><span class="line">    <span class="comment">// 上面已经判断过是否到期了，所以这里的 key 肯定设计过期的 key ,不过如果是主节点创建的 key 从节点就不删除，只会返回已经过期了</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">// 删除 key </span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/db.c#L1485</span></span><br><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="type">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有过期</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lua 脚本执行的过程中不过期</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们正在执行一个命令，我们仍然希望使用一个不会改变的引用时间:在这种情况下，我们只使用缓存的时间，我们在每次调用call()函数之前更新。</span></span><br><span class="line">    <span class="comment">// 这样我们就避免了RPOPLPUSH之类的命令，这些命令可能会重新打开相同的键多次，如果下次调用会看到键过期，则会使已经打开的对象在下次调用中失效，而第一次调用没有。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况下，获取最新的时间</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否过期了</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定 key 的过期时间，如果没有过期则返回-1</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的惰性删除，对于主节点创建的过期 key ，虽然不能进行删除的操作，但是可以进行过期时间的判断，所以如果主库创建的过期键，如果主库没有及时进行删除，这时候从库可以通过惰性删除来判断键值对的是否过期，避免读取到过期的内容。</p><h1 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h1><p>前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b9ab9e10-6900-11ea-95ab-8f8eaf73a78b" alt="img"></p><h2 id="如何设置-Redis-最大运行内存？"><a href="#如何设置-Redis-最大运行内存？" class="headerlink" title="如何设置 Redis 最大运行内存？"></a>如何设置 Redis 最大运行内存？</h2><p>在配置文件 redis.conf 中，可以通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。 不同位数的操作系统，maxmemory 的默认值是不同的：</p><ul><li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li><li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li></ul><h2 id="Redis-淘汰机制有哪些？"><a href="#Redis-淘汰机制有哪些？" class="headerlink" title="Redis 淘汰机制有哪些？"></a>Redis 淘汰机制有哪些？</h2><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><em>1、不进行数据淘汰的策略</em></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p><p><em>2、进行数据淘汰的策略</em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><p>在<strong>设置了过期时间的数据</strong>中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在<strong>所有数据</strong>范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><blockquote><p>如何查看当前 Redis 使用的内存淘汰策略？</p></blockquote><p>可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;noeviction&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出，当前 Redis 使用的是 <code>noeviction</code> 类型的内存淘汰策略，它是 Redis 3.0 之后默认使用的内存淘汰策略，表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。</p><blockquote><p>如何修改 Redis 内存淘汰策略？</p></blockquote><p>设置内存淘汰策略有两种方法：</p><ul><li>方式一：通过“<code>config set maxmemory-policy &lt;策略&gt;</code>”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li><li>方式二：通过修改 Redis 配置文件修改，设置“<code>maxmemory-policy &lt;策略&gt;</code>”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li></ul><h2 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h2><p>除了随机删除和不删除之外，主要有两种淘汰算法：LRU 算法和 LFU 算法。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU 全称是<code>Least Recently Used</code>译为最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p><p>一般 LRU 算法的实现基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可。</p><p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间，Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p><h4 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h4><p>Redis 在源码中对于每个键值对中的值，会使用一个 redisObject 结构体来保存指向值的指针，这里先来看下 redisObject 的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/server.h#L673</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 这里保存 </span></span><br><span class="line">    <span class="comment">// LRU时间(相对于全局LRU时钟)</span></span><br><span class="line">    <span class="comment">// LFU数据 (低 8 bits 作为计数器,用 24 bits 中的高 16 bits，记录访问的时间戳)</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>当一个键值对被创建的时候，就会记录下更新的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/object.c#L41  </span></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存替换策略是LFU，那么将lru变量设置为LFU的计数值</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是 lru </span></span><br><span class="line">    <span class="comment">// 调用LRU_CLOCK函数获取LRU时钟值</span></span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时一个键值对被访问的时候记录的时间也会被更新，当一个键值对被访问时，访问操作最终都会调用 lookupKey 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/db.c#L63</span></span><br><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the access time for the ageing algorithm.</span></span><br><span class="line"><span class="comment">         * Don&#x27;t do it if we have a saving child, as this will trigger</span></span><br><span class="line"><span class="comment">         * a copy on write madness. */</span></span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 LRU 更新 lru 的时间</span></span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们分别看了，创建和访问一个键值对的代码，每次操作，redisObject 中记录的 lru 时间就会被同步的更新</p><p>Redis 会判断当前内存的使用情况，如果超过了 maxmemory 配置的值，就会触发新的内存淘汰了</p><p>如果内存超过了 maxmemory 的值，这时候还需要去计算需要释放的内存量，这个释放的内存大小等于已使用的内存量减去 maxmemory。不过，已使用的内存量并不包括用于主从复制的复制缓冲区大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L512</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; (<span class="type">long</span> <span class="type">long</span>)mem_tofree) &#123;</span><br><span class="line">        <span class="type">int</span> j, k, i;</span><br><span class="line">        <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don&#x27;t want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="comment">// 根据淘汰策略，决定使用全局哈希表还是设置了过期时间的key的哈希表</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将选择的哈希表dict传入evictionPoolPopulate函数，同时将全局哈希表也传给evictionPoolPopulate函数</span></span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来填充evictionPool</span></span><br><span class="line"><span class="comment">// 按升序插入键，所以空闲时间小的键在左边，空闲时间高的键在右边。</span></span><br><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L145</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">evictionPoolPopulate</span><span class="params">(<span class="type">int</span> dbid, dict *sampledict, dict *keydict, <span class="keyword">struct</span> evictionPoolEntry *pool)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line"></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将元素插入池中。 首先，找到第一个空闲时间小于我们空闲时间的空桶或第一个填充的桶。</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can&#x27;t insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理淘汰的数据，Redis 中提供了一个数组 EvictionPoolLRU，用来保存待淘汰的候选键值对。这个数组的元素类型是 evictionPoolEntry 结构体，该结构体保存了待淘汰键值对的空闲时间 idle、对应的 key 等信息。</p><p>可以看到上面的上面会选取一定的过期键，然后插入到 EvictionPoolLRU 中</p><p>dictGetSomeKeys 函数采样的 key 的数量，是由 redis.conf 中的配置项 maxmemory-samples 决定的，该配置项的默认值是 5</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L55</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 待淘汰的键值对的空闲时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    <span class="comment">// 待淘汰的键值对的key</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    <span class="comment">// 缓存的SDS对象</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="comment">// 待淘汰键值对的key所在的数据库ID</span></span><br><span class="line">    <span class="type">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span></span><br></pre></td></tr></table></figure><p>然后通过 evictionPoolPopulate 函数，进行采样，然后将采样数据写入到 EvictionPoolLRU 中，插入到 EvictionPoolLRU 中的数据是按照空闲时间从小到大进行排好序的</p><p>freeMemoryIfNeeded 函数会遍历一次 EvictionPoolLRU 数组，从数组的最后一个 key 开始选择，如果选到的 key 不是空值，那么就把它作为最终淘汰的 key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L512</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSafeToPerformEvictions()) <span class="keyword">return</span> EVICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> keys_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> mem_reported, mem_tofree;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mem_freed; <span class="comment">/* May be negative */</span></span><br><span class="line">    <span class="type">mstime_t</span> latency, eviction_latency;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> delta;</span><br><span class="line">    <span class="type">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="type">int</span> result = EVICT_FAIL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> EVICT_OK;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; (<span class="type">long</span> <span class="type">long</span>)mem_tofree) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="comment">// 从数组最后一个key开始查找</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="comment">// 当前key为空值，则查找下一个key</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从全局哈希表或是expire哈希表中，获取当前key对应的键值对；</span></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="comment">// 将当前key从EvictionPoolLRU数组删除</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="comment">// 如果当前key对应的键值对不为空，选择当前key为被淘汰的key</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">            delta = (<span class="type">long</span> <span class="type">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="comment">// 惰性删除</span></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 同步删除</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次选中一部分过期的键值对，每次淘汰最久没有使用的那个，如果释放的内存空间还不够，就会重复的进行采样，删除的过程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240608182614556.png" alt="image-20240608182614556"></p><h4 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h4><p>LRU 算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰，因此在 Redis 4.0 之后引入了 LFU 算法，下面我们一起来看。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU 全称是 <code>Least Frequently Used</code> 翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>LFU 解决了偶尔被访问一次之后，数据就不会被淘汰的问题，相比于 LRU 算法也更合理一些。</p><p>上面分析 LRU 的时候，聊到了 redisObject，Redis 在源码中对于每个键值对中的值，会使用一个 redisObject 结构体来保存指向值的指针。里面 <code>lru:LRU_BITS</code> 字段记录了 LRU 算法和 LFU 算法需要的时间和计数器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/lru%E5%AD%97%E6%AE%B5.png" alt="img"></p><ul><li>ldt 是用来记录 key 的访问时间戳；</li><li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li></ul><p>logc 并不是单纯的访问次数，而是<strong>访问频次（访问频率）</strong>，因为 <strong>logc 会随时间推移而衰减的</strong>。</p><p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L298</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> &#123;</span><br><span class="line">    <span class="comment">// 等于255，不在进行次数的更新</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 计算一个随机数</span></span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="comment">// 计算当前访问次数和初始值的差值</span></span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据baseval和lfu_log_factor计算阈值p</span></span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 概率值小于阀值</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前访问次数小于255的时候，每次 <code>LFULogIncr</code> 函数会计算一个阈值 p，以及一个取值为 0 到 1 之间的随机概率值 r。如果概率 r 小于阈值 p，那么 <code>LFULogIncr</code> 函数才会将logc 加 1。否则的话，<code>LFULogIncr</code> 函数会返回当前的logc ，不做更新。</p><p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p><ol><li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li><li>然后，再按照一定概率增加 logc 的值</li></ol><p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p><ul><li><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，<code>lfu-decay-time</code> 值越大，衰减越慢；</li><li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，<code>lfu-log-factor</code> 值越大，logc 增长越慢。</li></ul><h4 id="使用-LFU-算法淘汰数据"><a href="#使用-LFU-算法淘汰数据" class="headerlink" title="使用 LFU 算法淘汰数据"></a><strong>使用 LFU 算法淘汰数据</strong></h4><p>LFU 处理数据淘汰和 LRU 方式差不多，这里回顾下 LRU 处理数据淘汰的过程</p><ul><li>1、调用 getMaxmemoryState 函数计算待释放的内存空间；</li><li>2、调用 evictionPoolPopulate 函数随机采样键值对，并插入到待淘汰集合 EvictionPoolLRU 中；</li><li>3、遍历待淘汰集合 EvictionPoolLRU，选择实际被淘汰数据，并删除。</li></ul><p>不同的是，LFU 算法在淘汰数据时，在第二步的 evictionPoolPopulate 函数中，使用了不同的方法来计算每个待淘汰键值对的空闲时间。</p><p>LRU 中 idle 记录的是它距离上次访问的空闲时间。</p><p>LFU 中 idle 记录的是用 255 减去键值对的 logc。也就是键值对访问次数越大，它的 idle 值就越小，反之 idle 值越大。</p><p><code>freeMemoryIfNeeded</code> 函数按照 idle 值从大到小，遍历 <code>EvictionPoolLRU</code> 数组，选择实际被淘汰的键值对时，它就能选出访问次数小的键值对了，也就是把访问频率低的键值对淘汰出去。</p><h3 id="为什么数据删除后内存占用还是很高？"><a href="#为什么数据删除后内存占用还是很高？" class="headerlink" title="为什么数据删除后内存占用还是很高？"></a>为什么数据删除后内存占用还是很高？</h3><p>Redis 中的内存可能会遇到这样一种情况，虽然进行了数据的删除，数据量已经不大了，但是使用 top 命令，发现 Redis 还是会占用大量的内存</p><p>因为，当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存。</p><p>但是这些内存可能是不连续的，对于不连续的小内存块，虽然是空闲内存，但是 Redis 却不能拿来用，会造成资源的浪费。</p><p>为什么会产生内存碎片呢？</p><h4 id="内存碎片如何产生？"><a href="#内存碎片如何产生？" class="headerlink" title="内存碎片如何产生？"></a>内存碎片如何产生？</h4><p><strong>1、内存分配器的分配策略</strong></p><p>内存分配器对于内存的分配，一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</p><p>Redis 可以使用 <code>libc、jemalloc、tcmalloc</code> 多种内存分配器来分配内存，默认使用 jemalloc。</p><p>jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如8字节、16字节、32字节、48字节，…, 2KB、4KB、8KB等。当程序申请的内存最接近某个固定值时，jemalloc会给它分配相应大小的空间。</p><p>这样的分配方式本身是为了减少分配次数。例如，Redis申请一个20字节的空间保存数据，jemalloc 就会分配 32 字节，此时，如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间了，因为刚才分配的32字节已经够用了，这就避免了一次分配操作。</p><p>减少了内存分配的次数，缺点就是增加了产生内存碎片的可能。</p><p><strong>2、键值对的删除更改操作</strong></p><p>Redis 中键值对会被修改和删除，这会导致空间的扩容和释放，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p><p>Redis中的值删除的时候，并没有把内存直接释放，交还给操作系统，而是交给了Redis内部有内存管理器。</p><p>Redis 中申请内存的时候，也是先看自己的内存管理器中是否有足够的内存可用。Redis的这种机制，提高了内存的使用率，但是会使 Redis 中有部分自己没在用，却不释放的内存，导致了内存碎片的发生。</p><h4 id="碎片率的意义"><a href="#碎片率的意义" class="headerlink" title="碎片率的意义"></a>碎片率的意义</h4><p><code>mem_fragmentation_ratio</code>的不同值，说明不同的情况。</p><ul><li>大于1：说明内存有碎片，一般在1到1.5之间是正常的；</li><li>大于1.5：说明内存碎片率比较大，需要考虑是否要进行内存碎片清理，要引起重视；</li><li>小于1：说明已经开始使用交换内存，也就是使用硬盘了，正常的内存不够用了，需要考虑是否要进行内存的扩容。</li></ul><p>可以使用 INFO memory 命令查看内存碎片率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO memory</span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:865672</span><br><span class="line">used_memory_human:845.38K</span><br><span class="line">used_memory_rss:8085504</span><br><span class="line">used_memory_rss_human:7.71M</span><br><span class="line">used_memory_peak:865672</span><br><span class="line">used_memory_peak_human:845.38K</span><br><span class="line">used_memory_peak_perc:100.01%</span><br><span class="line">used_memory_overhead:819226</span><br><span class="line">used_memory_startup:802056</span><br><span class="line">used_memory_dataset:46446</span><br><span class="line">used_memory_dataset_perc:73.01%</span><br><span class="line">allocator_allocated:995552</span><br><span class="line">allocator_active:1282048</span><br><span class="line">allocator_resident:3690496</span><br><span class="line">total_system_memory:1929736192</span><br><span class="line">total_system_memory_human:1.80G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.29</span><br><span class="line">allocator_frag_bytes:286496</span><br><span class="line">allocator_rss_ratio:2.88</span><br><span class="line">allocator_rss_bytes:2408448</span><br><span class="line">rss_overhead_ratio:2.19</span><br><span class="line">rss_overhead_bytes:4395008</span><br><span class="line">mem_fragmentation_ratio:9.80</span><br><span class="line">mem_fragmentation_bytes:7260856</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:16986</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure><p>mem_fragmentation_ratio 表示的就是内存碎片率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_fragmentation_ratio = used_memory_rss/ used_memory</span><br></pre></td></tr></table></figure><p>used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；而 used_memory 是 Redis 为了保存数据实际申请使用的空间。</p><h4 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h4><p>Redis服务器重启后，Redis会将没用的内存归还给操作系统，碎片率会降下来；</p><p>4.0 版本的 Redis 引入了自动内存碎片清理的功能。</p><p>自动碎片清理，只要设置了如下的配置，内存就会自动清理了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set activedefrag yes</span><br></pre></td></tr></table></figure><p>不过对于具体什么时候开始，受下面两个参数的控制，只要一个不满足就停止自动清理</p><ul><li>active-defrag-ignore-bytes 100mb：表示内存碎片的字节数达到100MB时，开始清理；</li><li>active-defrag-threshold-lower 10：表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。</li></ul><p>为了保证清理过程中对 CPU 的影响，还设置了两个参数，分别用于控制清理操作占用的CPU时间比例的上、下限，既保证清理工作能正常进行，又避免了降低Redis性能。</p><ul><li>active-defrag-cycle-min 25： 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；</li><li>active-defrag-cycle-max 75：表示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。 </li></ul><p>如果你对自动清理的效果不满意，可以使用如下命令，直接试下手动碎片清理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory purge</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis 使用的过期删除策略是「惰性删除+定期删除」，删除的对象是已过期的 key。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p>内存淘汰策略是解决内存过大的问题，当 Redis 的运行内存超过最大运行内存时，就会触发内存淘汰策略，Redis 4.0 之后共实现了 8 种内存淘汰策略，我也对这 8 种的策略进行分类，如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p>Redis 一切操作都是为了保证高效、灵活地利用内存，提供飞快的读写速度。希望你看完这篇文章，对 Redis 的键值过期操作和内存淘汰机制有了一个轻松愉快的了解。记住，Redis 虽然是个内存管理高手，但也需要你合理设置过期时间和选择合适的淘汰策略，这样才能愉快地玩耍下去！</p><p>更加深入的东西还是需要通过源码来进行学习，仅仅通过别人的博客还是学不到深入的内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/23%20%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6%e4%b8%8e%e7%ae%97%e6%b3%95.md">内存淘汰机制与算法</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/17%20Redis%20%e9%94%ae%e5%80%bc%e8%bf%87%e6%9c%9f%e6%93%8d%e4%bd%9c.md">键值过期操作</a></p><p><a href="https://www.xiaolincoding.com/redis/module/strategy.html">Redis 过期删除策略和内存淘汰策略有什么区别？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 是一个 k-v 型数据库，我们所有的数据都是存放在内存中的，但是内存是有大小限制的，不可能无限制的增量。&lt;br&gt;想要把不需要的数据清理掉，一种办法是直接删除，这个咱们前面章节有详细说过；另外一种就是设置过期时间，缓存过期后，由Redis系统自行删除。&lt;br&gt;这边</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务的深潜之旅：像个老司机一样操作数据！</title>
    <link href="http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/"/>
    <id>http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/</id>
    <published>2024-06-08T07:57:12.000Z</published>
    <updated>2024-06-08T11:11:53.406Z</updated>
    
    <content type="html"><![CDATA[<p>在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。</p><p>那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？</p><p>为了解开这些疑问，也为了能更加熟练地掌握 Redis，成为一个老司机。今天，我们就来学习 Redis 事务相关的内容。</p><h1 id="什么是Redis事务？"><a href="#什么是Redis事务？" class="headerlink" title="什么是Redis事务？"></a>什么是Redis事务？</h1><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h1 id="事务的基本使用"><a href="#事务的基本使用" class="headerlink" title="事务的基本使用"></a>事务的基本使用</h1><p>事务在其他语言中，一般分为以下三个阶段：</p><ul><li>开启事务——Begin Transaction</li><li>执行业务代码，提交事务——Commit Transaction</li><li>业务处理中出现异常，回滚事务——Rollback Transaction</li></ul><p>以 Java 中的事务执行为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 中的事务从开始到结束也是要经历三个阶段：</p><ul><li>开启事务</li><li>命令入列</li><li>执行事务/放弃事务</li></ul><p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p><p>下面一一介绍关于事务的命令。</p><h2 id="MULTI：聚会的开场白"><a href="#MULTI：聚会的开场白" class="headerlink" title="MULTI：聚会的开场白"></a>MULTI：聚会的开场白</h2><p>multi 命令用于开启事务，实现代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f2898390-5ddf-11ea-9d6d-67bd1a14f4fe" alt="img"></p><p>当客户端是非事务状态时，使用 multi 命令，客户端会返回结果 OK，如果客户端已经是事务状态，再执行 multi 命令会提示 multi 命令不能嵌套的错误，但不会终止客户端为事务的状态，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3aa4ae70-5de0-11ea-9d6d-67bd1a14f4fe" alt="img"></p><h2 id="常规命令：聚会人员入场"><a href="#常规命令：聚会人员入场" class="headerlink" title="常规命令：聚会人员入场"></a>常规命令：聚会人员入场</h2><p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>执行流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68d8d640-5de0-11ea-9d6d-67bd1a14f4fe" alt="img"></p><p>命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p><h2 id="EXEC：行动的高潮"><a href="#EXEC：行动的高潮" class="headerlink" title="EXEC：行动的高潮"></a>EXEC：行动的高潮</h2><p>执行事务的命令是 exec，输入 exec 后会执行开启事务后的所有操作。执行事务示例代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e31a4ab0-5de0-11ea-9359-3b811418c7dd" alt="img"></p><h2 id="DISCARD：优雅的撤退"><a href="#DISCARD：优雅的撤退" class="headerlink" title="DISCARD：优雅的撤退"></a>DISCARD：优雅的撤退</h2><p>放弃事务的命令是 discard，有时候，事情并不像你预想的那样发展，你决定取消事务。DISCARD就是你的优雅撤退，所有的准备工作都被抛之脑后，大家都当做什么都没发生过一样。</p><p>放弃事务示例代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">discard</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>具体的执行流程和 exec 一致。</p><h2 id="WATCH：秘密特工的侦查"><a href="#WATCH：秘密特工的侦查" class="headerlink" title="WATCH：秘密特工的侦查"></a>WATCH：秘密特工的侦查</h2><p>WATCH就是你在事务前的小心侦查，确保一切都在你的掌控之中。如果有人试图偷偷溜进来搞破坏，WATCH会立刻发出警报，保护你的数据不被篡改。</p><p>watch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个<strong>监控项被修改</strong>了，那么<strong>整个事务</strong>就会<strong>终止执行</strong>。</p><p>watch 基本语法如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure><p><code>watch</code> 示例代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p><p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 <code>get k</code> 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p><p>执行流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/191ad650-5de3-11ea-9e57-957b6467a3fc" alt="img"></p><p><strong>注意</strong>： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">(error) ERR WATCH inside MULTI is not allowed</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure><p>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</p><p>unwatch 示例如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">unwatch</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>以下是事务在 Java 中的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置键值</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启监视 watch</span></span><br><span class="line">        jedis.watch(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 开始事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="comment">// 命令入列</span></span><br><span class="line">        tx.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        tx.exec();</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事务出现错误的处理"><a href="#事务出现错误的处理" class="headerlink" title="事务出现错误的处理"></a>事务出现错误的处理</h1><p>事务执行中的错误分为以下三类：</p><ul><li>执行时才会出现的错误（简称：执行时错误）；</li><li>入列时错误，不会终止整个事务；</li><li>入列时错误，会终止整个事务。</li></ul><h2 id="执行时出错"><a href="#执行时出错" class="headerlink" title="执行时出错"></a>执行时出错</h2><p>执行命令解释如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/aa0ca950-5de2-11ea-9e6b-b3dcd9fe8595" alt="img"></p><p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p><h2 id="入列错误不会导致事务结束"><a href="#入列错误不会导致事务结束" class="headerlink" title="入列错误不会导致事务结束"></a>入列错误不会导致事务结束</h2><p>执行命令解释如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/cc4111f0-5de2-11ea-9e6b-b3dcd9fe8595" alt="img"></p><p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果。</p><h2 id="入列错误导致事务结束"><a href="#入列错误导致事务结束" class="headerlink" title="入列错误导致事务结束"></a>入列错误导致事务结束</h2><p>执行命令解释如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fd00c6a0-5de2-11ea-9d6f-15d639c92acd" alt="img"></p><p>当然可以！让我们详细探讨一下Redis事务的局限性，揭开这种“完美的幻觉”，看看有哪些实际中的限制和注意事项。</p><h1 id="Redis事务的局限：完美的幻觉？"><a href="#Redis事务的局限：完美的幻觉？" class="headerlink" title="Redis事务的局限：完美的幻觉？"></a>Redis事务的局限：完美的幻觉？</h1><p>Redis事务通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>和<code>DISCARD</code>等命令实现了一定程度上的事务处理。然而，与传统关系型数据库的事务机制相比，Redis事务仍然存在一些局限性。</p><h2 id="乐观锁的陷阱"><a href="#乐观锁的陷阱" class="headerlink" title="乐观锁的陷阱"></a>乐观锁的陷阱</h2><p><strong>概念：</strong> Redis通过<code>WATCH</code>命令实现乐观锁。<code>WATCH</code>命令用于监视一个或多个键，当事务执行期间，如果这些键发生变化（例如被其他客户端修改），则事务会失败。</p><p><strong>局限性：</strong> </p><ul><li><strong>冲突频繁：</strong> 在高并发环境下，如果监视的键频繁被修改，事务成功的概率会降低，需要多次重试。</li><li><strong>数据竞争：</strong> 乐观锁适用于数据冲突较少的场景，对于高冲突的场景可能并不合适。</li></ul><h2 id="缺乏回滚机制"><a href="#缺乏回滚机制" class="headerlink" title="缺乏回滚机制"></a>缺乏回滚机制</h2><p><strong>概念：</strong> 在传统关系型数据库中，如果事务中的某个操作失败，可以回滚事务，撤销已经执行的操作。但是在Redis中，一旦执行<code>EXEC</code>命令，所有命令都会被依次执行，不支持部分回滚。</p><p><strong>局限性：</strong></p><ul><li><strong>不可中断：</strong> 一旦事务开始执行，无法中途停止或回滚已经成功的操作。</li><li><strong>操作不可逆：</strong> 如果事务中的某个操作失败，必须手动处理恢复或补救措施，不能依赖自动回滚。</li></ul><h1 id="更加深入的理解"><a href="#更加深入的理解" class="headerlink" title="更加深入的理解"></a>更加深入的理解</h1><h2 id="为什么-Redis-不支持回滚？"><a href="#为什么-Redis-不支持回滚？" class="headerlink" title="为什么 Redis 不支持回滚？"></a>为什么 Redis 不支持回滚？</h2><blockquote><p>如果你有使用关系式数据库的经验， 那么 “<strong>Redis 在事务失败时不进行回滚，而是继续执行余下的命令</strong>”这种做法可能会让你觉得有点奇怪。</p></blockquote><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， <strong>回滚并不能解决编程错误带来的问题</strong>。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p><h2 id="如何理解-Redis-与事务的-ACID？"><a href="#如何理解-Redis-与事务的-ACID？" class="headerlink" title="如何理解 Redis 与事务的 ACID？"></a>如何理解 Redis 与事务的 ACID？</h2><blockquote><p>一般来说，事务有四个性质称为ACID，分别是原子性，一致性，隔离性和持久性。这是基础，但是很多文章对Redis 是否支持ACID有一些异议，我觉的有必要梳理下：</p></blockquote><ul><li><strong>原子性 Atomicity</strong></li></ul><p>首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。</p><p>Redis官方文档给的理解是，<strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行</strong>。而不是完全成功。</p><ul><li><strong>一致性 Consistency</strong></li></ul><p>Redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非Redis进程意外终结。</p><ul><li><strong>隔离性 Isolation</strong></li></ul><p>Redis事务是严格遵守隔离性的，原因是Redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。</p><p>但是，Redis不像其它结构化数据库有隔离级别这种设计。</p><ul><li><strong>持久性 Durability</strong></li></ul><p><strong>Redis事务是不保证持久性的</strong>，这是因为Redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</p><p>关于 Redis 事务能不能保证 ACID这一问题，我在网上也是众说纷纭，但是在 <strong>一致性</strong> 和 <strong>隔离性</strong> 上，大家都保持着相同的看法，那就是能保证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 Redis 事务的全部内容了，内容并不多，没有在学习 MySQL 时的海量内容，也可以看出其实在 Redis 中并不会很频繁的使用到事务，算一个小知识点吧。</p><p>我是怎么得出这个结论的？因为小林coding写的八股文中都找不到和事务相关的内容，所以我断言它不重要。</p><p>前天晚上死活睡不着，熬了个通宵之后直接来了一个说走就走的旅行，岳阳还是很好玩的。不得不说，晚上确实是一个容易冲动消费的时间，纠结了两周的耳机还是买了，不过不知道为什么没有之前买东西的那种期待感了。</p><p>这里就不得不吐槽一下京东了，太呆瓜了，我在晚上冲动消费后，中午觉得这样不行所以决定退了，但是思考两分钟后又觉得得买，所以我就取消了我的取消申请，客服同意后，快递竟然还是被退回来。我联系客服，客服跟我说没办法了。然后我就又申请了退款，结果快递又开始配送了，不得不联系美女客服帮我退款。京东找个真人客服是真难。害的我还得再等一天。</p><p>昨天高考开始，竟然没刷到几个丢准考证和身份证的，看来今年的学生学聪明了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7203274235425505336">redis 事务能保证ACID吗</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html">Redis 事务</a></p><p><a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">Redis 事务解析</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/16%20Redis%20%e4%ba%8b%e5%8a%a1%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90.md">Redis事务深度解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。&lt;/p&gt;
&lt;p&gt;那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构五兄弟：数据江湖的武林盟主</title>
    <link href="http://example.com/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/"/>
    <id>http://example.com/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/</id>
    <published>2024-06-05T12:56:19.000Z</published>
    <updated>2024-06-06T04:48:58.607Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习 Redis 相关的知识，Redis 的五种基础数据结构。虽然在之前的博客中也有提到过这五种数据结构，当时赶着背东西，基本上就是从别人的八股文里抄的，所以还是重新学一下，重新记录加深记忆，正文开始。</p><p>在数据的江湖里，Redis无疑是那位神秘莫测、武功高强的武林盟主。今天，我们要介绍的就是Redis的五个顶级弟子（Redis 到现在已经有 9 种数据结构了），他们各怀绝技，行走江湖无往不利。话不多说，让我们一睹这五兄弟的风采！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我知道现在你已经迫不及待的想要了解这五个大侠了，但是在正式学习这些之前，我们先来了解一下 Redis 武林中的一些“潜规则”。</p><h2 id="Redis的两层数据结构简介"><a href="#Redis的两层数据结构简介" class="headerlink" title="Redis的两层数据结构简介"></a>Redis的两层数据结构简介</h2><p>Redis 为什么会有如此高的性能？这也是一个老生常谈的问题了，其中之一的原因就是它的每种数据结构都是经过专门设计的，并都有一种或多种数据结构来支持，依赖这些灵活的数据结构，来提升读取和写入的性能。</p><p>想要了解Redis的数据结构，可以从两个不同的层面来讨论它：</p><ol><li>第一个层面，是从使用者的角度，这一层面也是Redis暴露给外部的调用接口，比如：<ul><li>string</li><li>list</li><li>hash</li><li>set</li><li>sorted set</li></ul></li><li>第二个层面，是从内部实现的角度，属于更底层的实现，比如：<ul><li>dict</li><li>sds</li><li>ziplist</li><li>quicklist</li><li>skiplist</li><li>intset</li></ul></li></ol><p>本文会先从第一个层面来了解 Redis 的基础操作，再深入学习其底层原理。</p><h2 id="redisObject：两层数据结构的桥梁"><a href="#redisObject：两层数据结构的桥梁" class="headerlink" title="redisObject：两层数据结构的桥梁"></a><code>redisObject</code>：两层数据结构的桥梁</h2><h3 id="什么是redisObject？"><a href="#什么是redisObject？" class="headerlink" title="什么是redisObject？"></a>什么是<code>redisObject</code>？</h3><p>从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系，这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash, set, sorted set等。<br> 而从 Redis 内部实现的角度来看，database 内的这个映射关系是用一个 dict 来维护的。dict 的 key固定用一种数据结构来表达就够了，这就是动态字符串 sds；而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是 robj，全名是<code>redisObject</code>。</p><blockquote><p>举个例子：</p><ul><li><p>如果value是list类型，那么它的内部存储结构是一个quicklist或者是一个ziplist</p></li><li><p>如果value是string类型，那么它的内部存储结构一般情况下是一个sds。但如果string类型的value的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。</p></li></ul><p>所以，一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p></blockquote><h3 id="Redis-的数据结构定义"><a href="#Redis-的数据结构定义" class="headerlink" title="Redis 的数据结构定义"></a>Redis 的数据结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><strong>一个 robj 包含如下 5 个字段</strong></p><ul><li><p>type: 对象的数据类型。占4个bit。可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构</p></li><li><p>encoding: 对象的内部表示方式（也可以称为编码）。占4个 bit。可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。</p></li><li>lru: 做LRU替换算法用，占24个bit。这个不是我们这里讨论的重点，暂时忽略。</li><li>refcount: 引用计数。它允许robj对象在某些情况下被共享。</li><li>ptr: 数据指针。指向真正的数据。比如，一个代表string的 robj，它的 ptr 可能指向一个 sds 结构；一个代表 list 的 robj，它的 ptr 可能指向一个 quicklist。</li></ul><p><strong>encoding字段的说明</strong></p><p>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><blockquote><p>当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p><ul><li><p>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。</p></li><li><p>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。</p></li><li>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。</li></ul><p>当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p><ul><li>OBJ_ENCODING_HT: hash采用一个dict来表示</li><li>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示</li></ul></blockquote><p><strong>10种encoding的取值说明</strong></p><ul><li><p>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。</p></li><li><p>OBJ_ENCODING_INT: 表示成数字。实际用long表示。</p></li><li>OBJ_ENCODING_HT: 表示成dict。</li><li>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。</li><li>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。</li><li>OBJ_ENCODING_ZIPLIST: 表示成ziplist。</li><li>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。</li><li>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。</li><li>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。</li><li>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</li></ul><h3 id="robj-的作用"><a href="#robj-的作用" class="headerlink" title="robj 的作用"></a>robj 的作用</h3><ul><li><code>redisObject</code>就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪些第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist等），则通过不同的encoding来区分。可以说，robj是联结两个层面的数据结构的桥梁。</li><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li><li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/720b2e10a6cc4f009963d0af153a2351.png" alt="img"></p><p>好了，在了解完武林江湖的一些潜规则后，我们就可以正式进入这个江湖了，可以避免露头秒了。</p><h1 id="字符串（String）：一招制敌的快剑手"><a href="#字符串（String）：一招制敌的快剑手" class="headerlink" title="字符串（String）：一招制敌的快剑手"></a>字符串（String）：一招制敌的快剑手</h1><p>首先登场的是字符串，这位老大哥简直是个“快剑手”，动作迅捷、干脆利落。他就像是江湖上的独行侠，擅长简单直接的攻击方式。字符串可以存储任何类型的数据：文本、数字甚至二进制数据，只要你给的，他都能快速接住。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151104537-442214557.png" alt="img"></p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作，下面我们分别来看，后面其他数据结构也都会按照这样的顺序讲解。</p><h3 id="命令行操作方式"><a href="#命令行操作方式" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值</td></tr><tr><td>MSET key1 value1 key2 value2 …</td><td>设置一个或多个指定 key 的值</td></tr><tr><td>MGET key1 key2 …</td><td>获取一个或多个指定 key 的值</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值(整型和浮点型)增一</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值(整型和浮点型)减一</td></tr><tr><td>INCRBY/DECRBY key increment</td><td>将 key 中储存的数字值(整型和浮点型)加/减 increment</td></tr><tr><td>EXISTS key</td><td>判断指定 key 是否存在</td></tr><tr><td>DEL key（通用）</td><td>删除指定的 key</td></tr><tr><td>EXPIRE key seconds（通用）</td><td>给指定 key 设置过期时间</td></tr><tr><td>APPEND key value</td><td>给指定 key 后面追加值 value</td></tr></tbody></table></div><p>更多 Redis String 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=string">Redis 官网</a> 对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）"><a href="#代码操作方式（采用Go-Redis-V8-版本）" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p><strong>常用方法:</strong></p><ul><li>Keys():根据正则获取keys</li><li>Type():获取key对应值得类型</li><li>Del():删除缓存项</li><li>Exists():检测缓存项是否存在</li><li>Expire(),ExpireAt():设置有效期</li><li>TTL(),PTTL():获取有效期</li><li>DBSize():查看当前数据库key的数量</li><li>FlushDB():清空当前数据</li><li>FlushAll():清空所有数据库</li><li>Set():设置键缓存</li><li>SetEX():设置并指定过期时间</li><li>SetNX():设置并指定过期时间,仅当key不存在的时候才设置。</li><li>Get():获取键值</li><li>GetRange():字符串截取</li><li>Incr():增加+1</li><li>IncrBy():按指定步长增加</li><li>Decr():减少-1</li><li>DecrBy():按指定步长减少</li><li>Append():追加</li><li>StrLen():获取长度</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis String Set/Get 示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGetExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.Set 设置 key 如果设置为-1则表示永不过期</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;score&quot;</span>, <span class="number">100</span>, <span class="number">60</span>*time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;set score failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Get 获取已存在的Key其存储的值</span></span><br><span class="line">val1, err := rdb.Get(ctx, <span class="string">&quot;score&quot;</span>).Result() <span class="comment">// 获取其值</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get score failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;val1 -&gt; score ：%v\n&quot;</span>, val1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取一个不存在的值返回redis.Nil 则说明不存在</span></span><br><span class="line">val2, err := rdb.Get(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[ERROR] - Key [name] not exist&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get name failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exists() 方法用于检测某个key是否存在</span></span><br><span class="line">n, _ := rdb.Exists(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name key 存在!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name key 不存在!&quot;</span>)</span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;weiyi&quot;</span>, <span class="number">60</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line">val2, _ = rdb.Get(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;val2 -&gt; name : &quot;</span>, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.SetNX 当不存在key时将进行设置该可以并设置其过期时间</span></span><br><span class="line">val3, err := rdb.SetNX(ctx, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;weiyigeek&quot;</span>, <span class="number">0</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;set username failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;val3 -&gt; username: %v\n&quot;</span>, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.Keys() 根据正则获取keys, DBSize() 查看当前数据库key的数量.</span></span><br><span class="line">keys, _ := rdb.Keys(ctx, <span class="string">&quot;*&quot;</span>).Result()</span><br><span class="line">num, err := rdb.DBSize(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;All Keys : %v, Keys number : %v \n&quot;</span>, keys, num)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据前缀获取Key</span></span><br><span class="line">  vals, _ := rdb.Keys(ctx, <span class="string">&quot;user*&quot;</span>).Result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.Type() 方法用户获取一个key对应值的类型</span></span><br><span class="line">vType, err := rdb.Type(ctx, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;username key type : %v\n&quot;</span>, vType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.Expire()方法是设置某个时间段(time.Duration)后过期，ExpireAt()方法是在某个时间点(time.Time)过期失效.</span></span><br><span class="line">val4, _ := rdb.Expire(ctx, <span class="string">&quot;name&quot;</span>, time.Minute*<span class="number">2</span>).Result()</span><br><span class="line"><span class="keyword">if</span> val4 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name 过期时间设置成功&quot;</span>, val4)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name 过期时间设置失败&quot;</span>, val4)</span><br><span class="line">&#125;</span><br><span class="line">val5, _ := rdb.ExpireAt(ctx, <span class="string">&quot;username&quot;</span>, time.Now().Add(time.Minute*<span class="number">2</span>)).Result()</span><br><span class="line"><span class="keyword">if</span> val5 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;username 过期时间设置成功&quot;</span>, val5)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;username 过期时间设置失败&quot;</span>, val5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.TTL()与PTTL()方法可以获取某个键的剩余有效期</span></span><br><span class="line">userTTL, _ := rdb.TTL(ctx, <span class="string">&quot;user&quot;</span>).Result() <span class="comment">// 获取其key的过期时间</span></span><br><span class="line">usernameTTL, _ := rdb.PTTL(ctx, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;user TTL : %v, username TTL : %v\n&quot;</span>, userTTL, usernameTTL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.Del():删除缓存项与FlushDB():清空当前数据</span></span><br><span class="line">  <span class="comment">// 当通配符匹配的key的数量不多时，可以使用Keys()得到所有的key在使用Del命令删除。</span></span><br><span class="line">num, err = rdb.Del(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Del() : &quot;</span>, num)</span><br><span class="line">  <span class="comment">// 如果key的数量非常多的时候，我们可以搭配使用Scan命令和Del命令完成删除。</span></span><br><span class="line">  iter := rdb.Scan(ctx, <span class="number">0</span>, <span class="string">&quot;user*&quot;</span>, <span class="number">0</span>).Iterator()</span><br><span class="line">  <span class="keyword">for</span> iter.Next(ctx) &#123;</span><br><span class="line">    err := rdb.Del(ctx, iter.Val()).Err()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := iter.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.清空当前数据库，因为连接的是索引为0的数据库，所以清空的就是0号数据库</span></span><br><span class="line">flag, err := rdb.FlushDB(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;FlushDB() : &quot;</span>, flag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>redis数据库中字符串与整型操作实践</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringIntExample 数据类型演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringIntExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置字符串类型的key</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetRange ：字符串截取</span></span><br><span class="line"><span class="comment">// 注：即使key不存在，调用GetRange()也不会报错，只是返回的截取结果是空&quot;&quot;,可以使用fmt.Printf(&quot;%q\n&quot;, val)来打印测试</span></span><br><span class="line">val1, _ := rdb.GetRange(ctx, <span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">4</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: hello, value: %v\n&quot;</span>, val1) <span class="comment">//截取到的内容为: ello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append()表示往字符串后面追加元素，返回值是字符串的总长度</span></span><br><span class="line">length1, _ := rdb.Append(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot; Go Programer&quot;</span>).Result()</span><br><span class="line">val2, _ := rdb.Get(ctx, <span class="string">&quot;hello&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前缓存key的长度为: %v，值: %v \n&quot;</span>, length1, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置整形的key</span></span><br><span class="line">err = rdb.SetNX(ctx, <span class="string">&quot;number&quot;</span>, <span class="number">1</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Incr()、IncrBy()都是操作数字，对数字进行增加的操作</span></span><br><span class="line"><span class="comment">// Decr()、DecrBy()方法是对数字进行减的操作，和Incr正好相反</span></span><br><span class="line"><span class="comment">// incr是执行原子加1操作</span></span><br><span class="line">val3, _ := rdb.Incr(ctx, <span class="string">&quot;number&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Incr -&gt; key当前的值为: %v\n&quot;</span>, val3) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// incrBy是增加指定的数</span></span><br><span class="line">val4, _ := rdb.IncrBy(ctx, <span class="string">&quot;number&quot;</span>, <span class="number">6</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;IncrBy -&gt; key当前的值为: %v\n&quot;</span>, val4) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StrLen 也可以返回缓存key的长度</span></span><br><span class="line">length2, _ := rdb.StrLen(ctx, <span class="string">&quot;number&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;number 值长度: %v\n&quot;</span>, length2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031225.png" alt="字符串总结图.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Redis 3.2 之前 SDS 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031222.png" alt="字符串存储结构图.png"></p><p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* 已使用长度，1 字节存储 */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* 总长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">// 真正存储字符串的数据空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* 已使用长度，2 字节存储 */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* 已使用长度，4 字节存储 */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* 已使用长度，8 字节存储 */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p><p>确切地说，String在Redis中是用一个robj来表示的。</p><p>用来表示String的robj可能编码成3种内部表示：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把 string 存成了 int 型。</p><ul><li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；</li><li>如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li></ul><p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p><p><strong>为什么是 44 字节？</strong></p><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p><p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p><p>在前言部分就已经提到过 <code>redisObject</code> 了，其中的五个字段一共占据了 16 字节。</p><p>SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：SDS <em> TYPE </em> 5、SDS <em> TYPE </em> 8、SDS <em> TYPE </em> 16、SDS <em> TYPE </em> 32、SDS <em> TYPE </em> 64，在这些类型中最小的存储类型为 SDS <em> TYPE </em> ５，但 SDS <em> TYPE </em> ５ 类型会默认转成 SDS <em> TYPE </em> 8，以下源码可以证明，如下图所示：<img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031223.png" alt="SDS-0116-1.png"></p><p><strong>为什么转换？</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-2.png" alt="img"></p><p>可以看出，SDS <em> TYPE </em> 5类型根本就无法使用。</p><p>那我们直接来看 SDS <em> TYPE </em> 8 的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 <code>\0</code> 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031224.png" alt="44字节说明图.png"></p><h2 id="性能优势"><a href="#性能优势" class="headerlink" title="性能优势"></a>性能优势</h2><p>SDS 与 C 语言字符串比较相近，但拥有更过的优势：</p><ul><li>SDS 获取字符串长度时间复杂度 O(1)：因为 SDS 通过 len 字段来存储长度，使用时直接读取就可以；C 语言要想获取字符串长度需要遍历整个字符串，时间复杂度 O(N)。</li><li>SDS 能杜绝缓冲区的溢出：因为当 SDS API 要对 SDS 进行修改时，会先检查 SDS 的空间是否足够，如果不够的话 SDS 会自动扩容，So，不会造成缓冲区溢出。而 C 语言则不具备这个功能。</li><li>SDS 能减少修改字符串时带来的内存重分配次数：<ul><li>空间预分配：当 SDS 扩容时不只是会增加需要的空间大小，还会额外的分配一些未使用的空间。分配的规则是：如果分配后 SDS 的长度小于 1MB，那么会分配等于分配后 SDS 的大小的未使用空间，简单说就是，SDS 动态分配后是 16KB，那么就会多分配 16KB 的未使用空间；如果 小于 1MB，那么久分配 1MB 的未使用空间。</li><li>惰性空间释放： 惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，并不会立即内存重分配来回收多出来的字节，而是用 free 来记录未使用空间。</li></ul></li></ul><h3 id="空间预分配补进一步理解"><a href="#空间预分配补进一步理解" class="headerlink" title="空间预分配补进一步理解"></a>空间预分配补进一步理解</h3><p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf=&#39;Hello World again!\0....................&#39;</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p><p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p><p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p><h1 id="哈希（Hash）：万花筒般的博学者"><a href="#哈希（Hash）：万花筒般的博学者" class="headerlink" title="哈希（Hash）：万花筒般的博学者"></a>哈希（Hash）：万花筒般的博学者</h1><p>接下来出场的是哈希，哈希就像是一个学识渊博的百科全书，里面装着各种各样的知识点。你问他什么，他都能迅速找到并回答你。哈希非常适合存储对象类型的数据，每个字段都能独立操作，让你在管理数据时游刃有余。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031216.png" alt="哈希表存储结构.png"></p><h2 id="如何使用？-1"><a href="#如何使用？-1" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-1"><a href="#命令行操作方式-1" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置指定哈希表中指定字段的值</td></tr><tr><td>HSETNX key field value</td><td>只有指定字段不存在时设置指定字段的值</td></tr><tr><td>HMSET key field1 value1 field2 value2 …</td><td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td></tr><tr><td>HGET key field</td><td>获取指定哈希表中指定字段的值</td></tr><tr><td>HMGET key field1 field2 …</td><td>获取指定哈希表中一个或者多个指定字段的值</td></tr><tr><td>HGETALL key</td><td>获取指定哈希表中所有的键值对</td></tr><tr><td>HEXISTS key field</td><td>查看指定哈希表中指定的字段是否存在</td></tr><tr><td>HDEL key field1 field2 …</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HLEN key</td><td>获取指定哈希表中字段的数量</td></tr></tbody></table></div><p>更多 Redis Hash 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=hash">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-1"><a href="#代码操作方式（采用Go-Redis-V8-版本）-1" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>HSet():设置</li><li>HMset():批量设置</li><li>HGet():获取某个元素</li><li>HGetAll():获取全部元素</li><li>HDel():删除某个元素</li><li>HExists():判断元素是否存在</li><li>HLen():获取长度</li></ul><p><strong>简单示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// (1) HSet() 设置字段和值</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>&#125;)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;key5&quot;</span>: <span class="string">&quot;value5&quot;</span>, <span class="string">&quot;key6&quot;</span>: <span class="string">&quot;value6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) HMset():批量设置</span></span><br><span class="line">rdb.HMSet(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;WeiyiGeek&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">88</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;重庆&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) HGet() 获取某个元素</span></span><br><span class="line">address, _ := rdb.HGet(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="string">&quot;address&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser.address -&gt; &quot;</span>, address)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) HGetAll() 获取全部元素</span></span><br><span class="line">hmuser, _ := rdb.HGetAll(ctx, <span class="string">&quot;hmuser&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser :=&gt; &quot;</span>, hmuser)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) HExists 判断元素是否存在</span></span><br><span class="line">flag, _ := rdb.HExists(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="string">&quot;address&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;address 是否存在 hmuser 中: &quot;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) HLen() 获取长度</span></span><br><span class="line">length, _ := rdb.HLen(ctx, <span class="string">&quot;hmuser&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser hash 键长度: &quot;</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (7) HDel() 支持一次删除多个元素</span></span><br><span class="line">count, _ := rdb.HDel(ctx, <span class="string">&quot;huser&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;删除元素的个数: &quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来的三个小节将分别介绍 Redis 的哈希表、哈希表节点、以及字典的实现。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组    </span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值    </span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p></li><li><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p></li><li>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</li></ul><p>下图 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b00db9f0d5b742d777ee65a9de3a0f7a.png" alt="img"></p><h4 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h4><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><ul><li>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</li><li>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</li></ul><p>举个例子， 下图就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/051f340b7b501e61045e94542bf519e0.png" alt="img"></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis 中的字典由 dict.h/dict 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li><li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>下图 展示了一个普通状态下（没有进行 rehash）的字典：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0469efb2d1c938e7ae4650ed62c7f121.png" alt="img"></p><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>字典类型本质上是由数组和链表结构组成的，通常情况下字典类型会使用数组的方式来存储相关的数据，但发生<strong>哈希冲突</strong>时才会使用链表的结构来存储数据。</p><p><strong>Redis 计算索引值的方法是：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>类似 Java 的 HashMap，计算 key 的 hash 值，然后 hash &amp; (len - 1), 而 Redis 的 sizemask 就是 size - 1。</p><p><strong>什么是哈希冲突？发生哈希冲突怎么办？</strong></p><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为<strong>哈希冲突</strong>。</p><p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p><p>键值查询的流程如下：</p><ul><li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li><li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li></ul><p>键值查询流程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031218.png" alt="Redis-HashType-03.png"></p><h2 id="性能优势-1"><a href="#性能优势-1" class="headerlink" title="性能优势"></a>性能优势</h2><p>dict本质上是为了解决算法中的查找问题，是一个基于哈希表的算法，在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，查询的时间复杂度接近<strong>O(1)</strong>。它采用某个哈希函数并通过计算key从而找到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发<strong>重哈希（rehash）</strong>，为了避免扩容时一次性对所有key进行重哈希，Redis采用了一种称为<strong>渐进式重哈希（incremental rehash）</strong>的方法，将重哈希的操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着不断的操作，hash 表中的键值对可能会增多或减少，为了让哈希表的负载因子保持在一个范围内，需要对 hash 表进行扩容或收缩，收缩和扩容的过程就叫 rehash。rehash 过程如下：</p><ol><li>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）(ht 是字典中的 hash 表，上文有介绍)：</li><li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li><li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备</li></ol><p><strong>触发扩容的条件</strong>：</p><p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p><p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p><p><strong>渐进式 rehash</strong></p><p>rehash 时会将 ht[0] 所有的键值对迁移到 ht[1] 中，但这个动作不是一次性的，而是分多次、渐进式地完成。这样的所得原因时：当数据量大的时候一次性迁移会造成服务器在一段时间内定制服务。为了避免发生这样的事就出现了 <strong>渐进式 rehash</strong>。</p><p>主要的执行流程如下：</p><ul><li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li><li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li><li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li></ul><h1 id="列表（List）：风驰电掣的快马"><a href="#列表（List）：风驰电掣的快马" class="headerlink" title="列表（List）：风驰电掣的快马"></a>列表（List）：风驰电掣的快马</h1><p>第三位登场的是列表，这位兄弟简直就是江湖上的快马，擅长在前后两个方向上迅速移动。无论是队列还是栈，列表都能应付自如。最适合需要顺序操作的场景，比如任务队列或者消息队列。</p><p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031229.png" alt="列表类型使用-列表结构图.png"></p><h2 id="如何使用？-2"><a href="#如何使用？-2" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-2"><a href="#命令行操作方式-2" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>LPUSH key value1 value2 ..</td><td>在指定列表的头部（左边）添加一个或多个元素</td></tr><tr><td>RPUSH key value1 value2 …</td><td>在指定列表的尾部（右边）添加一个或多个元素</td></tr><tr><td>LSET key index value</td><td>将指定列表索引 index 位置的值设置为 value</td></tr><tr><td>LPOP key</td><td>移除并获取指定列表的第一个元素(最左边)</td></tr><tr><td>RPOP key</td><td>移除并获取指定列表的最后一个元素(最右边)</td></tr><tr><td>LLEN key</td><td>获取列表元素数量</td></tr><tr><td>LRANGE key start end</td><td>获取列表 start 和 end 之间 的元素</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151156374-72815148.png" alt="img"></p><p>更多 Redis List 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=list">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-2"><a href="#代码操作方式（采用Go-Redis-V8-版本）-2" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p><strong>常用方法:</strong></p><ul><li>LPush():将元素压入链表</li><li>LInsert():在某个位置插入新元素</li><li>LSet():设置某个元素的值</li><li>LLen():获取链表元素个数</li><li>LIndex():获取链表下标对应的元素</li><li>LRange():获取某个选定范围的元素集</li><li>LPop()从链表左侧弹出数据</li><li>LRem():根据值移除元素</li></ul><p><strong>简单示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 插入指定值到list列表中，返回值是当前列表元素的数量</span></span><br><span class="line"><span class="comment">// 使用LPush()方法将数据从左侧压入链表（后进先出）,也可以从右侧压如链表对应的方法是RPush()</span></span><br><span class="line">count, _ := rdb.LPush(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;插入到list集合中元素的数量: &quot;</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LInsert() 在某个位置插入新元素</span></span><br><span class="line"><span class="comment">// 在名为key的缓存项值为2的元素前面插入一个值，值为123 ， 注意只会执行一次</span></span><br><span class="line">_ = rdb.LInsert(ctx, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;before&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">123</span>).Err()</span><br><span class="line"><span class="comment">// 在名为key的缓存项值为2的元素后面插入一个值，值为321</span></span><br><span class="line">_ = rdb.LInsert(ctx, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;after&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">321</span>).Err()</span><br><span class="line"></span><br><span class="line"><span class="comment">// LSet() 设置某个元素的值</span></span><br><span class="line"><span class="comment">//下标是从0开始的</span></span><br><span class="line">val1, _ := rdb.LSet(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>, <span class="number">256</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;是否成功将下标为2的元素值改成256: &quot;</span>, val1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LLen() 获取链表元素个数</span></span><br><span class="line">length, _ := rdb.LLen(ctx, <span class="string">&quot;list&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前链表的长度为: %v\n&quot;</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LIndex() 获取链表下标对应的元素</span></span><br><span class="line">val2, _ := rdb.LIndex(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;下标为2的值为: %v\n&quot;</span>, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表左侧弹出数据</span></span><br><span class="line">val3, _ := rdb.LPop(ctx, <span class="string">&quot;list&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;弹出下标为0的值为: %v\n&quot;</span>, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRem() 根据值移除元素 lrem key count value</span></span><br><span class="line">n, _ := rdb.LRem(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>, <span class="string">&quot;256&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;移除了: %v 个\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding list</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p><ol><li><p>Redis3.2之前的底层实现方式：压缩列表ziplist 或者 双向循环链表linkedlist</p><p>当list存储的数据量较少时，会使用ziplist存储数据，也就是同时满足下面两个条件：</p><ul><li>列表中数据个数少于512个</li><li>list中保存的每个元素的长度小于 64 字节</li><li>当不能同时满足上面两个条件的时候，list就通过双向循环链表linkedlist来实现了</li></ul></li><li><p>Redis3.2及之后的底层实现方式：quicklist</p><p>quicklist是一个双向链表，而且是一个基于ziplist的双向链表，quicklist的每个节点都是一个ziplist，结合了双向链表和ziplist的优点。</p></li></ol><h3 id="数据类型-2"><a href="#数据类型-2" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>我们来看下 quicklist 的实现源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistLZF is a 4+N byte struct holding &#x27;sz&#x27; followed by &#x27;compressed&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;sz&#x27; is byte length of &#x27;compressed&#x27; field.</span></span><br><span class="line"><span class="comment"> * &#x27;compressed&#x27; is LZF data with total (compressed) length &#x27;sz&#x27;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span></span><br><span class="line"><span class="comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="type">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bookmarks are padded with realloc at the end of of the quicklist struct.</span></span><br><span class="line"><span class="comment"> * They should only be used for very big lists if thousands of nodes were the</span></span><br><span class="line"><span class="comment"> * excess memory usage is negligible, and there&#x27;s a real need to iterate on them</span></span><br><span class="line"><span class="comment"> * in portions.</span></span><br><span class="line"><span class="comment"> * When not used, they don&#x27;t add any memory overhead, but when used and then</span></span><br><span class="line"><span class="comment"> * deleted, some overhead remains (to avoid resonance).</span></span><br><span class="line"><span class="comment"> * The number of bookmarks used should be kept to minimum since it also adds</span></span><br><span class="line"><span class="comment"> * overhead on node deletion (searching for a bookmark to update). */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistBookmark</span> &#123;</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; quicklistBookmark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: -1 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor.</span></span><br><span class="line"><span class="comment"> * &#x27;bookmakrs are an optional feature that is used by realloc this struct,</span></span><br><span class="line"><span class="comment"> *      so that they don&#x27;t consume memory when not used. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure><p>这里定义了6个结构体:</p><ul><li><code>quicklistNode</code>：宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例。</li><li><code>quicklistLZF</code>：ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例。</li><li><code>quicklistBookmark</code>：在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>：这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间。</li><li><code>quicklistIter</code>是一个迭代器。</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下。</li></ul><p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：        </p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-31230.png" alt="列表类型使用-quicklist结构图.png"></p><p><strong>quicklist更多额外信息：</strong></p><p>下面是有关quicklist的更多额外信息:</p><ul><li><code>quicklist.fill</code>的值影响着每个链表结点中, ziplist的长度. <ol><li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li><li>-1 不超过4kb</li><li>-2 不超过 8kb</li><li>-3 不超过 16kb</li><li>-4 不超过 32kb</li><li>-5 不超过 64kb</li><li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li></ol></li><li><code>quicklist.compress</code>的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF <ol><li>0 表示不压缩, zl字段直接指向ziplist</li><li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>以此类推, 最大值为2^16</li></ol></li><li><code>quicklistNode.encoding</code>字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</li><li><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</li><li><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</li></ul><h4 id="zaplist"><a href="#zaplist" class="headerlink" title="zaplist"></a>zaplist</h4><p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，<strong>ziplist 数据结构</strong>如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-6.png" alt="img"></p><p>其中的字段含义如下：</p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数。</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作。</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到。</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255。</li></ul><p><strong>Entry 结构</strong></p><ul><li><strong>先看下源码中相关介绍</strong></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-7.png" alt="img"></p><p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p><ul><li><code>prevlen</code>：前一个entry的大小，编码方式见下文；</li><li><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</li><li><code>entry-data</code>：真是用于存储entry表示的数据；</li></ul><p><strong>第二种情况</strong>：在entry中存储的是int类型时，<code>encoding</code> 和<code>entry-data</code>会合并在<code>encoding</code>中表示，此时没有<code>entry-data</code>字段；</p><p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p><p>此时entry结构：<code>&lt;prevlen&gt; &lt;encoding&gt;</code></p><ul><li><strong>prevlen编码</strong></li></ul><p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构</span><br><span class="line">0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254</span><br></pre></td></tr></table></figure><ul><li><strong>encoding编码</strong></li></ul><p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p><p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><p><strong>存储string时</strong>：</p><p><code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p><p><code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p><p><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p><p><strong>存储int时</strong>：</p><p><code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；</p><p><code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32;</p><p><code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64;</p><p><code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；</p><p><code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；</p><p><code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p><p><code>|11111111|</code> 还记得zlend么？</p><ul><li><strong>源码中数据结构支撑</strong></li></ul><p>你可以看到为了操作上的简易实际还增加了几个属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><ul><li><code>prevrawlensize</code>表示 previous_entry_length字段的长度</li><li><code>prevrawlen</code>表示 previous_entry_length字段存储的内容</li><li><code>lensize</code>表示 encoding字段的长度</li><li><code>len</code>表示数据内容长度</li><li><code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li><li><code>encoding</code>表示数据类型</li><li><code>p</code>表示当前元素首地址</li></ul><p><strong>看个例子：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis_ziplist_sample.png" alt="Redis Ziplist Sample"></p><p>上图是一份真实的ziplist数据。我们逐项解读一下：</p><ul><li>这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</li><li>头4个字节（0x21000000）是按小端（little endian）模式存储的<code>&lt;zlbytes&gt;</code>字段。因此，这里<code>&lt;zlbytes&gt;</code>的值应该解析成0x00000021，用十进制表示正好就是33。</li><li>接下来4个字节（byte[4..7]）是<code>&lt;zltail&gt;</code>，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</li><li>再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</li><li>接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为”name”。</li><li>接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串”tielei”。</li><li>接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串”age”。</li><li>接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</li><li>最后1个字节（byte[32]）表示<code>&lt;zlend&gt;</code>，是固定的值255（0xFF）。</li></ul><p>总结一下，这个ziplist里存了4个数据项，分别为：</p><ul><li>字符串: “name”</li><li>字符串: “tielei”</li><li>字符串: “age”</li><li>整数: 20</li></ul><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="添加功能源码分析"><a href="#添加功能源码分析" class="headerlink" title="添加功能源码分析"></a>添加功能源码分析</h4><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        <span class="comment">// 在列表头部添加元素</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        <span class="comment">// 在列表尾部添加元素</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 quicklistPushHead 为例，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 在头部节点插入元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p><p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p><p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。 quicklistPushHead 执行流程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031232.png" alt="列表类型使用-插入流程图.png"></p><h4 id="删除功能源码分析"><a href="#删除功能源码分析" class="headerlink" title="删除功能源码分析"></a>删除功能源码分析</h4><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p><h5 id="单一元素删除"><a href="#单一元素删除" class="headerlink" title="单一元素删除"></a>单一元素删除</h5><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> &#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="type">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p><h5 id="区间元素删除"><a href="#区间元素删除" class="headerlink" title="区间元素删除"></a>区间元素删除</h5><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start 表示开始删除的下标，count 表示要删除的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="type">const</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> extent = count; </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// 删除的元素个数大于已有元素</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// 删除指定的元素个数</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// extent 为剩余需要删除的元素个数，</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> del;</span><br><span class="line">        <span class="type">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 删除整个 quicklistNode</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">           <span class="comment">// 删除本节点的所有元素</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除本节点部分元素</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line">        D(<span class="string">&quot;[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), &quot;</span></span><br><span class="line">          <span class="string">&quot;node count: %u&quot;</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余待删除元素的个数</span></span><br><span class="line">        extent -= del;</span><br><span class="line">        <span class="comment">// 下个 quicklistNode</span></span><br><span class="line">        node = next;</span><br><span class="line">        <span class="comment">// 从下个 quicklistNode 起始位置开始删除</span></span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p><p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p><h4 id="更多源码"><a href="#更多源码" class="headerlink" title="更多源码"></a>更多源码</h4><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p><ul><li>quicklistCreate：创建 quicklist；</li><li>quicklistInsertAfter：在某个元素的后面添加数据；</li><li>quicklistInsertBefore：在某个元素的前面添加数据；</li><li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li><li>quicklistReplaceAtIndex：替换某个元素。</li></ul><h2 id="性能优势-2"><a href="#性能优势-2" class="headerlink" title="性能优势"></a>性能优势</h2><p>quicklist有自己的优点， 也有缺点， 对于使用者来说， 其使用体验类似于线性数据结构， list作为最传统的双链表， 结点通过指针持有数据， 指针字段会耗费大量内存。 ziplist解决了耗费内存这个问题。 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配。 quicklist在两者之间做了一个平衡。 并且使用者可以通过自定义<code>quicklist.fill</code>， 根据实际业务情况， 经验主义调参。</p><h3 id="为什么-ziplist-特别省内存"><a href="#为什么-ziplist-特别省内存" class="headerlink" title="为什么 ziplist 特别省内存"></a>为什么 ziplist 特别省内存</h3><p>只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p><p>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</p><p>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</p><p>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</p><hr><p>结合了双向链表和ziplist的优点，quicklist就应运而生了。</p><h1 id="集合（Set）：独步天下的独行侠"><a href="#集合（Set）：独步天下的独行侠" class="headerlink" title="集合（Set）：独步天下的独行侠"></a>集合（Set）：独步天下的独行侠</h1><p>然后，我们的集合大师登场了！集合就像是江湖中的独行侠，天生不爱重复。他擅长处理那些独一无二的数据，无论是要去重还是计算交集并集，集合都能完美胜任。正是他那种独特的个性，让他在数据江湖中独步天下。</p><p>集合类型 (Set) 是一个无序并唯一的键值集合。之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储。</p><p>集合类型和列表类型的区别如下：</p><ul><li>列表可以存储重复元素，集合只能存储非重复元素；</li><li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151400257-695491959.png" alt="img"></p><h2 id="如何使用？-3"><a href="#如何使用？-3" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-3"><a href="#命令行操作方式-3" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SADD key member1 member2 …</td><td>向指定集合添加一个或多个元素</td></tr><tr><td>SMEMBERS key</td><td>获取指定集合中的所有元素</td></tr><tr><td>SCARD key</td><td>获取指定集合的元素数量</td></tr><tr><td>SISMEMBER key member</td><td>判断指定元素是否在指定集合中</td></tr><tr><td>SINTER key1 key2 …</td><td>获取给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 key2 …</td><td>将给定所有集合的交集存储在 destination 中</td></tr><tr><td>SUNION key1 key2 …</td><td>获取给定所有集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 key2 …</td><td>将给定所有集合的并集存储在 destination 中</td></tr><tr><td>SDIFF key1 key2 …</td><td>获取给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 key2 …</td><td>将给定所有集合的差集存储在 destination 中</td></tr><tr><td>SPOP key count</td><td>随机移除并获取指定集合中一个或多个元素</td></tr><tr><td>SRANDMEMBER key count</td><td>随机获取指定集合中指定数量的元素</td></tr></tbody></table></div><p>更多 Redis Set 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=set">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-3"><a href="#代码操作方式（采用Go-Redis-V8-版本）-3" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>SAdd():添加元素</li><li>SPop():随机获取一个元素</li><li>SRem():删除集合里指定的值</li><li>SSMembers():获取所有成员</li><li>SIsMember():判断元素是否在集合中</li><li>SCard():获取集合元素个数</li><li>SUnion():并集,SDiff():差集,SInter():交集</li></ul><p>Tips：集合数据的特征，元素不能重复保持唯一性, 元素无序不能使用索引(下标)操作</p><p><strong>简单示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 集合元素缓存设置</span></span><br><span class="line">keyname := <span class="string">&quot;Program&quot;</span></span><br><span class="line">mem := []<span class="type">string</span>&#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Delphi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Golang&quot;</span>&#125;</span><br><span class="line"><span class="comment">// //由于Golang已经被添加到Program集合中，所以重复添加时无效的</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> mem &#123;</span><br><span class="line">rdb.SAdd(ctx, keyname, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SCard() 获取集合元素个数</span></span><br><span class="line">total, _ := rdb.SCard(ctx, keyname).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;golang集合成员个数: &quot;</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPop() 随机获取一个元素 （无序性，是随机的）</span></span><br><span class="line">val1, _ := rdb.SPop(ctx, keyname).Result()</span><br><span class="line"><span class="comment">// SPopN()  随机获取多个元素.</span></span><br><span class="line">val2, _ := rdb.SPopN(ctx, keyname, <span class="number">2</span>).Result()</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSMembers() 获取所有成员</span></span><br><span class="line">val3, _ := rdb.SMembers(ctx, keyname).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;随机获取一个元素: %v , 随机获取多个元素: %v \n所有成员: %v\n&quot;</span>, val1, val2, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIsMember() 判断元素是否在集合中</span></span><br><span class="line">exists, _ := rdb.SIsMember(ctx, keyname, <span class="string">&quot;golang&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;golang 存在 Program 集合中.&quot;</span>) <span class="comment">// 注意:我们存入的是Golang而非golang</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;golang 不存在 Program 集合中.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SUnion():并集, SDiff():差集, SInter():交集</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;setB&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">union, _ := rdb.SUnion(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;并集&quot;</span>, union)</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line">diff, _ := rdb.SDiff(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;差集&quot;</span>, diff)</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">inter, _ := rdb.SInter(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;交集&quot;</span>, inter)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除集合中指定元素(返回成功)</span></span><br><span class="line">  n, _ := rdb.SRem(ctx, <span class="string">&quot;setB&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;f&quot;</span>).Result()</span><br><span class="line">  fmt.Println(<span class="string">&quot;已成功删除元素的个数: &quot;</span>,n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031226.png" alt="集合Set-hashtable.png"></p><p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储。</p><p>当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储：</p><ol><li>当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。 </li><li>当元素为非整数时，集合将会使用 hashtable 来存储。</li></ol><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>先看源码结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 <strong>encoding 属性</strong>的值：如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。下图是一个包含五个 int16_t 类型整数值的整数集合。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/46856dc6c841acc54dc4a4513eda1007.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-8.png" alt="img"></p><p>可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？</p><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ul><li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ul><p>整数集合<strong>不支持降级操作</strong>， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p><h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 添加元素到集合</span></span><br><span class="line"><span class="comment"> * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 字典类型</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// inset 数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转化为整数类型失败，使用字典类型存储</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未知编码(类型)</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p><h2 id="性能优势-3"><a href="#性能优势-3" class="headerlink" title="性能优势"></a>性能优势</h2><p>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p><p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p><h1 id="有序集合（Sorted-Set）：运筹帷幄的智者"><a href="#有序集合（Sorted-Set）：运筹帷幄的智者" class="headerlink" title="有序集合（Sorted Set）：运筹帷幄的智者"></a>有序集合（Sorted Set）：运筹帷幄的智者</h1><p>最后一位出场的是有序集合，这位兄弟简直是个运筹帷幄的智者。他不仅有集合哥的特质，还多了一项绝技：排序。每个成员都有一个分数，他可以根据分数将成员排序，非常适合排行榜、评分系统等场景。</p><p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p><p>当我们把学生的成绩存储在有序集合中时，它的存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031227.png" alt="学生存储值.png"></p><h2 id="如何使用？-4"><a href="#如何使用？-4" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-4"><a href="#命令行操作方式-4" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>ZADD key score1 member1 score2 member2 …</td><td>向指定有序集合添加一个或多个元素</td></tr><tr><td>ZCARD KEY</td><td>获取指定有序集合的元素数量</td></tr><tr><td>ZSCORE key member</td><td>获取指定有序集合中指定元素的 score 值</td></tr><tr><td>ZINTERSTORE destination numkeys key1 key2 …</td><td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td></tr><tr><td>ZUNIONSTORE destination numkeys key1 key2 …</td><td>求并集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZDIFF destination numkeys key1 key2 …</td><td>求差集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td></tr><tr><td>ZREVRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td></tr><tr><td>ZREVRANK key member</td><td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td></tr></tbody></table></div><p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=sorted-set">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-4"><a href="#代码操作方式（采用Go-Redis-V8-版本）-4" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>ZAdd():添加元素</li><li>ZIncrBy():增加元素分值</li><li>ZRange()、ZRevRange():获取根据score排序后的数据段</li><li>ZRangeByScore()、ZRevRangeByScore():获取score过滤后排序的数据段</li><li>ZCard():获取元素个数</li><li>ZCount():获取区间内元素个数</li><li>ZScore():获取元素的score</li><li>ZRank()、ZRevRank():获取某个元素在集合中的排名</li><li>ZRem():删除元素</li><li>ZRemRangeByRank():根据排名来删除</li><li>ZRemRangeByScore():根据分值区间来删除</li></ul><p><strong>简单示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zsetExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 有序集合成员与分数设置</span></span><br><span class="line"><span class="comment">// zSet类型需要使用特定的类型值*redis.Z，以便作为排序使用</span></span><br><span class="line">lang := []*redis.Z&#123;</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">90.0</span>, Member: <span class="string">&quot;Golang&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">98.0</span>, Member: <span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">95.0</span>, Member: <span class="string">&quot;Python&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">97.0</span>, Member: <span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">99.0</span>, Member: <span class="string">&quot;C/C++&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入ZSet类型</span></span><br><span class="line">num, err := rdb.ZAdd(ctx, <span class="string">&quot;language_rank&quot;</span>, lang...).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zadd failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zadd %d succ.\n&quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ZSet中的某一个元素顺序值增加: 把Golang的分数加10</span></span><br><span class="line">newScore, err := rdb.ZIncrBy(ctx, <span class="string">&quot;language_rank&quot;</span>, <span class="number">10.0</span>, <span class="string">&quot;Golang&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zincrby failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Golang&#x27;s score is %f now.\n&quot;</span>, newScore)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据分数排名取出元素:取分数最高的3个</span></span><br><span class="line">ret, err := rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;language_rank&quot;</span>, <span class="number">0</span>, <span class="number">2</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zrevrange failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zsetKey前3名热度的是: %v\n,Top 3 的 Memeber 与 Score 是:\n&quot;</span>, ret)</span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">fmt.Println(z.Member, z.Score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZRangeByScore()、ZRevRangeByScore():获取score过滤后排序的数据段</span></span><br><span class="line"><span class="comment">// 此处表示取95~100分的</span></span><br><span class="line">op := redis.ZRangeBy&#123;</span><br><span class="line">Min: <span class="string">&quot;95&quot;</span>,</span><br><span class="line">Max: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">ret, err = rdb.ZRangeByScoreWithScores(ctx, <span class="string">&quot;language_rank&quot;</span>, &amp;op).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zrangebyscore failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出全部成员及其score分数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;language_rank 键存储的全部元素:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">fmt.Println(z.Member, z.Score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p><h3 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h4><p>跳跃表（zskiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p><p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p><p> Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。</p><p><strong>跳跃表的实现原理：</strong></p><p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-9.png" alt="img"></p><p>如果我们增加如下两级索引，那么它搜索次数就变成了3次</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-10.png" alt="img"></p><h3 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>层</p><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p><p>下图分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ，以此类推。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d96fcb014a96af27bcebc26c724919dc.png" alt="img"></p><p>跨度</p><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：两个节点之间的跨度越大， 它们相距得就越远。指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</p><p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子， 下图用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/9ddac8937a38c8bb4a3a7850c1a8a188.png" alt=""></p><p>后退指针</p><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p><p>下图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bbfca4ed488e379585b9ea102757b232.png" alt="img"></p><p>分值和成员</p><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p>举个例子， 在下图所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &lt;= o2 &lt;= o3 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c62c33310c977b13d64a210dadbe0a13.png" alt="img"></p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/964cab7318119286f61ffb60a39d942b.png" alt="img"></p><p>但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a09e3a9836113e5a9da1ccaeeefb3241.png" alt="img"></p><p>zskiplist 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中节点的数量    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数    </span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</li><li>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</li><li>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</li></ul><h2 id="性能优势-4"><a href="#性能优势-4" class="headerlink" title="性能优势"></a>性能优势</h2><h3 id="为什么是跳跃表？而非红黑树？"><a href="#为什么是跳跃表？而非红黑树？" class="headerlink" title="为什么是跳跃表？而非红黑树？"></a>为什么是跳跃表？而非红黑树？</h3><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p><h3 id="kiplist与平衡树、哈希表的比较"><a href="#kiplist与平衡树、哈希表的比较" class="headerlink" title="kiplist与平衡树、哈希表的比较"></a>kiplist与平衡树、哈希表的比较</h3><p>来源于：<a href="https://www.jianshu.com/p/8ac45fd01548">https://www.jianshu.com/p/8ac45fd01548</a></p><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通过学习上面的内容，我们已经非常了解这五种数据结构的基本使用和内部原理了，那么在实际生产中到底要怎么用，每种数据结构的使用场景是什么，我们来看一下。</p><p>当然！下面是关于Redis五种基础数据结构的应用场景的详细介绍：</p><h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>缓存数据</strong>：字符串是缓存数据的最常用数据结构，比如缓存用户信息、产品详情等。</li><li><strong>计数器</strong>：使用INCR、DECR等命令，可以轻松实现各种计数功能，如网站访问量、点赞数等。</li><li><strong>会话存储</strong>：将用户会话信息存储在字符串中，便于快速读取和更新。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存用户信息</span></span><br><span class="line">SET user:<span class="number">1001</span> <span class="string">&quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数器：增加网站访问量</span></span><br><span class="line">INCR site:views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话存储：设置和获取用户会话</span></span><br><span class="line">SET session:<span class="number">12345</span> <span class="string">&quot;user_id:1001&quot;</span></span><br><span class="line">GET session:<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h2><h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>存储对象</strong>：哈希非常适合存储具有多个字段的对象，如用户信息、商品信息等。</li><li><strong>轻量级的数据存储</strong>：可以存储相对较小的数据，如配置项、状态信息等。</li><li><strong>减少内存消耗</strong>：对于多字段数据，使用哈希可以比字符串节省内存。</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储用户信息</span></span><br><span class="line">HSET user:<span class="number">1001</span> name <span class="string">&quot;John Doe&quot;</span> age <span class="number">30</span> email <span class="string">&quot;john@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的某个字段</span></span><br><span class="line">HGET user:<span class="number">1001</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的所有字段</span></span><br><span class="line">HGETALL user:<span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>任务队列</strong>：列表可以用作任务队列，支持从两端插入和删除元素。</li><li><strong>消息队列</strong>：可以用列表来实现简单的消息队列，保证消息的顺序性。</li><li><strong>日志存储</strong>：将日志条目存储在列表中，便于按时间顺序追加和读取。</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加任务到队列</span></span><br><span class="line">LPUSH task_queue <span class="string">&quot;Task1&quot;</span></span><br><span class="line">RPUSH task_queue <span class="string">&quot;Task2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列获取任务</span></span><br><span class="line">LPOP task_queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储日志条目</span></span><br><span class="line">RPUSH logs <span class="string">&quot;Log entry 1&quot;</span></span><br><span class="line">RPUSH logs <span class="string">&quot;Log entry 2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><h3 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>去重</strong>：集合天生不允许重复元素，非常适合用于去重场景。</li><li><strong>标签管理</strong>：适合存储用户标签、商品标签等。</li><li><strong>社交网络</strong>：可以用来管理好友关系、共同兴趣等。</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储用户标签</span></span><br><span class="line">SADD user:<span class="number">1001</span>:tags <span class="string">&quot;redis&quot;</span> <span class="string">&quot;database&quot;</span> <span class="string">&quot;nosql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在某标签</span></span><br><span class="line">SISMEMBER user:<span class="number">1001</span>:tags <span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有标签</span></span><br><span class="line">SMEMBERS user:<span class="number">1001</span>:tags</span><br></pre></td></tr></table></figure><h2 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h2><h3 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>排行榜</strong>：有序集合非常适合实现排行榜，按分数排序展示前N名用户。</li><li><strong>带权重的数据存储</strong>：适用于需要按权重排序的数据，如评分系统。</li><li><strong>延迟队列</strong>：可以根据分数（时间戳）实现延迟任务队列。</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户到排行榜</span></span><br><span class="line">ZADD leaderboard <span class="number">100</span> <span class="string">&quot;Alice&quot;</span> <span class="number">200</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取排行榜前N名</span></span><br><span class="line">ZRANGE leaderboard <span class="number">0</span> <span class="number">1</span> WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某用户的排名</span></span><br><span class="line">ZRANK leaderboard <span class="string">&quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><p>通过这些应用场景的介绍，相信你对Redis五种基础数据结构的使用有了更深入的了解。每种数据结构都有其独特的优势和适用场景，根据具体需求选择合适的数据结构可以大大提升系统的性能和效率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis数据结构五兄弟，各个身怀绝技，各有千秋。无论是字符串的快剑手、哈希的万花筒、列表的快马、集合的独行侠，还是有序集合的智者，他们都在数据江湖中扮演着不可或缺的角色。希望这篇介绍能让你对Redis的五种基础数据结构有一个更生动形象的了解。让我们一起在Redis的世界中，成为数据江湖的侠客吧！</p><p>哈哈，抽象的标题、抽象的开头和抽象的结尾，笔者实在是懒得去想这些东西要怎么写了，但是又想搞一篇有趣的文章，于是去请教了万能的人工智能 ChatGPt，还可以吧，描述很传神。</p><p>这篇博客真是史诗级的长度，光是看标题就看的眼花缭乱，本来只看了技术摘抄里的文章，觉得好像没有多少内容，还在感慨昨天没学什么东西。结果在搜索更多的资料时发现看的全是概述，重要的内容还没学，于是边学边写，太夸张了，不过还是学到了不少东西的。</p><p>在正式学习 Redis 底层之前，一直觉得 Redis 快就是因为它被存放在内存里，现在发现其实它每一处的设计都有考虑性能和效率。 </p><p>什么？你问为什么今天没有记录什么有趣的东西。</p><p>实在是因为最近一直都在闷着头学东西，也就没怎么去关心实习方面的事，不找实习，连烦恼都消失不见了。</p><p>终于知道为什么大家都讨厌HR了，老小子耍我，说要让技术经理加我的微信跟我面试，结果到现在都没有，骗子不得好死。还好我本来就没有抱希望。</p><p>不过昨天我的好舍友说把我的简历发给他的Leader看了，说不定能帮我找一个实习，不过以我的狗运气，应该不太可能。还是沉下心来学习吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98">Redis数据结构的基本使用和内部原理</a></p><p><a href="https://www.cnblogs.com/xiangningdeguang/p/16955355.html">数据结构的命令行用法</a></p><p><a href="https://www.cnblogs.com/timelesszhuang/p/go-redis.html">数据结构的Go 语言操作</a></p><p><a href="https://blog.csdn.net/a745233700/article/details/113449889">Redis 底层数据结构的概述</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">Redis 底层数据结构的详解</a></p><p><a href="https://xie.infoq.cn/article/78215ce2bb651e7079ea3c80b">Redis 底层数据结构的详解 2</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-dict.html">dict详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-sds.html">SDS详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-robj.html">robj详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-ziplist.html">ziplist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-quicklist.html">quicklist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">skiplist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-intset.html">intset详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天继续学习 Redis 相关的知识，Redis 的五种基础数据结构。虽然在之前的博客中也有提到过这五种数据结构，当时赶着背东西，基本上就是从别人的八股文里抄的，所以还是重新学一下，重新记录加深记忆，正文开始。&lt;/p&gt;
&lt;p&gt;在数据的江湖里，Redis无疑是那位神秘莫测、武</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：让你的数据不再“无疾而终”</title>
    <link href="http://example.com/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/"/>
    <id>http://example.com/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/</id>
    <published>2024-06-04T09:21:41.000Z</published>
    <updated>2024-06-04T11:03:27.376Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的出现，大大提高了我们的查询速度，因其将数据存在内存中，我们的查询速度得到了质的提升。也正是因为在内存中，如果服务器突然断电关机，再次开机后我们的数据也就荡然无存了，这会让我们很崩溃。如何解决？那就是 Redis 的持久化。</p><p>今天我要聊的就是 Redis 持久化。没错，就是那个让你的数据在服务器重启后依然坚挺的功能。不知道你有没有这种感觉：当你以为自己写的代码“永垂不朽”时，服务器重启却让一切化为乌有？别担心，Redis 持久化来拯救你！</p><h1 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h1><p>Redis是一个超级快的内存数据库，但问题来了，内存的特点是断电即失，所以Redis默认情况下，你的数据就像美梦一样——一觉醒来全没了。因此，Redis提供了持久化的功能，帮你把数据存储到硬盘上，这样就算是大风吹断电缆，你的数据也不会“风中凌乱”。</p><p>Redis 持久化拥有以下三种方式：</p><ul><li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li><li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li></ul><p>接下来，咱们一个一个聊。</p><h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p>RDB(Redis database)：实现方式是将存在 Redis 内存中的数据写入到 RDB 文件中保存到磁盘上从而实现持久化的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604174014416.png" alt="image-20240604174014416"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16530eac18882d66%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image1"></p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><p>触发rdb持久化的方式有2种，分别是<strong>手动触发</strong>和<strong>自动触发</strong></p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>Redis 中对于手动触发备份数据到 RDB 文件中，提供了两种方式</p><ol><li><p><code>save</code>: 在主线程中执行，不过这种会阻塞 Redis 服务进程；</p></li><li><p><code>bgsave</code>: 主线程会 fork 出一个子进程来负责处理 RDB 文件的创建，不会阻塞主线程的命令操作，这也是 Redis 中 RDB 文件生成的默认配置；</p></li></ol><p>对于 <code>save</code> 和 <code>bgsave</code> 这两种快照方式，服务端是禁止这两种方式同时执行的，防止产生竞争条件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604174933377.png" alt="image-20240604174933377"></p><p>具体流程如下：</p><ul><li>redis客户端执行<code>bgsave</code>命令或者自动触发<code>bgsave</code>命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就<code>fork</code>一个新的子进程进行持久化数据，<code>fork</code>过程是阻塞的，<code>fork</code>操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。</li></ul><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li>执行debug reload命令重新加载redis时也会触发<code>bgsave</code>操作；</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发<code>bgsave</code>操作；</li></ul><h2 id="redis-conf-中配置-RDB"><a href="#redis-conf-中配置-RDB" class="headerlink" title="redis.conf 中配置 RDB"></a>redis.conf 中配置 RDB</h2><p><strong>快照周期</strong>：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。</p><ul><li><strong>Redis中默认的周期新设置</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 周期性执行条件的设置格式为</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line"># 默认的设置为：</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 以下设置方式为关闭RDB快照功能</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照；</li><li>如果300秒内有10条Key信息发生变化，则进行快照；</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整。</li></ul><p>其他相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p><code>dbfilename</code>：RDB文件在磁盘上的名称。</p><p><code>dir</code>：RDB文件的存储路径。默认设置为“./”，也就是Redis服务的主目录。</p><p><code>stop-writes-on-bgsave-error</code>：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no。</p><p><code>rdbcompression</code>：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”。</p><p><code>rdbchecksum</code>：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no。</p><h2 id="快照时发生数据修改"><a href="#快照时发生数据修改" class="headerlink" title="快照时发生数据修改"></a>快照时发生数据修改</h2><ul><li><strong>由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢</strong>？</li></ul><p>RDB中的核心思路是<strong>Copy-on-Write</strong>，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-rdb-cow.png" alt="redis"></p><h2 id="多久做一次快照"><a href="#多久做一次快照" class="headerlink" title="多久做一次快照"></a>多久做一次快照</h2><p>对于快照，如果做的太频繁，可能会出现前一次快照还没有处理完成，后面的快照数据马上就进来了，同时过于频繁的快照也会增加磁盘的压力。</p><p>如果间隔时间过久，服务器在两次快照期间宕机，丢失的数据大小会随着快照间隔时间的增长而增加。</p><p>那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。</p><p>但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的<strong>空间开销问题</strong>。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？且看后文中4.0版本中引入的RDB和AOF的混合方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li><strong>缺点</strong><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p><h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><p>AOF(Append Only File)：通过保存数据库执行的命令来记录数据库的状态。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-aof.png" alt="redis"></p><p>AOF日志对数据库命令的保存顺序是，Redis 先执行命令，把数据写入内存，然后才记录日志。</p><p><strong>为什么采用写后日志？</strong></p><p>Redis 要求高性能，采用写日志有量方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作。</li></ul><h2 id="如何实现-AOF"><a href="#如何实现-AOF" class="headerlink" title="如何实现 AOF"></a>如何实现 AOF</h2><p>AOF 日志记录 Redis 的每个命令，步骤为：命令追加(append)、文件写入(write) 和文件同步(sync)。</p><ul><li><strong>命令追加：</strong>当 AOF 持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将执行的写命令追加到服务器的 <code>aof_buf</code> 缓冲区。</li><li><strong>文件写入和同步：</strong>关于何时将 <code>aof_buf</code> 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-4.jpg" alt="img"></p><p><code>Always</code>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p><p><code>Everysec</code>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p><p><code>No</code>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><hr><p><strong>三种写回策略的优缺点</strong></p><p>上面的三种写回策略体现了一个重要原则：<strong>trade-off</strong>，取舍，指在性能和可靠性保证之间做取舍。</p><p>关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的：</p><blockquote><p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p><p>这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p></blockquote><h2 id="redis-conf-中配置-AOF"><a href="#redis-conf-中配置-AOF" class="headerlink" title="redis.conf 中配置 AOF"></a>redis.conf 中配置 AOF</h2><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>以下是Redis中关于AOF的主要配置信息：</p><p><code>appendonly</code>：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p><p><code>appendfilename</code>：这个参数项很好理解了，就是AOF文件的名字。</p><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。</p><p>什么叫“真正执行”呢？还记得Linux操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中I/O队列的操作效率，应用程序提交的I/O操作请求一般是被放置在linux Page Cache中的，然后再由Linux操作系统中的策略自行决定正在写到磁盘上的时机。而Redis中有一个fsync()函数，可以将Page Cache中待写的数据真正写入到物理设备上，而缺点是频繁调用这个fsync()函数干预操作系统的既定策略，可能导致I/O卡顿的现象频繁 。</p><p>与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为everysec。</p><p><code>no-appendfsync-on-rewrite</code>：always和everysec的设置会使真正的I/O操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的Redis是没法解决的。为了尽量缓解这个情况，Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache（这段时间Redis还在接受客户端的各种写操作命令）。</p><p><code>auto-aof-rewrite-percentage</code>：上文说到在生产环境下，技术人员不可能随时随地使用“BGREWRITEAOF”命令去重写AOF文件。所以更多时候我们需要依靠Redis中对AOF文件的自动重写策略。Redis中对触发自动重写AOF文件的操作提供了两个设置：auto-aof-rewrite-percentage表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。</p><p><code>auto-aof-rewrite-min-size</code>：参考auto-aof-rewrite-percentage选项的介绍，auto-aof-rewrite-min-size设置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage和auto-aof-rewrite-min-size只是用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右。</p><h2 id="AOF-文件重写机制"><a href="#AOF-文件重写机制" class="headerlink" title="AOF 文件重写机制"></a>AOF 文件重写机制</h2><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供<strong>AOF文件重写机制</strong>来对AOF文件进行“瘦身”。</p><p>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-1.jpg" alt="img"></p><p>简单来讲就是多变一，就是把 AOF 中日志根据当前键值的状态，合并成一条操作命令。</p><p>重写之后的文件会保存到新的 AOF 文件中，这时候旧的 AOF 文件和新的 AOF 文件中键值对的状态是一样的。然后新的 AOF 文件会替换掉旧的 AOF 文件，这样 重写操作一直在进行，AOF 文件就不至于变的过大。</p><p><strong>AOF会阻塞吗？</strong></p><p>AOF重写过程是由后台进程<code>bgrewriteaof</code>来完成的。主线程<code>fork</code>出后台的<code>bgrewriteaof</code>子进程，<code>fork</code>会把主线程的内存拷贝一份给<code>bgrewriteaof</code>子进程，这里面就包含了数据库的最新数据。然后，<code>bgrewriteaof</code>子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>所以aof在重写时，在<code>fork</code>进程时是会阻塞住主线程的。</p><p><strong>AOF日志何时会重写？</strong></p><p>有两个配置项控制AOF重写的触发：</p><p><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。</p><p><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p><p><strong>重写日志时，有新数据写入咋整</strong>？</p><p>重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个  aof 日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：<code>bgrewriteaof</code>进程使用的日志文件）</p><p>而在<code>bgrewriteaof</code>子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。</p><p>最后通过修改文件名的方式，保证文件切换的原子性。</p><p>在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604183732936.png" alt="image-20240604183732936"></p><p><strong>为什么AOF重写不复用原AOF日志</strong>？</p><p>两方面原因：</p><ol><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li></ol><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>AOF 优点</strong></p><ul><li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li><li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li><li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li></ul><p><strong>AOF 缺点</strong></p><ul><li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li><li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li><li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li></ul><h1 id="RDB-和-AOF-混合方式"><a href="#RDB-和-AOF-混合方式" class="headerlink" title="RDB 和 AOF 混合方式"></a>RDB 和 AOF 混合方式</h1><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h1 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h1><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-5.png" alt="img"></p><ul><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ul><p>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h1 id="过期的键如何持久化"><a href="#过期的键如何持久化" class="headerlink" title="过期的键如何持久化"></a>过期的键如何持久化</h1><p>在生成 RDB 文件的过程中，如果一个键已经过期，那么其不会被保存到 RDB 文件中。在载入 RDB 的时候，要分两种情况：</p><ul><li>如果 Redis 以主服务器的模式运行，那么会对 RDB 中的键进行时间检查，过期的键不会被恢复到 Redis 中。</li><li>如果 Redis 以从服务器的模式运行，那么 RDB 中所有的键都会被载入，忽略时间检查。在从服务器与主服务器进行数据同步的时候，从服务器的数据会先被清空，所以载入过期键不会有问题。</li></ul><p>对于 AOF 来说，如果一个键过期了，那么不会立刻对 AOF 文件造成影响。因为 Redis 使用的是惰性删除和定期删除，只有这个键被删除了，才会往 AOF 文件中追加一条 DEL 命令。在重写 AOF 的过程中，程序会检查数据库中的键，已经过期的键不会被保存到 AOF 文件中。</p><p>在运行过程中，对于主从复制的 Redis，主服务器和从服务器对于过期键的处理也不相同：</p><ul><li>对于主服务器，一个过期的键被删除了后，会向从服务器发送 DEL 命令，通知从服务器删除对应的键；</li><li>从服务器接收到读取一个键的命令时，即使这个键已经过期，也不会删除，而是照常处理这个命令；</li><li>从服务器接收到主服务器的 DEL 命令后，才会删除对应的过期键。</li></ul><p>这样保证了数据的一致性，一个键值对存在于主服务器，也必然存在于从服务器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis 4.0中提出了一个混合使用 AOF 日志和内存快照的方法，如果想要保证数据不丢失，这是一个比较好的选择；</p><p>如果允许分钟级别的数据丢失，可以只使用RDB；</p><p>如果只用AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</p><p>行文至此，我只能说大概了解了 Redis 如何进行持久化，还是有一些地方不是很清楚，后续会去读其他的文章来解开我心中的疑惑。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ybyn/p/14157568.html">https://www.cnblogs.com/ybyn/p/14157568.html</a></li><li><a href="https://boilingfrog.github.io/2022/01/07/redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/#%E5%89%8D%E8%A8%80">https://boilingfrog.github.io/2022/01/07/redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/#%E5%89%8D%E8%A8%80</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html</a></li><li><a href="https://juejin.cn/post/6844903655527677960">https://juejin.cn/post/6844903655527677960</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/03%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94RDB.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/03%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94RDB.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/04%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94AOF.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/04%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94AOF.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/05%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/05%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis的出现，大大提高了我们的查询速度，因其将数据存在内存中，我们的查询速度得到了质的提升。也正是因为在内存中，如果服务器突然断电关机，再次开机后我们的数据也就荡然无存了，这会让我们很崩溃。如何解决？那就是 Redis 的持久化。&lt;/p&gt;
&lt;p&gt;今天我要聊的就是 Red</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis执行流程大揭秘：从命令到结果的奇幻之旅</title>
    <link href="http://example.com/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/"/>
    <id>http://example.com/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/</id>
    <published>2024-06-04T08:10:46.000Z</published>
    <updated>2024-06-04T09:13:31.122Z</updated>
    
    <content type="html"><![CDATA[<p>随着内卷这一情况的不断深化，在数据库方面只学习 MySQL 显然是不够的。那么效率极高的 Redis 就成为了学习首选，以至于现在熟练掌握 Redis 已经成为应届生的必备技能了。</p><p>笔者也是在一个多月前第一次接触到 Redis，期间断断续续地学了一点内容，但并不是深入系统的学习，只是去看了一下几个常见问题的八股文，太浮躁了。既然要直接准备秋招，那就还有大把的时间，所以今天开始系统地学习一下 Redis 相关的内容。</p><p>安装、运行这些最开始的东西就不多赘述了，毕竟操作 Redis 的代码也已经写了不少了。那除了这些以外，还有什么适合当作学习的第一步呢？</p><p>今天的文章将会深入 Redis 到底是如何执行我们输入的命令的。</p><h1 id="Redis-是怎么执行命令的？"><a href="#Redis-是怎么执行命令的？" class="headerlink" title="Redis 是怎么执行命令的？"></a>Redis 是怎么执行命令的？</h1><p>面对这个问题，大部分朋友心中的答案是：客户端发送命令给到服务端，服务端收到执行之后再处理将命令执行结果返回给客户端，简单来说如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9124af423f948eecb328a3ead95259b.png" alt="img"></p><p>显然这样的答案不能帮我们了解 Redis 的工作原理，还是看看更细节的过程吧。</p><h2 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h2><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604162911047.png" alt="image-20240604162911047"></p><h2 id="第一步：连接"><a href="#第一步：连接" class="headerlink" title="第一步：连接"></a>第一步：连接</h2><p>一切的开始，都是从客户端和Redis服务器之间的连接开始的。这就好比你和朋友约好了一起去探险，首先得打个电话确认一下。</p><ol><li><strong>客户端发送连接请求</strong>：客户端就像那个迫不及待的探险者，发出了一条连接请求。</li><li><strong>Redis服务器接受请求</strong>：Redis服务器则像是守门员，确认探险者的身份后，挥舞着双手迎接他们。</li></ol><p>在连接之前，我们先看一下 Redis 服务器的启动，这也是客户端能建立连接的前提。</p><p>Redis服务器启动后，需要经过一些列的初始化及配置的设置，比如状态参数、用户配置、初始化数据结构等，流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0652951979112aa1be062edf1d30223.jpg" alt="0652951979112aa1be062edf1d30223"></p><p>Redis 客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监听接客户端的 socket 连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 开启 Socket 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 【redis.h/redisServer】 中redisServer结构体存储Redis服务器的所有信息，包括但不限于数据库、</p><p>配置参数、命令表、监听端口与地址、客户端列表、若干统计信息、RDB与AOF持久化相关信息、主从复制相关信息、集群相关信息等。</p><p>而客户端连接服务器之前需要创建socket（一套固定的模式），然后根据设定的IP和端口号与服务器进行连接。</p><p>这里有个重要的知识点：在通过网络与redis服务器连接的普通客户端和lua脚本的客户端，服务器都会创建相对应的client 结构，用于记录他们的状态信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端在redisServer结构中的属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 存放普通客户端的列表</span></span><br><span class="line">    <span class="built_in">list</span> *clients;   <span class="comment">/* List of active clients */</span></span><br><span class="line">    <span class="comment">// 存放lua脚本客户端</span></span><br><span class="line">    client *lua_client;    <span class="comment">/* The &quot;fake client&quot; to query Redis from Lua */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Redis客户端其实有三种类型：1：负责执行Lua脚本的伪客户端，2：用来加载aof文件的伪客户端，3：通过网络连接的普通客户端</p></blockquote><p>到这里Redis客户端和服务端就完成连接，接下来继续看到底如何传输执行用户指令的！</p><h2 id="第二步：发送与解析"><a href="#第二步：发送与解析" class="headerlink" title="第二步：发送与解析"></a>第二步：发送与解析</h2><p>当连接建立后，客户端会发送命令给Redis服务器。这时候，就好像你给你的探险伙伴发出了一条魔法指令。</p><ol><li><p><strong>命令发送</strong>：你输入的命令就像是一封魔法信件，通过网络这个传送门，飞向Redis服务器。</p></li><li><p><strong>命令解析</strong>：Redis服务器收到信件后，会认真阅读（解析）你写的内容，确保每个字都理解无误。</p></li></ol><h3 id="客户端发送命令"><a href="#客户端发送命令" class="headerlink" title="客户端发送命令"></a>客户端发送命令</h3><p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于<strong>把服务器端的解析工作交给了每一个客户端</strong>，这样会很大程度的提高 Redis 的运行速度。</p><p>比如我们输入 <code>set xkey xiaoxu</code> 命令会转换成如下格式：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/13e2f2d81c17c4f91bea81ef096adcc1.png" alt="img"></p><p>你问上面的是什么意思，来看下面的解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*3        //参数个数是*开头，3个参数</span><br><span class="line">$3        //参数长度是$开头，命令长度</span><br><span class="line">SET       //命令名称SET</span><br><span class="line">$4        //参数长度是$开头，key长度</span><br><span class="line">xkey      //key的内容</span><br><span class="line">$6        //参数长度是$开头，value长度</span><br><span class="line">xiaoxu      //value内容</span><br><span class="line">参数个数是*开头，参数长度是$开头，每个参数通过\r\n隔开</span><br><span class="line">回复协议格式：</span><br><span class="line">* 状态回复（status reply）的第一个字节是 “+”，如：+ok\r\n</span><br><span class="line">* 错误回复（error reply）的第一个字节是 “-“，如：-ERR unknown command xxx\r\n</span><br></pre></td></tr></table></figure><h3 id="服务端读取命令"><a href="#服务端读取命令" class="headerlink" title="服务端读取命令"></a>服务端读取命令</h3><p>通过连接套接字让客户端的写入变得可读，服务端将读取协议内容，并存储到客户端的缓冲区，这里的缓冲区是client结构的输入缓冲区。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c722ffb11c89aa2bea50a9b31dd1f305.png" alt="img"></p><blockquote><p>每个连接到服务端的客户端，会保存在redisServer结构体中的clients链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 客户端状态的输入缓冲区，保存客户端的命令请求</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="comment">// 下面这两个是解析出来的命令和参数</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 一个是根据argv[0]解析出来的命令，一个是最后一次执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><p>接着会对输入缓冲区中的命令请求进行分析，提取解析出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/6634ecba67597fcf177bed53ec5cee4b.png" alt="img"></p><hr><p>这里插播一个小知识！</p><p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3d48b0f27f7c3338e76b109a7d02a8c7.png" alt="img"></p><h2 id="第三步：命令执行"><a href="#第三步：命令执行" class="headerlink" title="第三步：命令执行"></a>第三步：命令执行</h2><p>解析完命令之后，Redis服务器开始执行命令。这一过程就像是启动了一个巨大的魔法阵，能量开始在其中流动。</p><ol><li><strong>查找命令</strong>：Redis服务器会在它的魔法书（命令表）中找到相应的魔法（命令）来施展。</li><li><strong>执行命令</strong>：服务器根据魔法书中的指示，精准地执行命令。</li></ol><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><p>命令执行器根据客户端状态的<code>argv[0]</code>参数，在命令表中查找参数所指定的命令，本文中的<code>argv[0]</code>参数就是 set ，找到命令后保存到客户端状态的 cmd 属性。</p><blockquote><p><strong>命令表</strong>：其实就是一个字典，字典的键是命令名称，比如”set”、”get”、”del”；而值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2e4dfeda09bd4370c4cb7812d436d50f.png" alt="img"></p><p>SET命令的名字为”set”，实现函数为setCommand；命令的参数个数为-3，表示命令接受三个或以上数量的参数；命令的标识为”wm”，表示SET命令是一个写入命令。</p><p>GET命令的名字为 “get”，实现函数为getCommand函数；命令的参数个数为2，表示命令只接受两个参数；命令的标识为”r”，表示这是一个只读命令。</p><h3 id="执行准备：参数、权限、内存校验"><a href="#执行准备：参数、权限、内存校验" class="headerlink" title="执行准备：参数、权限、内存校验"></a>执行准备：参数、权限、内存校验</h3><p>获得了执行需要的命令、参数后，服务器还需要做一些校验：</p><p>命令校验：检查客户端状态的cmd指针是否指向NULL。</p><p>参数校验：根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确。</p><p>权限校验：检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令。</p><p>内存检测：如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行</p><p>其他校验..</p><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>服务器将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器执行命令时，只需要一个指向客户端状态的指针作为参数，调用实际执行函数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2b16c771057fbfe6cb2ca425e7bd1464.png" alt="img"></p><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端</p><h3 id="后续：命令、参数、AOF"><a href="#后续：命令、参数、AOF" class="headerlink" title="后续：命令、参数、AOF"></a><strong>后续：命令、参数、AOF</strong></h3><p>执行完毕后，会有一些后续操作，包括慢日志记录、redisCommand结构属性更新、AOF持久化记录、主从复制命令传播等。</p><h2 id="第四步：返回结果"><a href="#第四步：返回结果" class="headerlink" title="第四步：返回结果"></a>第四步：返回结果</h2><p>命令执行完毕后，Redis服务器会将结果通过网络传送回客户端。这就像是魔法信使带着宝贵的探险成果返回你的身边。</p><ol><li><strong>结果生成</strong>：执行完命令后，Redis服务器生成结果，就像是从宝箱中拿出了宝物。</li><li><strong>结果传送</strong>：通过网络传送门，结果迅速飞回客户端。</li><li><strong>客户端接收</strong>：最终，客户端收到结果，探险圆满成功！</li></ol><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>发送完毕后，回复处理器会清空客户端状态的输出缓冲区，为下一个命令请求做好准备。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604165654029.png" alt="image-20240604165654029"></p><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p><p>比如之前的 set xkey xiaoxu，服务器发送的 “+OK\r\n”，通过协议转换成 “OK\n”</p><hr><p>ok，到这里其实整个发送命令和接收回复的流程就完成了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604165949466.png" alt="image-20240604165949466"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们知道了一条Redis命令请求从发送到完成的步骤，答题如下：</p><ol><li>Redis客户端发送命令请求到服务器</li><li>服务器读取命令请求，解析命令参数</li><li>命令执行器根据命令参数查找命令的实际实现函数，然后执行，接着回复执行结果给客户端</li></ol><p>服务器的Server结构使用Clients链表来链接多个客户端的状态，包括我们的输入请求和输出结果、解析的命令参数等。</p><p>进入到闲聊部分，最近两天好像并没有什么有意思的事情发生，再决定不找实习之后反倒有几家公司找我要简历，当然还是老样子，要过简历之后就开始已读不回了，有时候想想当一个 HR 好爽啊，可以随时耍求职的人玩。好在我的心态已经放平了。</p><p>你问这么抽象的标题是怎么想出来的。对，就是ChatGPT给的，我觉得很好，优点标题党的意思了，营销号要失业了。</p><p>为了秋招顺利，我还是觉得要学一下 Java 的东西，只凭 Go 还是优点不安心。先把前段时间积压的东西学完，然后学着做一个项目。</p><p>对了，这一段时间的网络奇差无比，这样不好。月初有钱了，又想要冲动消费了，今天去看了苹果的头戴耳机，有点心动了，怎么办，克制一下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/01%20Redis%20%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/01%20Redis%20%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84.md</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2311065">https://cloud.tencent.com/developer/article/2311065</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着内卷这一情况的不断深化，在数据库方面只学习 MySQL 显然是不够的。那么效率极高的 Redis 就成为了学习首选，以至于现在熟练掌握 Redis 已经成为应届生的必备技能了。&lt;/p&gt;
&lt;p&gt;笔者也是在一个多月前第一次接触到 Redis，期间断断续续地学了一点内容，但并</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>细说空结构体：Go语言中的奇妙用途</title>
    <link href="http://example.com/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/"/>
    <id>http://example.com/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/</id>
    <published>2024-06-03T08:44:19.000Z</published>
    <updated>2024-06-03T09:50:24.011Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，正常的 <code>struct</code> 就是一个普通的内存块，必定是要占用一块内存的，并且结构体的大小是要经过边界，长度是对其的。</p><p>当你需要一个结构体，但是却丝毫不关系里面的内容，声明一个最小的结构体，也需要占用 1 字节，这是就要用到今天的主角——空结构体了。</p><p>“空结构体”是不占内存的，size 为 0；运行下面的代码可以得出，空结构体是不占用内存的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上来讲，使用空结构体的初衷只有一个：节省内存，但是更多的情况，节省的内存其实很有限，这种情况使用空结构体的考量其实是：<strong>根本不关心结构体变量的值</strong>。</p><h1 id="什么原理"><a href="#什么原理" class="headerlink" title="什么原理"></a>什么原理</h1><h2 id="特殊变量：zerobase"><a href="#特殊变量：zerobase" class="headerlink" title="特殊变量：zerobase"></a>特殊变量：<code>zerobase</code></h2><p>空结构体时没有内存大小的结构体。这句话是没有错，但是更准确的来说，其实是有一个特殊起点的，那就是 <code>zerobase</code> 变量，这是一个  <code>uintptr</code> 全局变量，占用 8 个字节。</p><p>当在任何地方定义无数个 <code>struct &#123;&#125;</code> 类型的变量，编译器都只是把这个 <code>zerobase</code> 变量的地址给出去。换句话说，在 GO 里面，涉及到所有内存 size 为 0 的内存分配，那么就是用的同一个地址 <code>&amp;zerobase</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">c := emptyStruct&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">0x57bb60</span><br><span class="line">0x57bb60</span><br><span class="line">0x57bb60</span><br></pre></td></tr></table></figure><p>无论如何定义空结构体，其变量都是一样的。</p><h2 id="内存特殊管理"><a href="#内存特殊管理" class="headerlink" title="内存特殊管理"></a>内存特殊管理</h2><p>编译器在编译期间，识别到 <code>struct &#123;&#125;</code> 这种特殊类型的内存分配，会统统分配出 <code>runtime.zerobase</code> 的地址出去，这个代码逻辑是在 <code>mallocgc</code> 函数里面：</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 分配 size 为 0 的结构体，把全局变量 zerobase 的地址给出去即可；</span></span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br></pre></td></tr></table></figure><p>golang 使用 <code>mallocgc</code> 分配内存的时候，如果 size 为 0 的时候，统一返回的都是全局变量 <code>zerobase</code> 的地址。</p><p>有这种全局唯一的特殊的地址也方便后面一些逻辑的特殊处理。</p><h1 id="定义的各种姿势"><a href="#定义的各种姿势" class="headerlink" title="定义的各种姿势"></a>定义的各种姿势</h1><h2 id="原生定义"><a href="#原生定义" class="headerlink" title="原生定义"></a>原生定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>struct&#123;&#125;</code> 可以就认为是一种类型，a 变量就是 <code>struct &#123;&#125;</code> 类型的一种变量，地址为 <code>runtime.zerobase</code> ，大小为 0 ，不占内存。</p><h2 id="重定义类型"><a href="#重定义类型" class="headerlink" title="重定义类型"></a>重定义类型</h2><p>golang 使用 <code>type</code>  关键字定义新的类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义出来的 <code>emptyStruct</code>  是新的类型，具有对应的 <code>type</code> 结构，但是性质 <code>struct&#123;&#125;</code> 完全一致，编译器对于 <code>emptryStruct</code> 类型的内存分配，也是直接给 <code>zerobase</code> 地址的。</p><h2 id="匿名嵌套类型"><a href="#匿名嵌套类型" class="headerlink" title="匿名嵌套类型"></a>匿名嵌套类型</h2><p><code>struct&#123;&#125;</code>  作为一个匿名字段，内嵌其他结构体。这种情况是怎么样的？</p><p><strong>匿名嵌套方式一</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">struct</span> &#123;</span><br><span class="line">    emptyStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名嵌套方式二</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住一点，空结构体还是空结构体，类型变量本身绝对不分配内存（ size=0 ），所以编译器对以上的 <code>Object</code>，<code>Object1</code> 两种类型的处理和空结构体类型是一致的，分配地址为 <code>runtime.zerobase</code> 地址，变量大小为0，不占任何内存大小。</p><h2 id="内置字段"><a href="#内置字段" class="headerlink" title="内置字段"></a>内置字段</h2><p>内置字段的场景没有什么特殊的，主要是地址和长度的对齐要考虑。还是只需要注意 3 个要点：</p><ul><li>空结构体的类型不占内存大小；</li><li>地址偏移要和自身类型对齐；</li><li>整体类型长度要和最长的字段类型长度对齐；</li></ul><p>我们分 3 种场景讨论这个问题：</p><p><strong>场景一：<code>struct &#123;&#125;</code>  在最前面</strong></p><p>这种场景非常好理解，<code>struct &#123;&#125;</code> 字段类型在最前面，这种类型不占空间，所以自然第二个字段的地址和整个变量的地址一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="comment">// Object1 类型变量占用 1 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">b <span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object2 类型变量占用 8 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object2 <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">n <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1&#123; &#125;</span><br><span class="line">o2 := Object2&#123; &#125;</span><br></pre></td></tr></table></figure><p>内存怎么分配？</p><ul><li><code>&amp;o1</code>  和 <code>&amp;o1.s</code> 是一致的，变量 <code>o1</code>  的内存大小对齐到 1 字节；</li><li><code>&amp;o2</code>  和 <code>&amp;o2.s</code> 是一致的，变量 <code>o2</code>  的内存大小对齐到 8 字节；</li></ul><p>这种分配是满足对齐规则的，编译器也不会对这种 <code>struct &#123;&#125;</code> 字段做任何特殊的字节填充。</p><p><strong>场景二：<code>struct &#123;&#125;</code> 在中间</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object1 类型变量占用 16 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">b  <span class="type">byte</span></span><br><span class="line">s  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">b1 <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>按照对齐规则，变量 <code>o1</code> 占用 16 个字节；</li><li><code>&amp;o1.s</code> 和 <code>&amp;o1.b1</code>  相同；</li></ul><p>编译器不会对 <code>struct &#123; &#125;</code> 做任何字节填充。</p><p><strong>场景三：<code>struct &#123;&#125;</code> 在最后</strong></p><p>这个场景稍微注意下，因为编译器遇到之后会做特殊的字节填充补齐，如下；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">b <span class="type">byte</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object2 <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int64</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object3 <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int16</span></span><br><span class="line">m <span class="type">int16</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object4 <span class="keyword">struct</span> &#123;</span><br><span class="line">n  <span class="type">int16</span></span><br><span class="line">m  <span class="type">int64</span></span><br><span class="line">s  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1 &#123; &#125;</span><br><span class="line">o2 := Object2 &#123; &#125;</span><br><span class="line">o3 := Object3 &#123; &#125;</span><br><span class="line">o4 := Object4 &#123; &#125;</span><br></pre></td></tr></table></figure><p>编译器在遇到这种 <code>struct &#123;&#125;</code>  在<strong>最后一个字段</strong>的场景，会进行特殊填充，<code>struct &#123; &#125;</code> 作为最后一个字段，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变；</p><p>可以现在心里思考下，<code>o1</code>，<code>o2</code>，<code>o3</code>，<code>o4</code>  这四个对象的内存分配分别占多少空间？下面解密：</p><ul><li>变量 <code>o1</code>  大小为 2 字节；</li><li>变量 <code>o2</code>  大小为 16 字节；</li><li>变量 <code>o3</code>  大小为 6 字节；</li><li>变量 <code>o4</code>  大小为 24 字节；</li></ul><p>这种情况，需要先把 <code>struct &#123;&#125;</code>  按照前一个字段的长度分配 padding 内存，然后整个变量按照地址和长度的对齐规则不变。</p><h1 id="空结构体的作用"><a href="#空结构体的作用" class="headerlink" title="空结构体的作用"></a>空结构体的作用</h1><p>因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。</p><h2 id="实现-Set"><a href="#实现-Set" class="headerlink" title="实现 Set"></a>实现 Set</h2><p>Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。</p><p>因此呢，将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Has(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">_, ok := s[key]</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Add(key <span class="type">string</span>) &#123;</span><br><span class="line">s[key] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Delete(key <span class="type">string</span>) &#123;</span><br><span class="line"><span class="built_in">delete</span>(s, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>(Set)</span><br><span class="line">s.Add(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">s.Add(<span class="string">&quot;Sam&quot;</span>)</span><br><span class="line">fmt.Println(s.Has(<span class="string">&quot;Tom&quot;</span>))</span><br><span class="line">fmt.Println(s.Has(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不发送数据的-channel"><a href="#不发送数据的-channel" class="headerlink" title="不发送数据的 channel"></a>不发送数据的 <code>channel</code></h2><p>有时候使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。<code>struct&#123;&#125;</code> 通常作为一个信号来传输，并不关注其中内容。<code>channel</code> 本质的数据结构是一个管理结构加上一个 ringbuffer ，如果 <code>struct&#123;&#125;</code> 作为元素的话，ringbuffer 就是 0 分配的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> worker(ch)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种场景我们思考下，是否一定是非 <code>struct&#123;&#125;</code> 不可？其实不是，而且也不多这几个字节的内存，所以这种情况真的就只是不关心 <code>chan</code> 的元素值而已，所以才用的 <code>struct&#123;&#125;</code>。</p><h2 id="struct-作为-receiver"><a href="#struct-作为-receiver" class="headerlink" title="struct {} 作为 receiver"></a><code>struct &#123;&#125;</code> 作为 receiver</h2><p>receiver 这个是 golang 里 struct 具有的基础特点。空结构体本质上作为结构体也是一样的，可以作为 receiver 来定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyStruct)</span></span> FuncB(n, m <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e emptyStruct)</span></span> FuncA(n, m <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := emptyStruct&#123;&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">m := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a.FuncA(n, m)</span><br><span class="line">a.FuncB(n, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>receiver 这种写法是 golang 支撑面向对象的基础，本质上的实现也是非常简单，常规情况（普通的结构体）可以翻译成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncA</span> <span class="params">(e *emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncB</span> <span class="params">(e  emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器只是把对象的值或地址作为第一个参数传给这个参数而已，就这么简单。</strong> 但是在这里要提一点，空结构体稍微有一点点不一样，空结构体应该翻译成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncA</span> <span class="params">(e *emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncB</span> <span class="params">(n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00000000004525d0 &lt;main.main&gt;:</span><br><span class="line">  4525d0:64 48 8b 0c 25 f8 ff mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  4525d9:48 3b 61 10          cmp    0x10(%rcx),%rsp</span><br><span class="line">  4525dd:76 63                jbe    452642 &lt;main.main+0x72&gt;</span><br><span class="line">  4525df:48 83 ec 30          sub    $0x30,%rsp</span><br><span class="line">  4525e3:48 89 6c 24 28       mov    %rbp,0x28(%rsp)</span><br><span class="line">  4525e8:48 8d 6c 24 28       lea    0x28(%rsp),%rbp</span><br><span class="line">  4525ed:48 c7 44 24 18 01 00 movq   $0x1,0x18(%rsp)</span><br><span class="line">  4525f6:48 c7 44 24 20 02 00 movq   $0x2,0x20(%rsp)</span><br><span class="line">  4525ff:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  452604:48 89 04 24          mov    %rax,(%rsp)// n 变量值压栈（第一个参数）</span><br><span class="line">  452608:48 c7 44 24 08 02 00 movq   $0x2,0x8(%rsp)// m 变量值压栈（第二个参数）</span><br><span class="line">  452611:e8 aa ff ff ff       callq  4525c0 &lt;main.emptyStruct.FuncA&gt;</span><br><span class="line">  452616:48 8d 44 24 18       lea    0x18(%rsp),%rax</span><br><span class="line">  45261b:48 89 04 24          mov    %rax,(%rsp)// $rax 里面是 zerobase 的值，压栈（第一个参数）；</span><br><span class="line">  45261f:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  452624:48 89 44 24 08       mov    %rax,0x8(%rsp)// n 变量值压栈（第二个参数）</span><br><span class="line">  452629:48 8b 44 24 20       mov    0x20(%rsp),%rax</span><br><span class="line">  45262e:48 89 44 24 10       mov    %rax,0x10(%rsp)// m 变量值压栈（第三个参数）</span><br><span class="line">  452633:e8 78 ff ff ff       callq  4525b0 &lt;main.(*emptyStruct).FuncB&gt;</span><br><span class="line">  452638:48 8b 6c 24 28       mov    0x28(%rsp),%rbp</span><br><span class="line">  45263d:48 83 c4 30          add    $0x30,%rsp</span><br><span class="line">  452641:c3                   retq   </span><br><span class="line">  452642:e8 b9 7a ff ff       callq  44a100 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">  452647:eb 87                jmp    4525d0 &lt;main.main&gt;</span><br></pre></td></tr></table></figure><p>通过这段代码证实几个点：</p><ol><li>receiver 其实就是一种语法糖，本质上就是作为第一个参数传入函数；</li><li>receiver 为值的场景，不需要传空结构体做第一个参数，因为空结构体没有值；</li><li>receiver 为一个指针的场景，对象地址作为第一个参数传入函数，函数调用的时候，编译器传入 <code>zerobase</code> 的值（编译期间就可以确认）；</li></ol><p>在二进制编译之后，一般 <code>e.FuncA</code> 的调用，第一个参数是直接压入 <code>&amp;zerobase</code> 到栈里。</p><p>总结几个知识点：</p><ul><li>receiver 本质上是非常简单的一个通用思路，就是把对象值或地址作为第一参数传入函数；</li><li>函数参数压栈方式从前往后（可以调试看下）；</li><li>对象值作为 receiver 的时候，涉及到一次值拷贝；</li><li>golang 对于值做 receiver 的函数定义，会根据现实需要情况可能会生成了两个函数，一个值版本，一个指针版本（思考：什么是“需要情况”？就是有 <code>interface</code> 的场景 ）；</li><li>空结构体在编译期间就能识别出来的场景，编译器会对既定的事实，可以做特殊的代码生成；</li></ul><p>可以这么说，编译期间，关于空结构体的参数基本都能确定，那么代码生成的时候，就可以生成对应的静态代码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习上面空指针的各种使用场景，我们能得出结论，一般只会在以下两种情况会使用到空结构体：</p><ol><li>需要一个占位符，并不关系数据的内容。</li><li>节省空间。</li></ol><p>空结构体就像一些牛马一样，又让人家干活，又不给人家内存地址。是你，是我，是大家。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://geektutu.com/post/hpg-empty-struct.html">https://geektutu.com/post/hpg-empty-struct.html</a></li><li><a href="https://juejin.cn/post/6908733156707287048#heading-0">https://juejin.cn/post/6908733156707287048#heading-0</a></li><li><a href="https://juejin.cn/post/7228977496514560058">https://juejin.cn/post/7228977496514560058</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，正常的 &lt;code&gt;struct&lt;/code&gt; 就是一个普通的内存块，必定是要占用一块内存的，并且结构体的大小是要经过边界，长度是对其的。&lt;/p&gt;
&lt;p&gt;当你需要一个结构体，但是却丝毫不关系里面的内容，声明一个最小的结构体，也需要占用 1 字节，这是就要用</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>了解MongoDB——你想知道的都在这</title>
    <link href="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/"/>
    <id>http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/</id>
    <published>2024-06-02T12:11:30.000Z</published>
    <updated>2024-06-03T08:45:05.897Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。</p><p>本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。</p><h1 id="什么是-NoSQL？"><a href="#什么是-NoSQL？" class="headerlink" title="什么是 NoSQL？"></a>什么是 NoSQL？</h1><p>在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQL 以外，还了解什么数据库。我回答，不知道。结束后，我机智的舍友问我为什么不回答 NoSQL，我以为这是不知道其他数据库的英文表达（离谱）。</p><p>NoSQL 也被称为 “not only SQL” 或 “non-SQL”，它是一种数据库设计方法，可以在关系数据库中的传统结构之外存储和查询数据。</p><p>虽然 NoSQL 仍然可以存储关系数据库管理系统 (RDBMS) 中的数据，但与 RDBMS 相比，数据存储方式有所不同。决定使用关系数据库还是非关系数据库在很大程度上取决于上下文，并且因用例而异。</p><p>NoSQL 数据库并非采用关系数据库的典型表结构，而是将数据存储在一个数据结构中，例如 JSON 文档。由于这种非关系数据库设计不需要使用架构，因此，它提供快速可扩展性以管理通常为非结构化的大型数据集。</p><p>NoSQL 也是一种分布式数据库类型，这意味着将信息复制并存储在不同的服务器上，这些服务器可能是远程服务器或本地服务器。这确保了数据的可用性和可靠性。如果一些数据脱机，数据库的其他部分可以继续运行。</p><p><strong>特点</strong></p><ol><li><strong>灵活的数据模型</strong>：NoSQL数据库支持多种数据模型，如键值对、文档、列族和图形模型，适应各种应用场景。</li><li><strong>高可扩展性</strong>：通过分布式架构实现水平扩展，可以轻松添加更多的服务器来处理增加的数据量和流量。</li><li><strong>高性能</strong>：NoSQL数据库设计优化了读写操作，能提供高性能的查询速度。</li><li><strong>可用性和可靠性</strong>：通常具备内置的故障转移和数据复制机制，保证数据的高可用性和可靠性。</li></ol><p><strong>类型</strong></p><ol><li><p>键值存储（Key-Value Store）</p><p>：数据以键值对的形式存储，适合简单查询和高速读写操作。</p><ul><li>示例：Redis, DynamoDB</li></ul></li><li><p>文档存储（Document Store）</p><p>：数据以文档的形式存储，每个文档可以有不同的结构，适合存储复杂的嵌套数据。</p><ul><li>示例：MongoDB, CouchDB</li></ul></li><li><p>列族存储（Column-Family Store）</p><p>：数据以列的形式存储，每一列可以独立查询，适合大规模数据分析。</p><ul><li>示例：Cassandra, HBase</li></ul></li><li><p>图形数据库（Graph Database）</p><p>：数据以节点和边的形式存储，适合处理复杂关系和网络图。</p><ul><li>示例：Neo4j, ArangoDB</li></ul></li></ol><h2 id="常见的-NoSQL"><a href="#常见的-NoSQL" class="headerlink" title="常见的 NoSQL"></a>常见的 NoSQL</h2><p>以下是几个常用的NoSQL数据库及其主要特点：</p><ol><li>MongoDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式（BSON）存储数据，文档具有灵活的结构。</li><li>强大的查询和索引功能，支持复杂的查询操作。</li><li>支持水平扩展，通过分片实现高可扩展性。</li><li>提供复制集功能，保证数据的高可用性和自动故障转移。</li></ul></li></ul><ol><li>Cassandra</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>采用分布式架构，无单点故障，提供高可用性和高容错性。</li><li>高写入和读取性能，适用于大规模数据处理。</li><li>支持多数据中心的复制，保证数据的高可用性和一致性。</li><li>灵活的Schema设计，适合时间序列数据和大数据分析。</li></ul></li></ul><ol><li>Redis</li></ol><ul><li><strong>类型</strong>：键值存储（Key-Value Store）</li><li><strong>特点</strong>：<ul><li>数据存储在内存中，提供极高的读写性能，适用于实时应用。</li><li>支持多种数据结构，如字符串、哈希、列表、集合和有序集合。</li><li>提供丰富的操作和事务功能，支持发布/订阅、Lua脚本等。</li><li>具有持久化机制，数据可以持久化到磁盘。</li></ul></li></ul><ol><li>Neo4j</li></ol><ul><li><strong>类型</strong>：图形数据库（Graph Database）</li><li><strong>特点</strong>：<ul><li>以节点和关系（边）的形式存储数据，适合处理复杂关系和网络图。</li><li>提供强大的图形查询语言Cypher，支持高效的图遍历和查询操作。</li><li>广泛应用于社交网络、推荐系统和网络分析等场景。</li><li>提供ACID事务保证，确保数据一致性和可靠性。</li></ul></li></ul><ol><li>CouchDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式存储数据，每个文档可以有不同的结构。</li><li>提供RESTful API接口，便于集成和访问数据。</li><li>支持多主复制，允许在不同节点之间同步数据。</li><li>具备内置的冲突解决机制，适用于分布式环境。</li></ul></li></ul><ol><li>HBase</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>基于Hadoop HDFS构建，适用于处理大规模结构化数据。</li><li>提供强一致性的读写操作，适合需要高可靠性的应用。</li><li>支持随机读写和实时查询，适合大数据分析和实时应用。</li><li>与Hadoop生态系统紧密集成，支持MapReduce等大数据处理框架。</li></ul></li></ul><p>这些NoSQL数据库在不同的应用场景中发挥着重要作用，根据具体需求选择合适的数据库可以显著提升系统的性能和可扩展性。</p><h1 id="MongoDB-出现的原因"><a href="#MongoDB-出现的原因" class="headerlink" title="MongoDB 出现的原因"></a>MongoDB 出现的原因</h1><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。而MongoDB可应对“三高”需求。“三高”需求：</p><p>（1）High performance - 对数据库高并发读写的需求。</p><p>（2）Huge Storage - 对海量数据的高效率存储和访问的需求。</p><p>（3）High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对“三高”需求。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从它的命名也可以看出来，设计者是有一定野心的。MongoDB 的原名一开始<strong>来自于 英文单词”Humongous”, 中文含义是指”庞大”</strong>，即命名者的意图是可以处理大规模的数据。</p><p>在使用 MongoDB 我会有两种感觉：</p><ul><li>第一层感受是”爽”，使用这个文档数据库的特点是几乎不受什么限制，一方面Json文档式的结构更容易理解，而无Schema约束也让DDL管理更加简单，一切都可以很快速的进行。</li><li>第二层感受是”酸爽”，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验”太过于友好”，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。</li></ul><p>所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的RDBMS数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的话，会遇到更多的坑。</p><p>尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-aedbdb7187c091f3b2e091baea945806_720w.webp" alt="img"></p><p>在全部的排名中，MongoDB 长期排在第5位(文档数据库排名第1位)，同时也是最受欢迎的 NoSQL 数据库。</p><p>MongoDB 数据库的一些特性：</p><ul><li>面向文档存储，基于JSON/BSON 可表示灵活的数据结构</li><li>动态 DDL能力，没有强Schema约束，支持快速迭代</li><li>高性能计算，提供基于内存的快速数据查询</li><li>容易扩展，利用数据分片可以支持海量数据存储</li><li>丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。</li><li>跨平台版本、支持多语言SDK..</li></ul><h1 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h1><p>数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。</p><blockquote><p>关于这点，也有人说，MongoDB 是 NoSQL中最像SQL的数据库..</p></blockquote><p>我们来看与MySQL的对比，通过对比来学习其基本模型。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428161048312-2056386348.png" alt="img"></p><ul><li>database 数据库，与SQL的数据库(database)概念相同，一个数据库包含多个集合(表)</li><li>collection 集合，相当于SQL中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是<strong>动态的</strong>，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema的校验。</li><li>document 文档，相当于SQL中的行(row)，一个文档由多个字段(列)组成，并采用<code>bson(json)</code>格式表示。</li><li>field 字段，相当于SQL中的列(column)，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。</li></ul><p>此外，MongoDB中字段的类型是<strong>固定的</strong>、<strong>区分大小写</strong>、并且文档中的字段也是<strong>有序的</strong>。</p><p>另外，SQL 还有一些其他的概念，对应关系如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a4ce8ff9c69d5402f70baa1b050ad0d_720w.webp" alt="img"></p><ul><li>_id 主键，MongoDB 默认使用一个 _id 字段来保证文档的<strong>唯一性</strong>。</li><li>reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。</li><li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。</li><li>index 索引，与SQL 的索引相同。</li><li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li><li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li><li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li></ul><h2 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a><code>BSON</code> 数据类型</h2><p> MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以 <code>BSON（Binary-JSON）</code>文档的格式存储在磁盘上。</p><p><code>BSON（Binary Serialized Document Format）</code>是一种类 <code>json</code> 的一种二进制形式的存储格式，简称<code>Binary JSON</code>。<code>BSON</code>和<code>JSON</code>一样，支持 内嵌的文档对象和数组对象，但是<code>BSON</code>有<code>JSON</code>没有的一些数据类型，如Date和BinData类型。</p><p><code>BSON</code>采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p><code>BSON</code>中，除了基本的JSON类型：string, integer, boolean, double, null, array 和 object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详 细信息。</p><p>BSON数据类型参考列表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428163656218-1316936233.png" alt="img"></p><p> 提示： shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符 号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p><h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><p>面试问题：在进行数据库分表或者将同一个数据库部署到不同的服务器上，如何保证主键不重复。</p><p>当然，方法有很多，不同公司会有自己的处理方式，具体的后续会写文章来分析。我们先看在 MongoDB 中是如何保证主键不重复的。</p><p>在单机时代，大多数应用可以使用数据可自增式 ID 来作为主键。传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。</p><p>为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。</p><p>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-227bd6ae2f8a3c05546f51cfd4a0b7a8_720w.webp" alt="img"></p><p>其中包括：</p><ul><li>4-byte Unix 时间戳</li><li>3-byte 机器 ID</li><li>2-byte 进程 ID</li><li>3-byte 计数器(初始化随机)</li></ul><p>值得一提的是 _id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。<br>当然服务端也会检测写入的文档是否包含 _id 字段，如果没有就生成一个。</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>除了文档模型本身，对于数据的操作命令也是基于JSON/BSON 格式的语法。</p><p>详细的语法操作，可以去看<a href="https://www.mongodb.com/docs/manual/reference/sql-comparison/">官方的文档</a>，下面简单介绍一下基础使用语法。</p><p>比如插入文档的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.book.insert(</span><br><span class="line">&#123;</span><br><span class="line">  title: &quot;My first blog post&quot;,</span><br><span class="line">  published: <span class="keyword">new</span> <span class="type">Date</span>(),</span><br><span class="line">  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],</span><br><span class="line">  type: &quot;Work&quot;,</span><br><span class="line">  author : &quot;James&quot;,</span><br><span class="line">  viewCount: <span class="number">25</span>,</span><br><span class="line">  commentCount: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行文档查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;author : &quot;James&quot;&#125;)</span><br></pre></td></tr></table></figure><p>更新文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.book.update(</span><br><span class="line">   &#123;&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)&#125;,</span><br><span class="line">   &#123;&quot;$inc&quot;: &#123;&quot;viewCount&quot;: <span class="number">3</span>&#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>删除文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.remove(&#123;&quot;_id&quot;:</span><br><span class="line">     ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&quot;author&quot;: &quot;James&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;: <span class="number">1</span>, &quot;title&quot;: <span class="number">1</span>, &quot;author&quot;: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>实现简单的分页查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&#125;)</span><br><span class="line">    .sort(&#123;&quot;viewCount&quot; : <span class="number">-1</span>&#125;)</span><br><span class="line">    .<span class="keyword">skip</span>(<span class="number">10</span>).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。<br>与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。</p><p>那么，一个有趣的问题是 MongoDB 能不能用 SQL进行查询？</p><p>当然是可以！</p><p>但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：</p><ul><li>客户端使用SQL，可以使用 mongobooster、studio3t 这样的工具</li><li>服务端的话，可以看看 presto 之类的一些平台..</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。</p><p>索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。在索引的实现上使用了 B 树，MySQL 则是采用 B+ 树来实现索引的。</p><p>使用 <code>ensureIndexes</code> 可以为集合声明一个普通的索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;author: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>author后面的数字 1 代表升序，如果是降序则是 -1</p></blockquote><p>实现复合式(compound)的索引，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;type: 1, published: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>只有对于复合式索引时，索引键的顺序才变得有意义</p></blockquote><p>如果索引的字段是数组类型，该索引就自动成为数组(multikey)索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;tags: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个</p></blockquote><h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a><strong>索引特性</strong></h2><p>在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：</p><ul><li>unique=true，表示一个唯一性索引</li><li>expireAfterSeconds=3600，表示这是一个TTL索引，并且数据将在1小时后老化</li><li>sparse=true，表示稀疏的索引，仅索引非空(non-null)字段的文档</li><li>partialFilterExpression: { rating: { $gt: 5 }，条件式索引，即满足计算条件的文档才进行索引</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h2><p>除了普通索引之外，MongoDB 支持的类型还包括：</p><ul><li>哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。</li><li>地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。</li><li>文本索引，用于支持快速的全文检索</li><li>模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。</li></ul><h2 id="索引评估、调优"><a href="#索引评估、调优" class="headerlink" title="索引评估、调优"></a><strong>索引评估、调优</strong></h2><p>使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。<br>如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.explain().find( &#123; a : 5 &#125; )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;queryPlanner&quot; : &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;winningPlan&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">      &quot;inputStage&quot; : &#123;</span><br><span class="line">        &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">        &quot;keyPattern&quot; : &#123;</span><br><span class="line">            &quot;a&quot; : 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;indexName&quot; : &quot;a_1&quot;,</span><br><span class="line">        &quot;isMultiKey&quot; : false,</span><br><span class="line">        &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">        &quot;indexBounds&quot; : &#123;&quot;a&quot; : [&quot;[5.0, 5.0]&quot;]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果 winningPlan 中可以看出执行计划是否高效，比如：</p><ul><li>未能命中索引的结果，会显示COLLSCAN</li><li>命中索引的结果，使用IXSCAN</li><li>出现了内存排序，显示为 SORT</li></ul><p>更加详细的内容，请移步到<a href="https://www.mongodb.com/docs/manual/indexes/">官方文档</a>。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>在大数据领域常常提到的4V特征中，Volume(数据量大)是首当其冲被提及的。<br>由于单机垂直扩展能力的局限，<strong>水平扩展</strong>的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。<br>此外，同时为了保证数据的高可用，MongoDB 采用<strong>副本集</strong>的方式来实现数据复制。</p><p>一个典型的MongoDB集群架构会同时采用分片+副本集的方式，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6f849c75bffb439f06e9ceafe6263377_720w.webp" alt="img"></p><p><strong>架构说明</strong></p><ul><li>数据分片（Shards）<br>分片用于存储真正的集群数据，可以是一个单独的 Mongod实例，也可以是一个副本集。 生产环境下Shard一般是一个 Replica Set，以防止该数据片的单点故障。<br>对于分片集合(sharded collection)来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard中。</li><li>配置服务器（Config Servers）<br>保存集群的元数据（metadata），包含各个Shard的路由规则，配置服务器由一个副本集(ReplicaSet)组成。</li><li>查询路由（Query Routers）<br>Mongos是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的Shard。<br>Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。</li></ul><h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><p>基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片(Shard) 则记录在 Config Server(配置服务器)上。<br>Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。</p><p><strong>数据是根据分片策略来进行切分的，而分片策略则由 分片键(ShardKey)+分片算法(ShardStrategy)组成。</strong></p><p>MongoDB 支持两种分片算法：</p><h3 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a9c8b977f026d13650d5fd70818d280_720w.webp" alt="img"></p><p>假设集合根据x字段来分片，x的取值范围为[minKey, maxKey]（x为整型，这里的minKey、maxKey为整型的最小值和最大值），将整个取值范围划分为多个chunk，每个chunk（默认配置为64MB）包含其中一小段的数据：<br>如Chunk1包含x的取值在[minKey, -75)的所有文档，而Chunk2包含x取值在[-75, 25)之间的所有文档…</p><p>范围分片能很好的满足<strong>范围查询</strong>的需求，比如想查询x的值在[-30, 10]之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力，比如使用_id作为 ShardKey，而MongoDB自动生成的id高位是时间戳，是持续递增的。</p><h3 id="哈希分片"><a href="#哈希分片" class="headerlink" title="哈希分片"></a>哈希分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6beb0f8fd6e84d4ffa847d7a579bf1e7_720w.webp" alt="img"></p><p>Hash分片是根据用户的 ShardKey 先计算出hash值（64bit整型），再根据hash值按照<strong>范围分片</strong>的策略将文档分布到不同的 chunk。<br>由于 hash值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。</p><h2 id="如何保证均衡"><a href="#如何保证均衡" class="headerlink" title="如何保证均衡"></a>如何保证均衡</h2><p>既然数据是分布在不同的 chunk 上的，而不同的 chunk 会被分配到不同的分片上，那么就会出现一个问题，如何保证分片上的数据（chunk）是均衡的。</p><p>一般会有以下两种情况：</p><ul><li>全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10个shard，存储1000个chunk，那么每个shard 分别拥有100个chunk。</li><li>非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂(split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk数据的搬迁达到均衡。</li></ul><p>MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点)上，而该节点也同时会控制 Chunk 数据的搬迁流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-ecb42a8acff963eacb2463f56d51465b_720w.webp" alt="img"></p><p>对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-a4afc0f479a98f4d8fa6302159dd5d4b_720w.webp" alt="img"></p><p>MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将<a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/%23sharding-schedule-balancing-window">均衡窗口</a>对齐到业务闲时段。</p><h2 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h2><p>应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-02b6729e1ae7d867e243c30524278a29_720w.webp" alt=""></p><p>当然，连接高可用的功能是由 Driver 实现的。</p><h3 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h3><p>副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个Shard(片)之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。<br>MongoDB 的副本集采取了一主多从的结构，即一个Primary Node + N* Secondary Node的方式，数据从主节点写入，并复制到多个备节点。</p><p>典型的架构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-69646e694e88aafce80498990307df9b_720w.webp" alt="img"></p><p>利用副本集，我们可以实现：：</p><ul><li>数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；</li><li>读写分离，读请求可以分流到备节点，减轻主节点的单点压力。</li></ul><p>请注意，读写分离只能增加集群”读”的能力，对于写负载非常高的情况却无能为力。<br>对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘IO、CPU能力可以取得一定效果。</p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config <span class="operator">=</span> &#123;</span><br><span class="line">    _id : &quot;my_replica_set&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : <span class="number">0</span>, host : &quot;rs1.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">1</span>, host : &quot;rs2.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">2</span>, host : &quot;rs3.example.net:27017&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster()命令就可以看到选举的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.isMaster()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;hosts&quot; : [</span><br><span class="line">    &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;192.168.100.2:27030&quot;,</span><br><span class="line">    &quot;192.168.100.3:27030&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;setName&quot; : &quot;myReplSet&quot;,</span><br><span class="line">    &quot;setVersion&quot; : <span class="number">1</span>,</span><br><span class="line">    &quot;ismaster&quot; : <span class="literal">true</span>,</span><br><span class="line">    &quot;secondary&quot; : <span class="literal">false</span>,</span><br><span class="line">    &quot;primary&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;me&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;electionId&quot; : ObjectId(&quot;7fffffff0000000000000001&quot;),</span><br><span class="line">    &quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 Raft算法的影响，主节点的选举需要满足”大多数”原则，可以参考下表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-099f568819dbb05978634934e3aa585e_720w.webp" alt="img"></p><p>因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如3个，正所谓三人行必有我师..</p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a><strong>心跳</strong></h4><p>在高可用的实现机制中，心跳(heartbeat)是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。<br>副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。<br>利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-81382e5544264faae3d6954584fe9254_720w.webp" alt="img"></p><p>默认情况下，节点会每2秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在10秒内没有收到主节点的响应就会主动发起选举。<br>此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。<br>如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>主节点和备节点的数据是通过日志(oplog)复制来实现的，这很类似于 mysql 的 binlog。<br>在每一个副本集的节点中，都会存在一个名为local.oplog.rs的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条oplog，<br>而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。</p><p>下面，看看一条 oplog 的具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ts&quot; : <span class="type">Timestamp</span>(<span class="number">1446011584</span>, <span class="number">2</span>),</span><br><span class="line">&quot;h&quot; : NumberLong(&quot;1687359108795812092&quot;),</span><br><span class="line">&quot;v&quot; : <span class="number">2</span>,</span><br><span class="line">&quot;op&quot; : &quot;i&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.nosql&quot;,</span><br><span class="line">&quot;o&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;563062c0b085733f34ab4129&quot;), &quot;name&quot; : &quot;mongodb&quot;, &quot;score&quot; : &quot;100&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的一些关键字段有：</p><ul><li>ts 操作的 optime，该字段不仅仅包含了操作的时间戳(timestamp)，还包含一个自增的计数器值。</li><li>h 操作的全局唯一表示</li><li>v oplog 的版本信息</li><li>op 操作类型，比如 i=insert,u=update..</li><li>ns 操作集合，形式为 database.collection</li><li>o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容</li></ul><p>MongoDB 对于 oplog 的设计是比较仔细的，比如：</p><ul><li>oplog 必须保证有序，通过 optime 来保证。</li><li>oplog 必须包含能够进行数据回放的完整信息。</li><li>oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。</li><li>oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。</li></ul><h1 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h1><p>一直以来，”不支持事务” 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡(放弃事务，追求高性能、高可扩展)<br>但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。<br>在4.0 版本之后，MongoDB 开始支持多文档的事务：</p><ul><li>4.0 版本支持副本集范围的多文档事务。</li><li>4.2 版本支持跨分片的多文档事务(基于两阶段提交)。</li></ul><p>在事务的隔离性上，MongoDB 支持快照(snapshot)的隔离级别，可以避免脏读、不可重复读和幻读。<br>尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向系统写入一条数据，应该能够马上读到写入的这个数据。</span><br></pre></td></tr></table></figure><p>在分布式架构的CAP理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-12e5c64d1e1df25b325af95055a7012c_720w.webp" alt="img"></p><p>在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：</p><ul><li>read preference<br>读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点</li><li>write concern<br>写关注，指定写入结果达到什么状态时才返回，可以为无应答(none)、应答(ack)，或者是大多数节点完成了数据复制等等</li><li>read concern<br>读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读(linearizable)等等。</li></ul><p>使用不同的设定将会产生对于C(一致性)、A(可用性)的不同的抉择，比如：</p><ul><li>将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败(可用性降低)</li><li>将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟(出现不一致)</li><li>将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了(节点失效会导致大多数写失败)</li></ul><p>关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动failover等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>行文至此，笔者对 MongoDB 也有了基本的了解，那么在什么样的情况下才需要使用 MongoDB 呢？换句话说就是 MongoDB 的应用场景是什么。</p><p>以下是几个实际的应用案例。</p><ul><li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li><li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。</li><li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li><li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li><li>视频直播，使用 MongoDB 存储用户信息、礼物信息等。</li></ul><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高 对于这样的数据，我们更适合使用MongoDB来实现数据的存储。</p><h2 id="辅助决策"><a href="#辅助决策" class="headerlink" title="辅助决策"></a>辅助决策</h2><p>如果你还在为是否应该使用 MongoDB，不如来做几个选择题来辅助决策</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428154322305-1499789968.png" alt="img"></p><p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择MongoDB绝不会后悔。</p><h1 id="优势和局限性"><a href="#优势和局限性" class="headerlink" title="优势和局限性"></a>优势和局限性</h1><p>MongoDB 为需要可靠数据库的公司提供了众多优势。以下是使用 MongoDB 的一些好处：</p><ul><li>速度：MongoDB比一般的关系数据库快 100 倍。作为一个面向文档的数据库，MongoDB 通过索引使访问文档变得容易。这有助于快速查询响应，从而节省用户宝贵的时间。</li><li>分片：MongoDB 提供的另一个好处是它允许用户存储大量数据。这是通过将数据分发到连接到应用程序的多个服务器来完成的。如果一台服务器无法处理数据的大小，则通过称为自动分片的过程将其共享给另一台服务器。</li><li>灵活的数据库：MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由。</li><li>水平可扩展性：MongoDB 是一个可水平扩展的数据库，这是它的基本优势之一。它允许用户有效地将大量数据分发到多台机器。</li><li>事务可行性：一些 MongoDB 功能包括gridFS 和 Replication。这些功能支持在使用 MongoDB 时提高数据可用性。这确保了应用程序的性能非常高。</li><li>缺少模式：MongoDB 是 NoSQL，这意味着它不需要模式。因此，在使用 MongoDB 时无需概述数据库模式。这减少了数据库处理信息所需的时间。因此，您的架构将由您编写的算法定义。</li></ul><p>尽管 MongoDB 提供了优于其他数据库的显着优势，但它并不完美。它有一些需要改进的限制。以下是 MongoDB 的一些缺点。 </p><ul><li>不支持连接：与支持连接的理性数据库不同，MongoDB 不支持。虽然可以通过手动编码添加连接功能，但执行速度可能会很慢并影响性能。</li><li>高内存使用率：MongoDB 旨在为每个值对存储键名称。它还受到数据冗余的影响，因为它缺少连接功能。这会导致高内存使用率。</li><li>有限数据大小：MongoDB 允许的最大文档大小为16MB。这是一个需要纠正的严峻挑战。</li><li>有限嵌套：MongoDB 提供有限的嵌套访问，因为用户不能执行超过100 级的文档嵌套。</li></ul><h1 id="ChatGPT-怎么看"><a href="#ChatGPT-怎么看" class="headerlink" title="ChatGPT 怎么看"></a>ChatGPT 怎么看</h1><p>问：怎么理解MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由？</p><p>答：MongoDB 作为无模式（schema-less）的文档存储数据库，其设计允许在同一个集合（相当于关系数据库中的表）中的不同文档（相当于关系数据库中的行）具有不同的结构和类型。以下是对这一特性的详细解释：</p><h3 id="1-无模式（Schema-less）特性"><a href="#1-无模式（Schema-less）特性" class="headerlink" title="1. 无模式（Schema-less）特性"></a>1. 无模式（Schema-less）特性</h3><p>在传统的关系数据库中，所有行必须符合预定义的表结构（schema），即每一列的数据类型和属性在创建表时就已经固定下来。这意味着每一行的数据必须遵循相同的格式。</p><p>相比之下，MongoDB 不强制要求文档具有相同的结构。每个文档可以有不同的字段和数据类型。这种灵活性源于 MongoDB 使用 BSON（一种二进制的 JSON 格式）来存储数据。</p><h3 id="2-灵活的数据模型"><a href="#2-灵活的数据模型" class="headerlink" title="2. 灵活的数据模型"></a>2. 灵活的数据模型</h3><ul><li><strong>不同文档的结构可以不同</strong>：在同一个集合中，一个文档可以包含某些字段，而另一个文档可以不包含这些字段，或者包含不同的字段。例如，在一个用户集合中，一个文档可以包含 <code>name</code> 和 <code>email</code> 字段，而另一个文档可以包含 <code>name</code>、<code>email</code> 和 <code>phone</code> 字段。</li><li><strong>字段的数据类型可以不同</strong>：即使是相同字段，在不同文档中也可以具有不同的数据类型。例如，一个文档中的 <code>age</code> 字段可以是整数类型，而在另一个文档中，<code>age</code> 字段可以是字符串类型。</li></ul><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul><li><strong>灵活性</strong>：开发者可以根据需要随时添加或修改文档中的字段，而无需修改整个集合的结构。这使得开发迭代更快，特别是在需求频繁变化的项目中。</li><li><strong>适应性</strong>：能够轻松存储和处理复杂和多变的数据结构，如嵌套文档和数组。适用于需要处理异构数据（heterogeneous data）的应用场景。</li><li><strong>快速开发和原型设计</strong>：无需提前定义和维护模式，能够快速启动项目和进行原型设计。</li></ul><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>考虑一个用户集合，其中的文档结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123-456-7890&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在上述例子中：</p><ul><li>文档1 和 文档2 具有不同的字段，文档2 比文档1 多了 <code>phone</code> 字段。</li><li>文档3 没有 <code>email</code> 字段，但有 <code>age</code> 字段，并且 <code>age</code> 字段的数据类型为整数。</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul><li><strong>内容管理系统（CMS）</strong>：需要存储不同类型的内容，如文章、评论、用户信息等，每种内容的结构可能不同。</li><li><strong>物联网（IoT）</strong>：不同的传感器设备产生的数据格式可能不同，需要灵活存储和处理。</li><li><strong>快速原型设计</strong>：在产品开发初期，需求可能频繁变化，无模式数据库可以快速适应这些变化。</li></ul><h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul><li><strong>数据一致性和验证</strong>：由于没有固定模式，可能会引入不一致的数据，需要在应用层进行数据验证和清理。</li><li><strong>查询优化</strong>：灵活的结构可能会影响查询性能，需要通过索引和查询优化来提高效率。</li></ul><p>总之，MongoDB 的无模式特性为开发者提供了极大的灵活性，允许存储和处理多种类型和结构的数据，适应快速变化的需求和复杂的应用场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通读全文，好像感觉这篇文章在哪看过。对，没错，这就是笔者对几篇文章的缝合。边学习边记录吗，不错的学习模式。</p><p>总之，MongoDB 以其高并发、高扩展性、高可用性和无模式特性取得了不错的成绩。也逐渐变成了找工作必须要会的一项技能。情到深处，不得不搞个一首，“都是内卷惹的祸……”。</p><p>关于 MongoDB 的学习绝不仅于此，后续会记录深入的内容。</p><p>一位同志在第三次考ccf通过后突然顿悟，决定不考研了，乐。猜一下他学 Java 能学多久，刚好我也要学。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/littleatp/p/11675233.html">了解 MongoDB 看这一篇就够了</a></p><p><a href="https://www.cnblogs.com/liaowenhui/p/17362409.html">MongoDB 的简介及应用场景</a></p><p><a href="https://developer.aliyun.com/article/64352">什么场景下该用 MongoDB</a></p><p><a href="https://www.mongodb.com/docs/manual/">MongoDB 官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。&lt;/p&gt;
&lt;p&gt;本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战总结</title>
    <link href="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-01T10:02:00.000Z</published>
    <updated>2024-06-03T08:45:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。</p><p>主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。</p><p>从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。</p><p>学习MySQL的索引，就避不开要了解 B+ 树，在 MySQL 里 InnoDB 存储引擎就是采用 B+ 树来组织数据的，这是我们在背八股文时一定要记住的东西。那么在 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？为什么要选择 B+ 树来组织数据呢？下面我们来深入学习一下。</p><h2 id="从数据页的角度看-B-树"><a href="#从数据页的角度看-B-树" class="headerlink" title="从数据页的角度看 B+ 树"></a>从数据页的角度看 B+ 树</h2><p>这次，我们<strong>从数据页的角度看 B+ 树</strong>，看看每个节点长啥样。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f7696506a3c1c94621fcbad10341f1a8.png" alt="图片"></p><h3 id="InnoDB-是如何进行存储数据的？"><a href="#InnoDB-是如何进行存储数据的？" class="headerlink" title="InnoDB 是如何进行存储数据的？"></a>InnoDB 是如何进行存储数据的？</h3><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同，我们最常用的就是 InnoDB 存储引擎。</p><p>记录时按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p><p>因此，InnoDB 的数据时按<strong>「数据页」</strong>为单位来读写的，也就是说，当需要读一条数据的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>InnoDB 数据页的默认大小是 16KB</strong>，数据页包括七个部分，结构如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p><p>这 7 个部分的作用如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向的链表</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/557d17e05ce90f18591c2305871af665.png" alt="图片"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><hr><p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>可以得出，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h3 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h3><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><hr><p>看了这么多关于 B+ 树和数据库索引的内容，我们对其也有了基本的了解，那就来再解决一个问题吧，为什么要用 B+ 树，而不是其他的数据结构，也顺便了解一下其他的树相关的知识。</p><h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的。</p><h3 id="怎样的索引的数据结构是好的？"><a href="#怎样的索引的数据结构是好的？" class="headerlink" title="怎样的索引的数据结构是好的？"></a>怎样的索引的数据结构是好的？</h3><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存在磁盘上的，因为这样及时设备断电了，数据也不会丢失。</p><p>这样就带来了一个新的问题，速度太慢，因为磁盘是一个慢的离谱的存储设备。磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><blockquote><p>索引的数据最好是按顺序排列的，这样才能使用<strong>「二分查找法」</strong>高效定位数据。</p></blockquote><h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p><p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p><p>那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？</p><p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/49cb4df3fb7d4accbc75f6970ff1d0ea.gif" alt="请添加图片描述"></p><p>这样这个数组就变成了一个二叉查找树。</p><p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p><p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p><p>那么既然已经解决了所有问题，是不是就可以直接用二叉查找树来组织索引了。</p><p>不行，因为二叉查找树有一个致命的问题，那就是当新插入的数据全都比已有数据大或者小，那这个二叉查找树就变成了一个链表了，也就失去了现有的优势。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/320c5c2653e74f9e9ebfcd8ca9681905.gif" alt="请添加图片描述"></p><h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p><p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树。</p><p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，由于也被面试官提到过类似的问题，后面会单独写一篇博客来记录。</p><p>现在，平衡二叉树退化成为链表的情况被解决了，但是随着数据的插入，树会变得越来越高，查询次数也就越来越多。</p><p>下面我们来看一下二叉树和三叉树在有相同节点个数的情况下高度的差别。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2d26d30c953cd47c6ab637ad0eba2f99.png" alt="图片"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00fb73de7014a87958f1597345e9ef2f.png" alt="图片"></p><p><strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B 树"></a>B 树</h3><p>对于上一节中提到的问题，一个新的数据结构被提出——B 树，它不在限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，特点就是每个节点最多有 M-1个数据，超过这些要求的话，就会分裂节点。</p><p>这么看来，B 树好像又解决了所有已经出现的问题，还有新的吗，当然。毕竟我们的主角是 B+ 树。</p><p>正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？</p><p>在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p><p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p><h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>好了好了，没想到设计一个索引需要的数据结构能遇到这么多困难，现在我们的救世主——B+ 树他终于来了。</p><p>B+ 树就是对 B 树做了一个升级，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mysql-20240322142950.png" alt="用户1260737：B+树"></p><p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了。</p><p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p><p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p><hr><p>至此，所有出现的问题都得到了解决，当然也并不是在所有的数据库中都使用 B+ 树来存储索引。比如在 MongoDB 中存储索引的数据结构就是 B 树。详细原因还是在后面的博客中记录吧，挖个坑先……</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>腾讯第二次面试时提的问题，我回答的不知道，后来美团面试也问了，我答了几种情况，当时就只是背下来了，也不知道为什么，面试官想要更深入地问，我就又不会了。</p><p>那在本文中就详细解释一下这个问题吧。</p><p>在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。</p><p>但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。</p><p>稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低（之前我甚至以为索引失效是索引直接被删除了，脑子坏了）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9e6a9708a6dbbcc65906d1338d2ae70.png" alt=""></p><h2 id="索引长什么样？"><a href="#索引长什么样？" class="headerlink" title="索引长什么样？"></a>索引长什么样？</h2><p>我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。</p><p>索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。</p><p>MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构。在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p><p>MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。</p><p>虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：</p><ul><li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；</li><li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；</li></ul><p>举个栗子：</p><p>这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00730eac527c21a4034f0f9ba0218aba.png" alt="图片"></p><p>如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f287701eba9bf6f32a2d09b013bb451b.png" alt="图片"></p><p>如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（图中叶子节点之间是双向链表）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ef726d7287b854ea4862f7442d8012ec.png" alt="图片"></p><p>InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p><p>如果将 name 字段设置为普通索引，那么这个二级索引长下图这样（图中叶子节点之间是双向链表）</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7dd91be9fe584d94a4d71572ae7214d0.png" alt="图片"></p><p>在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 字段为主键索引</span><br><span class="line">select * from t_user where id=1;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：</p><ul><li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li><li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li></ul><p>上面这个过程叫做<strong>回表</strong>，如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select * from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做<strong>覆盖索引</strong>。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select id from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><h2 id="什么情况会导致索引失效？"><a href="#什么情况会导致索引失效？" class="headerlink" title="什么情况会导致索引失效？"></a>什么情况会导致索引失效？</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><blockquote><p>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</p></blockquote><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b161c1d88f978e42077f8c14e10972a7.png" alt="图片"></p><p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li><li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li></ul><p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p><h3 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h3><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><blockquote><p>为什么对索引使用函数，就无法走索引了呢？</p></blockquote><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><h3 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h3><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><blockquote><p>为什么对索引进行表达式计算，就无法走索引了呢？</p></blockquote><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><h3 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h3><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>MySQL 的数据类型转换规则是什么？是会将字符串转成数字处理，还是将数字转换成字符串处理。</p><p>《MySQL45讲》里有一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p><ul><li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li><li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li></ul><p>在 MySQL 中，执行的结果如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/25316fd06cadff4434f02391ef0b5c55.png" alt="图片"></p><p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>所以，在索引字段为字符串类型，比较字段为数字类型时，MySQL会对索引使用函数实现隐式类型转换，从而导致索引失效。</p><h3 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul><blockquote><p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？</p><p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>为什么联合索引不遵循最左匹配原则就会失效？</p></blockquote><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><h3 id="WHERE-字句中地-OR"><a href="#WHERE-字句中地-OR" class="headerlink" title="WHERE 字句中地 OR"></a>WHERE 字句中地 OR</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><h2 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h1 id="百万-千万级数据库如何优化？"><a href="#百万-千万级数据库如何优化？" class="headerlink" title="百万/千万级数据库如何优化？"></a>百万/千万级数据库如何优化？</h1><p>百万级、千万级数据处理，个人认为核心关键在于数据存储方案设计，存储方案设计的是否合理，直接影响到数据CRUD操作。总体设计可以考虑一下几个方面进行设计考虑：</p><ul><li>数据存储结构设计</li><li>索引设计</li><li>数据主键设计</li><li>查询方案设计</li></ul><p>由于本人也没有这个实力去真正实操百万千万级别地数据库，所以更到还是纸上谈兵，图个乐就行了。</p><h2 id="百万级"><a href="#百万级" class="headerlink" title="百万级"></a>百万级</h2><h3 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><ul><li>表字段 not null，因为 null 值很难查询优化且占用额外的索引空间，推荐默认数字 0。</li><li>数据状态类型的字段，比如 status, type 等等，尽量不要定义负数，如 -1。因为这样可以加上 UNSIGNED，数值容量就会扩大一倍。</li><li>可以的话用 TINYINT、SMALLINT 等代替 INT，尽量不使用 BIGINT，因为占的空间更小。</li><li>字符串类型的字段会比数字类型占的空间更大，所以尽量用整型代替字符串，很多场景是可以通过编码逻辑来实现用整型代替的。</li><li>字符串类型长度不要随意设置，保证满足业务的前提下尽量小。</li><li>用整型来存 IP。</li><li>单表不要有太多字段，建议在20以内。</li><li>为能预见的字段提前预留，因为数据量越大，修改数据结构越耗时。</li></ul><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul><li>索引，空间换时间的优化策略，基本上根据业务需求设计好索引，足以应付百万级的数据量，养成使用 explain 的习惯，关于 explain 也可以访问：explain 让你的 sql 写的更踏实了解更多。</li><li>一个常识：索引并不是越多越好，索引是会降低数据写入性能的。</li><li>索引字段长度尽量短，这样能够节省大量索引空间；</li><li>取消外键，可交由程序来约束，性能更好。</li><li>复合索引的匹配最左列规则，索引的顺序和查询条件保持一致，尽量去除没必要的单列索引。</li><li>值分布较少的字段（不重复的较少）不适合建索引，比如像性别这种只有两三个值的情况字段建立索引意义不大。</li><li>需要排序的字段建议加上索引，因为索引是会排序的，能提高查询性能。</li><li>字符串字段使用前缀索引，不使用全字段索引，可大幅减小索引空间。</li></ul><h3 id="查询语句优化"><a href="#查询语句优化" class="headerlink" title="查询语句优化"></a>查询语句优化</h3><ul><li>尽量使用短查询替代复杂的内联查询。</li><li>查询不使用 select *，尽量查询带索引的字段，避免回表。</li><li>尽量使用 limit 对查询数量进行限制。</li><li>查询字段尽量落在索引上，尤其是复合索引，更需要注意最左前缀匹配。</li><li>拆分大的 delete / insert 操作，一方面会锁表，影响其他业务操作，还有一方面是 MySQL 对 sql 长度也是有限制的。</li><li>不建议使用 MySQL 的函数，计算等，可先由程序处理，从上面提的一些点会发现，能交由程序处理的尽量不要把压力转至数据库上。因为多数的服务器性能瓶颈都在数据库上。</li><li>查询 count，性能：count(1) = count(*) &gt; count(主键) &gt; count(其他字段)。</li><li>查询操作符能用 between 则不用 in，能用 in 则不用 or。</li><li>避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符，因为这些查询无法使用索引。</li><li>sql 尽量简单，少用 join，不建议两个 join 以上。</li></ul><h2 id="千万级"><a href="#千万级" class="headerlink" title="千万级"></a>千万级</h2><h3 id="数据存储结构设计-1"><a href="#数据存储结构设计-1" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><p>到了这个阶段的数据量，数据本身已经有很大的价值了，数据除了满足常规业务需求外，还会有一些数据分析的需求。而这个时候数据可变动性不高，基本上不会考虑修改原有结构，一般会考虑从分区，分表，分库三方面做优化：<br><strong>分区</strong><br>分区是根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分，是一种水平划分。对应用来说是完全透明的，不影响应用的业务逻辑，即不用修改代码。因此能存更多的数据，查询，删除也支持按分区来操作，从而达到优化的目的。如果有考虑分区，可以提前做准备，避免下列一些限制：</p><ul><li>一个表最多只能有1024个分区（6之后支持8192个分区）。但你实际操作的时候，最好不要一次性打开超过100 个分区，因为打开分区也是有时间损耗的。</li><li>如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。</li><li>分区表中无法使用外键约束。</li><li>NULL值会使分区过滤无效，这样会被放入默认的分区里，请千万不要让分区字段出现NULL。</li><li>所有分区必须使用相同的存储引擎。</li></ul><p><strong>分表</strong><br>分表分水平分表和垂直分表。<br>水平分表即拆分成数据结构相同的各个小表，如拆分成 table1, table2…，从而缓解数据库读写压力。<br>垂直分表即将一些字段分出去形成一个新表，各个表数据结构不相同，可以优化高并发下锁表的情况。<br>可想而知，分表的话，程序的逻辑是需要做修改的，所以，一般是在项目初期时，预见到大数据量的情况，才会考虑分表。后期阶段不建议分表，成本很大。<br><strong>分库</strong><br>分库一般是主从模式，一个数据库服务器主节点复制到一个或多个从节点多个数据库，主库负责写操作，从库负责读操作，从而达到主从分离，高可用，数据备份等优化目的。<br>当然，主从模式也会有一些缺陷，主从同步延迟，binlog 文件太大导致的问题等等，这里不细讲（笔者也学不动了）。<br><strong>其他</strong><br>冷热表隔离。对于历史的数据，查询和使用的人数少的情况，可以移入另一个冷数据库里，只提供查询用，来缓解热表数据量大的情况。</p><h3 id="数据库表主键设计"><a href="#数据库表主键设计" class="headerlink" title="数据库表主键设计"></a><strong>数据库表主键设计</strong></h3><p>数据库主键设计，个人推荐带有时间属性的自增长数字ID。（分布式自增长ID生成算法）<br>雪花算法<br>百度分布式ID算法<br>美团分布式ID算法<br>为什么要使用这些算法呢，这个与MySQL数据存储结构有关</p><p><strong>从业务上来说</strong></p><p>   在设计数据库时不需要费尽心思去考虑设置哪个字段为主键。然后是这些字段只是理论上是唯一的，例如使用图书编号为主键，这个图书编号只是理论上来说是唯一的，但实践中可能会出现重复的情况。所以还是设置一个与业务无关的自增ID作为主键，然后增加一个图书编号的唯一性约束。</p><p><strong>从技术上来说</strong></p><ol><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。</li><li>对InnoDB来说主键索引既存储索引值，又在叶子节点中存储行的数据，也就是说数据文件本身就是按照b+树方式存放数据的。</li><li>如果没有定义主键，则会使用非空的UNIQUE键做主键 ; 如果没有非空的UNIQUE键，则系统生成一个6字节的rowid做主键;聚簇索引中，N行形成一个页（一页通常大小为16K)。如果碰到不规则数据插入时，为了保持B+树的平衡，会造成频繁的页分裂和页旋转，插入速度比较慢。所以聚簇索引的主键值应尽量是连续增长的值，而不是随机值(不要用随机字符串或UUID)。</li><li>故对于InnoDB的主键，尽量用整型，而且是递增的整型。这样在存储/查询上都是非常高效的。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又到了我最爱的总结环节了，就能想写什么就写什么了。本来这篇文章要写四大部份的，还有一个sql注入的问题，之前看的文章就讲了一点例子，我以为就只有那么一点呢，今天仔细一查才发现还有那么多没有看过，下次再写吧。</p><p>昨天为什么破防，因为还是没有找到实习，一直都没有公司跟我约面试，我也不知道是那个环节出现问题了，可能还是因为学的东西太少了吧，所以我决定不找实习了，沉淀三个月，把MongoDO、kafka、docker、k8s还有Linux这些东西学一下。</p><p>之前一直觉得边找边学挺好的，找着找着发现面试太少了，不能从面试里面学到什么东西，又要因为准备面试耽误时间。我还是得练练表达能力，老是紧张也不是个事啊。加油吧，祝我自己秋招顺利，也祝我的朋友们考研成功、秋招顺利。还有两个有实习的，那就祝他们实习顺利吧（呜呜呜……，留下了羡慕的泪水）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/mysql/index/index_interview.html">小林coding 图解MySQL 索引篇</a></p><p><a href="https://javabetter.cn/sidebar/sanfene/mysql.html">MySQL八股文</a></p><p><a href="https://bbs.huaweicloud.com/blogs/222183">数据库优化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。&lt;/p&gt;
&lt;p&gt;主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。&lt;/p&gt;
&lt;p&gt;从头开始总结一下最近一段时</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>解锁灵活与高效——Casbin</title>
    <link href="http://example.com/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/"/>
    <id>http://example.com/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/</id>
    <published>2024-05-31T13:52:01.000Z</published>
    <updated>2024-05-31T15:32:35.988Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇博客的标题看起来就很有逼格，不错，就是我们万能的 ChatGPT起的。当然，还是稍微改了一下，它给的实在是太有逼格了，我不太敢用。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240531215653176.png" alt="image-20240531215653176"></p><p>每隔一段时间使用ChatGPT就会给我一种AI已经发展得这么牛逼的感觉，但是每次用它来解决一些实际问题的时候又会让我觉得它是个智障。</p><p>不得不说，ChatGPT在很多方面都已经发展到了可以取代一大部分人的水平了。从它出现之后，我就没有自己动手写过思政方面的任何东西，全是它完成的，属实是有点东西。写点题外话让破防的自己慢慢恢复一下，题外话到此为止。</p><p>本文要记录的是一个访问控制库——Casbin。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Casbin 是一个开源的访问控制框架，用于实现权限管理和访问控制的功能。它提供了一种简单而灵活的访问控制模型，可以用于保护应用程序、服务或其他系统中的资源。Casbin 的设计目标是提供一种通用的访问控制模型，并支持多种编程语言。</p><p>Casbin 的核心概念是访问控制模型和策略。访问控制模型定义了一组规则，用于描述谁可以访问哪些资源以及在什么条件下可以访问。策略是基于模型定义的规则，描述了实际的访问控制规则集合。</p><p>Casbin 支持多种访问控制模型，包括基于角色的访问控制（RBAC）、访问控制列表（ACL）和属性访问控制（ABAC）等。它还提供了灵活的策略管理机制，可以将策略存储在不同的持久化存储中，如文件、数据库或远程服务。</p><p>使用 Casbin，你可以轻松地实现细粒度的权限管理，定义和管理角色、资源和操作之间的访问规则，并在应用程序中进行访问控制的验证。无论是 Web 应用程序、API 服务还是其他类型的系统，Casbin 都可以帮助你实现安全的访问控制机制。</p><h2 id="关键性概念"><a href="#关键性概念" class="headerlink" title="关键性概念"></a>关键性概念</h2><ol><li>模型（Model）：模型定义了访问控制策略的基本结构和规则。它由多个规则组成，每个规则包含多个字段，如”sub”（Subject，主体，表示用户）、”obj”（Object，对象，表示资源）、”act”（Action，动作，表示操作）等。</li><li>策略（Policy）：策略是实际的访问控制规则集合，用于定义谁可以对什么资源执行什么操作。Casbin 支持多种类型的策略，包括基于角色的访问控制（Role-Based Access Control，RBAC）、基于对象的访问控制（Object-Based Access Control，OBAC）等。</li><li>主体（Subject）：主体代表用户或者实体，它通常通过唯一标识符（如用户名、角色等）进行识别。主体在访问控制中被授予特定的权限。</li><li>对象（Object）：对象代表系统中的资源，可以是文件、数据库表、API 端点等。对象具有特定的属性和标识符，用于确定访问控制规则。</li><li>动作（Action）：动作表示主体对对象执行的操作或行为，如读取、写入、删除等。动作定义了主体对资源的权限。</li><li>策略存储（Policy Store）：策略存储用于存储和管理策略规则。Casbin 支持多种策略存储后端，如内存、文件、数据库等。</li></ol><p>通过定义模型、策略和访问请求，Casbin 可以进行访问控制决策，判断是否允许主体执行特定的操作。它提供了灵活的访问控制模型和丰富的策略管理功能，使开发人员能够轻松实现细粒度的权限管理和访问控制策略。</p><h1 id="和JWT有什么关系"><a href="#和JWT有什么关系" class="headerlink" title="和JWT有什么关系"></a>和<code>JWT</code>有什么关系</h1><p>提到鉴权，笔者第一个学习到的是 JWT。之前面试官会问，在你的项目里面是怎么实现鉴权操作的。我会统一回答，使用JWT生成token，然后解析出用户数据，最后在数据库中查找相关信息。其实我也不知道这样的回答是不是正确的，反正那么多场面试到最后都是不了了之，这都不是重点，重点是不要把 casbin 和 JWT 搞混了。</p><p>JWT（JSON Web Token）鉴权和 Casbin 鉴权在权限管理体系中扮演着不同但互补的角色。以下是它们的关系和区别：</p><h3 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h3><p><strong>JWT 鉴权：</strong></p><ul><li><strong>作用：</strong> JWT 主要用于认证（Authentication），即验证用户的身份。它确保请求的发起者是合法用户。</li><li><strong>功能：</strong> JWT 是一种自包含的令牌，通常包含用户ID、用户名、角色等信息，并且通过数字签名进行验证，确保数据的完整性和真实性。</li></ul><p><strong>Casbin 鉴权：</strong></p><ul><li><strong>作用：</strong> Casbin 主要用于授权（Authorization），即确定已认证用户是否有权限执行某个操作。它基于访问控制模型和策略来决定权限。</li><li><strong>功能：</strong> Casbin 通过模型和策略定义权限规则，可以实现复杂的权限管理，如基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>JWT 鉴权：</strong></p><ol><li>用户登录并提供凭据（用户名和密码）。</li><li>服务器验证凭据，如果验证通过，生成 JWT 并返回给用户。</li><li>用户在后续请求中附带 JWT（通常在 HTTP 头部的 Authorization 字段）。</li><li>服务器验证 JWT 的签名和有效期，确定用户身份。</li></ol><p><strong>Casbin 鉴权：</strong></p><ol><li>用户的请求经过 JWT 验证后，服务器获取用户身份信息。</li><li>服务器根据用户身份信息（如用户ID或角色），请求资源和操作。</li><li>使用 Casbin 的 Enforcer 进行权限校验，判断用户是否有权执行该操作。</li><li>根据校验结果，允许或拒绝用户的请求。</li></ol><h3 id="关系和结合"><a href="#关系和结合" class="headerlink" title="关系和结合"></a>关系和结合</h3><ul><li><strong>关系：</strong> JWT 和 Casbin 是互补的。JWT 负责认证，确保请求者的身份；Casbin 负责授权，确保请求者有权限执行特定操作。</li><li><strong>结合：</strong> 在实际应用中，通常会先进行 JWT 验证，确认用户身份后，再使用 Casbin 进行权限检查。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><strong>JWT 验证身份，Casbin 验证权限：</strong> JWT 确认用户是谁，Casbin 确认用户能做什么。</li><li><strong>JWT 是一种令牌，Casbin 是一种访问控制工具：</strong> JWT 是一种令牌机制，用于在无状态的环境中传递用户信息。Casbin 是一个权限管理库，用于根据预定义的策略进行权限判断。</li><li><strong>使用时机不同：</strong> JWT 通常在每次请求的开始进行验证，以确定用户身份。而 Casbin 的权限校验则在身份验证通过后，根据请求的具体资源和操作进行。</li></ul><h3 id="结合实例"><a href="#结合实例" class="headerlink" title="结合实例"></a>结合实例</h3><p>在一个 Web 应用中，结合 JWT 和 Casbin 的典型流程如下：</p><ol><li><p><strong>用户登录：</strong></p><ul><li>用户提交登录信息。</li><li>服务器验证登录信息，生成 JWT 并返回给用户。</li></ul></li><li><p><strong>用户请求资源：</strong></p><ul><li>用户在请求头中附带 JWT 访问资源。</li><li>服务器验证 JWT，确定用户身份。</li></ul></li><li><p><strong>权限校验：</strong></p><ul><li>服务器提取用户身份、请求资源和操作。</li><li>使用 Casbin Enforcer 进行权限检查，判断用户是否有权访问该资源或执行该操作。</li></ul></li><li><p><strong>处理请求：</strong></p><ul><li>如果权限校验通过，处理请求并返回结果。</li><li>如果权限校验不通过，返回 403 Forbidden 响应。</li></ul></li></ol><p>通过这种方式，JWT 和 Casbin 可以无缝结合，实现安全且灵活的认证和授权机制。</p><h1 id="能做什么？又不能做什么？"><a href="#能做什么？又不能做什么？" class="headerlink" title="能做什么？又不能做什么？"></a>能做什么？又不能做什么？</h1><p>我们从上面的回答就能看出，这两个东西其实是结合在一起使用的，在本项目中也是如此。在更加详细地了解其原理之前，我们先来看一下在什么情况下会使用到它。</p><h2 id="Can-Do"><a href="#Can-Do" class="headerlink" title="Can Do"></a>Can Do</h2><ol><li>以典型的 {主体、对象、动作} 形式或您定义的自定义形式形成策略。支持允许和拒绝授权。</li><li>具有访问控制模型 <code>model</code> 和策略 <code>policy</code> 两个核心概念。</li><li>支持 RBAC 中的多层角色继承，不止主体可以有角色，资源也可以具有角色。</li><li>支持内置超级用户，如 <code>root</code> 或 <code>administrator</code>。 超级用户可以在没有明确权限的情况下做任何事情。</li><li>提供多个内置操作符，支持规则匹配。例如，<code>keyMatch</code> 可将资源键 <code>/foo/bar</code> 映射到模式 <code>/foo*</code>。</li></ol><h2 id="Can‘t-do"><a href="#Can‘t-do" class="headerlink" title="Can‘t do"></a>Can‘t do</h2><ol><li>验证（又称用户登录时验证用户名和密码）：Casbin 仅负责权限管理，不负责用户身份验证。身份验证需要通过其他机制（如 JWT、OAuth 等）实现。</li><li>管理用户列表或角色列表：Casbin 不提供用户管理功能，如用户注册、密码管理等。这些功能通常由用户管理系统（如 LDAP、Active Directory）或自定义用户管理模块实现。</li><li>数据加密和解密：Casbin 不处理数据的加密和解密任务。这需要通过其他安全工具和库来实现。</li><li>网络安全：Casbin 不直接处理网络安全问题，如防火墙、防御 DDoS 攻击等。这需要通过网络安全设备和配置来实现。</li><li>审计和日志管理：虽然 Casbin 可以配合其他工具进行权限使用的审计和日志记录，但它自身不具备全面的审计和日志管理功能。</li></ol><p>项目管理用户、角色或密码列表更加方便。用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。 而是存储 RBAC 方案中用户和角色之间的映射关系。</p><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><p>讲了那么对概念，想必对casbin也有了一个大概的了解了。拿就来看一下要怎么使用吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> ( </span><br><span class="line"><span class="string">&quot;github.com/casbin/casbin/v2&quot;</span> </span><br><span class="line"><span class="string">&quot;fmt&quot;</span> </span><br><span class="line">) </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">sub := <span class="string">&quot;lili&quot;</span> </span><br><span class="line">obj := <span class="string">&quot;/posts&quot;</span> </span><br><span class="line">act := <span class="string">&quot;GET&quot;</span> </span><br><span class="line"> </span><br><span class="line"> e,err := casbin.NewEnforcer(<span class="string">&quot;resources/model.conf&quot;</span>,<span class="string">&quot;resources/policy.csv&quot;</span>) </span><br><span class="line"> checkError(err) </span><br><span class="line">ok,err := e.Enforce(sub,obj,act) </span><br><span class="line"> checkError(err) </span><br><span class="line"> <span class="keyword">if</span> ok &#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;通过！&quot;</span>) </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;不通过！&quot;</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 统一错误检查 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span>  &#123; </span><br><span class="line"> <span class="keyword">if</span> err!=<span class="literal">nil</span> &#123; </span><br><span class="line">  <span class="built_in">println</span>(err.Error()) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里面涉及到两个配置文件，分别是 model.conf 和 policy.csv 文件。</p><p>内容如下：</p><p><strong>model.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[request_definition] </span><br><span class="line">r = sub, obj, act </span><br><span class="line"> </span><br><span class="line">[policy_definition] </span><br><span class="line">p = sub, obj, act </span><br><span class="line"> </span><br><span class="line">[role_definition] </span><br><span class="line">g = _, _ </span><br><span class="line"> </span><br><span class="line">[policy_effect] </span><br><span class="line">e = some(where (p.eft == allow)) </span><br><span class="line"> </span><br><span class="line">[matchers] </span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act </span><br></pre></td></tr></table></figure><p><strong>policy.csv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p, member, /posts, GET </span><br><span class="line">p, member, /posts/:id, GET </span><br><span class="line"> </span><br><span class="line">p, admin, /posts, POST </span><br><span class="line">p, admin, /posts/:id, PUT </span><br><span class="line">p, admin, /posts/:id, DELETE </span><br><span class="line"> </span><br><span class="line">g, admin, member </span><br><span class="line">g, super, admin </span><br><span class="line">g, lili, member </span><br></pre></td></tr></table></figure><p>这两个配置文件你现在就暂时先理解为 model.conf 定义了匹配规则，policy.csv 定义了权限组等权限。</p><p>直接运行起来，你会看到控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过！ </span><br></pre></td></tr></table></figure><p>假如此时我们把 act 改成 POST 就不能通过了。</p><hr><p>学习过大概怎么使用后，就要更加深入地学习了。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>casbin 支持多种模型，适用于多种业务场景</p><ol><li><a href="https://en.wikipedia.org/wiki/Access_control_list"><strong>ACL (Access Control List, 访问控制列表)</strong></a></li><li><strong>具有 <a href="https://en.wikipedia.org/wiki/Superuser">超级用户</a> 的 ACL</strong></li><li><strong>ACL without users</strong>: 这对于没有身份验证或用户登录的系统特别有用。</li><li><strong>ACL without resources</strong>: 在某些场景中，目标是一种类型的资源，而不是单个资源。可以使用 “写文章” 和 “读日志” 等权限。这不会控制对特定文章或日志的访问。</li><li><strong><a href="https://en.wikipedia.org/wiki/Role-based_access_control">RBAC (基于角色的访问控制)</a></strong></li><li><strong>RBAC with resource roles</strong>: 用户和资源可以同时拥有角色（或组）。</li><li><strong>RBAC with domains/tenants</strong>: 用户可以为不同的域 / 租户拥有不同的角色集。</li><li><strong><a href="https://en.wikipedia.org/wiki/Attribute-Based_Access_Control">ABAC (Attribute-Based Access Control)</a></strong>: 像 “resource.Owner” 这样的语法糖可以用来获取资源的属性。</li><li><strong><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a></strong>: 支持 “/res/*”、“/res/：id” 等路径，以及 “GET”、“POST”、“PUT”、“DELETE” 等 HTTP 方法。</li><li><strong>Deny-override</strong>: 在允许拒绝覆盖的情况下，允许和拒绝授权都受支持。</li><li><strong>Priority</strong>: 策略规则可以按优先级排列，类似于防火墙规则。</li></ol><p>一般会通过使用场景确定模型，然后在官网实例中查询模型，直接使用。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>casbin 支持通过加载存储的模型、策略、策略子集实现动态调整。</p><h3 id="模型的存储"><a href="#模型的存储" class="headerlink" title="模型的存储"></a>模型的存储</h3><p>与策略不同，模型只能加载，不能保存。我们认为，模型不是动态组件，不应在运行时修改，因此我们没有实现将模型保存到存储中的应用程序接口。</p><p>不过，有一个好消息。我们提供了三种等效的方法来静态或动态加载模型：</p><ul><li>从 <code>.conf</code> 文件中加载 model</li><li>从代码加载 model</li><li>从字符串加载 model</li></ul><h3 id="策略地存储"><a href="#策略地存储" class="headerlink" title="策略地存储"></a>策略地存储</h3><p>在 casbin 中，策略存储作为 <strong>适配器</strong> 来实现</p><ul><li>从 <code>.csv</code> 文件加载</li><li>从后端存储加载实现</li></ul><h3 id="策略子集加载"><a href="#策略子集加载" class="headerlink" title="策略子集加载"></a>策略子集加载</h3><p>一些 adapter 支持过滤策略管理。 这意味着 Casbin 加载的策略是根据给定过滤器存储在数据库中的策略的子集。这样就能在大型多租户环境中高效执行策略，因为在这种环境中，解析整个策略会成为性能瓶颈。</p><p>为了防止意外数据丢失，当策略已经加载， SavePolicy 方法会被禁用。</p><p>要使用支持的 adapter 处理过滤后的策略，只需调用 <code>LoadFilteredPolicy</code> 方法。 过滤器参数的有效格式取决于所用的适配器。 为了防止意外数据丢失，当策略已经加载， <code>SavePolicy</code> 方法会被禁用。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>Casbin 使用配置文件来定义访问控制模型。</p><p>例如使用文件记录模型和策略存储文件，作为两个配置文件：<code>model.conf</code> 和 <code>policy.csv</code>。<code>model.conf</code> 保存访问模型，而 <code>policy.csv</code> 保存具体的用户权限配置。<code>Casbin</code> 的使用非常简单。我们只需创建一个主要结构：<code>enforcer</code>。当构造这个结构的时候，<code>model.conf</code> 和 <code>policy.csv</code> 将会被加载。</p><p>换句话说，<strong>要创建一个 Casbin 执行器，您需要提供一个模型和一个适配器。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, <span class="string">&quot;path/to/policy.csv&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 Casbin 中，执行器（Enforcer）是负责执行访问控制策略的核心组件。它提供了一系列方法，用于判断主体是否被授予对特定资源执行特定操作的权限。</p><p>执行器的主要功能包括：</p><ol><li>加载策略：执行器可以从不同的策略存储（如文件、数据库）中加载访问控制策略。它可以读取和解析策略规则，并将其转换为内部模型进行处理。</li><li>决策判断：执行器可以根据加载的策略和传入的访问请求，进行访问控制决策。它会根据模型中定义的规则和策略，判断主体是否有权限执行特定的操作。</li><li>策略管理：执行器提供了管理策略的方法，可以动态地添加、修改或删除策略规则。这使得开发人员可以根据需要对访问控制策略进行灵活的调整和管理。</li><li>角色管理：执行器支持角色（Role）的管理，包括角色的添加、删除和关联。角色可以用于实现基于角色的访问控制（RBAC）模型。</li></ol><p>通过执行器，开发人员可以轻松地集成 Casbin 的访问控制功能到他们的应用程序中。执行器提供了简单而强大的 API，使开发人员能够方便地进行访问控制决策和策略管理。</p><h3 id="几种执行器"><a href="#几种执行器" class="headerlink" title="几种执行器"></a>几种执行器</h3><ul><li>通用执行器：最基础的执行器，Enforcer 是用户与 Casbin 策略和模型交互的基本结构。</li><li>带缓存的执行器：<code>CachedEnforcer</code> 基于 <code>Enforcer</code>，支持使用 <code>map</code> 将请求的判断结果（是否具有能力）缓存在内存中。它能在指定的过期时间内清除缓存。此外，它还通过读写锁保证线程安全。您可以使用 <code>EnableCache</code> 启用缓存评估结果（默认为启用）。<code>CachedEnforcer</code> 的其他 API 方法与 <code>Enforcer</code> 相同。</li><li>分布式执行器：<code>DistributedEnforcer</code> 支持分布式集群中的多个实例。它为调度器封装了 <code>SyncedEnforcer</code>。官方的分布式执行器无法指定适配器，使用内置的适配器，而且通过 HTTP 接口实现一致性。</li><li>同步执行器：<code>SyncedEnforcer</code> 同步执行器提供并发功能，是线程安全的。</li><li>带缓存的同步执行器：<code>SyncedCachedEnforcer</code> ，同步执行器和带缓存的执行器结合</li></ul><p>如何挑选：</p><ul><li>如果是简单环境，使用通用执行器：<code>casbin.NewEnforcer()</code></li><li>如果需要提高判断结果的并发，则使用带缓存的执行器：<code>casbin.NewCachedEnforcer()</code></li><li>如果是分布式的场景，例如多个服务器集群中，每个集群都需要有 casbin 实例，而且需要有独立的后端存储，则使用分布式执行器：<code>casbin.NewDistributedEnforcer()</code></li><li>如果会频繁变动策略，而且是并发场景，则使用同步执行器：<code>casbin.NewSyncedEnforcer()</code></li><li>如果既要频繁变动策略，也要求判断结果的高并发，则使用带缓存的同步执行器：<code>casbin.NewSyncedCachedEnforcer()</code></li></ul><p>在当下云原生的场景下，部署在 <code>k8s</code> 上，并且后端使用同一个存储，多个实例，推荐使用同步执行器或者带缓存的同步执行器。</p><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>在 Casbin 中，策略存储作为 adapter (Casbin 的中间件) 实现。 Casbin 用户可以使用 adapter 从存储中加载策略规则 (<code>LoadPolicy()</code>) 或者将策略规则保存到其中 (<code>SavePolicy()</code>)。</p><blockquote><ol><li>如果使用显式或隐式 adapter 调用 <code>casbin.NewEnforcer()</code>，策略将自动加载。</li><li>可以调用 <code>e.LoadPolicy()</code> 来从存储中重新加载策略规则。</li><li>如果 adapter 不支持 <code>Auto-Save</code> 特性，则在添加或删除策略时不能将策略规则自动保存回存储器。 你必须手动调用 <code>SavePolicy()</code> 来保存所有的策略规则</li></ol></blockquote><p>当然，以下是使用 Go 语言结合 Casbin 和多种适配器的代码示例：</p><h3 id="使用文件适配器"><a href="#使用文件适配器" class="headerlink" title="使用文件适配器"></a>使用文件适配器</h3><p>文件适配器是 Casbin 的默认适配器，使用本地文件系统存储策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载模型文件和策略文件</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, <span class="string">&quot;path/to/policy.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-MySQL-适配器"><a href="#使用-MySQL-适配器" class="headerlink" title="使用 MySQL 适配器"></a>使用 MySQL 适配器</h3><p>使用 MySQL 数据库存储策略，需要安装 <code>github.com/casbin/mysql-adapter/v2</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/mysql-adapter/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MySQL 适配器</span></span><br><span class="line">    a, err := mysqladapter.NewAdapter(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:1234@tcp(127.0.0.1:3306)/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create MySQL adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-PostgreSQL-适配器"><a href="#使用-PostgreSQL-适配器" class="headerlink" title="使用 PostgreSQL 适配器"></a>使用 PostgreSQL 适配器</h3><p>使用 PostgreSQL 数据库存储策略，需要安装 <code>github.com/casbin/pg-adapter</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/pg-adapter&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 PostgreSQL 适配器</span></span><br><span class="line">    a, err := pgadapter.NewAdapter(<span class="string">&quot;postgresql://user:password@localhost:5432/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create PostgreSQL adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-MongoDB-适配器"><a href="#使用-MongoDB-适配器" class="headerlink" title="使用 MongoDB 适配器"></a>使用 MongoDB 适配器</h3><p>使用 MongoDB 数据库存储策略，需要安装 <code>github.com/casbin/mongodb-adapter/v3</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/mongodb-adapter/v3&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MongoDB 适配器</span></span><br><span class="line">    a, err := mongodbadapter.NewAdapter(<span class="string">&quot;mongodb://localhost:27017/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create MongoDB adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Redis-适配器"><a href="#使用-Redis-适配器" class="headerlink" title="使用 Redis 适配器"></a>使用 Redis 适配器</h3><p>使用 Redis 数据库存储策略，需要安装 <code>github.com/casbin/redis-adapter/v2</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/redis-adapter/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Redis 适配器</span></span><br><span class="line">    a, err := redisadapter.NewAdapter(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create Redis adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义适配器"><a href="#自定义适配器" class="headerlink" title="自定义适配器"></a>自定义适配器</h3><p>如果现有适配器不能满足需求，可以实现自定义适配器。自定义适配器需要实现 <code>casbin.Adapter</code> 接口的以下方法：</p><ul><li><code>LoadPolicy(model model.Model) error</code></li><li><code>SavePolicy(model model.Model) error</code></li><li><code>AddPolicy(sec string, ptype string, rule []string) error</code></li><li><code>RemovePolicy(sec string, ptype string, rule []string) error</code></li><li><code>RemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) error</code></li></ul><p>这是一个自定义适配器的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2/model&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2/persist&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义存储结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> LoadPolicy(model model.Model) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 加载策略到模型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> SavePolicy(model model.Model) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 保存策略到存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> AddPolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, rule []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 添加策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> RemovePolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, rule []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 移除策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> RemoveFilteredPolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, fieldIndex <span class="type">int</span>, fieldValues ...<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 移除符合过滤条件的策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建自定义适配器</span></span><br><span class="line">    a := &amp;CustomAdapter&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这些示例，可以看到如何使用 Casbin 和不同的适配器实现权限管理，具体选择哪种适配器取决于应用的具体需求和环境。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>casbin 支持使用分布式消息系统（如 etcd）来保持多个 Casbin 执行器实例之间的一致性。这样，用户就可以同时使用多个 Casbin 执行器来处理大量权限检查请求。</p><p>与策略存储适配器类似，casbin 在主库中不包含监视器代码。任何对新消息系统的支持都应该作为监视程序来实现。</p><p>关于监视器的完整列表建议去<a href="https://casbin.org/zh/docs/watchers/">casbin官网</a>查看。</p><p>推荐使用 Redis ，内部是通过 redis 的 channel 实现多个实例之间通讯。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>调度程序提供了一种同步策略增量变化的方法。它们应基于 Raft 等一致性算法，以确保所有执行者实例的一致性。通过调度器，用户可以轻松建立分布式集群。</p><p>调度器的方法分为两部分。 第一部分是与 Casbin 结合的方法。这些方法应在 Casbin 内部调用。用户可以使用 Casbin 本身提供的更完整的 API。</p><p>另一部分是调度器自身定义的方法，包括调度器初始化方法和不同算法提供的不同功能，如动态成员资格和配置更改。</p><blockquote><p>我们希望调度器只在运行时确保 Casbin 执行器的一致性。因此，如果策略在初始化时不一致，调度程序将无法正常工作。用户需要在使用调度程序前确保所有实例的状态一致。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dispatcher-architecture.svg" alt="overall architecture"></p><p>调度器的使用场景更合适分布式的环境下。</p><h2 id="角色管理器"><a href="#角色管理器" class="headerlink" title="角色管理器"></a>角色管理器</h2><p>角色管理器用于管理 Casbin 中的 RBAC 角色层次结构（用户角色映射）。 角色管理器可从 Casbin 策略规则或外部来源（如 LDAP、Okta、Auth0、Azure AD 等）检索角色数据。我们支持不同的角色管理器实现。 为了保持轻量级，我们在主库中不包含角色管理器代码（默认角色管理器除外）。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面一共介绍了casbin的五个组件，那么它们之间有什么关系呢？</p><p>在 Casbin 中，执行器（Enforcer）、适配器（Adapter）、监视器（Watcher）、调度器（Dispatcher）和角色管理器（RoleManager）是五个核心组件，它们各自负责不同的功能，但在 Casbin 的权限管理系统中有着密切的联系。</p><ul><li><strong>适配器与执行器：</strong> 适配器为执行器提供加载策略的数据源，执行器在权限判断时依赖适配器加载的策略数据。</li><li><strong>监视器与适配器：</strong> 监视器与适配器协作，适配器加载策略数据后，监视器可以持续监控数据的变化。</li><li><strong>调度器与执行器：</strong> 调度器负责管理执行器的并发访问，确保执行器在多线程环境下的安全运行。</li><li><strong>角色管理器与执行器：</strong> 角色管理器与执行器配合，执行器在权限判断时可能涉及角色信息，需要通过角色管理器查询和验证角色。</li></ul><p>总的来说，执行器是 Casbin 权限判断的核心，适配器用于加载和保存策略数据，监视器用于监控数据的变化，调度器用于管理并发访问，角色管理器用于管理角色信息。这些组件之间紧密联系并协作，共同构建了 Casbin 的权限管理系统。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>嘿，这才是真正的总结，我的博客文章怎么可能有一个那么正经的总结呢。</p><p>上面已经基本把casbin中会使用到的东西讲的很清楚了，在本项目中也是结合着 JWT 来实现的权限控制。基本流程为，先使用 JWT 检查是否正常登录，若正常登录再检查该用户的操作权限，两者相辅相成。</p><p>ok，那么又增加了一个在面试时能讲的内容，但是孩子现在根本就没有面试的机会，该说自己是运气不好呢，还是脑子里根本就没有那么多东西，所以才会一次又一次地被牵着鼻子走。再沉淀沉淀吧，先不急着找实习（其实是找不到）。</p><p>现在觉得要学的东西好像还有很多，一直赶着找实习会让我根本就没法集中去学习，老是速成也会一直忘，还是放慢脚步吧。</p><p>其实在学完 casbin 鉴权之后，这个开源项目里边比较新的东西就差不多结束了，还能继续学的就是一些数据库的操作了，不过我觉得这个大佬好像不是很想使用其他数据库，也基本上都没有什么能学的。不过 MongoDB 还是要学一下的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://casbin.org/zh/docs/category/the-basics">Casbin官方文档</a></p><p><a href="https://www.xiaoyeshiyu.com/post/bda0.html">大佬的博客</a></p><p><a href="https://www.51cto.com/article/687493.html">鉴权的简单使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天这篇博客的标题看起来就很有逼格，不错，就是我们万能的 ChatGPT起的。当然，还是稍微改了一下，它给的实在是太有逼格了，我不太敢用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zxh3032/save-ima</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>管理定时任务--cron</title>
    <link href="http://example.com/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/"/>
    <id>http://example.com/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/</id>
    <published>2024-05-27T09:03:17.000Z</published>
    <updated>2024-05-31T13:32:23.234Z</updated>
    
    <content type="html"><![CDATA[<p><code>corn</code> 是一个用于管理定时任务的库，用 Go 实现 Linux 中 <code>crontab</code> 这个命令的效果。除了 <code>cron</code> 以外，Go语言中还有另一个比较小巧、灵活的定时任务库，可以执行定时的、周期性的任务。但是它功能相对简单些，并且已经不维护了。如果有定时任务需求，还是建议使用<code>cron</code>。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/robfig/cron/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">&quot;@every 1s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;tick every 1 second&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用非常简单，创建<code>cron</code>对象，这个对象用于管理定时任务。</p><p>调用<code>cron</code>对象的<code>AddFunc()</code>方法向管理器中添加定时任务。<code>AddFunc()</code>接受两个参数，参数 1 以字符串形式指定触发时间规则，参数 2 是一个无参的函数，每次触发时调用。<code>@every 1s</code>表示每秒触发一次，<code>@every</code>后加一个时间间隔，表示每隔多长时间触发一次。例如<code>@every 1h</code>表示每小时触发一次，<code>@every 1m2s</code>表示每隔 1 分 2 秒触发一次。<code>time.ParseDuration()</code>支持的格式都可以用在这里。</p><p>调用<code>c.Start()</code>启动定时循环。</p><p>注意一点，因为<code>c.Start()</code>启动一个新的 goroutine 做循环检测，我们在代码最后加了一行<code>time.Sleep(time.Second * 5)</code>防止主 goroutine 退出。</p><p>运行效果，每隔 1s 输出一行字符串：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br></pre></td></tr></table></figure><h1 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h1><p>与Linux 中<code>crontab</code>命令相似，<code>cron</code>库支持用 <strong>5</strong> 个空格分隔的域来表示时间。这 5 个域含义依次为：</p><ul><li><code>Minutes</code>：分钟，取值范围<code>[0-59]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Hours</code>：小时，取值范围<code>[0-23]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Day of month</code>：每月的第几天，取值范围<code>[1-31]</code>，支持特殊字符<code>* / , - ?</code>；</li><li><code>Month</code>：月，取值范围<code>[1-12]</code>或者使用月份名字缩写<code>[JAN-DEC]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Day of week</code>：周历，取值范围<code>[0-6]</code>或名字缩写<code>[JUN-SAT]</code>，支持特殊字符<code>* / , - ?</code>。</li></ul><p>注意，月份和周历名称都是不区分大小写的。</p><p>特殊字符含义如下：</p><ul><li><code>*</code>：使用<code>*</code>的域可以匹配任何值，例如将月份域（第 4 个）设置为<code>*</code>，表示每个月；</li><li><code>/</code>：用来指定范围的<strong>步长</strong>，例如将小时域（第 2 个）设置为<code>3-59/15</code>表示第 3 分钟触发，以后每隔 15 分钟触发一次，因此第 2 次触发为第 18 分钟，第 3 次为 33 分钟。。。直到分钟大于 59；</li><li><code>,</code>：用来列举一些离散的值和多个范围，例如将周历的域（第 5 个）设置为<code>MON,WED,FRI</code>表示周一、三和五；</li><li><code>-</code>：用来表示范围，例如将小时的域（第 1 个）设置为<code>9-17</code>表示上午 9 点到下午 17 点（包括 9 和 17）；</li><li><code>?</code>：只能用在月历和周历的域中，用来代替<code>*</code>，表示每月/周的任意一天。</li></ul><p>了解规则之后，我们可以定义任意时间：</p><ul><li><code>30 * * * *</code>：分钟域为 30，其他域都是<code>*</code>表示任意。每小时的 30 分触发；</li><li><code>30 3-6,20-23 * * *</code>：分钟域为 30，小时域的<code>3-6,20-23</code>表示 3 点到 6 点和 20 点到 23 点。3,4,5,6,20,21,22,23 时的 30 分触发；</li><li><code>0 0 1 1 *</code>：1（第 4 个） 月 1（第 3 个） 号的 0（第 2 个） 时 0（第 1 个） 分触发。</li></ul><h2 id="预定义时间规则"><a href="#预定义时间规则" class="headerlink" title="预定义时间规则"></a>预定义时间规则</h2><p>为了方便使用，<code>cron</code>预定义了一些时间规则：</p><ul><li><code>@yearly</code>：也可以写作<code>@annually</code>，表示每年第一天的 0 点。等价于<code>0 0 1 1 *</code>；</li><li><code>@monthly</code>：表示每月第一天的 0 点。等价于<code>0 0 1 * *</code>；</li><li><code>@weekly</code>：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于<code>0 0 * * 0</code>；</li><li><code>@daily</code>：也可以写作<code>@midnight</code>，表示每天 0 点。等价于<code>0 0 * * *</code>；</li><li><code>@hourly</code>：表示每小时的开始。等价于<code>0 * * * *</code>。</li></ul><h2 id="固定时间间隔"><a href="#固定时间间隔" class="headerlink" title="固定时间间隔"></a>固定时间间隔</h2><p><code>cron</code>支持固定时间间隔，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@every &lt;duration&gt;</span><br></pre></td></tr></table></figure><p>含义为每隔<code>duration</code>触发一次。<code>&lt;duration&gt;</code>会调用<code>time.ParseDuration()</code>函数解析，所以<code>ParseDuration</code>支持的格式都可以。</p><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>默认情况下，所有时间都是基于当前时区的。当然我们也可以指定时区，有 2 两种方式：</p><ul><li>在时间字符串前面添加一个<code>CRON_TZ=</code> + 具体时区，东京时区为<code>Asia/Tokyo</code>，纽约时区为<code>America/New_York</code>；</li><li>创建<code>cron</code>对象时增加一个时区选项<code>cron.WithLocation(location)</code>，<code>location</code>为<code>time.LoadLocation(zone)</code>加载的时区对象，<code>zone</code>为具体的时区格式。或者调用已创建好的<code>cron</code>对象的<code>SetLocation()</code>方法设置时区。</li></ul><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nyc, _ := time.LoadLocation(<span class="string">&quot;America/New_York&quot;</span>)</span><br><span class="line">  c := cron.New(cron.WithLocation(nyc))</span><br><span class="line">  c.AddFunc(<span class="string">&quot;0 6 * * ?&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Every 6 o&#x27;clock at New York&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">&quot;CRON_TZ=Asia/Tokyo 0 6 * * ?&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Every 6 o&#x27;clock at Tokyo&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Job接口"><a href="#Job接口" class="headerlink" title="Job接口"></a><code>Job</code>接口</h1><p>除了直接将无参函数作为回调外，<code>cron</code>还支持<code>Job</code>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">interface</span> &#123;</span><br><span class="line">  Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个实现接口<code>Job</code>的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreetingJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GreetingJob)</span></span> Run() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello &quot;</span>, g.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>cron</code>对象的<code>AddJob()</code>方法将<code>GreetingJob</code>对象添加到定时管理器中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">&quot;@every 1s&quot;</span>, GreetingJob&#123;<span class="string">&quot;dj&quot;</span>&#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br></pre></td></tr></table></figure><hr><p>实际上<code>AddFunc()</code>方法内部也调用了<code>AddJob()</code>方法。首先，<code>cron</code>基于<code>func()</code>类型定义一个新的类型<code>FuncJob</code>并实现<code>Job</code>接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> FuncJob <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncJob)</span></span> Run() &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AddFunc()</code>方法中，将传入的回调转为<code>FuncJob</code>类型，然后调用<code>AddJob()</code>方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cron)</span></span> AddFunc(spec <span class="type">string</span>, cmd <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) (EntryID, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c.AddJob(spec, FuncJob(cmd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><code>cron</code>会创建一个新的 goroutine 来执行触发回调。如果这些回调需要并发访问一些资源、数据，我们需要显式地做同步。</p><h1 id="自定义时间格式"><a href="#自定义时间格式" class="headerlink" title="自定义时间格式"></a>自定义时间格式</h1><p><code>cron</code>支持灵活的时间格式，如果默认的格式不能满足要求，我们可以自己定义时间格式。时间规则字符串需要<code>cron.Parser</code>对象来解析。</p><p>我们先来看看默认的解析器是如何工作的。</p><p>首先定义各个域：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Second         ParseOption = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  SecondOptional                        </span><br><span class="line">  Minute                                </span><br><span class="line">  Hour                                  </span><br><span class="line">  Dom                                   </span><br><span class="line">  Month                                 </span><br><span class="line">  Dow                                   </span><br><span class="line">  DowOptional                           </span><br><span class="line">  Descriptor                            </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了<code>Minute/Hour/Dom(Day of month)/Month/Dow(Day of week)</code>外，还可以支持<code>Second</code>。相对顺序都是固定的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">var</span> places = []ParseOption&#123;</span><br><span class="line">  Second,</span><br><span class="line">  Minute,</span><br><span class="line">  Hour,</span><br><span class="line">  Dom,</span><br><span class="line">  Month,</span><br><span class="line">  Dow,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaults = []<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的时间格式使用 5 个域。</p><p>我们可以调用<code>cron.NewParser()</code>创建自己的<code>Parser</code>对象，以位格式传入使用哪些域，例如下面的<code>Parser</code>使用 6 个域，支持<code>Second</code>（秒）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser := cron.NewParser(</span><br><span class="line">  cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用<code>cron.WithParser(parser)</code>创建一个选项传入构造函数<code>cron.New()</code>，使用时就可以指定秒了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := cron.New(cron.WithParser(parser))</span><br><span class="line">c.AddFunc(<span class="string">&quot;1 * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;every 1 second&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br></pre></td></tr></table></figure><p>这里时间格式必须使用 6 个域，顺序与上面的<code>const</code>定义一致。</p><p>因为上面的时间格式太常见了，<code>cron</code>定义了一个便捷的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithSeconds</span><span class="params">()</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> WithParser(NewParser(</span><br><span class="line">    Second | Minute | Hour | Dom | Month | Dow | Descriptor,</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>Descriptor</code>表示对<code>@every/@hour</code>等的支持。有了<code>WithSeconds()</code>，我们不用手动创建<code>Parser</code>对象了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := cron.New(cron.WithSeconds())</span><br></pre></td></tr></table></figure><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p><code>cron</code>对象创建使用了选项模式，我们前面已经介绍了 3 个选项：</p><ul><li><code>WithLocation</code>：指定时区；</li><li><code>WithParser</code>：使用自定义的解析器；</li><li><code>WithSeconds</code>：让时间格式支持秒，实际上内部调用了<code>WithParser</code>。</li></ul><p><code>cron</code>还提供了另外两种选项：</p><ul><li><code>WithLogger</code>：自定义<code>Logger</code>；</li><li><code>WithChain</code>：Job 包装器。</li></ul><h2 id="WithLogger"><a href="#WithLogger" class="headerlink" title="WithLogger"></a><code>WithLogger</code></h2><p><code>WithLogger</code>可以设置<code>cron</code>内部使用我们自定义的<code>Logger</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New(</span><br><span class="line">    cron.WithLogger(</span><br><span class="line">      cron.VerbosePrintfLogger(log.New(os.Stdout, <span class="string">&quot;cron: &quot;</span>, log.LstdFlags))))</span><br><span class="line">  c.AddFunc(<span class="string">&quot;@every 1s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面调用<code>cron.VerbosPrintfLogger()</code>包装<code>log.Logger</code>，这个<code>logger</code>会详细记录<code>cron</code>内部的调度过程。</p><p>默认的<code>Logger</code>是什么样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultLogger Logger = PrintfLogger(log.New(os.Stdout, <span class="string">&quot;cron: &quot;</span>, log.LstdFlags))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#125;) Logger &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerbosePrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#125;) Logger &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printfLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger  <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) &#125;</span><br><span class="line">  logInfo <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithChain"><a href="#WithChain" class="headerlink" title="WithChain"></a><code>WithChain</code></h2><p>Job 包装器可以在执行实际的<code>Job</code>前后添加一些逻辑：</p><ul><li>捕获<code>panic</code>；</li><li>如果<code>Job</code>上次运行还未结束，推迟本次执行;</li><li>如果<code>Job</code>上次运行还未介绍，跳过本次执行；</li><li>记录每个<code>Job</code>的执行情况。</li></ul><p>我们可以将<code>Chain</code>类比为 Web 处理器的中间件。实际上就是在<code>Job</code>的执行逻辑外在封装一层逻辑。我们的封装逻辑需要写成一个函数，传入一个<code>Job</code>类型，返回封装后的<code>Job</code>。<code>cron</code>为这种函数定义了一个类型<code>JobWrapper</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chain.go</span></span><br><span class="line"><span class="keyword">type</span> JobWrapper <span class="function"><span class="keyword">func</span><span class="params">(Job)</span></span> Job</span><br></pre></td></tr></table></figure><p>然后使用一个<code>Chain</code>对象将这些<code>JobWrapper</code>组合到一起：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chain <span class="keyword">struct</span> &#123;</span><br><span class="line">  wrappers []JobWrapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChain</span><span class="params">(c ...JobWrapper)</span></span> Chain &#123;</span><br><span class="line">  <span class="keyword">return</span> Chain&#123;c&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Chain</code>对象的<code>Then(job)</code>方法应用这些<code>JobWrapper</code>，返回最终的<code>Job</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chain)</span></span> Then(j Job) Job &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> c.wrappers &#123;</span><br><span class="line">    j = c.wrappers[<span class="built_in">len</span>(c.wrappers)-i<span class="number">-1</span>](j)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意应用<code>JobWrapper</code>的顺序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本项目中其实并没有用到这么多与之相关的东西，当然还有更加详细的内容本文并没有记录。</p><p>本文就不放参考资料了，因为整篇博客都是照抄的别人的，原因是我破防了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;corn&lt;/code&gt; 是一个用于管理定时任务的库，用 Go 实现 Linux 中 &lt;code&gt;crontab&lt;/code&gt; 这个命令的效果。除了 &lt;code&gt;cron&lt;/code&gt; 以外，Go语言中还有另一个比较小巧、灵活的定时任务库，可以执行定时的、周期性的</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>高性能日志库——Zap</title>
    <link href="http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/"/>
    <id>http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/</id>
    <published>2024-05-25T09:39:37.000Z</published>
    <updated>2024-05-25T12:23:08.130Z</updated>
    
    <content type="html"><![CDATA[<p>今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>在任何一个投入使用的项目中，都需要一个好的日志系统（关于什么是<a href="https://zxh3032.github.io/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/">日志</a>，可以看之前的总结，更建议看总结中的参考）。在 Go 语言中，我们有很多能够投入使用的日志库，比如<code>log</code>、<code>zap</code>等。对于一个好的日志记录器来说，我们需要它能够实现一下功能：</p><ul><li>能够将事件记录到文件中，而不是应用程序控制台。</li><li>日志切割-能够根据文件大小、时间或间隔等来切割日志文件。</li><li>支持不同的日志级别。例如INFO，DEBUG，ERROR等。</li><li>能够打印基本信息，如调用文件/函数名和行号，日志时间等。</li></ul><h1 id="默认的Go-Logger"><a href="#默认的Go-Logger" class="headerlink" title="默认的Go Logger"></a>默认的Go Logger</h1><p>在学习Uber-go的zap包之前，还是先学习一下Go语言提供的基本日志功能。由于之前写项目的时候在日志系统设计方面并没有很在意，所以根本就没记住什么东西，还是重新学一下吧。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。</p><p>那就来看一段简单的实现代码吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFileLocation, _ := os.OpenFile(<span class="string">&quot;test.log&quot;</span>, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="number">0744</span>)</span><br><span class="line">log.SetOutput(logFileLocation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error fetching url %s : %s&quot;</span>, url, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Status Code for %s : %s&quot;</span>, url, resp.Status)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">SetupLogger()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行上述代码后，会有一个 <code>test.log</code> 文件被创建，文件中的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Error fetching url www.baidu.com <span class="punctuation">:</span> Get <span class="attr">&quot;www.baidu.com&quot;</span><span class="punctuation">:</span> unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Status Code for http<span class="punctuation">:</span><span class="comment">//www.baidu.com : 200 OK</span></span><br></pre></td></tr></table></figure><h2 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>它最大的优点是使用非常简单。我们可以设置任何<code>io.Writer</code>作为日志记录输出并向其发送要写入的日志。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>仅限基本的日志级别<ul><li>只有一个<code>Print</code>选项。不支持<code>INFO</code>/<code>DEBUG</code>等多个级别。</li></ul></li><li>对于错误日志，它有 <code>Fatal</code> 和 <code>Panic</code><ul><li>Fatal日志通过调用<code>os.Exit(1)</code>来结束程序</li><li>Panic日志在写入日志消息之后抛出一个panic</li><li>但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误</li></ul></li><li>缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。</li><li>不提供日志切割的能力。</li></ul><h1 id="Uber-go-Zap"><a href="#Uber-go-Zap" class="headerlink" title="Uber-go Zap"></a>Uber-go Zap</h1><p>由于上面提到的 <code>Logger</code> 库的劣势并不能帮助我们设计一个良好的日志记录器，所以在本项目中选择了另一个功能更丰富等库——<code>Zap</code>。它同时提供了结构化日志记录和 printf 风格的日志记录。</p><p>那这时候就有同学会有疑问了，提供了更多的功能会不会导致在完成设定的任务时变得更慢呢？</p><p>一个优秀的工具就是实现了既要又要，根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好——也比标准库更快。 以下是Zap发布的基准测试信息</p><p>记录一条消息和10个字段:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">862 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">5 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">1250 ns/op</td><td style="text-align:center">+45%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">4021 ns/op</td><td style="text-align:center">+366%</td><td style="text-align:center">76 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">4542 ns/op</td><td style="text-align:center">+427%</td><td style="text-align:center">105 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">26785 ns/op</td><td style="text-align:center">+3007%</td><td style="text-align:center">115 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">29501 ns/op</td><td style="text-align:center">+3322%</td><td style="text-align:center">125 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">29906 ns/op</td><td style="text-align:center">+3369%</td><td style="text-align:center">122 allocs/op</td></tr></tbody></table></div><p>记录一个静态字符串，没有任何上下文或printf风格的模板：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">118 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">191 ns/op</td><td style="text-align:center">+62%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">93 ns/op</td><td style="text-align:center">-21%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">280 ns/op</td><td style="text-align:center">+137%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">standard library</td><td style="text-align:center">499 ns/op</td><td style="text-align:center">+323%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">1990 ns/op</td><td style="text-align:center">+1586%</td><td style="text-align:center">10 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">3129 ns/op</td><td style="text-align:center">+2552%</td><td style="text-align:center">24 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">3887 ns/op</td><td style="text-align:center">+3194%</td><td style="text-align:center">23 allocs/op</td></tr></tbody></table></div><h2 id="Zap的特性"><a href="#Zap的特性" class="headerlink" title="Zap的特性"></a>Zap的特性</h2><ul><li>高性能：zap 对日志输出进行了多项优化以提高它的性能</li><li>日志分级：有 Debug，Info，Warn，Error，DPanic，Panic，Fatal 等</li><li>日志记录结构化：日志内容记录是结构化的，比如 json 格式输出</li><li>自定义格式：用户可以自定义输出的日志格式</li><li>自定义公共字段：用户可以自定义公共字段，大家输出的日志内容就共同拥有了这些字段</li><li>调试：可以打印文件名、函数名、行号、日志时间等，便于调试程序</li><li>自定义调用栈级别：可以根据日志级别输出它的调用栈信息</li><li>Namespace：日志命名空间。定义命名空间后，所有日志内容就在这个命名空间下。命名空间相当于一个文件夹</li><li>支持 hook 操作</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  url := <span class="string">&quot;http://example.org/api&quot;</span></span><br><span class="line">  logger.Info(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">    zap.Int(<span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    zap.Duration(<span class="string">&quot;backoff&quot;</span>, time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  sugar := logger.Sugar()</span><br><span class="line">  sugar.Infow(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span>, url,</span><br><span class="line">    <span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;backoff&quot;</span>, time.Second,</span><br><span class="line">  )</span><br><span class="line">  sugar.Infof(<span class="string">&quot;Failed to fetch URL: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>zap</code>库的使用与其他的日志库非常相似。先创建一个<code>logger</code>，然后调用各个级别的方法记录日志（<code>Debug/Info/Error/Warn</code>）。</p><p><code>zap</code>提供了几个快速创建<code>logger</code>的方法</p><ul><li><code>zap.NewExample()</code></li><li><code>`zap.NewDevelopment()</code></li><li><code>zap.NewProduction()</code></li><li>还有高度定制化的创建方法<code>zap.New()</code>。</li></ul><p>创建前 3 个<code>logger</code>时，<code>zap</code>会使用一些预定义的设置，它们的使用场景也有所不同。<code>Example</code>适合用在测试代码中，<code>Development</code>在开发环境中使用，<code>Production</code>用在生成环境。</p><p><code>zap</code>底层 API 可以设置缓存，所以一般使用<code>defer logger.Sync()</code>将缓存同步到文件中。</p><hr><p>Zap提供了两种类型的日志记录器—<code>Sugared Logger</code>和<code>Logger</code>。</p><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li>通过调用<code>zap.NewProduction()</code>/<code>zap.NewDevelopment()</code>或者<code>zap.Example()</code>创建一个Logger。</li><li>上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。</li><li>通过Logger调用Info/Error等。</li><li>默认情况下日志都会打印到应用程序的console界面。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(</span><br><span class="line"><span class="string">&quot;Error fetching url..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">zap.Error(err))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Success..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;statusCode&quot;</span>, resp.Status),</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url))</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先创建了一个Logger，然后使用Info/ Error等Logger方法记录消息。</p><h3 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h3><p>现在让我们使用Sugared Logger来实现相同的功能。</p><ul><li>大部分的实现基本都相同。</li><li>惟一的区别是，我们通过调用主logger的<code>. Sugar()</code>方法来获取一个<code>SugaredLogger</code>。</li><li>然后使用<code>SugaredLogger</code>以<code>printf</code>格式记录语句</li></ul><p>下面是修改过后使用<code>SugaredLogger</code>代替<code>Logger</code>的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line"><span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么会有两种？"><a href="#为什么会有两种？" class="headerlink" title="为什么会有两种？"></a>为什么会有两种？</h3><p>由于<code>fmt.Printf</code>之类的方法大量使用<code>interface&#123;&#125;</code>和反射，会有不少性能损失，并且增加了内存分配的频次。<code>zap</code>为了提高性能、减少内存分配次数，没有使用反射，而且默认的<code>Logger</code>只支持强类型的、结构化的日志。必须使用<code>zap</code>提供的方法记录字段。<code>zap</code>为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，<code>zap.Type</code>（<code>Type</code>为<code>bool/int/uint/float64/complex64/time.Time/time.Duration/error</code>等）就表示该类型的字段，<code>zap.Typep</code>以<code>p</code>结尾表示该类型指针的字段，<code>zap.Types</code>以<code>s</code>结尾表示该类型切片的字段。如：</p><ul><li><code>zap.Bool(key string, val bool) Field</code>：<code>bool</code>字段</li><li><code>zap.Boolp(key string, val *bool) Field</code>：<code>bool</code>指针字段；</li><li><code>zap.Bools(key string, val []bool) Field</code>：<code>bool</code>切片字段。</li></ul><p>当然也有一些特殊类型的字段：</p><ul><li><code>zap.Any(key string, value interface&#123;&#125;) Field</code>：任意类型的字段；</li><li><code>zap.Binary(key string, val []byte) Field</code>：二进制串的字段。</li></ul><p>当然，每个字段都用方法包一层用起来比较繁琐。<code>zap</code>也提供了便捷的方法<code>SugarLogger</code>，可以使用<code>printf</code>格式符的方式。调用<code>logger.Sugar()</code>即可创建<code>SugaredLogger</code>。<code>SugaredLogger</code>的使用比<code>Logger</code>简单，只是性能比<code>Logger</code>低 50% 左右，可以用在非热点函数中。调用<code>SugarLogger</code>以<code>f</code>结尾的方法与<code>fmt.Printf</code>没什么区别，如例子中的<code>Infof</code>。同时<code>SugarLogger</code>还支持以<code>w</code>结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可。</p><h2 id="记录层级关系"><a href="#记录层级关系" class="headerlink" title="记录层级关系"></a>记录层级关系</h2><p>前面记录的日志都是一层结构，没有嵌套的层级。我们可以使用 <code>zap.Namespace(key string) Field</code> 构建一个<strong>命名空间</strong>，后续的<code>Filed</code>都记录在此命名空间中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  logger.Info(<span class="string">&quot;tracked some metrics&quot;</span>,</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  logger2 := logger.With(</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line">  logger2.Info(<span class="string">&quot;tracked some metrics&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrics&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrices&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面我们演示了两种<code>Namespace</code>的用法，一种是直接作为字段传入<code>Debug/Info</code>等方法，一种是调用<code>With()</code>创建一个新的<code>Logger</code>，新的<code>Logger</code>记录日志时总是带上预设的字段。</p><h2 id="定制Logger"><a href="#定制Logger" class="headerlink" title="定制Logger"></a>定制<code>Logger</code></h2><p>调用<code>NexExample()/NewDevelopment()/NewProduction()</code>这 3 个方法，<code>zap</code>使用默认的配置。我们也可以手动调整，配置结构如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/config.go</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Level AtomicLevel <span class="string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span></span><br><span class="line">  Encoding <span class="type">string</span> <span class="string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span></span><br><span class="line">  EncoderConfig zapcore.EncoderConfig <span class="string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span></span><br><span class="line">  OutputPaths []<span class="type">string</span> <span class="string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span></span><br><span class="line">  ErrorOutputPaths []<span class="type">string</span> <span class="string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span></span><br><span class="line">  InitialFields <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Level</code>：日志级别；</li><li><code>Encoding</code>：输出的日志格式，默认为 JSON；</li><li><code>OutputPaths</code>：可以配置多个输出路径，路径可以是文件路径和<code>stdout</code>（标准输出）；</li><li><code>ErrorOutputPaths</code>：错误输出路径，也可以是多个；</li><li><code>InitialFields</code>：每条日志中都会输出这些值。</li></ul><p>其中<code>EncoderConfig</code>为编码配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/zapcore/encoder.go</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  MessageKey    <span class="type">string</span> <span class="string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span></span><br><span class="line">  LevelKey      <span class="type">string</span> <span class="string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span></span><br><span class="line">  TimeKey       <span class="type">string</span> <span class="string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span></span><br><span class="line">  NameKey       <span class="type">string</span> <span class="string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span></span><br><span class="line">  CallerKey     <span class="type">string</span> <span class="string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span></span><br><span class="line">  StacktraceKey <span class="type">string</span> <span class="string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span></span><br><span class="line">  LineEnding    <span class="type">string</span> <span class="string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span></span><br><span class="line">  EncodeLevel    LevelEncoder    <span class="string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span></span><br><span class="line">  EncodeTime     TimeEncoder     <span class="string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span></span><br><span class="line">  EncodeDuration DurationEncoder <span class="string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span></span><br><span class="line">  EncodeCaller   CallerEncoder   <span class="string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span></span><br><span class="line">  EncodeName NameEncoder <span class="string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>MessageKey</code>：日志中信息的键名，默认为<code>msg</code>；</li><li><code>LevelKey</code>：日志中级别的键名，默认为<code>level</code>；</li><li><code>EncodeLevel</code>：日志中级别的格式，默认为小写，如<code>debug/info</code>。</li></ul><h3 id="将日志写入文件而不是终端"><a href="#将日志写入文件而不是终端" class="headerlink" title="将日志写入文件而不是终端"></a>将日志写入文件而不是终端</h3><p>在实际运行的项目中，将日志写入终端显然不是一个好的想法，即不方便查看，又不能够长时间存储。所以，将日志单独写入到一个文件夹中，是一个非常好的设计。这时，我们就要用到<code>zap.New()</code>方法来定制创建logger。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span></span> *Logger</span><br></pre></td></tr></table></figure><p><code>zapcore.Core</code>需要三个配置——<code>Encoder</code>，<code>WriteSyncer</code>，<code>LogLevel</code>。</p><ol><li><strong>Encoder</strong>：编码器（如何写入日志）。</li><li><strong>WriterSyncer</strong> ：指定日志将写到哪里去。</li><li><strong>Log Level</strong>：哪种级别的日志将被写入。</li></ol><p>在本项目的实际开发中，对以上三个配置都做出了相应的设计。根据日期以及日志的等级实现了相应的日志分割功能，将日志输出的时间格式也进行了更加简洁的设置。</p><h2 id="全局Logger"><a href="#全局Logger" class="headerlink" title="全局Logger"></a>全局<code>Logger</code></h2><p>为了方便使用，<code>zap</code>提供了两个全局的<code>Logger</code>，一个是<code>*zap.Logger</code>，可调用<code>zap.L()</code>获得；另一个是<code>*zap.SugaredLogger</code>，可调用<code>zap.S()</code>获得。需要注意的是，全局的<code>Logger</code>默认并不会记录日志！它是一个无实际效果的<code>Logger</code>。看源码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.uber.org/zap/global.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  _globalMu sync.RWMutex</span><br><span class="line">  _globalL  = NewNop()</span><br><span class="line">  _globalS  = _globalL.Sugar()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以使用<code>ReplaceGlobals(logger *Logger) func()</code>将<code>logger</code>设置为全局的<code>Logger</code>，该函数返回一个无参函数，用于恢复全局<code>Logger</code>设置：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  zap.L().Info(<span class="string">&quot;global Logger before&quot;</span>)</span><br><span class="line">  zap.S().Info(<span class="string">&quot;global SugaredLogger before&quot;</span>)</span><br><span class="line"></span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  zap.ReplaceGlobals(logger)</span><br><span class="line">  zap.L().Info(<span class="string">&quot;global Logger after&quot;</span>)</span><br><span class="line">  zap.S().Info(<span class="string">&quot;global SugaredLogger after&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;global Logger after&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;global SugaredLogger after&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到在调用<code>ReplaceGlobals</code>之前记录的日志并没有输出。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是在本项目中已经使用的有关 <code>Zap</code> 库的内容，更加详细和底层的东西还是去看大佬的博客和实际源码吧，我写的博客也只是为了强化一下记忆。</p><p>呜呜呜……，暑期实习还是没有一点眉目，不知道该怎么办了，真是不想背八股文啊！！！昨天面了边无际的面试，感觉这才应该是面试该有的情况，就不要问那些要靠死记硬背的八股文了，日常工作又能用到多少，谁会在写代码的时候需要考虑三次握手怎么握呀。不过不问八股好像也没什么可问的了。这就是绝大多数本科生的悲哀之处吧，上了四年学，什么都没学到。</p><p>不过边无际的面试面的好像也没有多好，不过这是我三个月以来说过最流畅的自我介绍了，感觉还是得深入的学习一下Redis和Docker的内容了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://darjun.github.io/2020/04/23/godailylib/zap/">Go 每日一库之 Zap</a></p></li><li><p><a href="https://www.liwenzhou.com/posts/Go/zap/">李文周的博客</a></p></li><li><a href="https://www.cnblogs.com/jiujuan/p/17304844.html">更加详细的Zap介绍</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。&lt;/p&gt;
&lt;h1 id=&quot;日志系统&quot;&gt;&lt;a href=&quot;#日志系统&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>命令行解析——flag</title>
    <link href="http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/"/>
    <id>http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/</id>
    <published>2024-05-23T12:18:13.000Z</published>
    <updated>2024-05-23T13:01:07.684Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用<code>Set</code>显示设置的 &gt; 命令行选项 &gt; 环境变量 &gt; 配置文件 &gt; 默认值。</p><p>在实际项目开发中一般不会直接 <code>Set</code> 来设置，因为要使用的配置现象过多。因此，在考虑直接读取配置文件之前，我们要先做一件事，那就是解析命令行，看看有没有相应的键值设置。</p><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><h1 id="如何获取命令行参数？"><a href="#如何获取命令行参数？" class="headerlink" title="如何获取命令行参数？"></a>如何获取命令行参数？</h1><p>如果只是简单的想要获取命令行参数，可以直接使用 <code>os.Args</code> 来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./args_demo a b c d</span><br><span class="line">args[0]=./args_demo</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=b</span><br><span class="line">args[3]=c</span><br><span class="line">args[4]=d</span><br></pre></td></tr></table></figure><p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p><h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p><code>flag</code>用于解析命令行选项。</p><p>命令行选项在实际开发中很常用，特别是在写工具的时候。</p><ul><li>指定配置文件的路径，如<code>redis-server ./redis.conf</code>以当前目录下的配置文件<code>redis.conf</code>启动 Redis 服务器；</li><li>自定义某些参数，如<code>python -m SimpleHTTPServer 8080</code>启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">flag参数</th><th style="text-align:center">有效值</th></tr></thead><tbody><tr><td style="text-align:center">字符串flag</td><td style="text-align:center">合法字符串</td></tr><tr><td style="text-align:center">整数flag</td><td style="text-align:center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td style="text-align:center">浮点数flag</td><td style="text-align:center">合法浮点数</td></tr><tr><td style="text-align:center">bool类型flag</td><td style="text-align:center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td style="text-align:center">时间段flag</td><td style="text-align:center">任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” /“µs”、“ms”、“s”、“m”、“h”。</td></tr></tbody></table></div><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a><code>flag.Type()</code></h3><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age := flag.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married := flag.Bool(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a><code>flag.TypeVar()</code></h3><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a><code>flag.Parse()</code></h3><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>遇到第一个非选项参数（即不是以<code>-</code>和<code>--</code>开头的）或终止符<code>--</code>，解析停止。</p><hr><p>总结一下，使用<code>flag</code>库的一般步骤：</p><ul><li>定义一些全局变量存储选项的值;</li><li>在<code>init</code>方法中使用<code>flag.TypeVar</code>方法定义选项，这里的<code>Type</code>可以为基本类型<code>Int/Uint/Float64/Bool</code>，还可以是时间间隔<code>time.Duration</code>。定义时传入变量的地址、选项名、默认值和帮助信息；</li><li>在<code>main</code>方法中调用<code>flag.Parse</code>从<code>os.Args[1:]</code>中解析选项。因为<code>os.Args[0]</code>为可执行程序路径，会被剔除。</li></ul><p>注意点：</p><p><code>flag.Parse</code>方法必须在所有选项都定义之后调用，且<code>flag.Parse</code>调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为<code>init</code>在所有代码之前执行，将选项定义都放在<code>init</code>中，<code>main</code>函数中执行<code>flag.Parse</code>时所有选项都已经定义了。</p><h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a><code>flag</code>其他函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="定义短选项"><a href="#定义短选项" class="headerlink" title="定义短选项"></a>定义短选项</h3><p><code>flag</code>库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有<strong>相同的默认值</strong>。否则不传该选项时，行为是不确定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    defaultLogLevel = <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">    usage = <span class="string">&quot;set log level value&quot;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;log_type&quot;</span>, defaultLogLevel, usage)</span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;l&quot;</span>, defaultLogLevel, usage + <span class="string">&quot;(shorthand)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;log level:&quot;</span>, logLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>除了使用<code>flag</code>库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interval []time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(*i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> Set(value <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(*i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;interval flag already set&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, dt := <span class="keyword">range</span> strings.Split(value, <span class="string">&quot;,&quot;</span>) &#123;</span><br><span class="line">    duration, err := time.ParseDuration(dt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    *i = <span class="built_in">append</span>(*i, duration)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  intervalFlag interval</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Var(&amp;intervalFlag, <span class="string">&quot;deltaT&quot;</span>, <span class="string">&quot;comma-seperated list of intervals to use between events&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(intervalFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个新类型，这里定义类型<code>interval</code>。</p><p>新类型必须实现<code>flag.Value</code>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="type">string</span></span><br><span class="line">  Set(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>String</code>方法格式化该类型的值，<code>flag.Parse</code>方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的<code>Set</code>方法。 这里将以<code>,</code>分隔的时间间隔解析出来存入一个切片中。</p><p>自定义类型选项的定义必须使用<code>flag.Var</code>方法。</p><h3 id="解析程序中的字符串"><a href="#解析程序中的字符串" class="headerlink" title="解析程序中的字符串"></a>解析程序中的字符串</h3><p>有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用<code>flag.FlagSet</code>结构的相关方法来解析这些选项。</p><p>实际上，我们前面调用的<code>flag</code>库的方法，都会间接调用<code>FlagSet</code>结构的方法。<code>flag</code>库中定义了一个<code>FlagSet</code>类型的全局变量<code>CommandLine</code>专门用于解析命令行选项。 前面调用的<code>flag</code>库的方法只是为了提供便利，它们内部都是调用的<code>CommandLine</code>的相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">var</span> CommandLine = NewFlagSet(os.Args[<span class="number">0</span>], ExitOnError)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  CommandLine.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntVar</span><span class="params">(p *<span class="type">int</span>, name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  CommandLine.Var(newIntValue(value, p), name, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Int(name, value, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NFlag</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.actual) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Arg</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Arg(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NArg</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.args) &#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以自己创建<code>FlagSet</code>类型变量来解析选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := []<span class="type">string</span>&#123;<span class="string">&quot;-intflag&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;-stringflag&quot;</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> intflag <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> boolflag <span class="type">bool</span></span><br><span class="line">  <span class="keyword">var</span> stringflag <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  fs := flag.NewFlagSet(<span class="string">&quot;MyFlagSet&quot;</span>, flag.ContinueOnError)</span><br><span class="line">  fs.IntVar(&amp;intflag, <span class="string">&quot;intflag&quot;</span>, <span class="number">0</span>, <span class="string">&quot;int flag value&quot;</span>)</span><br><span class="line">  fs.BoolVar(&amp;boolflag, <span class="string">&quot;boolflag&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;bool flag value&quot;</span>)</span><br><span class="line">  fs.StringVar(&amp;stringflag, <span class="string">&quot;stringflag&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;string flag value&quot;</span>)</span><br><span class="line"></span><br><span class="line">  fs.Parse(args)</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">&quot;int flag:&quot;</span>, intflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;bool flag:&quot;</span>, boolflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;string flag:&quot;</span>, stringflag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewFlagSet</code>方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：</p><ul><li><code>ContinueOnError</code>：发生错误后继续解析，<code>CommandLine</code>就是使用这个选项；</li><li><code>ExitOnError</code>：出错时调用<code>os.Exit(2)</code>退出程序；</li><li><code>PanicOnError</code>：出错时产生 panic。</li></ul><p>随便看一眼<code>flag</code>库中的相关代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlagSet)</span></span> Parse(arguments []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  f.parsed = <span class="literal">true</span></span><br><span class="line">  f.args = arguments</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    seen, err := f.parseOne()</span><br><span class="line">    <span class="keyword">if</span> seen &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> f.errorHandling &#123;</span><br><span class="line">    <span class="keyword">case</span> ContinueOnError:</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> ExitOnError:</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> PanicOnError:</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与直接使用<code>flag</code>库的方法有一点不同，<code>FlagSet</code>调用<code>Parse</code>方法时需要显示传入字符串切片作为参数。因为<code>flag.Parse</code>在内部调用了<code>CommandLine.Parse(os.Args[1:])</code>。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，本项目的解析配置文件功能已经基本完成了，该功能先是使用 flag 库来解析命令行中的内容，当命令行内容不为空时，则使用输入值来进行配置；若为空，则通过解析原有的配置文件来实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.liwenzhou.com/posts/Go/flag/">李文周的博客</a></li><li><a href="https://darjun.github.io/2020/01/10/godailylib/flag/">Go每日一库之 flag</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用&lt;code&gt;Set&lt;/code&gt;显示设置的 &amp;gt; 命令行选项 &amp;gt; 环境变量 &amp;gt; 配置文件 &amp;gt; 默认值。&lt;/p&gt;
&lt;p&gt;在实际项目开发中一般不会直接 &lt;cod</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go语言配置管理神器——Viper</title>
    <link href="http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/"/>
    <id>http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/</id>
    <published>2024-05-23T11:39:34.000Z</published>
    <updated>2024-05-23T12:24:48.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——<code>Viper</code>。</p><p>在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 <strong>Viper</strong>。关于 Viper，我也已经不是第一次使用了，但之前确实是没有去了解过，所以要从头开始学习。</p><h1 id="Viper-是什么"><a href="#Viper-是什么" class="headerlink" title="Viper 是什么"></a>Viper 是什么</h1><p>XXX是什么？这是我们去学习一个东西想到的第一个问题。那么 Viper是 什么，详细内容如下：</p><p>viper 是一个配置解决方案，拥有丰富的特性：</p><ul><li>支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；</li><li>可以设置监听配置文件的修改，修改时自动加载新的配置；</li><li>从环境变量、命令行选项和<code>io.Reader</code>中读取配置；</li><li>从远程配置系统中读取和监听修改，如 etcd/Consul；</li><li>代码逻辑中显示设置键值。</li></ul><h2 id="为什么选择-Viper-？"><a href="#为什么选择-Viper-？" class="headerlink" title="为什么选择 Viper ？"></a>为什么选择 Viper ？</h2><p>在构建现代应用程序时，你无需担心配置文件格式；你想要专注于构建出色的软件。Viper的出现就是为了在这方面帮助你的。</p><p>Viper能够为你执行下列操作：</p><ol><li>查找、加载和反序列化<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>INI</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件。</li><li>提供一种机制为你的不同配置选项设置默认值。</li><li>提供一种机制来通过命令行参数覆盖指定选项的值。</li><li>提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。</li><li>当用户提供了与默认值相同的命令行或配置文件时，可以很容易地分辨出它们之间的区别。</li></ol><p>Viper会按照下面的优先级。每个项目的优先级都高于它下面的项目:</p><ul><li>显示调用<code>Set</code>设置值</li><li>命令行参数（flag）</li><li>环境变量</li><li>配置文件</li><li>key/value存储</li><li>默认值</li></ul><p><strong>重要：</strong> 目前Viper配置的键（Key）是大小写不敏感的。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>Viper 的使用非常简单，它需要很少的设置。设置文件名（<code>SetConfigName</code>）、配置类型（<code>SetConfigType</code>）、和搜索路径（<code>AddConfigPath</code>），然后调用<code>ReadInConfig</code>。viper 会自动根据类型来读取配置。使用时调用 <code>viper.Get</code> 方法获取键值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  viper.SetDefault(<span class="string">&quot;redis.port&quot;</span>, <span class="number">6381</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;app_name&quot;</span>))</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;log_level&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql ip: &quot;</span>, viper.Get(<span class="string">&quot;mysql.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql port: &quot;</span>, viper.Get(<span class="string">&quot;mysql.port&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql user: &quot;</span>, viper.Get(<span class="string">&quot;mysql.user&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql password: &quot;</span>, viper.Get(<span class="string">&quot;mysql.password&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql database: &quot;</span>, viper.Get(<span class="string">&quot;mysql.database&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis ip: &quot;</span>, viper.Get(<span class="string">&quot;redis.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.Get(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>设置文件名时不要带后缀；</li><li>搜索路径可以设置多个，viper 会根据设置顺序依次查找；</li><li>viper 获取值时使用<code>section.key</code>的形式，即传入嵌套的键名；</li><li>默认值可以调用<code>viper.SetDefault</code>设置。</li></ul><h2 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h2><p>viper 提供了多种形式的读取方法。在上面的例子中，我们看到了<code>Get</code>方法的用法。<code>Get</code>方法返回一个<code>interface&#123;&#125;</code>的值，使用有所不便。</p><p><code>GetType</code>系列方法可以返回指定类型的值。 其中，Type 可以为<code>Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice</code>。 但是请注意，<strong>如果指定的键不存在或类型不正确，<code>GetType</code>方法返回对应类型的零值</strong>。</p><p>如果要判断某个键是否存在，使用<code>IsSet</code>方法。 另外，<code>GetStringMap</code>和<code>GetStringMapString</code>直接以 map 返回某个键下面所有的键值对，前者返回<code>map[string]interface&#123;&#125;</code>，后者返回<code>map[string]string</code>。 <code>AllSettings</code>以<code>map[string]interface&#123;&#125;</code>返回所有设置。</p><h2 id="设置键值"><a href="#设置键值" class="headerlink" title="设置键值"></a>设置键值</h2><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><h3 id="viper-Set"><a href="#viper-Set" class="headerlink" title="viper.Set"></a>viper.Set</h3><p>如果某个键通过<code>viper.Set</code>设置了值，那么这个值的优先级最高。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`viper.Set(&quot;redis.port&quot;, 5381) `</span></span><br></pre></td></tr></table></figure><p>如果将上面这行代码放到程序中，运行程序，输出的<code>redis.port</code>将是 5381。</p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>如果一个键没有通过<code>viper.Set</code>显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在<code>init</code>方法中定义选项，并且调用<code>viper.BindPFlags</code>绑定选项到配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pflag.Int(<span class="string">&quot;redis.port&quot;</span>, <span class="number">8381</span>, <span class="string">&quot;Redis port to connect&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定命令行</span></span><br><span class="line">  viper.BindPFlags(pflag.CommandLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>main</code>方法开头处调用<code>pflag.Parse</code>解析选项。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。</p><p>在<code>init</code>方法中调用<code>AutomaticEnv</code>方法绑定全部环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.AutomaticEnv()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="string">&quot;GOPATH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以单独绑定环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;redis.port&quot;</span>)<span class="comment">//只传入一个参数，这个参数即表示键名，又表示环境变量名。</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;go.path&quot;</span>, <span class="string">&quot;GOPATH&quot;</span>)<span class="comment">//传入两个参数，第一个参数表示键名，第二个参数表示环境变量名。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;go path: &quot;</span>, viper.Get(<span class="string">&quot;go.path&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过<code>viper.SetEnvPrefix</code>方法设置环境变量前缀，这样一来，通过<code>AutomaticEnv</code>和一个参数的<code>BindEnv</code>绑定的环境变量， 在使用<code>Get</code>的时候，viper 会自动加上这个前缀再从环境变量中查找。</p><p>如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名<code>gopath</code>也能读取环境变量<code>GOPATH</code>的值。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果经过前面的途径都没能找到该键，viper 接下来会尝试从配置文件中查找。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>使用 <code>viper.SetDefault()</code> 来设置默认值，以供使用。</p><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><h3 id="从io-Reader中读取"><a href="#从io-Reader中读取" class="headerlink" title="从io.Reader中读取"></a>从<code>io.Reader</code>中读取</h3><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bytes&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  tomlConfig := []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">app_name = &quot;awesome web&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># possible values: DEBUG, INFO, WARNING, ERROR, FATAL</span></span><br><span class="line"><span class="string">log_level = &quot;DEBUG&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[mysql]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 3306</span></span><br><span class="line"><span class="string">user = &quot;dj&quot;</span></span><br><span class="line"><span class="string">password = 123456</span></span><br><span class="line"><span class="string">database = &quot;awesome&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[redis]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 7381</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.GetInt(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unmarshal"><a href="#Unmarshal" class="headerlink" title="Unmarshal"></a><code>Unmarshal</code></h3><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  AppName  <span class="type">string</span></span><br><span class="line">  LogLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  MySQL    MySQLConfig</span><br><span class="line">  Redis    RedisConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP       <span class="type">string</span></span><br><span class="line">  Port     <span class="type">int</span></span><br><span class="line">  User     <span class="type">string</span></span><br><span class="line">  Password <span class="type">string</span></span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP   <span class="type">string</span></span><br><span class="line">  Port <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c Config</span><br><span class="line">  viper.Unmarshal(&amp;c)</span><br><span class="line"></span><br><span class="line">  fmt.Println(c.MySQL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><p>有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！</p><ul><li><code>WriteConfig</code>：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖；</li><li><code>WriteConfigAs</code>：保存配置到指定路径，如果文件存在，则覆盖；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是入股配置文件存在，则不覆盖。</li></ul><h2 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h2><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><p>只需要调用<code>viper.WatchConfig</code>，viper 会自动监听配置修改。如果有修改，重新加载的配置。</p><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Config file:%s Op:%s\n&quot;</span>, e.Name, e.Op)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，在本项目中所用到的有关 Viper 的内容就记录完了。但是viper相关的设计还没结束，还有另外一个很重要的库 flag。那就再下一篇博客中记录吧，一些写太多容易猪脑过载。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://darjun.github.io/2020/01/18/godailylib/viper/">Go每日一库之 viper</a></li><li><a href="https://www.liwenzhou.com/posts/Go/viper/">李文周的博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——&lt;code&gt;Viper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 &lt;strong&gt;Viper&lt;/s</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go-vue-admin学习</title>
    <link href="http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-05-22T14:00:49.000Z</published>
    <updated>2024-05-31T15:48:14.848Z</updated>
    
    <content type="html"><![CDATA[<p>将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。</p><p>这里插一句，道心破了主要是因为在后面的几场面试里总是达不到想要的效果，说话磕磕巴巴，问项目就回答的含糊不清，也不怪面试官给我秒挂，太不自信了，再沉淀一段时间吧，只能寄希望于秋招了。</p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── deploy： 部署相关的文件</span><br><span class="line">├── docs： 项目文档</span><br><span class="line">├── server： 后端代码</span><br><span class="line">└── web： 前端代码</span><br></pre></td></tr></table></figure><p>项目分为两个部分，使用 vue 框架的前端部分和使用 gin 框架的后端部分，前端部分在<code>web</code> 目录下，后端部分在<code>server</code>目录下。由于我对前端的内容不是很了解，所以主要关注 <code>server</code> 后端部分。了解一下目前 github 排名第一的 golang admin 项目是怎么设计的。</p><h1 id="后端结构"><a href="#后端结构" class="headerlink" title="后端结构"></a>后端结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   └── v1: v1 版本的 api，相当于java中的 controller</span><br><span class="line">├── config: 配置类，包括数据库配置，jwt 配置，redis 配置等</span><br><span class="line">├── core</span><br><span class="line">│   └── internal: 服务启动方法</span><br><span class="line">├── docs: swagger 文档</span><br><span class="line">├── global: 全局对象</span><br><span class="line">├── initialize</span><br><span class="line">│   └── internal: 初始化方法，日志，数据库，redis，jwt，定时任务等</span><br><span class="line">├── middleware: 中间件,包括跨域，jwt，casbin，日志，全局异常处理等,使用了 gin.handleFunc 的特性</span><br><span class="line">├── model: 数据库模型，请求参数，响应参数</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── system</span><br><span class="line">├── packfile</span><br><span class="line">├── plugin:</span><br><span class="line">│   ├── email: email 插件，是个完整的小项目，里面结构和外部类似</span><br><span class="line">│   ├── plugin-tool:</span><br><span class="line">│   └── ws</span><br><span class="line">├── resource: 资源文件，包括自动生成代码的模板，页面模板，插件模板等</span><br><span class="line">│   ├── autocode_template: 代码模板，从结构体生成代码</span><br><span class="line">│   ├── page: 前端静态资源</span><br><span class="line">│   └── plug_template: 插件代码模板</span><br><span class="line">├── router:路由代码</span><br><span class="line">│   └── system:</span><br><span class="line">├── service: 业务代码，相当于 java 中的 service</span><br><span class="line">│   └── system</span><br><span class="line">├── source: 数据库的初始数据</span><br><span class="line">│   └── system</span><br><span class="line">└── utils: 公共的工具类</span><br><span class="line">    ├── captcha</span><br><span class="line">    ├── plugin</span><br><span class="line">    ├── timer</span><br><span class="line">    └── upload</span><br></pre></td></tr></table></figure><p>本文是总结篇，提前写是想要有条理一点。下面是代码的主函数，我计划从主函数开始，一行一行地写一遍完整的项目，实在找不到相关的教程，所以学习的过程应该会比较艰辛，希望自己能够坚持下来吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">global.GVA_VP = core.Viper() <span class="comment">// 初始化Viper</span></span><br><span class="line">initialize.OtherInit()</span><br><span class="line">global.GVA_LOG = core.Zap() <span class="comment">// 初始化zap日志库</span></span><br><span class="line">zap.ReplaceGlobals(global.GVA_LOG)</span><br><span class="line">global.GVA_DB = initialize.Gorm() <span class="comment">// gorm连接数据库</span></span><br><span class="line">initialize.Timer()</span><br><span class="line">initialize.DBList()</span><br><span class="line"><span class="keyword">if</span> global.GVA_DB != <span class="literal">nil</span> &#123;</span><br><span class="line">initialize.RegisterTables() <span class="comment">// 初始化表</span></span><br><span class="line"><span class="comment">// 程序结束前关闭数据库链接</span></span><br><span class="line">db, _ := global.GVA_DB.DB()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br><span class="line">core.RunWindowsServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h1><p>Go语言库：</p><ul><li><a href="https://zxh3032.github.io/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/">Viper</a></li><li><a href="https://zxh3032.github.io/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/">Flag</a></li><li><a href="https://zxh3032.github.io/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/">Zap</a></li><li><a href="https://zxh3032.github.io/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/">cron</a></li><li><p><a href="https://zxh3032.github.io/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/">Casbin</a></p></li><li><p><a href="https://zxh3032.github.io/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/">gorm</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。&lt;/p&gt;
&lt;p&gt;这里插一句</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学——语言特性</title>
    <link href="http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</id>
    <published>2024-04-20T15:40:43.000Z</published>
    <updated>2024-04-23T04:11:09.863Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在学过基础的 Go 语言语法后，我们就发现了 Go 和 C++ 最大的不同，那就是 Go 好像不支持面向对象。</p><p>这门编程语言里没有类（class）、继承（extends），难道真的不支持面向对象编程，难道它也知道我没有对象？完了，被监视了（狗头）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/40b80bdfcc42d53f0ab1bfc99fe1132.jpg" alt="40b80bdfcc42d53f0ab1bfc99fe1132"></p><p>你看，找工作给脑子找坏了吧。不必理会上面一段无脑发言，总结为玩原神玩的。那么 Go 到底支不支持面向对象，让我们一步一步地探寻。</p><h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><p>类（class）在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的特性和方法（via @维基百科）。</p><p>继承是面向对象软件技术当中的一个概念，如果一个类别 B “继承自”另一个类别 A，就把这个 B 称为 “A的子类”，而把 A 称为 “B的父类别” 也可以称 “A 是 B 的超类”（via @维基百科）。</p><p>继承有如下两个特性：</p><ul><li>子类具有父类别的各种属性和方法，不需要再次编写相同的代码。</li><li>子类别继承父类时，可以重新定义某些属性，并重写某些方法，使其获得与父类别不同的功能。</li></ul><h2 id="结构和组合"><a href="#结构和组合" class="headerlink" title="结构和组合"></a>结构和组合</h2><p>在 Go 里就比较 ”特别“ 了，因为没有传统的类，也没有继承。</p><p>取而代之的是结构和组合的方式。这也是业内对 Go 是否 OOP 争议最大的地方。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>我们可以在 Go 中通过结构体的方式来组织代码，达到类似类的方式。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>类的声明采取结构体的方式取代后，也可以配套使用 ”组合“ 来达到类似继承的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> man <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span></span> hello1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">man</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> hello2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">p := person&#123;name: name&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := newPerson(<span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">p.hello1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 man 和 person 两个结构体，并将 man 嵌入到 person 中，形成组合。</p><h2 id="Go-是面向对象的语言吗"><a href="#Go-是面向对象的语言吗" class="headerlink" title="Go 是面向对象的语言吗"></a>Go 是面向对象的语言吗</h2><p>“Go 语言是否一门面向对象的语言？”，这是一个日经话题。官方 FAQ 给出的答复是：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/go-faq-objects.png" alt="image"></p><p>是的，也不是。原因是：</p><ul><li>Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。</li><li>Go 中的 “接口 “概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。</li><li>Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、“未装箱的 “整数。它们并不局限于结构（类）。</li><li>Go 由于缺乏类型层次，Go 中的 “对象 “比 C++ 或 Java 等语言更轻巧。</li></ul><h1 id="函数重载和缺省参数"><a href="#函数重载和缺省参数" class="headerlink" title="函数重载和缺省参数"></a>函数重载和缺省参数</h1><p>Go 语言中并不支持函数重载和缺省参数，下面将会介绍这两个是什么。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载（function overloading），也叫方法重载。是某些编程语言（如 C++、C#、Java、Swift、Kotlin 等）具有的一项特性。</p><p>该特性<strong>允许创建多个具有不同实现的同名函数</strong>，对重载函数的调用会运行其适用于调用上下文的具体实现。</p><p>从功能上来讲，就是允许一个函数调用根据上下文执行不同的方法，达到调用同一个函数名，执行不同的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Volume</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;  <span class="comment">// 立方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> s * s * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Volume</span><span class="params">(<span class="type">double</span> r, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 圆柱体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.1415926</span> * r * r * <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Volume</span><span class="params">(<span class="type">long</span> l, <span class="type">int</span> b, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 长方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> l * b * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">2.5</span>, <span class="number">8</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">100l</span>, <span class="number">75</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值，又叫缺省参数。指的是允许程序员设定缺省参数并指定默认值，<strong>当调用该函数并未指定值时，该缺省参数将为缺省值来使用</strong>。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c=<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，函数 <code>my_func</code> 一共有 3 个变量，分别是：a、b、c。变量 c 设置了缺省值，也就是 12。</p><p>其调用方式可以为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在第一种方式中，就会正常的传入所有参数。在第二种方式，由于第三个参数 c 并没有传递，因此会直接使用缺省值 12。</p><p>这就是参数默认值，也叫缺省参数。</p><h2 id="为什么不支持"><a href="#为什么不支持" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>从上述的功能特性介绍来看，似乎非常的不错，能够节省很多功夫。像是 Go 语言的 context 库中的这些方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>要是有函数重载，直接就 WithXXX 就好了，只需要关注传入的参数类型，也不用 “记” 那么多个方法名了。</p><p>有同学说，有参数默认值。那就可以直接设置在上面，作为 “最佳实践” 给到使用函数的人，岂不美哉。那怎么 Go 语言就不支持呢？</p><h3 id="细思"><a href="#细思" class="headerlink" title="细思"></a>细思</h3><p>其实这和设计理念，和对程序的理解有关系。说白了，就是你喜欢 “显式”，还是 “隐喻”。</p><p>函数重载和参数默认值，其实是不好的行为。调用者只看函数名字，可能没法知道，你这个默认值，又或是入参不同，会调用的东西，会产生怎么样的后果？</p><p>你可以观察一下自己的行为。大部分人都会潜意识的追进去看代码，看看会调到哪，缺省值的作用是什么，以确保可控。</p><h3 id="敲定"><a href="#敲定" class="headerlink" title="敲定"></a>敲定</h3><p>这细思的可能，在 Go 语言中是不被允许的。Go 语言的<strong>设计理念就是 “显式大于隐喻”，追求明确，显式</strong>。</p><p>在 Go FAQ 《Why does Go not support overloading of methods and operators?》有相关的解释。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/func-overloading.png" alt="image"></p><p>官方有明确提到两个观点：</p><ul><li>函数重载：拥有各种同名但不同签名的方法有时是很有用的，但在实践中也可能是混乱和脆弱的。</li><li>参数默认值：操作符重载，似乎更像是一种便利，不是绝对的要求。没有它，程序会更简单。</li></ul><p>这就是为什么 Go 语言不支持的原因。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p><strong>Go 里的锁，竟然不支持可重入</strong>？</p><p>如果对已经上锁的普通互斥锁进行 “加锁” 操作，其结果要么失败，要么会阻塞至解锁。</p><p>可重入互斥锁是互斥锁的一种，同一线程对其多次加锁不会产生死锁，又或是导致阻塞。</p><ul><li>在加锁上：如果是可重入互斥锁，当前尝试加锁的线程如果就是持有该锁的线程时，加锁操作就会成功。</li><li>在解锁上：可重入互斥锁一般都会记录被加锁的次数，只有执行相同次数的解锁操作才会真正解锁。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="Go-设计原则"><a href="#Go-设计原则" class="headerlink" title="Go 设计原则"></a>Go 设计原则</h3><p>在工程中使用互斥的根本原因是：为了保护不变量，也可以用于保护内、外部的不变量。</p><p>基于此，Go 在互斥锁设计上会遵守这几个原则。如下：</p><ul><li>在调用 <code>mutex.Lock</code> 方法时，要保证这些变量的不变性保持，不会在后续的过程中被破坏。</li><li>在调用<code>mu.Unlock</code>方法时，要保证：<ul><li>程序不再需要依赖那些不变量。</li><li>如果程序在互斥锁加锁期间破坏了它们，则需要确保已经恢复了它们。</li></ul></li></ul><h3 id="不支持的原因"><a href="#不支持的原因" class="headerlink" title="不支持的原因"></a>不支持的原因</h3><p>讲了 Go 自己的设计原则后，那为什么不支持可重入呢？</p><p>其实 Russ Cox 于 2010 年在《<a href="https://groups.google.com/g/golang-nuts/c/XqW1qcuZgKg/m/Ui3nQkeLV80J">Experimenting with GO</a>》就给出了答复，认为递归（又称：重入）互斥是个坏主意，这个设计并不好。</p><h1 id="并发读写"><a href="#并发读写" class="headerlink" title="并发读写"></a>并发读写</h1><p>来不及惋惜 Redis 三兄弟了，接下来登场的是 Go 语言自己的三兄弟——垃圾回收机制、协程机制和为什么 <code>map</code> 和 <code>slice</code>是非线性的。</p><p>为什么在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？</p><h2 id="非线程安全的例子"><a href="#非线程安全的例子" class="headerlink" title="非线程安全的例子"></a>非线程安全的例子</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>我们使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;随便寻了 %d 个地方&quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一次执行</span><br><span class="line">随便寻了5790个地方</span><br><span class="line">// 第二次执行</span><br><span class="line">随便寻了7370个地方</span><br><span class="line">// 第三次执行</span><br><span class="line">随便寻了6792个地方</span><br></pre></td></tr></table></figure><p>每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式的问题。</p><p>这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>同样针对 map 也如法炮制一下，重复针对类型为 map 的变量进行写入，结果会直接出现报错，并且是 Go 源码调用 <code>throw</code> 方法所导致的致命错误，也就是说 Go 进程会中断。</p><h2 id="如何支持并发读写"><a href="#如何支持并发读写" class="headerlink" title="如何支持并发读写"></a>如何支持并发读写</h2><h3 id="对-map-上锁"><a href="#对-map-上锁" class="headerlink" title="对 map 上锁"></a>对 map 上锁</h3><p>实际上我们仍然会经过有并发 map 的诉求，因为 Go 语言中的 goroutine 实在是太方便了。像是一般写爬虫任务时，基本会用到多个 goroutine，获取到数据后再写入到 map 或者 slice 中去。</p><p>Go 官方在 Go maps in action 中提供了一种简单又便利的方式来实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>这条语句声明了一个变量，它是一个匿名结构（struct）体，包含一个原生和一个嵌入读写锁 <code>sync.RWMutex</code>。</p><h3 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h3><p>虽然有了 Map+Mutex 的极简方案，但是也仍然存在一定问题。那就是在 map 的数据量非常大时，只有一把锁（Mutex）就非常可怕了，一把锁会导致大量的争夺锁，导致各种冲突和性能低下。</p><p>常见的解决方案是分片化，将一个大 map 分成多个区间，各区间使用多个锁，这样子锁的粒度就大大降低了。不过该方案实现起来很复杂，很容易出错。因此 Go 团队到比较为止暂无推荐，而是采取了其他方案。</p><p>该方案就是在 Go1.9 起支持的 <code>sync.Map</code>，其支持并发读写 map，起到一个补充的作用。</p><p>Go 语言的 <code>sync.Map</code> 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex</span><br><span class="line">read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其是专门为 <code>append-only</code> 场景设计的，也就是适合读多写少的场景。这是他的优点之一。</p><p>若出现写多/并发多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。这是他的重大缺点。</p><p>提供了以下常用方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>Delete：删除某一个键的值。</li><li>Load：返回存储在 map 中的键的值，如果没有值，则返回 nil。ok 结果表示是否在 map 中找到了值。</li><li>LoadAndDelete：删除一个键的值，如果有的话返回之前的值。</li><li>LoadOrStore：如果存在的话，则返回键的现有值。否则，它存储并返回给定的值。如果值被加载，加载的结果为 true，如果被存储，则为 false。</li><li>Range：递归调用，对 map 中存在的每个键和值依次调用闭包函数 <code>f</code>。如果 <code>f</code> 返回 false 就停止迭代。</li><li>Store：存储并设置一个键的值。</li></ul><h2 id="为什么不支持-1"><a href="#为什么不支持-1" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>Go Slice 的话，主要还是索引位覆写问题，这个就不需要纠结了，势必是程序逻辑在编写上有明显缺陷，自行改之就好。</p><p>但 Go map 就不大一样了，很多人以为是默认支持的，一个不小心就翻车，这么的常见。那凭什么 Go 官方还不支持，难不成太复杂了，性能太差了，到底是为什么？</p><p>原因如下（via @go faq）：</p><ul><li>典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。</li><li>非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。</li><li>性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。</li></ul><p>汇总来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在学习所谓的 Go 语言哲学时并不会有很多知识上的收获，要去探讨为什么设计师要这么设计某一个功能其实就是在揣测别人的心思，或许并没有什么原因，他只是喜欢。</p><p>那为什么还会有这种 XX 语言哲学的存在呢，我觉得是为了让学习者能够更快地抓住语言特性，也会给未来使用其进行开发带来深远的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……&lt;/p&gt;
&lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言2——反射与unsafe</title>
    <link href="http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/"/>
    <id>http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/</id>
    <published>2024-04-20T15:36:56.000Z</published>
    <updated>2024-04-21T08:37:58.487Z</updated>
    
    <content type="html"><![CDATA[<p>又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在计算机科学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。（来自wikipedia）</p><p>反射是程序审查自身结构的能力，并能对程序做出一定的修改。</p><p>对于人来说，审查自身或过往事情的能力，叫 “反思” 或 “反省”。</p><h2 id="Go-中的反射包：reflect介绍"><a href="#Go-中的反射包：reflect介绍" class="headerlink" title="Go 中的反射包：reflect介绍"></a>Go 中的反射包：reflect介绍</h2><p>同 Java 语言一样，Go 语言也有运行时反射，这为我们提供了一种可以在运行时操作任意类型对象的能力。比如查看一个接口变量的具体类型、看看一个结构体又多少字段、修改某个字段的值等。</p><p>Go语言是静态编译类语言，比如在定义一个变量的时候，已经知道了它是什么类型，那么为什么还需要反射呢？这是因为有些事情只有在运行时才知道。比如你定义了一个函数，它有一个 interface｛｝类型的参数，这也就意味着调用者可以传递任何类型的参数给这个函数。在这种情况下，如果你想知道调用者传递的是什么类型的参数，就需要用到反射。如果你想知道一个结构体有哪些字段和方法，也需要反射。</p><p>Go 中的反射是建立在类型系统之上，它与空接口 interface{} 密切相关。</p><p>每个 interface{} 类型的变量包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</p><blockquote><p>所以 nil != nil </p></blockquote><ul><li>获取 2 种类型信息的方法：</li></ul><blockquote><p><code>reflect.TypeOf()</code> 获取类型信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/type.go;l=39">Type</a> 类型；</p><p><code>reflect.ValueOf()</code> 获取数据信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/value.go;l=39">Value</a> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421145232856.png" alt="image-20240421145232856"></p><ul><li>2 个方法部分源码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> ，经过中间变量 <code>interface&#123;&#125;</code>，把一个普通的变量转换为反射包中类型对象： Type 和 Value 2 个类型，然后再用 reflect 包中的方法对它们进行各种操作。</p><blockquote><p>步骤：Go 变量 -&gt; interface{} -&gt; 反射包的反射类型对象</p></blockquote><p>反射包 reflect 中所有方法基本都是围绕 Type 和 Value 这 2 个类型设计和操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303885-113976386.png" alt="image-20230220180637118"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303895-169946680.png" alt="image-20230220180651792"></p><h2 id="reflect-简单使用"><a href="#reflect-简单使用" class="headerlink" title="reflect 简单使用"></a>reflect 简单使用</h2><p>从上面可以看出 TypeOf() 返回的是一个反射包中的 Type 类型，ValueOf() 返回的是一个反射包中的 Value 类型。</p><h3 id="float-反射实例"><a href="#float-反射实例" class="headerlink" title="float 反射实例"></a>float 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==TypeOf==&quot;</span>) <span class="comment">//TypeOf</span></span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>, t) <span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, t.Kind())<span class="comment">//kind: float64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==ValueOf==&quot;</span>)<span class="comment">//ValueOf</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>, v)<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())<span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind())<span class="comment">//kind: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(v.Interface())<span class="comment">//1.2345</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value is %5.2e\n&quot;</span>, v.Interface())<span class="comment">//value is 1.23e+00</span></span><br><span class="line"></span><br><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)<span class="comment">//1.2345</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;===kind===&quot;</span>)<span class="comment">//=kind=</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v = reflect.ValueOf(m)</span><br><span class="line">    fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind()) <span class="comment">// kind: int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type()) <span class="comment">// type: main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，reflect 包中 <code>reflect.TypeOf()</code> 返回 Type 和 <code>reflect.ValueOf()</code> 返回 Value 类型 都有一个 <code>Kind()</code> 方法，<code>Kind()</code> 返回一个底层的数据类型，如 Unit，Float64，Slice, Int 等。</p><p><strong>reflect.ValueOf() 返回的 Value 类型</strong>：</p><ul><li>它有一个 Type() 方法，返回的是 reflect.Value 的 Type</li><li>它有获取 Value 类型值的方法<ul><li>如果我们知道是 <code>float</code> 类型，所以直接用 <code>Float()</code> 方法。</li><li>如果不知道具体类型呢？由上面例子可知用 <code>Interface()</code> 方法，然后在进行类型断言 <code>v.Interface().(float64)</code> 来判断获取值</li></ul></li></ul><p><strong>v.Kind() 和 v.Type() 区别</strong>：</p><ul><li>在 Go 中，可以用 type 关键字定义自定义类型，<code>Kind()</code> 方法返回底层类型。</li><li>比如还有结构体，指针等类型用 type 定义的，那么 <code>Kind()</code> 方法就可以获取这些类型的底层类型。</li></ul><h3 id="struct-反射实例"><a href="#struct-反射实例" class="headerlink" title="struct 反射实例"></a>struct 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot; id:&quot;1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := student&#123;</span><br><span class="line">Name: <span class="string">&quot;hangmeimei&quot;</span>,</span><br><span class="line">Age:  <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueOfStu := reflect.ValueOf(stu)</span><br><span class="line"><span class="comment">// 获取struct字段数量</span></span><br><span class="line">fmt.Println(<span class="string">&quot;NumFields: &quot;</span>, valueOfStu.NumField()) <span class="comment">//NumFields:  2</span></span><br><span class="line"><span class="comment">// 获取字段 Name 的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name value: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).String(), <span class="string">&quot;, &quot;</span>, valueOfStu.FieldByName(<span class="string">&quot;Name&quot;</span>).String()) <span class="comment">//Name value:  hangmeimei ,  hangmeimei</span></span><br><span class="line"><span class="comment">// 字段类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name type: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).Type()) <span class="comment">//Name type:  string</span></span><br><span class="line"></span><br><span class="line">typeOfStu := reflect.TypeOf(stu)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfStu.NumField(); i++ &#123;</span><br><span class="line"><span class="comment">// 获取字段名</span></span><br><span class="line">name := typeOfStu.Field(i).Name</span><br><span class="line">fmt.Println(<span class="string">&quot;Field Name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tag</span></span><br><span class="line"><span class="keyword">if</span> fieldName, ok := typeOfStu.FieldByName(name); ok &#123;</span><br><span class="line">tag := fieldName.Tag</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;tag-&quot;</span>, tag, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;json:&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), <span class="string">&quot;, id&quot;</span>, tag.Get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//循环输出结果</span></span><br><span class="line">    <span class="comment">//Field Name:  Name</span></span><br><span class="line"><span class="comment">//tag- json:&quot;name&quot; ,  json: name , id</span></span><br><span class="line"><span class="comment">//Field Name:  Age</span></span><br><span class="line">    <span class="comment">//tag- json:&quot;age&quot; id:&quot;1&quot; ,  json: age , id 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 struct 信息的一些方法：</p><ul><li><code>NumField()</code> 获取结构体字段数量</li><li><code>Field(i)</code> 可以通过 i 字段索引来获取结构体字段信息，比如 Field(i).Name 获取字段名</li><li><code>FieldByName(name)</code> 通过 name 获取字段信息</li></ul><h2 id="三大定理"><a href="#三大定理" class="headerlink" title="三大定理"></a>三大定理</h2><p>在 Go 官方博客文章 <a href="https://go.dev/blog/laws-of-reflection">laws-of-reflection</a> 中，叙述了反射的 3 定律：</p><ul><li>第一定律：从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>第二定律：从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>第三定律：要修改反射对象，其值必须可设置；</li></ul><h3 id="第一定律"><a href="#第一定律" class="headerlink" title="第一定律"></a>第一定律</h3><p>反射的第一定律是我们能将 Go 语言的 <code>interface&#123;&#125;</code> 变量转换成反射对象。为什么是从 <code>interface&#123;&#125;</code> 变量到反射对象？</p><blockquote><p>当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://draveness.me/golang/tree/reflect.TypeOf"><code>reflect.TypeOf</code></a>、<a href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface&#123;&#125;</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface&#123;&#125;</code> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151203850.png" alt="image-20240421151203850"></p><h3 id="第二定律"><a href="#第二定律" class="headerlink" title="第二定律"></a>第二定律</h3><p>反射的第二定律是我们可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code>中的 <code>reflect.Value.Interface</code>就能完成这项工作：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151429967.png" alt="image-20240421151429967"></p><p>不过调用 <code>reflect.Value.Interface</code>方法只能获得 <code>interface&#123;&#125;</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p><ul><li>从接口值到反射对象：<ul><li>从基本类型到接口类型的类型转换；</li><li>从接口类型到反射对象的转换；</li></ul></li><li>从反射对象到接口值：<ul><li>反射对象转换成接口类型；</li><li>通过显式类型转换变成原始类型；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151704589.png" alt="image-20240421151704589"></p><h3 id="第三定律"><a href="#第三定律" class="headerlink" title="第三定律"></a>第三定律</h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的。</p><p>看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>这个问题并不是 7.1 不可寻址，而是这个 x 不可设置。</p><p>可设置性是反射值的一个属性，并不是所有的反射值有这个属性。</p><p>Value 的 <code>CanSet</code> 方法可以获取值是否可设置，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>为什么有可设置性？</p><blockquote><p>因为 reflect.ValueOf(x) 这个 x 传递的是一个原数据的副本，上面代码 <code>v.SetFloat(7.1)</code> 如果设置成功，那么更新的是副本值，原始值 x 并没有更新。这就会造成原值和新值的混乱，可设置属性就是避免这个问题。</p></blockquote><p>那怎么办？</p><p>传递的是一个副本，而不是值本身。如果希望能直接修改 x，那么必须把 x 的地址传递给函数，即指向 x 的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet())</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copytype of p:</span> <span class="meta">*float64</span></span><br><span class="line"><span class="attr">settability of p:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>还是 <code>false</code>，为什么？</p><p>反射对象 p 不可设置，它并不是我们要设置的 p，它实际上是 <em>p。为了得到 p 所指向的东西，我们需要调用 Value 的 <code>Elem</code> 方法，通过指针进行简介<em>*寻址</em></em>，然后将结果保存在一个名为 v 的反射 Value 中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyv := p.<span class="built_in">Elem</span>()</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;settability of v:&quot;</span>, v.<span class="built_in">CanSet</span>())</span><br></pre></td></tr></table></figure><p>现在 v 是一个可设置的反射对象，输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后我们可以用 <code>v.SetFloat()</code> 设置值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyv<span class="selector-class">.SetFloat</span>(<span class="number">7.1</span>)</span><br><span class="line">fmt<span class="selector-class">.Println</span>(v.Interface())</span><br><span class="line">fmt<span class="selector-class">.Println</span>(x)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy7.1</span><br><span class="line">7.1</span><br></pre></td></tr></table></figure><blockquote><p>说明：请记住，修改反射值需要值的地址，以便修改他们的真正值。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以根据条件灵活的调用函数。最大一个优点就是灵活。</li></ul><p>比如函数参数的数据类型不确定，这时可以根据反射来判断数据类型，在调用适当的函数。</p><p>还有比如根据某些条件来调用哪个函数。</p><p>需要根据动态需要来调用函数，可以用反射。</p><blockquote><p>使用反射的 2 个典型场景：1、操作数据库的 ORM 框架 ，2、依赖注入</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>用反射编写的代码比较难以阅读和理解</li><li>反射是在运行时才执行，所以编译期间比较难以发现错误</li><li>反射对性能的影响，比一般正常运行代码慢一到两个数量级。</li></ul><h1 id="不安全但高效的-unsafe"><a href="#不安全但高效的-unsafe" class="headerlink" title="不安全但高效的 unsafe"></a>不安全但高效的 unsafe</h1><p>Go的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<strong>强类型的静态语言</strong>。强类型意味着一旦定义了，类型就不能改变；静态意味着在运行前就做了类型检查。同时出于安全考虑，Go语言是不允许两个指针类型进行转换的。</p><p>我们一般使用 <code>*T</code> 作为一个指针类型，表示一个指向类型 <code>T</code> 变量的指针。基于安全考虑，两个不同的指针类型不能相互转换，比如 <em>int 不能转为 </em>float64。</p><p>go官方是不推荐使用unsafe的操作因为它是不安全的，它绕过了golang的内存安全原则，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。但是在很多地方却是很实用。在一些go底层的包中unsafe包被很频繁的使用。</p><h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"><span class="comment">//ArbitraryType仅用于文档目的，实际上并不是unsafe包的一部分,它表示任意Go表达式的类型。</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="comment">//任意类型的指针，类似于C的*void</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"><span class="comment">//确定结构在内存中占用的确切大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的对其值（字节对齐的原因）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>官方中定义了四个描述：</p><ol><li>任何类型的指针都可以被转化为Pointer</li><li>Pointer可以被转化为任何类型的指针</li><li>uintptr可以被转化为Pointer</li><li>Pointer可以被转化为uintptr</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421155246421.png" alt="image-20240421155246421"></p><h2 id="uintptr-指针类型"><a href="#uintptr-指针类型" class="headerlink" title="uintptr 指针类型"></a>uintptr 指针类型</h2><p>uintptr 也是一种指针类型，它足够大，可以表示任何指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">uintptr</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>既然已经有了 <code>unsafe.Pointer</code>，为什么还要设计 <code>uintptr</code> 类型呢？</p><p>通常<code>Pointer</code>不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，<code>Pointer</code> 是不能做这个运算的，那么谁可以呢？这里要靠 <code>uintptr</code> 类型了，只有将 <code>Pointer</code> 类型先转换成 <code>uintptr</code> 类型，做完地址加减法运算后，再转换成 <code>Pointer</code> 类型，通过*操作达到取值、修改值的目的。</p><p><code>uintptr</code> 是 Go 语言的内置类型，是能存储指针的整型， <code>uintptr</code> 的底层类型是int，它和 <code>unsafe.Pointer</code> 可相互转换。</p><p><code>uintptr</code> 和 <code>unsafe.Pointer</code> 的区别就是：</p><ul><li><code>unsafe.Pointer</code> 只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li><li>而<code>uintptr</code>是用于指针运算的，GC 不把 <code>uintptr</code> 当指针，也就是说 <code>uintptr</code> 无法持有对象， <code>uintptr</code> 类型的目标会被回收；</li><li><code>unsafe.Pointer</code> 可以和 普通指针 进行相互转换；</li><li><code>unsafe.Pointer</code> 可以和 <code>uintptr</code> 进行相互转换。</li></ul><h1 id="slice-为何如此高效"><a href="#slice-为何如此高效" class="headerlink" title="slice 为何如此高效"></a>slice 为何如此高效</h1><p><code>slice</code> 是 <code>Go</code> 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 <code>Go</code> 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 <code>Go</code> 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 <code>slice</code> 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在讲 slice的原理之前，我先来介绍一下数组。几乎所有的编程语言里都存在数组，Go也不例外。那么为什么 Go语言除了数组之外又设计了 slice 呢？要想解答这个问题，我们先来了解数组的局限性。</p><p>一个数组由两部分构成：数组的<strong>大小</strong>和数组内的<strong>元素类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组结构伪代码表示</span></span><br><span class="line">array&#123;</span><br><span class="line"><span class="number">1</span>en</span><br><span class="line">    item <span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个数组被声明，它的大小和内部元素就不能改变，你不能随意地向数组添加任意多个元素。这是数组的<strong>第一个限制</strong>。<br>既然数组的大小是固定的，如果需要使用数组存储大量的数据，就需要提前指定一个合适的大小，比如 100000，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a10：= [<span class="number">100000</span>]<span class="type">string</span>｛<span class="string">&quot;随便寻个地方&quot;</span>｝</span><br></pre></td></tr></table></figure><p>这样虽然可以解决问题，但又带来了另外的问题，那就是内存占用。因为在Go语言中，函数间的传参是值传递的，数组作为参数在各个函数之间被传递的时候，同样的内容就会被一遍遍地复制，这就会造成大量的内存浪费，这是数组的<strong>第二个限制</strong>。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>在上面，我们已经了解到了数组的限制，为了解决这些限制，Go 语言创造了 slice，也就是<strong>切片</strong>。</p><p>切片是对数组的抽象和封装，它的底层是一个数组，存储所有的元素，但是它可以动态地添加元素，容量不足时还可以自动扩容，你完全可以把切片理解为动态数组。在Go语言中，除了长度固定的类型需要使用数组外，大多数情况下都是使用切片。</p><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>通过内置的 <code>append</code> 方法，可以向一个切片中追加任意多个元素，这就可以解决数组的第一个限制了。</p><p>当通过 <code>append</code> 追加元素时，如果切片的容量不够，<code>append</code> 函数会自动扩容。</p><p><code>append</code> 自动扩容的原理是新创建一个底层数组，把原来切片内的元素拷贝到新数组中，然后再返回一个指向新数组的切片。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-3708315c909a8a8a327b733597e66938_720w.webp" alt="img"></p><p>底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><p>切片的本质就是 <code>sliceHeader</code>，又因为函数的参数是值传递，所以传递的是 <code>SliceHteader</code>的副本、而不是底层数组的副本。这时候切片的优势就体现出来了，因为 <code>SiceHteader</code> 的副本内存占用非常少，即使是一个非常大的切片（底层数组有很多元素），也顶多占用24字节的内存，这就解决了大数组在传参时内存浪费的问题。</p><blockquote><p>SliceHeader 的三个字段的类型分别是 uintptr、int 和 int，在64位的机器上，这三个字段最多也就是 int64 类型，一个int64 占8字节，三个int64 占24字节肉存。</p></blockquote><h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><p>如果从集合类型的角度考虑，数组、切片和 map 都是集合类型，因为它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是连续的内存操作，通过索引就可以快速地找到元素存储的地址。</p><p>进一步对比，在数组和切片中，切片又更高效，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 <code>SliceHleader</code> 的三个字段就可以了，共用的还是同一个底层数组。</p><p>切片的高效还体现在 <code>for tange</code> 循环中，因为循环得到的临时变量也是个值拷贝，所以在遍历大的数组时，切片的效率更高。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本周所学基础知识就是上面的三大块内容，额，了解 Go 语言的底层设计就会发现其设计的巧妙性，初学数组和切片时认为单独设计这两个明明差不多的东西有点多此一举。看了它的底层逻辑，有了解了其设计哲学才发现好像是有道理的。</p><p>其实可以回答一个面试官很爱问的问题——为什么要学习 Go 这门语言？</p><p>其实这个问题我已经不止一次地在博客中写了，最开始学习的原因是因为舍友说这门语言有着严格的语法和结构要求，所以每个人写出来的代码都没有太大的区别，所以出于规划自己的代码风格以及缩小自己与大佬的差距，我选择学习Go 语言。</p><p>在开始做 Go 语言项目时，发现这个语言要比 C++ 或者 Python 好用很多，简单的语法、高并发等特性吸引着我去继续做项目。</p><p>现在也已经做了不少关于 Go 语言开发的内容，代码量也有几万行了，也开始关注其设计哲学和底层代码，更是被其严谨性所折服。所有设计出来的东西好像都是必须要有的，既不会多出一些无关紧要的设计，也没有什么必不可少的功能。</p><blockquote><p>不过 Go 语言确实不适合用来刷题，不仅仅是在设计输入输出的时候很麻烦，实现一些功能也是不方便。仅代表个人观点。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>反射：<ul><li><a href="https://www.cnblogs.com/jiujuan/p/17142703.html">https://www.cnblogs.com/jiujuan/p/17142703.html</a></li><li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93">https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93</a></li></ul></li><li>unsafe：<ul><li><a href="https://segmentfault.com/a/1190000021625500">https://segmentfault.com/a/1190000021625500</a></li><li><a href="https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html">https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html</a></li><li><a href="https://xie.infoq.cn/article/6513f7a056774b47c63535fae">https://xie.infoq.cn/article/6513f7a056774b47c63535fae</a></li></ul></li><li>slice：<ul><li><a href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html">https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/61121325">https://zhuanlan.zhihu.com/p/61121325</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。&lt;/p&gt;
&lt;h1 id=&quot;反射&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
