<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-18T09:36:36.786Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树是什么？——一个“清朝”的遗留问题</title>
    <link href="http://example.com/2024/06/17/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E2%80%9C%E6%B8%85%E6%9C%9D%E2%80%9D%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/06/17/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E2%80%9C%E6%B8%85%E6%9C%9D%E2%80%9D%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/</id>
    <published>2024-06-17T13:38:37.000Z</published>
    <updated>2024-06-18T09:36:36.786Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学我们的老朋友——红黑树。为什么今天的标题透着一股诡异的气息，清朝的遗留问题，其实是笔者从大一就开始说要去学一直到现在都没学的一个知识点。</p><p>为什么最近突然想起来这个老朋友了？最近 Java 的基础知识也学得差不多了，所以开始看一些 Java 的集合框架，学的过程中我又看到了这个老朋友。做事实在是太拖拉了，都两年多了才开始学一些基础的东西，被秒挂也不是什么稀奇事了。</p><h1 id="红黑树为什么必须掌握？"><a href="#红黑树为什么必须掌握？" class="headerlink" title="红黑树为什么必须掌握？"></a>红黑树为什么必须掌握？</h1><p>来看看，红黑树的广泛的应用</p><ul><li>JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树</li><li>Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构</li><li>Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。</li><li>多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。</li></ul><p>面试过程中，HashMap 常常是面试的重点， 而且会以<strong>连环炮 的方式</strong>进行发问，</p><p>所以， <strong>红黑树基本是 面试必须的 要点</strong>， <strong>如果 答不上来，面试就有 很大程度 就黄了</strong>。笔者就有相似的经历，被面试官突然提起的红黑树硬控了几秒，回忆起三年前的青葱岁月（bushi）。</p><p>红黑树，又比较复杂，有非常多的场景, 大家记住不容易。</p><p>那为了更加全面地了解红黑树，我们就不得不再一次提起之前在 MySQL 索引方面提到的几种二叉树了。还是再看看吧，加深一下记忆。</p><h1 id="BST-二叉搜索树"><a href="#BST-二叉搜索树" class="headerlink" title="BST 二叉搜索树"></a>BST 二叉搜索树</h1><p>二叉查找树（BST）具备以下特性：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ol><h2 id="完美的二叉搜索树"><a href="#完美的二叉搜索树" class="headerlink" title="完美的二叉搜索树"></a>完美的二叉搜索树</h2><p>一般人们理解的二叉树（<strong>又叫二叉搜索树 BST</strong>）会出现一个问题，完美的情况下，它是这样的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8555d3dc4ccc9c65bd59977ff14397ee.png" alt="img"></p><h2 id="极端情况下的二叉搜索树"><a href="#极端情况下的二叉搜索树" class="headerlink" title="极端情况下的二叉搜索树"></a>极端情况下的二叉搜索树</h2><p>二叉查找树是有缺点的，在不断插入的时候，<strong>有可能出现这样一种情况：</strong>很容易“退化”成链表，</p><p>如果bst 树的节点正好从大到小的插入，此时树的结构也类似于链表结构，这时候的查询或写入耗时与链表相同。</p><h4 id="退化成为了-链表的特殊BST"><a href="#退化成为了-链表的特殊BST" class="headerlink" title="退化成为了 链表的特殊BST"></a>退化成为了 链表的特殊BST</h4><p>一颗特殊BST，退化成为了 链表，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fbbb12eb4a708f7c02cfaf1cda065d24.png" alt="img"></p><p>它和链表一样，搜索的时候，最坏情况的时间复杂度O(n) 。</p><h4 id="那么我们怎么避免这种情况呢？"><a href="#那么我们怎么避免这种情况呢？" class="headerlink" title="那么我们怎么避免这种情况呢？"></a>那么我们怎么避免这种情况呢？</h4><p>为了避免这种特殊的情况发生，引入了平衡二叉树（AVL）和红黑树（red-black tree）。</p><p>AVL 、rbt 都是通过本身的建树原则来控制树的层数和节点位置，</p><p>因为 rbtree 是由AVL演变而来，所以我们从了解AVL开始。</p><h1 id="AVL-平衡二叉树"><a href="#AVL-平衡二叉树" class="headerlink" title="AVL 平衡二叉树"></a>AVL 平衡二叉树</h1><p>平衡二叉树也叫AVL（发明者名字简写），也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡。</p><blockquote><p>AVL树是最先发明的自平衡二叉查找树。</p><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。</p><p>增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p></blockquote><h2 id="AVL-的特性"><a href="#AVL-的特性" class="headerlink" title="AVL 的特性"></a>AVL 的特性</h2><p>AVL树本质上还是一棵二叉搜索树，它有以下特性：</p><ul><li>特性1： 对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li><li>特性2：对于AVL树而言，其中任何子树仍然是AVL树；</li><li>特性3：每个节点的左右子节点的高度之差的绝对值最多为1；</li></ul><blockquote><p>特性1表明，AVL 继承于 BST , 所以:</p><p>1.AVL本身首先是一棵BST 二叉搜索树。<br>2.AVL带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p></blockquote><p>在插入、删除树节点的时候，如果破坏了以上的原则，<strong>AVL树会自动进行调整</strong>使得以上三条原则仍然成立。</p><p>也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。</p><h2 id="AVL-的平衡功能"><a href="#AVL-的平衡功能" class="headerlink" title="AVL 的平衡功能"></a>AVL 的平衡功能</h2><p>举个例子，下左图为AVL树最长的2节点与最短的8节点高度差为1；</p><p>当插入一个新的节点后，根据上面第一条原则，它会出现在2节点的左子树，但这样一来就违反了原则3。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a075215c8d79d1930c4233e44bb7a8ae.png" alt="img"></p><p>此时AVL树会通过节点的旋转进行进行平衡，</p><p>AVL调整的过程称之为左旋和右旋。</p><h3 id="调整过程"><a href="#调整过程" class="headerlink" title="调整过程"></a>调整过程</h3><p><strong>旋转之前，首先确定旋转支点（pivot）：</strong> 这个旋转支点就是失去平衡这部分树，在自平衡之后的根节点，</p><p>平衡的调整过程，需要根据pivot它来进行旋转。</p><p>我们在学习AVL树的旋转时，不要将失衡问题扩大到整个树来看，这样会扰乱你的思路，</p><p>我们只关注<strong>失衡子树的根结点</strong> 及它的子节点和孙子节点即可。</p><p>事实上，AVL树的旋转，我们权且叫“AVL旋转”是有规律可循的，因为只要聚焦到<strong>失衡子树，</strong>然后进行左旋、右旋即可。</p><blockquote><p>很多人在左旋和右旋有时候弄不明白，</p><p>其实左旋就是逆时针转，右旋是顺时针转</p></blockquote><h2 id="AVL-子树的四大场景"><a href="#AVL-子树的四大场景" class="headerlink" title="AVL 子树的四大场景"></a>AVL 子树的四大场景</h2><p>导致AVL失衡的场景就是有限的4个：</p><ul><li>左左结构失衡（LL型失衡）</li><li>右右结构失衡（RR型失衡）</li><li>左右结构失衡（LR型失衡）</li><li>右左结构失衡（RL型失衡）</li></ul><p>删除元素，也会导致AVL失衡，需要再平衡，但是原理和插入元素是类似的。</p><p>这里聚焦 介绍插入元素的平衡过程， 删除元素，不做介绍。</p><h3 id="场景一：LL型失衡-左左结构失衡（右旋）"><a href="#场景一：LL型失衡-左左结构失衡（右旋）" class="headerlink" title="场景一：LL型失衡-左左结构失衡（右旋）"></a>场景一：LL型失衡-左左结构失衡（右旋）</h3><p>场景： 插入的元素在子树root的左侧不平衡元素的左侧</p><p>此时，以root的左儿为支点，也就是，左侧的不平衡元素为pivot(支点), 进行右旋</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618164813142.png" alt="image-20240618164813142"></p><p>来一个右旋的动画：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/96a7aa160f13424abb4acd1ada47edbf.webp" alt="在这里插入图片描述"></p><blockquote><p>右旋过程中，如果pivot有右子树，则作为 原root的 左子树， 保障AVL的特性1</p></blockquote><h4 id="记忆要点"><a href="#记忆要点" class="headerlink" title="记忆要点"></a><strong>记忆要点</strong></h4><blockquote><p>旋转的反向，与失衡的方向相反，</p><p>LL 型失衡，与左边 相反的方向， 是右边，所以是右旋</p></blockquote><h3 id="场景二：RR型失衡-右右结构失衡（左旋）"><a href="#场景二：RR型失衡-右右结构失衡（左旋）" class="headerlink" title="场景二：RR型失衡-右右结构失衡（左旋）"></a>场景二：RR型失衡-右右结构失衡（左旋）</h3><blockquote><p>场景：插入的元素在子树root右侧的不平衡子树的右侧</p><p>此时，以root的右儿为支点，也就是，右侧的不平衡元素 为 pivot(支点)， 进行左旋</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dea622e0576539552458e3afcffb1f59.png" alt="img"></p><p>来一个左旋的动画：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba1adc2895cf4b1aaef2e7088d9f6a69.webp" alt="在这里插入图片描述"></p><blockquote><p>左旋过程中，如果pivot有左子树，则作为 原root的 右子树，</p><p>保障AVL的特性1，</p></blockquote><h4 id="记忆要点-1"><a href="#记忆要点-1" class="headerlink" title="记忆要点"></a><strong>记忆要点</strong></h4><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RR 型失衡，与右边 相反的方向， 是左边，所以是左旋</p></blockquote><h3 id="场景三：LR型失衡-左右结构失衡（左旋-右旋）"><a href="#场景三：LR型失衡-左右结构失衡（左旋-右旋）" class="headerlink" title="场景三：LR型失衡-左右结构失衡（左旋+右旋）"></a>场景三：LR型失衡-左右结构失衡（左旋+右旋）</h3><blockquote><p>场景： 插入的元素在左侧的不平衡元素的右侧</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a50f45a2c27e4f330603481789d5234c.png" alt="img"></p><h4 id="记忆要点-2"><a href="#记忆要点-2" class="headerlink" title="记忆要点"></a>记忆要点</h4><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>LR型失衡，与只相反的方向是 RL，但是先旋转底部，再旋转顶部，RL进行次序颠倒，LR</p><p>所以， LR型失衡，旋转的方式，是先左旋， 再右旋</p></blockquote><h3 id="场景四：RL失衡-右左结构失衡-（右旋-左旋）"><a href="#场景四：RL失衡-右左结构失衡-（右旋-左旋）" class="headerlink" title="场景四：RL失衡:-右左结构失衡 （右旋+左旋）"></a>场景四：RL失衡:-右左结构失衡 （右旋+左旋）</h3><p>场景： 插入的元素在右侧的不平衡元素的左侧</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/24326f9fded29e6f566738f86525d468.png" alt="img"></p><h4 id="记忆要点-3"><a href="#记忆要点-3" class="headerlink" title="记忆要点"></a>记忆要点</h4><blockquote><p>旋转的反向，<strong>与失衡的方向相反</strong>，</p><p>RL型失衡，与只相反的方向是 LR，但是先旋转底部，再旋转顶部，所以，LR进行次序颠倒，RL</p><p>最终， RL型失衡，旋转的方式，是先右旋， 再左旋</p></blockquote><h3 id="AVL-的删除"><a href="#AVL-的删除" class="headerlink" title="AVL 的删除"></a>AVL 的删除</h3><p><strong>删除的判断标准</strong></p><ol><li>要删除的节点是什么类型的节点？；</li><li>删除后是否会破坏平衡 ；</li></ol><p><strong>节点类型</strong></p><ol><li>叶子节点；</li><li>节点只有左子树或只有右子树 ；</li><li>既有左右子树都有。</li></ol><p><strong>处理的思路</strong></p><ol><li>当删除为叶子节点，则直接删除，并从父亲节点开始往上看，判断是否失衡；如果没有失衡，再判断父亲的父节点是否失衡，直到根节点。若失衡则判断失衡类型（LL、LR、RR、RL），再进行相应的调整。</li><li>删除的节点只有左子树或只有右子树，那么将节点删除，以左子树或右子树进行代替，并进行相应的平衡判断，若失衡则调整，一直到根节点 ；</li><li>删除的节点既有左子树又有右子树，找到其前驱或者后驱节点将其替换，再判断是否失衡，然后根据失衡情况调整，直到根节点。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>既然AVL树可以保证二叉树的平衡，这就意味着AVL搜索的时候，它最坏情况的时间复杂度O(logn) ，要低于普通二叉树BST和链表的最坏情况O(n)。</p><p>那么HashMap直接使用AVL树来替换链表就好了，为什么选择用红黑树呢？</p><p>原因是：</p><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;= 1，所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p><p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是 <strong>增加删除 频繁</strong>的场景。</p><p><strong>红黑树(rbt)做了什么优化呢？</strong></p><p>红黑树(rbt)继承了AVL可自平衡的优点，</p><p>同时, 红黑树(rbt)在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除 频繁</strong>的场景。</p><p>在实际应用中，红黑树的使用要多得多。</p><h1 id="RBTree-红黑树"><a href="#RBTree-红黑树" class="headerlink" title="RBTree 红黑树"></a>RBTree 红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树）</p><p>红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees），在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p>红黑树也是一种自平衡二叉查找树，它与AVL树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。</p><p>与AVL树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时<strong>较少的旋转</strong>操作，整体来说性能要优于AVL树。</p><p>虽然 RBTree 是复杂的, 但它的<strong>最坏情况运行时间</strong>也是非常良好的,并且在实践中是高效的：</p><blockquote><p>它可以在<strong>O(log n)</strong>时间内做查找,插入和删除,这里的<strong>n 是树中元素的数目.</strong></p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>红黑树是实际应用中最常用的平衡二叉查找树，它不严格的具有平衡属性，但平均的使用性能非常良好。</p><p>在红黑树中，节点被标记为红色和黑色两种颜色。</p><p>红黑树的原则有以下几点：</p><ul><li>特性1：节点非黑即红</li><li>特性2：根节点一定是黑色</li><li>特性3：叶子节点（NIL）一定是黑色</li><li>特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p><strong>红色属性</strong> 说明，红色节点的孩子，一定是黑色。 但是，RBTree 黑色节点的孩子，可以是红色，也可以是黑色，具体如下图。</p><p><strong>叶子属性</strong> 说明， 叶子节点可以是空nil ，AVL的叶子节点不是空的，具体如下图。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20200901114718174.png" alt="img"></p><p>基于上面的原则，我们一般在插入红黑树节点的时候，会将这个节点设置为红色，</p><p>原因参照最后一条原则： <strong>红色破坏原则的可能性最小</strong>，如果是黑色, 很可能<strong>导致这条支路的黑色节点比其它支路的要多1</strong>，破坏了平衡。</p><p>黑色属性，可以理解为<strong>平衡特征</strong>， 如果满足不了平衡特征，就要进行平衡操作。</p><p><strong>空间换时间</strong></p><p>RBT有点属于一种<strong>空间换时间</strong>类型的优化，</p><p>在 AVL 的节点上，增加了<strong>颜色属性的 数据</strong>，相当于增加了空间的消耗。通过颜色属性的增加，换取后面平衡操作的次数减少。</p><h2 id="黑色完美平衡"><a href="#黑色完美平衡" class="headerlink" title="黑色完美平衡"></a>黑色完美平衡</h2><p>红黑树并不是一颗<strong>AVL平衡二叉搜索树</strong>，从图上可以看到，根节点P的左子树显然比右子树高</p><p>根据 红黑树的特性5，从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点， 说明：</p><blockquote><p>rbt 的 左子树和右子树的黑节点的层数是相等的</p><p>红黑树的平衡条件，不是以整体的高度来约束的，而是以黑色 节点的 高度，来约束的。</p></blockquote><p>所以称红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210410220909965.png" alt="在这里插入图片描述"></p><p>看看<strong>黑色完美平衡</strong>的效果，</p><p>去掉 rbt中的红色节点，会得到 一个四叉树， 从根节点到每一个叶子，高度相同，就是rbt的root到叶子的黑色路径长度。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618170439695.png" alt=""></p><h2 id="红黑树的平衡操作"><a href="#红黑树的平衡操作" class="headerlink" title="红黑树的平衡操作"></a>红黑树的平衡操作</h2><p>一旦红黑树5个原则有不满足的情况，我们视为平衡被打破，如何恢复平衡？</p><p>靠它的三种操作：<strong>变色、左旋、右旋</strong>。</p><h3 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h3><p>节点的颜色由红变黑或由黑变红。（这个操作很好了解）</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的左子树（左旋），pivot的原左子树变成 原root节点的 右子树，pivot的原右子树保持不变。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba1adc2895cf4b1aaef2e7088d9f6a69.webp" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618170920241.png" alt="image-20240618170920241"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>以某个结点作为支点(pivot)，其父节点（子树的root）旋转为自己的右子树（<strong>右旋</strong>），pivot的原右子树变成 原root节点的 左子树，pivot的原左子树保持不变。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/96a7aa160f13424abb4acd1ada47edbf.webp" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618171005287.png" alt="image-20240618171005287"></p><p>红黑树的左旋、右旋操作，AVL树的左旋，右旋操作差不多</p><h2 id="插入节点场景分析"><a href="#插入节点场景分析" class="headerlink" title="插入节点场景分析"></a>插入节点场景分析</h2><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>默认新插入的节点为红色</strong>：</p><p>因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突</p><h3 id="场景一：红黑树为空树"><a href="#场景一：红黑树为空树" class="headerlink" title="场景一：红黑树为空树"></a>场景一：红黑树为空树</h3><p>直接把插入结点作为根节点就可以了</p><p>另外：根据红黑树性质 2根节点是黑色的。还需要把插入节点设置为黑色。</p><h3 id="场景二：插入节点的-Key-已经存在"><a href="#场景二：插入节点的-Key-已经存在" class="headerlink" title="场景二：插入节点的 Key 已经存在"></a>场景二：插入节点的 Key 已经存在</h3><p>更新当前节点的值，为插入节点的值。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412094118977.png" alt="在这里插入图片描述"></p><h3 id="场景三：插入节点的父节点为黑色"><a href="#场景三：插入节点的父节点为黑色" class="headerlink" title="场景三：插入节点的父节点为黑色"></a>场景三：插入节点的父节点为黑色</h3><p>由于插入的节点是红色的，当插入节点的父节点是黑色时，不会影响红黑树的平衡，</p><p>所以： <strong>直接插入无需做自平衡</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412094724987.png" alt="在这里插入图片描述"></p><h3 id="场景四：插入节点的父节点为红色"><a href="#场景四：插入节点的父节点为红色" class="headerlink" title="场景四：插入节点的父节点为红色"></a>场景四：插入节点的父节点为红色</h3><p>根据性质2：根节点是黑色。</p><p>如果插入节点的父节点为红色节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点(三代关系)。</p><p>根据性质4：每个<strong>红色</strong>节点的两个子节点一定是<strong>黑色</strong>的。不能有<strong>两个红色节点相连</strong>。</p><p>此时会出现两种状态：</p><ul><li>父亲和叔叔为红色</li><li>父亲为红色，叔叔为黑色</li></ul><p>如图</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412100154174.png" alt="在这里插入图片描述"></p><h4 id="场景4-1：父亲和叔叔为红色节点"><a href="#场景4-1：父亲和叔叔为红色节点" class="headerlink" title="场景4.1：父亲和叔叔为红色节点"></a>场景4.1：父亲和叔叔为红色节点</h4><p>根据性质4：<strong>红色节点不能相连 ==》祖父节点肯定为黑色节点：</strong></p><p>父亲为红色，那么此时该插入子树的红黑树层数的情况是：黑红红。</p><p>因为不可能同时存在两个相连的红色节点，需要进行 变色， 显然处理方式是把其改为：红黑红</p><p><strong>变色 处理</strong>：黑红红 ==&gt; 红黑红</p><p>1.将F和V节点改为黑色</p><p>2.将P改为红色</p><p>3.将P设置为当前节点，进行后续处理</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2021041210371914.png" alt="在这里插入图片描述"></p><p>可以看到，将P设置为红色了，</p><p>如果<strong>P的父节点是黑色</strong>，那么无需做处理；</p><p>但如果P的父节点是红色，则违反红黑树性质了，所以需要将P设置为当前节点，继续插入操作, 作自平衡处理，直到整体平衡为止。</p><h4 id="场景4-2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点"><a href="#场景4-2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点" class="headerlink" title="场景4.2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点"></a>场景4.2：叔叔为黑色，父亲为红色，并且父亲节点是祖父节点的左子节点</h4><p>叔叔为黑色，或者不存在（NIL）也是黑节点，并且节点的父亲节点是祖父节点的左子节点</p><p>注意：单纯从插入来看，叔叔节点非红即黑(NIL节点)，否则破坏了红黑树性质5，此时路径会比其他路径多一个黑色节点。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412104637494.png" alt="在这里插入图片描述"></p><h5 id="场景4-2-1：LL型失衡"><a href="#场景4-2-1：LL型失衡" class="headerlink" title="场景4.2.1：LL型失衡"></a>场景4.2.1：LL型失衡</h5><p>细分场景 1： 新插入节点，为其父节点的左子节点(LL红色情况)， 插入后 就是LL 型失衡</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412151911439.png" alt="在这里插入图片描述"></p><h5 id="自平衡处理："><a href="#自平衡处理：" class="headerlink" title="自平衡处理："></a>自平衡处理：</h5><p>1.变颜色：将F设置为黑色，将P设置为红色</p><p>2.对F节点进行<strong>右旋</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412160626713.png" alt="在这里插入图片描述"></p><h5 id="场景4-2-2：LR型失衡"><a href="#场景4-2-2：LR型失衡" class="headerlink" title="场景4.2.2：LR型失衡"></a>场景4.2.2：LR型失衡</h5><p>细分场景 2： 新插入节点，为其父节点的右子节点(LR红色情况)， 插入后 就是LR 型失衡</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412153113242.png" alt="在这里插入图片描述"></p><h5 id="自平衡处理：-1"><a href="#自平衡处理：-1" class="headerlink" title="自平衡处理："></a>自平衡处理：</h5><p>1.对F进行左旋</p><p>2.将F设置为当前节点，得到LL红色情况</p><p>3.按照LL红色情况处理(1.变色 2.右旋P节点)<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412153954767.png" alt="在这里插入图片描述"></p><h4 id="情景4-3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点"><a href="#情景4-3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点" class="headerlink" title="情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点"></a>情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点</h4><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412155353126.png" alt="在这里插入图片描述"></p><h5 id="情景4-3-1：RR型失衡"><a href="#情景4-3-1：RR型失衡" class="headerlink" title="情景4.3.1：RR型失衡"></a>情景4.3.1：RR型失衡</h5><p>新插入节点，为其父节点的右子节点(RR红色情况)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412155529702.png" alt="在这里插入图片描述"></p><p><strong>自平衡处理</strong>：</p><p>1.变色：将F设置为黑色，将P设置为红色</p><p>2.对P节点进行<strong>左旋</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412160829355.png" alt="在这里插入图片描述"></p><h5 id="情景4-3-2：RL型失衡"><a href="#情景4-3-2：RL型失衡" class="headerlink" title="情景4.3.2：RL型失衡"></a>情景4.3.2：RL型失衡</h5><p>新插入节点，为其父节点的左子节点(RL红色情况)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412161045393.png" alt="在这里插入图片描述"></p><p><strong>自平衡处理</strong>：</p><p>1.对F进行右旋</p><p>2.将F设置为当前节点，得到RR红色情况</p><p>3.按照RR红色情况处理(1.变色 2.左旋 P节点)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/20210412161924591.png" alt="在这里插入图片描述"></p><h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="有了二叉搜索树，为什么还需要平衡二叉树？"><a href="#有了二叉搜索树，为什么还需要平衡二叉树？" class="headerlink" title="有了二叉搜索树，为什么还需要平衡二叉树？"></a><strong>有了二叉搜索树，为什么还需要平衡二叉树？</strong></h3><p>二叉搜索树容易退化成一条链</p><p>这时，查找的时间复杂度从O ( log n）也将退化成O ( N )</p><p>引入对左右子树高度差有限制的平衡二叉树 AVL，保证查找操作的最坏时间复杂度也为O ( log n）。</p><h3 id="有了平衡二叉树，为什么还需要红黑树？"><a href="#有了平衡二叉树，为什么还需要红黑树？" class="headerlink" title="有了平衡二叉树，为什么还需要红黑树？"></a>有了平衡二叉树，为什么还需要红黑树？</h3><p>AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡</p><p>在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣</p><p>红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，</p><p>整体性能优于AVL</p><ul><li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</li><li>红黑树的红黑规则，保证最坏的情况下，也能在O ( log n）时间内完成查找操作。</li></ul><h3 id="红黑树那几个原则，你还记得么？"><a href="#红黑树那几个原则，你还记得么？" class="headerlink" title="红黑树那几个原则，你还记得么？"></a>红黑树那几个原则，你还记得么？</h3><p>可以按照括号里边的分类，记住 红黑树的几个原则：</p><ul><li>（<strong>颜色属性</strong>）节点非黑即红</li><li>（<strong>根属性</strong>）根节点一定是黑色</li><li>（<strong>叶子属性</strong>）叶子节点（NIL）一定是黑色</li><li>（<strong>红色属性</strong>）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li><strong>（黑色属性）</strong>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><h3 id="红黑树写入操作-，是如何找到它的父节点的？"><a href="#红黑树写入操作-，是如何找到它的父节点的？" class="headerlink" title="红黑树写入操作 ，是如何找到它的父节点的？"></a>红黑树写入操作 ，是如何找到它的父节点的？</h3><p>红黑树的节点 TreeNode它就是继承Node结构，</p><p>先看看红黑树的节点结构</p><p>以HashMap中的红黑树的结构定义为例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> <span class="keyword">val</span>;</span><br><span class="line">        volatile <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TreeNode在Node基础上加了几个字段，分别指向父节点parent，然后指向左子节点left，还有指向右子节点的right，</p><p>然后还有表示颜色red属性</p><p><strong>红黑树的插入操作</strong>：</p><p>首先是找到一个合适的插入点，就是找到插入节点的父节点，</p><p>由于红黑树 它又满足BST二叉查找树的 有序特性，这个找父节点的操作和二叉查找树是完全一致的。</p><p>二叉查找树，左子节点小于当前节点，右子节点大于当前节点，</p><p>然后每一次向下查找一层就可以排除掉一半的数据，查找的效率在log(N)</p><p>最终查找到nil节点或者 key一样的节点。</p><p>如果最终查找到 key一样的节点，进行更新操作。这个TreeNode.key 与当前 put.key 完全一致。这就不需要插入，替换value就可以了，父节点就是当前节点的父节点</p><p>如果最终查找到nil节点，进行插入操作。nil节点的父节点，就是当前节点的父节点，把插入的节点替换nil节点。然后进行红黑树的 平衡处理。</p><h3 id="红黑树的有那些内部操作"><a href="#红黑树的有那些内部操作" class="headerlink" title="红黑树的有那些内部操作"></a>红黑树的有那些内部操作</h3><p><strong>变色</strong></p><p>把一个红色的节点变成黑色，或者把一个黑色的节点变成红色，就是对这个节点的<code>变色</code>。</p><p><strong>旋转</strong></p><p>与平衡二叉树的旋转操作类似。</p><h3 id="红黑树与AVL树区别"><a href="#红黑树与AVL树区别" class="headerlink" title="红黑树与AVL树区别"></a>红黑树与AVL树区别</h3><p><strong>1、调整平衡的实现机制不同</strong></p><p>红黑树根据路径上黑色节点数目一致，来确定是否失衡，如果失衡，就通过变色和旋转来恢复</p><p>AVL根据树的<a href="https://so.csdn.net/so/search?q=平衡因子&amp;spm=1001.2101.3001.7020">平衡因子</a>(<strong>所有节点的左右子树高度差的绝对值不超过1</strong>)，来确定是否失衡，如果失衡，就通过旋转来恢复</p><p><strong>2、红黑树的插入效率更高</strong></p><p>红黑树是用<strong>非严格的平衡</strong>来换取增删节点时候旋转次数的降低，<strong>任何不平衡都会在三次旋转之内解决</strong>，</p><p>红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能</p><p>而AVL是<strong>严格平衡树</strong>(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</p><p>所以红黑树的插入效率更高</p><p><strong>3、红黑树统计性能比AVL树更高</strong></p><p>红黑树能够以<strong>O(log n)</strong> 的时间复杂度进行查询、插入、删除操作。</p><p>AVL树查找、插入和删除在平均和最坏情况下都是<strong>O(log n)</strong>。</p><p>红黑树的算法时间复杂度和AVL相同，<strong>但统计性能比AVL树更高</strong>，</p><p><strong>4、适用性：AVL查找效率高</strong></p><p><strong>如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树</strong>。</p><p>即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>隔了好几天才又开始写博客，前几天实在是有太多考试了。又考试又生病，搞得我一点学习的心情都没有了，好在今天算是好一点了，最近几天估计要更新好几篇内容，都是最近学习的内容。</p><p>由于最近考试，找到实习的舍友回来了，听他讲了很多在腾讯工作的事情，实名羡慕了。感觉挺好的，可能就是有点卷，但是没办法，大家都在卷，不卷就要走人了。</p><p>学校这两周考试周，我们已经考完了，所以未来两周将会究极闲，突然想学一下测试相关的东西了，大概了解一下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/crazymakercircle/p/16320430.html">https://www.cnblogs.com/crazymakercircle/p/16320430.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1739709">https://cloud.tencent.com/developer/article/1739709</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来学我们的老朋友——红黑树。为什么今天的标题透着一股诡异的气息，清朝的遗留问题，其实是笔者从大一就开始说要去学一直到现在都没学的一个知识点。&lt;/p&gt;
&lt;p&gt;为什么最近突然想起来这个老朋友了？最近 Java 的基础知识也学得差不多了，所以开始看一些 Java 的集合框架，</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统</title>
    <link href="http://example.com/2024/06/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2024/06/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-06-17T05:23:58.000Z</published>
    <updated>2024-06-18T13:23:08.936Z</updated>
    
    <content type="html"><![CDATA[<p>秒杀活动是指网络商家为促销等目的组织或网上限时抢购活动，这种活动具有瞬时并发量大、库存量少和业务逻辑简单等特点。设计一个秒杀系统需要考虑的因素很多，比如对现有业务的影响、网络带宽消耗以及超卖等因素。</p><p>选择学习这部分内容主要是因为秒杀、抽奖这些实际开发中会遇到的问题是面试的高频问题，而且整个设计过程确实涉及了很多方面的内容。本文会讨论秒杀系统的各个环节可能存在的问题以及解决方案。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>秒杀系统设计是国内系统设计面试的高频题，在面试中，你需要分析架构的瓶颈，潜在问题以及不同方案的优缺点，在本文的最后我们会提到这些面试技巧。开始之前，你需要了解如何设计一个基础的电商系统，秒杀系统只是在电商系统上增加了一些特定条件。现在的电商系统功能繁多，除了最基本的购买商品功能，还有物流跟踪，订单管理，社区交互等功能。不过面试中关注的主要是购买商品功能，我们将其他次要功能归类为其他业务功能，购买商品流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618175932074.png" alt="image-20240618175932074"></p><ol><li>客户通过客户端下单</li><li>如果下单成功则进入支付阶段，否则返回购买失败</li><li>进入支付阶段后，如果在一定时间内支付成功则返回购买成功，否则返回购买失败</li></ol><h1 id="从0到1000"><a href="#从0到1000" class="headerlink" title="从0到1000"></a>从0到1000</h1><p>想象你自己从零搭建一个电商平台，一开始平台里的商品种类以及日订单量都较少，商品种类有 100 款，日订单量只有 1000 条。根据以上信息，我们可以设计出架构 1：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f254536253945254236254536253945253834312e737667" alt="img"></p><ol><li>客户端发送下单请求给服务端</li><li>服务端查询数据库<ul><li>若该商品库存大于零，将库存减一并且返回下单成功</li><li>若该商品库存等于零的话，返回下单失败</li></ul></li></ol><p>架构 1 简单直观，它忽略了系统可用性以及可扩展性，但在日订单量少，不会出现多位客户对同一件商品同时下单的情况下，它很好地完成了我们需要的功能。</p><h1 id="从1000到100万"><a href="#从1000到100万" class="headerlink" title="从1000到100万"></a>从1000到100万</h1><p>经过一段时间后，你的电商平台商品种类增加到 1 万款，日订单量飙升到 100 万条，而且在高峰期，例如晚饭后，睡觉前的订单量会特别多。这是一个好的消息，不过同时你发现了一个问题，某些商品的成功下单量要大于库存量，也就是说出现了商品超卖的情况。这可是个严重的问题，因为没办法及时交货给客户对电商平台的信誉有极大影响。仔细分析架构 1 后，我们发现了问题的根源：当商品库存只剩下 1 件而有多位客户同时下单的时候，每个下单请求在查询的时候都发现库存大于零，并且将库存减 1 返回下单成功。下图中，在库存只有 1 件的时候，两个请求却都返回下单成功。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545352542392542362545352538462539312545352541452538392545352538352541382e737667" alt="并发安全"></p><p>幸运的是，我们知道大部分并发问题都可以通过锁机制或者队列服务来解决：</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>我们可以观察到，超卖问题的原因在于事务查询和更新库区期间，库存已经被其他事务修改了。在学习悲观锁之前，我们先了解下什么是两阶段加锁，两阶段加锁是一个典型的悲观锁策略：</p><blockquote><p>两阶段加锁方法类似，但锁的强制性更高。多个事务可以同时读取同一对象，当只要出现任何写操作（包括修改或删除），则必须加锁以独占访问。—-《数据密集型应用系统设计》</p></blockquote><p>我们的电商系统中可以应用两阶段加锁，由于下单请求涉及到修改库存，可以先使用排他锁锁定记录，防止被其他事务所修改。大部分关系型数据库都提供这种功能（在 MySQL 和 PostgresSQL 里面的语法是 SELECT … FOR 下UPDATE）。流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545362538322542322545382541372538322545392539342538312e737667" alt="悲观锁"></p><ol><li>蓝色请求先获取排他锁，查询和更新库存，在此期间黑色请求等待获取排他锁。</li><li>蓝色请求更新库存后释放排他锁，返回下单成功</li><li>黑色请求获取排他锁，发现库存为 0，释放排他锁，返回下单失败</li></ol><p>我们可以看到悲观锁成功解决了商品超卖问题，不过它的缺点也比较明显：</p><ol><li>处理性能不高，当一件商品有多位客户同时下单的时候，每个请求需要等待排他锁，也要较长才知道是否下单成功。</li><li>容易发生死锁：在实际工程中，下单操作不只涉及了库存修改，还可能涉及其他业务功能，由于悲观锁下每个请求都轮流持有锁，应用层的代码处理不好的话会更容易发生死锁。</li></ol><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>和悲观锁不同，乐观锁策略下事务会记录下查询时的版本号，当事务准备更新库存的时候，如果此时的版本号与查询时的版本号不同，则代表库存被其他事务修改了，这时候就会回滚事务，流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545342542392539302545382541372538322545392539342538312e737667" alt="乐观锁"></p><ol><li>蓝色请求与黑色请求查询库存，并记录库存版本号</li><li>蓝色请求先更新库存为 0，返回下单成功</li><li>黑色请求更新前发现版本与之前版本号不同，回归事务，返回下单失败</li></ol><p>乐观锁因为并不需要等待锁，所以在事务竞争较少的情况下比悲观锁有更好的性能，缺点是事务竞争较多的情况下，由于经常需要回滚事务导致性能反而较差。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁在服务端以及数据库之间加上分布式组件来保证请求的并发安全，国内较常使用 Redis 或者 ZooKeeper。和悲观锁类似，每个请求需要先从组件中获取分布式锁之后才可以继续执行。流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545352538382538362545352542382538332545352542432538462545392539342538312e737667" alt="分布式锁"></p><ol><li>蓝色请求先获取分布式锁，查询和更新库存，在此期间黑色请求等待获取分布式锁</li><li>蓝色请求更新库存后释放分布式锁，返回下单成功</li><li>黑色请求获取分布式锁，查询库存，发现库存为 0，释放分布式锁，返回下单失败</li></ol><p>分布式锁的优点是将功能进行分离，分布式组件负责解决并发安全的问题，数据库负责数据存储。不过缺点在于：</p><ol><li>分布式锁的正确实现并不简单，错误的实现方式容易引起其他一致性的问题。</li><li>分布式锁在高并发下也会产生锁竞争的问题，性能不佳。</li><li>由于引入了新的组件，要考虑分布式组件的可靠性，以及崩溃之后的恢复机制。</li></ol><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>另一个直观的解决方法就是使用消息队列，确保每个商品每个时刻只有一个请求，流程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545362542362538382545362538312541462545392539382539462545352538382539372e737667" alt="消息队列"></p><ol><li>客户端发送下单请求给服务端</li><li>服务端将请求发送到消息队列</li><li>数据库每次从消息队列取出请求<ul><li>若该商品库存大于零，将库存减一</li><li>若该商品库存等于零的话，不做操作</li></ul></li><li>服务端根据消息队列里的消息状态返回下单结果</li></ol><h1 id="从电商系统到秒杀系统"><a href="#从电商系统到秒杀系统" class="headerlink" title="从电商系统到秒杀系统"></a>从电商系统到秒杀系统</h1><p>秒杀系统和电商系统有两个核心区别：</p><ol><li>双十一也有极大的流量，但是双十一的商品种类很多，所以流量会分布到不同的商品中。而秒杀系统中，商品的种类和库存都比较少，导致大部分流量集中在少量商品中。</li><li>秒杀系统由于商品稀缺，价值高。同一位客户可能会对同一商品多次提交下单请求，而且恶意刷单的请求比较多，所以系统接收到的无效请求及非法请求较多。</li></ol><p>针对这两个区别，我们发现架构 2 有 3 个潜在问题：</p><ol><li>当一款商品库存只有 10 件却有 1 万名用户下单的时候，只有前 10 名客户可以下单成功，其他用户都浪费时间在队列等待以及无意义地查询库存，既牺牲了用户体验也增加了消息队列以及数据库的压力。</li><li>由于库存过少，有大量的请求（例如非法用户的请求，超过秒杀活动开始一定时间的请求）其实是没有机会抢到商品的，所以没有必要到达服务器，更不用说数据库了。</li><li>大量的客户端在下单前同时请求同一个商品的秒杀页面，导致服务器压力骤升。</li></ol><p>针对这三个问题我们可以考虑两个方案：<strong>流量控制</strong>和<strong>资源隔离</strong>。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>第三个问题相对简单，可以将秒杀页面使用 CDN 缓存起来，客户端就可以直接从 CDN 获取到秒杀页面，不需要重复请求服务器。另外两个问题可以通过流量限制来解决，可以通过限流器，负载均衡以及安全验证组件实现：</p><ul><li>限流器分为前端限流与后端限流：<ul><li>前端限流包括验证答题，防止重复点击按钮等常见机制。</li><li>后端限流使用限流算法进行流量限制，简单情况下可以使用固定限流算法，例如秒杀商品的库存是 10 件，只要限流器接收到 10 <em> k（k 可以根据业务进行调整）个请求之后，就停止接受该商品的所有请求。这样无论有多少个下单请求，最终到达服务器的单个商品请求数量都不超过 10 </em> k。实际工程中，因为有客户可能会出现支付超时导致释放库存的情况，系统需要通知限流器接受新的请求。</li></ul></li><li>负载均衡负责将下单请求通过负载均衡算法转发到最合适的服务器。</li><li>安全验证组件分为前端安全验证以及后端安全验证：<ul><li>后端安全验证包括黑名单校验，IP 地址校验等机制。</li><li>前端安全验证包括：客户端账户验证（确保客户有资格参考秒杀活动），客户端版本安全验证（防止反编译以及修改客户端代码），秒杀接口动态生成（防止使用刷单脚本）等机制。</li></ul></li></ul><p>这时候系统的整体架构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545362542352538312545392538372538462545392539392539302545352538382542362e737667" alt="img"></p><h2 id="热门资源隔离"><a href="#热门资源隔离" class="headerlink" title="热门资源隔离"></a>热门资源隔离</h2><p>既然大部分流量集中在少量商品中，我们能不能针对这些商品进行特殊处理呢？这样既可以防止秒杀活动影响其他业务功能，也可以针对热门商品进行资源分配，答案是可以的，首先我们需要识别出热门商品，这里有两种常见的方法：</p><ul><li>静态识别：包括京东在内的一些电商平台，客户在参加秒杀活动之前需要先进行预约，只有预约过的客户才能参考秒杀活动。这样系统可以提早识别热门商品以及进行流量预估。</li><li>动态识别：通过实时数据分析系统在秒杀活动前统计出现在较多客户浏览的热门商品，针对预估结果进行资源分配。</li></ul><p>识别出热门商品之后，我们可以将热门商品的资源进行隔离，并且设置独立的策略，例如</p><ul><li>使用特殊的限流器，由于秒杀系统的库存很少，在下单请求开始阶段就可以随机丢弃大部分请求。</li><li>使用单独的数据库，在架构 2 中，下单请求的处理速度受限于消费者的处理速度，也就是数据库的处理速度。我们可以对热门商品进行分库分表，这样可以将请求处理的压力分摊到多个数据库中。下图中，我们将秒杀系统的一些组件独立开来：</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f2545382542352538342545362542412539302545392539412539342545372541362542422e737667" alt="资源隔离"></p><p>根据以上两个方案，我们可以设计出最后的架构 3：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f4f534a6f62732f6f736a6f62732d73797374656d2f7374617469632f7370696b652f254536253945254236254536253945253834332e737667" alt="架构3"></p><ol><li>客户端从 CDN 获取到秒杀页面</li><li>客户端发送下单请求给网关</li><li>在网关或者服务器前进行流量控制以及负载均衡等策略</li><li>服务端将请求发送到消息队列</li><li>数据库每次从消息队列取出请求<ul><li>若该商品库存大于零，将库存减一</li><li>若该商品库存等于零的话，不做操作</li></ul></li><li>服务端根据消息队列里的消息状态返回下单结果</li></ol><hr><p>关于秒杀系统的大概设计流程已经讲完了，但这也就只能回答面试官一个问题——设计流程，如果细问，依旧还有很多细节要学习，下面我们来看更多的细节问题。</p><p>一般在<strong>秒杀时间点</strong>前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量才会到达顶峰。</p><p>但由于这类活动是大量用户抢少量商品的场景，必定会出现<code>狼多肉少</code>的情况，所以其实绝大部分用户秒杀会失败，只有极少部分用户能够成功。</p><p>正常情况下，大部分用户会收到商品已经抢完的提醒，收到该提醒后，他们大概率不会在那个活动页面停留了，如此一来，用户并发量又会急剧下降。所以这个峰值持续的时间其实是非常短的，这样就会出现瞬时高并发的情况，下面用一张图直观的感受一下流量的变化：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/99ec913130454ce291652c97bedca7bc%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="图片"></p><p>像这种瞬时高并发的场景，传统的系统很难应对，我们需要设计一套全新的系统。可以从以下几个方面入手：</p><ol><li>页面静态化</li><li>CDN加速</li><li>缓存</li><li>mq异步处理</li><li>限流</li></ol><h1 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h1><p>活动页面是用户流量的第一入口，所以是并发量最大的地方。</p><p>如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618200428203.png" alt="image-20240618200428203"></p><p>不知道你是否还记得，最早的秒杀系统其实是要刷新整体页面的，但后来秒杀的时候，你只要点击“刷新抢宝”按钮就够了，这种变化的本质就是动静分离，分离之后，客户端大幅度减少了请求的数据量。这不自然就“快”了吗？</p><p>活动页面绝大多数内容都是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做<code>静态化</code>处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618200852213.png" alt="image-20240618200852213"></p><p>这样能过滤大部分无效请求。</p><p>但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。</p><p>如何才能让用户最快访问到活动页面呢？</p><p>这就需要使用CDN，它的全称是Content Delivery Network，即内容分发网络。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1e5c1fb0fa47ba4eae4977f4cfc564c2.jpeg" alt="img"></p><p>使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><h2 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h2><p>那到底什么才是动静分离呢？所谓“动静分离”，其实就是把用户请求的数据（如HTML页面）划分为“动态数据”和“静态数据”。</p><p>简单来说，<strong>“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和URL、浏览者、时间、地域相关，以及是否含有Cookie等私密数据</strong>。比如说：</p><ol><li>很多媒体类的网站，某一篇文章的内容不管是你访问还是我访问，它都是一样的。所以它就是一个典型的静态数据，但是它是个动态页面。</li><li>我们如果现在访问淘宝的首页，每个人看到的页面可能都是不一样的，淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。</li></ol><p>这里再强调一下，我们所说的静态数据，不能仅仅理解为传统意义上完全存在磁盘上的HTML页面，它也可能是经过Java系统产生的页面，但是它输出的页面本身不包含上面所说的那些因素。也就是所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据。</p><p>还有一点要注意，就是页面中“不包含”，指的是“页面的HTML源码中不含有”，这一点务必要清楚。</p><p>理解了静态数据和动态数据，我估计你很容易就能想明白“动静分离”这个方案的来龙去脉了。分离了动静数据，我们就可以对分离出来的静态数据做缓存，有了缓存之后，静态数据的“访问效率”自然就提高了。</p><p>那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。</p><p><strong>第一，你应该把静态数据缓存到离用户最近的地方</strong>。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN上或者在服务端的Cache中。你应该根据情况，把它们尽量缓存到离用户最近的地方。</p><p><strong>第二，静态化改造就是要直接缓存HTTP连接</strong>。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存HTTP连接而不是仅仅缓存数据，如下图所示，Web代理服务器根据请求URL，直接取出对应的HTTP响应头和响应体然后直接返回，这个响应过程简单得连HTTP协议都不用重新组装，甚至连HTTP请求头也不需要解析。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2c608715621afc9c95570dce00a87546.jpg" alt="img"></p><p><strong>第三，让谁来缓存静态数据也很重要。</strong>不同语言写的Cache软件处理缓存数据的效率也各不相同。以Java为例，因为Java系统本身也有其弱点（比如不擅长处理大量连接请求，每个连接消耗的内存较多，Servlet容器解析HTTP协议较慢），所以你可以不在Java层做缓存，而是直接在Web服务器层上做，这样你就可以屏蔽Java语言层面的一些弱点；而相比起来，Web服务器（如Nginx、Apache、Varnish）也更擅长处理大并发的静态文件请求。</p><h2 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h2><p>理解了动静态数据的“why”和“what”，接下来我们就要看“how”了。我们如何把动态页面改造成适合缓存的静态页面呢？其实也很简单，就是去除前面所说的那几个影响因素，把它们单独分离出来，做动静分离。</p><p>下面，我以典型的商品详情系统为例来详细介绍。这里，你可以先打开京东或者淘宝的商品详情页，看看这个页面里都有哪些动静数据。我们从以下5个方面来分离出动态内容。</p><ol><li><strong>URL唯一化</strong>。商品详情系统天然地就可以做到URL唯一化，比如每个商品都由ID来标识，那么 <a href="http://item.xxx.com/item.htm?id=xxxx">http://item.xxx.com/item.htm?id=xxxx</a> 就可以作为唯一的URL标识。为啥要URL唯一呢？前面说了我们是要缓存整个HTTP连接，那么以什么作为Key呢？就以URL作为缓存的Key，例如以id=xxx这个格式进行区分。</li><li><strong>分离浏览者相关的因素</strong>。浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。</li><li><strong>分离时间因素</strong>。服务端输出的时间也通过动态请求获取。</li><li><strong>异步化地域因素</strong>。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。</li><li><strong>去掉Cookie</strong>。服务端输出的页面包含的Cookie可以通过代码软件来删除，如Web服务器Varnish可以通过unset req.http.cookie 命令去掉Cookie。注意，这里说的去掉Cookie并不是用户端收到的页面就不含Cookie了，而是说，在缓存的静态数据中不含有Cookie。</li></ol><p>分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户ID是否匹配等，所以这个时候我们应该将这些信息JSON化（用JSON格式组织这些数据），以方便前端获取。</p><p>前面我们介绍里用缓存的方式来处理静态数据。而动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和CSI（Client Side Include）方案。</p><ol><li><strong>ESI方案（或者SSI）</strong>：即在Web代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。</li><li><strong>CSI方案</strong>。即单独发起一个异步JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</li></ol><h2 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a>架构方案</h2><p>根据架构上的复杂度，有3种方案可选：</p><ol><li>实体机单机部署；</li><li>统一Cache层；</li><li>上CDN。</li></ol><p>上面我们也谈到要使用 CDN 来实现动静分离，所以在这里着重讨论一下，其余方案就不在细讲了。</p><p>使用 CDN 我们将面临以下几个问题：</p><ol><li><strong>失效问题</strong>。前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要保证CDN可以在秒级时间内，让分布在全国各地的Cache同时失效，这对CDN的失效系统要求很高。</li><li><strong>命中率问题</strong>。Cache最重要的一个衡量指标就是“高命中率”，不然Cache的存在就失去了意义。同样，如果将数据全部放到全国的CDN上，必然导致Cache分散，而Cache分散又会导致访问请求命中同一个Cache的可能性降低，那么命中率就成为一个问题。</li><li><strong>发布更新问题</strong>。如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。</li></ol><p>从前面的分析来看，将商品详情系统放到全国的所有CDN节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：</p><ol><li>靠近访问量比较集中的地区；</li><li>离主站相对较远；</li><li>节点到主站间的网络比较好，而且稳定；</li><li>节点容量比较大，不会占用其他CDN太多的资源。</li></ol><p>最后，还有一点也很重要，那就是：节点不要太多。</p><p>基于上面几个因素，选择CDN的二级Cache比较合适，因为二级Cache数量偏少，容量也更大，让用户的请求先回源的CDN的二级Cache中，如果没命中再回源站获取数据，部署方式如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202203356.png" alt="image-20240618202203356"></p><p>使用CDN的二级Cache作为缓存，可以达到和当前服务端静态化Cache类似的命中率，因为节点数不多，Cache不是很分散，访问量也比较集中，这样也就解决了命中率问题，同时能够给用户最好的访问体验，是当前比较理想的一种CDN化方案。</p><p>除此之外，CDN化部署方案还有以下几个特点：</p><ol><li>把整个页面缓存在用户浏览器中；</li><li>如果强制刷新整个页面，也会请求CDN；</li><li>实际有效请求，只是用户对“刷新抢宝”按钮的点击。</li></ol><p>这样就把90%的静态数据缓存在了用户端或者CDN上，当真正秒杀时，用户只需要点击特殊的“刷新抢宝”按钮，而不需要刷新整个页面。这样一来，系统只是向服务端请求很少的有效数据，而不需要重复请求大量的静态数据。</p><p>秒杀的动态数据和普通详情页面的动态数据相比更少，性能也提升了3倍以上。所以“抢宝”这种设计思路，让我们不用刷新页面就能够很好地请求到服务端最新的动态数据。</p><h1 id="秒杀按钮"><a href="#秒杀按钮" class="headerlink" title="秒杀按钮"></a>秒杀按钮</h1><p>大部分用户怕错过<code>秒杀时间点</code>，一般会提前进入活动页面。此时看到的<code>秒杀按钮</code>是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。</p><p>但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。</p><p>从前面得知，该活动页面是静态的。那么我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？</p><p>没错，使用js文件控制。</p><p>为了性能考虑，一般会将css、js和图片等静态资源文件提前缓存到CDN上，让用户能够就近访问秒杀页面。</p><p>看到这里，有些聪明的小伙伴，可能会问：CDN上的js文件是如何更新的？</p><p>秒杀开始之前，js标志为false，还有另外一个随机参数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202349540.png" alt="image-20240618202349540"></p><p>当秒杀开始的时候系统会生成一个新的js文件，此时标志为true，并且随机参数生成一个新值，然后同步给CDN。由于有了这个随机参数，CDN不会缓存数据，每次都能从CDN中获取最新的js代码。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202411522.png" alt="image-20240618202411522"></p><p>此外，前端还可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。</p><h1 id="读多写少"><a href="#读多写少" class="headerlink" title="读多写少"></a>读多写少</h1><p>在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。</p><p>由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。</p><p>这是非常典型的：<code>读多写少</code> 的场景。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c5c91688e2704bfb9779b46d716d6a66%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="图片"></p><p>如果有数十万的请求过来，同时通过数据库查缓存是否足够，此时数据库可能会挂掉。因为数据库的连接资源非常有限，比如：MySQL，无法同时支持这么多的连接。</p><p>而应该改用缓存，比如：redis。单个 Redis 可以处理几万的 QPS，如果预估请求的 QPS 大于几万，我们还可以使用 Redis 集群模式来增加 Redis 的处理能力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618202831227.png" alt="image-20240618202831227"></p><p>在 Redis 存放和售卖商品数目大小相同的数字，秒杀服务每次访问数据库之前，都需要先去 Redis 中扣减库存，扣减成功才能继续更新数据库。这样，最终到的数据库的请求数目和需要售卖商品的数目基本一致，数据库的压力可以大大减少。</p><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><p>通常情况下，我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。</p><p>用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。</p><p>大致流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203128539.png" alt="image-20240618203128539"></p><p>根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。</p><p>这个过程表面上看起来是OK的，但是如果深入分析一下会发现一些问题。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>比如商品A第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。</p><p>然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。</p><p>如何解决这个问题呢？</p><p>这就需要加锁，最好使用分布式锁。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203215050.png" alt="image-20240618203215050"></p><p>当然，针对这种情况，最好在项目启动之前，先把缓存进行<code>预热</code>。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。</p><p>是不是上面加锁这一步可以不需要了？</p><p>表面上看起来，确实可以不需要。但如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加速同样可能出现缓存击穿。</p><p>其实这里加锁，相当于买了一份保险。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>如果有大量的请求传入的商品id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。</p><p>由于前面已经加了锁，所以即使这里的并发量很大，也不会导致数据库直接挂掉。</p><p>但很显然这些请求的处理性能并不好，有没有更好的解决方案？</p><p>这时可以想到<code>布隆过滤器</code>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203349855.png" alt="image-20240618203349855"></p><p>系统根据商品id，先从布隆过滤器中查询该id是否存在，如果存在则允许从缓存中查询数据，如果不存在，则直接返回失败。</p><p>虽说该方案可以解决缓存穿透问题，但是又会引出另外一个问题：布隆过滤器中的数据如何更缓存中的数据保持一致？</p><p>这就要求，如果缓存中数据有更新，则要及时同步到布隆过滤器中。如果数据同步失败了，还需要增加重试机制，而且跨数据源，能保证数据的实时一致性吗？</p><p>显然是不行的。</p><p>所以布隆过滤器绝大部分使用在缓存数据更新很少的场景中。</p><p>如果缓存数据更新非常频繁，又该如何处理呢？</p><p>这时，就需要把不存在的商品id也缓存起来。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203456511.png" alt="image-20240618203456511"></p><p>下次，再有该商品id的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。</p><h1 id="库存问题"><a href="#库存问题" class="headerlink" title="库存问题"></a>库存问题</h1><p>对于库存问题看似简单，实则里面还是有些东西。</p><p>真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。</p><p>所以，在这里引出了一个<code>预扣库存</code>的概念，预扣库存的主要流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618203626470.png" alt="image-20240618203626470"></p><p>扣减库存中除了上面说到的<code>预扣库存</code>和<code>回退库存</code>之外，还需要特别注意的是<strong>库存不足</strong>和<strong>库存超卖</strong>问题。</p><p>检测库存不足问题，无论是直接使用 MySQL 的操作还是 Redis 的操作都会出现同一个问题，查询操作和更新操作不是原子的，在高并发的情况下，这种问题是绝对不能出现的。如何解决？</p><p>最简单的方法就是加锁。</p><p>虽然加锁可以解决商品超卖的问题，但是效率太低了。还有没有更好的方法，那就是 lua 脚本。</p><p>我们都知道lua脚本，是能够保证原子性的，它跟redis一起配合使用，能够完美解决上面的问题。</p><p>lua脚本有段非常经典的代码：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder <span class="attr">lua</span> = new StringBuilder()<span class="comment">;</span></span><br><span class="line">lua.append(&quot;if (redis.call(&#x27;exists&#x27;, KEYS<span class="section">[1]</span>) == 1) then&quot;)<span class="comment">;</span></span><br><span class="line">lua.append(&quot;    local <span class="attr">stock</span> = tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    if (<span class="attr">stock</span> == -<span class="number">1</span>) then<span class="string">&quot;);</span></span><br><span class="line"><span class="string">lua.append(&quot;</span>        return <span class="number">1</span><span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    end<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    if (stock &gt; 0) then&quot;)<span class="comment">;</span></span><br><span class="line">lua.append(&quot;        redis.call(&#x27;incrby&#x27;, KEYS<span class="section">[1]</span>, -1)<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;        return stock<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    end<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;    return 0<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;end<span class="comment">;&quot;);</span></span><br><span class="line">lua.append(&quot;return -1<span class="comment">;&quot;);</span></span><br></pre></td></tr></table></figure><p>该代码的主要流程如下：</p><ol><li>先判断商品id是否存在，如果不存在则直接返回。</li><li>获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。</li><li>如果库存大于0，则扣减库存。</li><li>如果库存等于0，是直接返回，表示库存不足。</li></ol><h1 id="mq-异步处理"><a href="#mq-异步处理" class="headerlink" title="mq 异步处理"></a>mq 异步处理</h1><p>我们都知道在真实的秒杀场景中，有三个核心流程：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204648082.png" alt="image-20240618204648082"></p><p>而这三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。</p><p>于是，秒杀后下单的流程变成如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204727363.png" alt="image-20240618204727363"></p><p>如果使用 mq，需要关注以下几个问题：</p><h2 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h2><p>秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。</p><p>那么，如何防止消息丢失呢？</p><p>答：加一张消息发送表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204856901.png" alt="image-20240618204856901"></p><p>在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。</p><p>如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。</p><p>这时候，要如何处理呢？</p><p>答：使用job，增加重试机制。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618204933636.png" alt="image-20240618204933636"></p><p>用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。</p><h2 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h2><p>本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。</p><p>那么，如何解决重复消息问题呢？</p><p>答：加一张消息处理表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205124237.png" alt="image-20240618205124237"></p><p>消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。</p><p>有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。</p><h2 id="垃圾消息问题"><a href="#垃圾消息问题" class="headerlink" title="垃圾消息问题"></a>垃圾消息问题</h2><p>这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。</p><p>那么，如何解决这个问题呢？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205305967.png" alt="image-20240618205305967"></p><p>每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。</p><p>这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。</p><h2 id="延迟消费问题"><a href="#延迟消费问题" class="headerlink" title="延迟消费问题"></a>延迟消费问题</h2><p>通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。</p><p>那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？</p><p>我们首先想到的可能是job，因为它比较简单。</p><p>但job有个问题，需要每隔一段时间处理一次，实时性不太好。还有更好的方案吗？</p><p>答：使用延迟队列。</p><p>我们都知道 RocketMQ，自带了延迟队列的功能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205417060.png" alt="image-20240618205417060"></p><p>下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。</p><p>还有个关键点，用户完成支付之后，会修改订单状态为已支付。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205435274.png" alt="image-20240618205435274"></p><h1 id="如何限流？"><a href="#如何限流？" class="headerlink" title="如何限流？"></a>如何限流？</h1><p>通过秒杀活动，如果我们运气爆棚，可能会用非常低的价格买到不错的商品（这种概率堪比买福利彩票中大奖）。</p><p>但有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。</p><p>如果是我们手动操作，一般情况下，一秒钟只能点击一次秒杀按钮。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205554568.png" alt="image-20240618205554568"></p><p>但是如果是服务器，一秒钟可以请求成上千接口。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205609980.png" alt="image-20240618205609980"></p><p>这种差距实在太明显了，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。</p><p>所以，我们有必要识别这些非法请求，做一些限制。那么，我们该如何现在这些非法请求呢？</p><p>目前有两种常用的限流方式：</p><ol><li>基于nginx限流</li><li>基于redis限流</li></ol><h2 id="对同一用户限流"><a href="#对同一用户限流" class="headerlink" title="对同一用户限流"></a>对同一用户限流</h2><p>为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205710985.png" alt="image-20240618205710985"></p><p>限制同一个用户id，比如每分钟只能请求5次接口。</p><h2 id="对同一ip限流"><a href="#对同一ip限流" class="headerlink" title="对同一ip限流"></a>对同一ip限流</h2><p>有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。</p><p>这时需要加同一ip限流功能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618205822876.png" alt="image-20240618205822876"></p><p>限制同一个ip，比如每分钟只能请求5次接口。</p><p>但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。</p><h2 id="对接口限流"><a href="#对接口限流" class="headerlink" title="对接口限流"></a>对接口限流</h2><p>别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。</p><p>这时可以限制请求的接口总次数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618210012653.png" alt="image-20240618210012653"></p><p>在高并发场景下，这种限制对于系统的稳定性是非常有必要的。但可能由于有些非法请求次数太多，达到了该接口的请求上限，而影响其他的正常用户访问该接口。看起来有点得不偿失。</p><h2 id="加入验证码"><a href="#加入验证码" class="headerlink" title="加入验证码"></a>加入验证码</h2><p>相对于上面三种方式，加验证码的方式可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240618210111861.png" alt="image-20240618210111861"></p><p>通常情况下，用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。</p><p>此外，验证码一般是一次性的，同一个验证码只允许使用一次，不允许重复使用。</p><p>普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。</p><p>还有一个验证码叫做：<code>移动滑块</code>，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选。</p><h2 id="提高业务门槛"><a href="#提高业务门槛" class="headerlink" title="提高业务门槛"></a>提高业务门槛</h2><p>上面说的加验证码虽然可以限制非法用户请求，但是有些影响用户体验。用户点击秒杀按钮前，还要先输入验证码，流程显得有点繁琐，秒杀功能的流程不是应该越简单越好吗？</p><p>其实，有时候达到某个目的，不一定非要通过技术手段，通过业务手段也一样。</p><p>12306刚开始的时候，全国人民都在同一时刻抢火车票，由于并发量太大，系统经常挂。后来，重构优化之后，将购买周期放长了，可以提前20天购买火车票，并且可以在9点、10、11点、12点等整点购买火车票。调整业务之后（当然技术也有很多调整），将之前集中的请求，分散开了，一下子降低了用户并发量。</p><p>回到这里，我们通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。</p><p>这样简单的提高一点门槛，即使是黄牛党也束手无策，他们总不可能为了参加一次秒杀活动，还另外花钱充值会员吧？</p><h1 id="面试中的常见问题"><a href="#面试中的常见问题" class="headerlink" title="面试中的常见问题"></a>面试中的常见问题</h1><ul><li>“应该在什么时候扣除库存，是下单后扣除库存还是支付后扣除库存呢？为什么？”</li></ul><blockquote><p>应该在下单的时候扣除库存，如果在支付成功再扣除库存的话会出现下单请求成功数量大于库存的情况。</p></blockquote><ul><li>“对秒杀商品进行分库分表之后可能导致某个分表库存为零，但其他分表还有库存，如何解决这个问题？”</li></ul><blockquote><p>“有三种解决方案：</p><ul><li>如果当前分表没有库存的话，到其他分表进行重试，缺点是会放大流量。</li><li>通过路由组件记录每个分表的库存情况，将下单请求转发到有库存的分表中。</li><li>使用分布式缓存记录每个分表的库存情况，并且每次下单请求只更新缓存，缓存后续再更新到数据库中，缺点是可能出现缓存和数据库不一致的问题。”</li></ul></blockquote><ul><li>“客户下单后可能支付超时并释放库存，这时候有哪些要注意的？”</li></ul><blockquote><p>“服务器能够通知限流器以及前端库存发生变化，限流器能够重新接收请求，前端页面显示可下单的页面，确保后续的用户能继续购买商品。”</p></blockquote><ul><li>“消息队列方案有什么潜在问题吗？”</li></ul><blockquote><p>“秒杀系统下，可能 80% 的流量都指向同一个热门商品，那么消息队列中的分区会特别大，影响了两个方面：</p><ol><li><p>消息队列本身的稳定性，吞吐量会受单个分区限制，也可能影响其他业务。</p></li><li><p>下单请求受到消费者消费能力的限制，即使消息队列每秒可以处理大量消息，但是数据库每秒处理的数量有限。可以使用以下几种方案：</p><ul><li><p>压力测试：在前期压力测试的时候，模拟流量极端分布的情况，确保现有架构能够支持服务。</p></li><li><p>资源隔离：对秒杀商品使用独立的消息队列，使用特殊的流量限流策略，配置更好的资源。</p></li><li><p>合并下单请求：将多个下单请求合并成一个请求，再交给数据库处理。不过在实际工程中，下单业务可能比较复杂，不只包含扣减库存。所以合并逻辑会影响后续业务的可扩展性。</p></li><li><p>合并事务：将多个事务合并成一个事务执行，这样能有效减少数据库压力，缺点是逻辑会比较复杂，而且一个事务执行失败会影响多个订单。</p></li></ul></li></ol></blockquote><p>“消息队列怎么保证消息有且仅生效一次（Exactly Once）？”</p><blockquote><ul><li>为了保证最少一次生效, 消费者需要下单成功后才能返回确认 ACK，否则有可能会丢失消息。</li><li>为了防止消息重复消费的问题，需要使下单逻辑变为幂等操作，常见的解决方案是保证下单请求有全局唯一的 ID，并在消息队列中对 ID 进行持久化，在发送给消费者之前先检查 ID 是否已经消费过。要注意中间层的重试机制不要修改这个全局唯一的 ID，不然会导致消息队列误以为该消息没有消费过。</li></ul></blockquote><p>“分布式锁和数据库悲观锁相比有什么优势？有什么共同的缺点？”</p><blockquote><ul><li>优点：加锁的操作不依赖数据库，降低数据库资源冲突的概率和压力。</li><li>共同缺点：可扩展性差，对于单个商品都是串行操作，假如每个订单执行要 100ms，每秒只能执行 10 个对应的订单，可能会出现大量请求阻塞的情况。</li></ul></blockquote><p>“如果电商系统流量过大，如何进行降级服务？”</p><blockquote><ul><li>暂停非核心业务：例如淘宝在双十一会暂时关闭退款功能。</li><li>拒绝服务：当系统压力到达一个阈值的的时候，随机丢弃部分秒杀请求。</li><li>减少重试：将重试次数降低甚至设置为0，否则容易造成雪崩效应，系统陷入负反馈循环，无法正常恢复。</li></ul></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于秒杀系统的设计，方法有很多种，本文中也就只介绍了很少的一部分。在架构方面还有更都需要去学习的，需要考虑的因素很多，二八原则、流量削峰等等都是很有趣的内容，当然在本文中也有提到过一些相关的设计。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F</a></p><p><a href="https://github.com/resumejob/How-to-design-a-spike-system?tab=readme-ov-file">https://github.com/resumejob/How-to-design-a-spike-system?tab=readme-ov-file</a></p><p><a href="https://juejin.cn/post/6990307911117307934">https://juejin.cn/post/6990307911117307934</a></p><p><a href="https://xie.infoq.cn/article/3b5c445bb62a5ca425489c08a">https://xie.infoq.cn/article/3b5c445bb62a5ca425489c08a</a></p><p><a href="https://gongfukangee.github.io/2019/06/09/SecondsKill/">https://gongfukangee.github.io/2019/06/09/SecondsKill/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;秒杀活动是指网络商家为促销等目的组织或网上限时抢购活动，这种活动具有瞬时并发量大、库存量少和业务逻辑简单等特点。设计一个秒杀系统需要考虑的因素很多，比如对现有业务的影响、网络带宽消耗以及超卖等因素。&lt;/p&gt;
&lt;p&gt;选择学习这部分内容主要是因为秒杀、抽奖这些实际开发中会遇到的</summary>
      
    
    
    
    <category term="技术剖析" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis高可用宝典：三招搞定你的数据堡垒</title>
    <link href="http://example.com/2024/06/13/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9D%E5%85%B8%EF%BC%9A%E4%B8%89%E6%8B%9B%E6%90%9E%E5%AE%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A0%A1%E5%9E%92/"/>
    <id>http://example.com/2024/06/13/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9D%E5%85%B8%EF%BC%9A%E4%B8%89%E6%8B%9B%E6%90%9E%E5%AE%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A0%A1%E5%9E%92/</id>
    <published>2024-06-13T11:10:16.000Z</published>
    <updated>2024-06-13T13:36:22.580Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发通常会提到一个名词 “三高”，即高并发、高性能、高可用。</p><p>具体的指标定义，如：高并发方面要求QPS 大于 10万；高性能方面要求请求延迟小于 100 ms；高可用方面要高于 99.99%。</p><p>在前面学习 Redis 时，我们也可以看出 Redis 已经实现了前两个“高”。今天，我们就来看一下 Redis 是否实现了第三个“高”——高可用。</p><h1 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h1><p>高可用(High Availability,即HA)，指的是通过尽量缩短日常维护操作和突发的系统崩溃所导致的停机时间，以提高系统和应用的可用性。一个业务系统如果全年无一时刻不在提供服务，它的可用性可达100%。那么什么样的系统可以称之为高可用呢，业界一般用几个九来衡量系统的可用性，当系统运行时间达到4个九即99.99%时的系统为高可用的，全年宕机时间为52分钟左右。</p><p> 高可用一般来说有两个含义：一是数据尽量不丢失，二是保证服务尽可能可用。 AOF 和 RDB 数据持久化保证了数据尽量不丢失，而多节点来保证服务尽可能提供服务。单个节点的系统缺点明显，一旦发生故障会导致服务不可用。而且，单个节点处理所有的请求，吞吐量有限，容量也有限。</p><p>关于数据持久化，前面已经聊过了，今天要看的就是 Redis 如何保证服务尽可能可用。</p><p>Redis 高可用的手段主要有以下三种：</p><ul><li>主从数据同步（主从复制）</li><li>Redis 哨兵模式（Sentinel）</li><li>Redis 集群（Cluster）</li></ul><p>主从数据同步可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换至另一台服务器以继续提供服务；哨兵模式用于发生故障之后自动切换服务器；而 Redis 集群提供了多主多从的 Redis 分布式集群环境，用于提供性能更好的 Redis 服务，并且它自身拥有故障自动切换的能力。</p><h1 id="主从复制-老少皆宜的经典菜"><a href="#主从复制-老少皆宜的经典菜" class="headerlink" title="主从复制 - 老少皆宜的经典菜"></a>主从复制 - 老少皆宜的经典菜</h1><p>主从复制（Master-Slave Replication）像是一道经典菜式，简单易懂，老少皆宜。主库写数据，从库读数据，轻松实现读写分离。</p><blockquote><p>主从复制，是指将一台 Redis 服务器的数据复制到其他的 Redis 服务器。前者成为<strong>主节点(master)</strong>，后者成为<strong>从节点(slave)</strong>；数据的复制是单向的，只能由主节点到从节点。</p><p>主从模式实现读写分离，只有master节点提供数据的事务性操作（增删改），slave节点只提供读操作。所有slave节点的数据都是从master节点同步过来的，该模式的结构图如下：</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-1.png" alt="img"></p><p><strong>主从复制的作用</strong>主要包括：</p><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="主从复制策略"><a href="#主从复制策略" class="headerlink" title="主从复制策略"></a>主从复制策略</h2><blockquote><p>注意：在2.8版本之前只有全量复制，而2.8版本后有全量和增量复制：</p></blockquote><ul><li><code>全量（同步）复制</code>：比如第一次同步时</li><li><code>增量（同步）复制</code>：只会把主从库网络断连期间主库收到的命令，同步给从库</li></ul><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><blockquote><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p></blockquote><p><strong>全量复制的三个阶段</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-2.jpg" alt="img"></p><p><strong>第一个阶段是主从库建立连接、协商同步的过程，</strong>主要是为全量复制做准备/在这一步，从库和主库建立其连接，并告诉主库即将进行同步，主库确认回复后，主从库就可以开始同步了。</p><p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。<strong>runID</strong>，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。<strong>offset</strong>，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，<strong>FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库</strong>。</p><p><strong>第二阶段，主库将所有数据同步到从库</strong>。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p><p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。<strong>为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</strong></p><p><strong>第三阶段，主库会把第二阶段执行过程中新收到的写命令再发送给从库</strong>。</p><p>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><blockquote><p>在 Redis 2.8 版本引入了增量复制。</p></blockquote><p><strong>为什么要设计增量复制？</strong></p><p>如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。</p><p><strong>增量复制的流程</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-3.jpg" alt="img"></p><p>先看两个概念： <code>replication buffer</code> 和 <code>repl_backlog_buffer</code></p><p><code>repl_backlog_buffer</code>：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以<strong>repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率</strong>。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。</p><p><code>replication buffer</code>：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。</p><p><strong>如果在网络断开期间，repl_backlog_size环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢</strong>？</p><p>对于这个问题来说，有两个关键点：</p><ol><li>一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。</li><li>每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。</li></ol><h2 id="更加深入"><a href="#更加深入" class="headerlink" title="更加深入"></a>更加深入</h2><blockquote><p>我们通过几个问题来深入理解主从复制。</p></blockquote><h3 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h3><blockquote><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</p></blockquote><p><strong>为什么不持久化的主服务器自动重启非常危险呢</strong>？为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了。</p><ul><li>我们设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</li><li>这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</li><li>节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。</li><li>当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</li></ul><p>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p><h3 id="为什么主从全量复制使用RDB而不使用AOF？"><a href="#为什么主从全量复制使用RDB而不使用AOF？" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF？"></a>为什么主从全量复制使用RDB而不使用AOF？</h3><ol><li><p>RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。</p></li><li><p>假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。</p></li></ol><h3 id="为什么还有无磁盘复制模式？"><a href="#为什么还有无磁盘复制模式？" class="headerlink" title="为什么还有无磁盘复制模式？"></a>为什么还有无磁盘复制模式？</h3><p>Redis 默认是磁盘复制，但是<strong>如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力</strong>。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。</p><p><strong>无磁盘复制模式</strong>：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。</p><p>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><p>使用<code>repl-diskless-sync-delay</code> 参数来配置传输开始的延迟时间；master等待一个<code>repl-diskless-sync-delay</code>的秒数，如果没slave来的话，就直接传，后来的得排队等了; 否则就可以一起传。</p><h3 id="主从级联模式分担全量复制时的主库压力"><a href="#主从级联模式分担全量复制时的主库压力" class="headerlink" title="主从级联模式分担全量复制时的主库压力"></a>主从级联模式分担全量复制时的主库压力</h3><p>通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。</p><p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。那么，有没有好的解决方法可以分担主库压力呢？</p><p>其实是有的，这就是“主 - 从 - 从”模式。</p><p>在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，我们可以通过“主 - 从 - 从”模式<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。</p><p>简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 所选从库的IP 6379</span><br></pre></td></tr></table></figure><p>这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-copy-4.jpg" alt="img"></p><p>级联的“主-从-从”模式好了，到这里，我们了解了主从库间通过全量复制实现数据同步的过程，以及通过“主 - 从 - 从”模式分担主库压力的方式。那么，一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</p><h3 id="读写分离及其中的问题"><a href="#读写分离及其中的问题" class="headerlink" title="读写分离及其中的问题"></a>读写分离及其中的问题</h3><p>在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。下面介绍在使用Redis读写分离时，需要注意的问题。</p><ul><li><strong>延迟与不一致问题</strong></li></ul><p>前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。</p><p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的slave-serve-stale-data参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。</p><ul><li><strong>数据过期问题</strong></li></ul><p>在单机版Redis中，存在两种删除策略：</p><ul><li><code>惰性删除</code>：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li><li><code>定期删除</code>：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li></ul><p>在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p><p>Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p><ul><li><strong>故障切换问题</strong></li></ul><p>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ol><li>配置简单，易于实现。</li><li>实现数据冗余，提高数据可靠性。</li><li>读写分离，提高系统性能。</li></ol><p><strong>缺点</strong>：</p><ol><li>主节点故障时，需要手动切换到从节点，故障恢复时间较长。</li><li>主节点承担所有写操作，可能成为性能瓶颈。</li><li>无法实现数据分片，受单节点内存限制。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主从复制模式适用于以下场景：</p><ol><li>数据备份和容灾恢复：通过从节点备份主节点的数据，实现数据冗余。</li><li>读写分离：将读操作分发到从节点，减轻主节点压力，提高系统性能。</li><li>在线升级和扩展：在不影响主节点的情况下，通过增加从节点来扩展系统的读取能力。</li></ol><h1 id="哨兵模式-忠诚的侍卫队"><a href="#哨兵模式-忠诚的侍卫队" class="headerlink" title="哨兵模式 - 忠诚的侍卫队"></a>哨兵模式 - 忠诚的侍卫队</h1><p>Redis哨兵模式（Sentinel）就像是一队忠诚的侍卫，时刻守护着你的Redis主从结构。它们监控主库的健康状态，一旦主库挂了，马上选出一个新的主库，确保服务不间断。</p><blockquote><p>Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-1.png" alt="img"></p><p>哨兵实现了什么功能呢？下面是Redis官方文档的描述：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h2 id="哨兵集群的组件"><a href="#哨兵集群的组件" class="headerlink" title="哨兵集群的组件"></a>哨兵集群的组件</h2><blockquote><p>上图中哨兵集群是如何组件的呢？哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。</p></blockquote><p>在主从集群中，主库上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到<code>__sentinel__:hello</code>频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-6.jpg" alt="img"></p><p>通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。</p><h2 id="哨兵监控-Redis-库"><a href="#哨兵监控-Redis-库" class="headerlink" title="哨兵监控 Redis 库"></a>哨兵监控 Redis 库</h2><blockquote><p>哨兵监控什么呢？怎么监控呢？</p></blockquote><p>这是由哨兵向主库发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-7.jpg" alt="img"></p><h2 id="主库下线的判定"><a href="#主库下线的判定" class="headerlink" title="主库下线的判定"></a>主库下线的判定</h2><blockquote><p>哨兵如何判断主库已经下线了呢？</p></blockquote><p>首先要理解两个概念：<strong>主观下线</strong>和<strong>客观下线</strong></p><ul><li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；</li></ul><p>当某个哨兵（如下图中的哨兵2）判断主库“主观下线”后，就会给其他哨兵发送 <code>is-master-down-by-addr</code> 命令。接着，其他哨兵会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-2.jpg" alt="img"></p><p>如果赞成票数（这里是2）是大于等于哨兵配置文件中的 <code>quorum</code> 配置项（比如这里如果是quorum=2）, 则可以判定<strong>主库客观下线</strong>了。</p><h2 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h2><blockquote><p>判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。</p></blockquote><p><strong>为什么必然会出现选举/共识机制？</strong></p><p>为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。</p><p><strong>哨兵的选举机制是什么样的？</strong></p><p>哨兵的选举机制其实很简单，就是一个Raft选举算法： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong>。</p><ul><li>任何一个想成为 Leader 的哨兵，要满足两个条件： <ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul></li></ul><p>需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。这一点很重要，你在实际应用时可不能忽略了。</p><blockquote><p>更进一步理解</p><p>这里很多人会搞混 <strong>判定客观下线</strong> 和 <strong>是否能够主从切换（用到选举机制）</strong> 两个概念，我们再看一个例子。</p><p>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？</p><p>经过实际测试：</p><p>1、哨兵集群可以判定主库“主观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，<strong>哨兵集群可以判定主库为“客观下线”</strong>。</p><p>2、<strong>但哨兵不能完成主从切换</strong>。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到<code>N/2+1</code>选票的结果。</p></blockquote><h2 id="选举新主库"><a href="#选举新主库" class="headerlink" title="选举新主库"></a>选举新主库</h2><blockquote><p>主库既然判定客观下线了，那么如何从剩余的从库中选择一个新的主库呢？</p></blockquote><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-3.jpg" alt="img"></p><h2 id="故障的转移"><a href="#故障的转移" class="headerlink" title="故障的转移"></a>故障的转移</h2><blockquote><p>新的主库选择出来后，就可以开始进行故障的转移了。</p></blockquote><p>假设根据我们一开始的图：（我们假设：判断主库客观下线了，同时选出<code>sentinel 3</code>是哨兵leader）</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240613201758671.png" alt="image-20240613201758671"></p><p><strong>故障转移流程如下</strong>：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-4.png" alt="img"></p><ul><li>将slave-1脱离原从节点（PS: 5.0 中应该是<code>replicaof no one</code>)，升级主节点，</li><li>将从节点slave-2指向新的主节点</li><li>通知客户端主节点已更换</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点</li></ul><p><strong>转移之后</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-sen-5.png" alt="img"></p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ol><li>自动故障转移，提高系统的高可用性。</li><li>具有主从复制模式的所有优点，如数据冗余和读写分离。</li></ol><p><strong>缺点</strong>：</p><ol><li>配置和管理相对复杂。</li><li>依然无法实现数据分片，受单节点内存限制。</li></ol><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>哨兵模式适用于以下场景：</p><ol><li>高可用性要求较高的场景：通过自动故障转移，确保服务的持续可用。</li><li>数据备份和容灾恢复：在主从复制的基础上，提供自动故障转移功能。</li></ol><h1 id="集群模式-坚不可摧的堡垒"><a href="#集群模式-坚不可摧的堡垒" class="headerlink" title="集群模式 - 坚不可摧的堡垒"></a>集群模式 - 坚不可摧的堡垒</h1><p>Redis集群模式（Cluster）像是一座坚不可摧的堡垒，分片存储数据，每个节点都是独立的守卫，即使其中一个倒下，其余的仍能坚守阵地。</p><p>当我们保存大量数据，单机的吞吐无法承受持续扩增的流量的时候，最好的办法是从横向（scale out） 和 纵向（scale up）两方面进行扩展。</p><ul><li>纵向扩展（scale up）：将单个实例的硬件资源做提升，比如 CPU核数量、内存容量、SSD容量。</li><li>横向扩展（scale out）：横向扩增 Redis 实例数，这样每个节点只负责一部分数据就可以，分担一下压力，典型的分治思维。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723113011412-1229895745.png" alt="image"></p><p>那横向扩展和纵向扩展各有什么优缺点呢？</p><ul><li>scale up 虽然操作起来比较简易。但是没法解决Redis一些瓶颈问题，比如持久化（如轮式RDB快照还是AOF指令），遇到大数据量的时候，照样效率会很低，响应慢。另外，单台服务机硬件扩容也是有限制的，不可能无限操作。</li><li>scale out 更容易扩展，分片的模式可以解决很多问题，包括单一实例节点的硬件扩容限制、成本限制，还可以分摊压力，精细化治理，精细化维护。但是同时也要面临分布式带来的一些问题</li></ul><p>现实情况下，在面对千万级甚至亿级别的流量的时候，很多大厂都是在千百台的实例节点组成的集群上进行流量调度、服务治理的。所以，使用Cluster模式，是业内广泛采用的模式。</p><h2 id="什么是Cluster模式？"><a href="#什么是Cluster模式？" class="headerlink" title="什么是Cluster模式？"></a>什么是Cluster模式？</h2><p>Cluster 即 集群模式，类似MySQL，Redis 集群也是一种分布式数据库方案，集群通过分片（sharding）模式来对数据进行管理，并具备分片间数据复制、故障转移和流量调度的能力。</p><p>Redis集群的做法是 将数据划分为 16384（2的14次方）个哈希槽（slots），如果你有多个实例节点，那么每个实例节点将管理其中一部分的槽位，槽位的信息会存储在各自所归属的节点中。以下图为例，该集群有4个 Redis 节点，每个节点负责集群中的一部分数据，数据量可以不均匀。比如性能好的实例节点可以多分担一些压力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723162102412-2114027779.png" alt="image"></p><p>一个Redis集群一共有16384个哈希槽，你可以有1 ~ n个节点来分配这些哈希槽，可以不均匀分配，每个节点可以处理0个 到至多 16384 个槽点。<br>当16384个哈希槽都有节点进行管理的时候，集群处于online 状态。同样的，如果有一个哈希槽没有被管理到，那么集群处于offline状态。</p><p>上面图中4个实例节点组成了一个集群，集群之间的信息通过 <a href="https://www.jianshu.com/p/37231c0455a9?u_atoken=8f004d09-69b0-426f-b061-eb2beec366bd&amp;u_asession=01kPy2LmGTRcCRkywzTBYEHCkosMcq1sc9kA_QMxQzS0laSORdnXM_dgnvDG1wTbw8X0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K-N03wKh1fGpdgnBALMXOj6nHmbkqVcEgdObpAroqY1_GBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05mlGEb2mTIXVShMltoDiqa8mmSULaVgG2oC6fDPX8mGfiV1LZT1wLbYW94ZRRUgNN2m30YJvBI8QN0vcGpawzqQ56Wvq9ANJ8evvyrzij6204SAUiczKrC3sz7bqPpXbYaozWZDEauebiZYp_CIfFOT2ReLQHIkgXR5cKZYDZCf_9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzRlYRaI5LXI74XoQdbRrBZ3vA9ftOKk0zloJSVmQmIfB6xbSxAaWh9ph0bRUFW-6vO3h9VXwMyh6PgyDIVSG1W_7c_dy_6Dl1wgLC3Whv7tuy_Ck9NIynL3sfTheEXzY-rYacisV-aUEZiNNy5yxHlkwafvmAr9jpurPBo8emYF2mWspDxyAEEo4kbsryBKb9Q&amp;u_aref=tGICtqx3upDt17e1WtJxSOZFJWU%3D">Gossip协议</a> 进行交互，这样就可以在某一节点记录其他节点的哈希槽（slots）的分配情况。</p><h2 id="Cluster-实现原理"><a href="#Cluster-实现原理" class="headerlink" title="Cluster 实现原理"></a>Cluster 实现原理</h2><h3 id="集群的组群过程"><a href="#集群的组群过程" class="headerlink" title="集群的组群过程"></a>集群的组群过程</h3><p>集群是由一个个互相独立的节点（readis node）组成的， 所以刚开始的时候，他们都是隔离，毫无联系的。我们需要通过一些操作，把他们聚集在一起，最终才能组成真正的可协调工作的集群。<br>各个节点的联通是通过 CLUSTER MEET 命令完成的：<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 。<br>具体的做法是其中一个node向另外一个 node（指定 ip 和 port） 发送 CLUSTER MEET 命令，这样就可以让两个节点进行握手（handshake操作） ，握手成功之后，node 节点就会将握手另一侧的节点添加到当前节点所在的集群中。<br>这样一步步的将需要聚集的节点都圈入同一个集群中，如下图：<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723160118701-1673167327.png" alt="image"></p><h3 id="集群数据分片原理"><a href="#集群数据分片原理" class="headerlink" title="集群数据分片原理"></a>集群数据分片原理</h3><p>现在的Redis集群分片的做法，主要是使用了官方提供的 Redis Cluster 方案。这种方案就是的核心就是集群的实例节点与哈希槽（slots）之间的划分、映射与管理。下面我们来看看他具体的步骤。</p><p><strong>哈希槽（slots）的划分</strong></p><p>这个前面已经说过了，我们会将整个Redis数据库划分为16384个哈希槽，你的Redis集群可能有n个实例节点，每个节点可以处理0个 到至多 16384 个槽点，这些节点把 16384个槽位瓜分完成。<br>而你实际存储的Redis键值信息也必然归属于这 16384 个槽的其中一个。slots 与 Redis Key 的映射是通过以下两个步骤完成的：</p><ul><li>使用 CRC16 算法计算键值对信息的Key，会得出一个 16 bit 的值。</li><li>将 第1步中得到的 16 bit 的值对 16384 取模，得到的值会在 0 ～ 16383 之间，映射到对应到哈希槽中。<br>当然，可能在一些特殊的情况下，你想把某些key固定到某个slot上面，也就是同一个实例节点上。这时候可以用hash tag能力，强制 key 所归属的槽位等于 tag 所在的槽位。<br>其实现方式为在key中加个{}，例如test_key{1}。使用hash tag后客户端在计算key的crc16时，只计算{}中数据。如果没使用hash tag，客户端会对整个key进行crc16计算。下面演示下hash tag使用:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">127.0.0.1:6380&gt;</span> cluster keyslot <span class="symbol">user:</span><span class="keyword">case</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">(integer) <span class="number">1024</span></span><br><span class="line"><span class="meta prompt_">127.0.0.1:6380&gt;</span> cluster keyslot <span class="symbol">user:</span>favor</span><br><span class="line">(integer) <span class="number">1023</span></span><br><span class="line"><span class="meta prompt_">127.0.0.1:6380&gt;</span> cluster keyslot <span class="symbol">user:</span>info&#123;<span class="number">1</span>&#125;</span><br><span class="line">(integer) <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>如上，使用hash tag 后会对应到通一个hash slot：1024中。</p><p><strong>哈希槽（slots）的映射</strong></p><p>一种是初始化的时候均匀分配 ，使用 cluster create 创建，会将 16384 个slots 平均分配在我们的集群实例上，比如你有n个节点，那每个节点的槽位就是 16384 / n 个了 。<br>另一种是通过 CLUSTER MEET 命令将 node1、node2、ndoe3、node4 4个节点联通成一个集群，刚联通的时候因为还没分配哈希槽，还是处于offline状态。我们使用 <code>cluster addslots</code> 命令来指定。<br>指定的好处就是性能好的实例节点可以多分担一些压力。</p><p>可以通过 addslots 命令指定哈希槽范围，比如下图中，我们哈希槽是这么分配的：实例 1 管理 0 ～ 7120 哈希槽，实例 2 管理 7121~9945 哈希槽，实例 3 管理 9946 ～ 13005 哈希槽，实例 4 管理 13006 ～ 16383 哈希槽。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">0</span><span class="string">,7120</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">7121</span><span class="string">,9945</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">9946</span><span class="string">,13005</span></span><br><span class="line"><span class="string">redis-cli</span> <span class="string">-h</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span> <span class="string">–p</span> <span class="number">6379 </span><span class="string">cluster</span> <span class="string">addslots</span> <span class="number">13006</span><span class="string">,16383</span></span><br></pre></td></tr></table></figure><p>slots 和 Redis 实例之间的映射关系如下：<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220723163103375-2028951983.png" alt="image"></p><p>key <code>testkey_1</code> 和 <code>testkey_2</code> 经过 CRC16 计算后再对slots的总个数 16384 取模，结果分别匹配到了 cache1 和 cache3 上。</p><h3 id="数据复制过程和故障转移"><a href="#数据复制过程和故障转移" class="headerlink" title="数据复制过程和故障转移"></a>数据复制过程和故障转移</h3><p><strong>数据复制</strong></p><p>Cluster 是具备Master 和 Slave模式，Redis 集群中的每个实例节点都负责一些槽位，比如上图中的四个节点分管了不同的槽位区间。而每个Master至少需要一个Slave节点，Slave 节点是通过主从复制方式同步主节点数据。 节点之间保持TCP通信，当Master发生了宕机，Redis Cluster自动会将对应的Slave节点选为Master，来继续提供服务。与纯主从模式不同的是，主从节点之间并没有读写分离， Slave 只用作 Master 宕机的高可用备份，所以更合理来说应该是主备模式。</p><p>如果主节点没有从节点，那么一旦发生故障时，集群将完全处于不可用状态。 但也允许配置 <code>cluster-require-full-coverage</code>参数，及时部分节点不可用，其他节点正常提供服务，这是为了避免全盘宕机。</p><p>主从切换之后，故障恢复的主节点，会转化成新主节点的从节点。这种自愈模式对提高可用性非常有帮助。</p><p><strong>故障检测</strong></p><p>一个节点认为某个节点宕机不能说明这个节点真的挂起了，无法提供服务了。只有占据多数的实例节点都认为某个节点挂起了，这时候cluster才进行下线和主从切换的工作。</p><p>Redis 集群的节点采用 Gossip 协议来广播信息，每个节点都会定期向其他节点发送ping命令，如果接受 ping 消息的节点在指定时间内没有回复 pong，则会认为该节点失联了（PFail），则发送 ping 的节点就把接受 ping 的节点标记为主观下线。</p><p>如果集群半数以上的主节点都将主节点 xxx 标记为主观下线，则节点 xxx 将被标记为客观下线，然后向整个集群广播，让其它节点也知道该节点已经下线，并立即对下线的节点进行主从切换。</p><p><strong>主从故障转移</strong></p><p>当一个从节点发现自己正在复制的主节点进入了已下线，则开始对下线主节点进行故障转移，故障转移的步骤如下：</p><ul><li>如果只有一个slave节点，则从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>如果是多个slave节点，则采用选举模式进行，竞选出新的Master<ul><li>集群中设立一个自增计数器，初始值为 0 ，每次执行故障转移选举，计数就会+1。</li><li>检测到主节点下线的从节点向集群所有master广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，所有收到消息、并具备投票权的主节点都向这个从节点投票。</li><li>如果收到消息、并具备投票权的主节点未投票给其他从节点（只能投一票哦，所以投过了不行），则返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示支持。</li><li>参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，如果收集到的选票 大于等于 (n/2) + 1 支持，n代表所有具备选举权的master，那么这个从节点就被选举为新主节点。</li><li>如果这一轮从节点都没能争取到足够多的票数，则发起再一轮选举（自增计数器+1），直至选出新的master。</li></ul></li><li>新的主节点会撤销所有对已下线主节点的slots指派，并将这些slots全部指派给自己。</li><li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ul><p>跟哨兵类似，两者都是基于 Raft 算法来实现的，流程如图所示：<br><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/167509-20220730150510040-589928276.png" alt="image"></p><h2 id="client-访问数据集群的过程"><a href="#client-访问数据集群的过程" class="headerlink" title="client 访问数据集群的过程"></a>client 访问数据集群的过程</h2><blockquote><p>Redis cluster采用去中心化的架构，集群的主节点各自负责一部分槽，客户端如何确定key到底会映射到哪个节点上呢？这就是我们要讲的请求重定向。</p></blockquote><p>在cluster模式下，<strong>节点对请求的处理过程</strong>如下：</p><ul><li>检查当前key是否存在当前NODE？ <ul><li>通过crc16（key）/16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果</li><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？</li><li>若key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若Slot未迁出，检查Slot是否导入中？</li><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul><p>这个过程中有两点需要具体理解下： <strong>MOVED重定向</strong> 和 <strong>ASK重定向</strong>。</p><h3 id="Moved-重定向"><a href="#Moved-重定向" class="headerlink" title="Moved 重定向"></a>Moved 重定向</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-3.png" alt="img"></p><ul><li>槽命中：直接返回结果</li><li>槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个Moved 重定向，客户端根据Moved 重定向所包含的内容找到目标节点，再一次发送命令。</li></ul><h3 id="ASK-重定向"><a href="#ASK-重定向" class="headerlink" title="ASK 重定向"></a>ASK 重定向</h3><p>Ask重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据可能已经迁移到了目标节点，使用Ask重定向来解决此种情况。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-5.png" alt="img"></p><h3 id="smart客户端"><a href="#smart客户端" class="headerlink" title="smart客户端"></a>smart客户端</h3><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来<strong>减低复杂性，追求更好的性能</strong>。客户端内部负责计算/维护键-&gt; 槽 -&gt; 节点映射，用于快速定位目标节点。</p><p>实现原理：</p><ul><li>从集群中选取一个可运行节点，使用 cluster slots得到槽和节点的映射关系</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-6.png" alt="img"></p><ul><li>将上述映射关系存到本地，通过映射关系就可以直接对目标节点进行操作（CRC16(key) -&gt; slot -&gt; node），很好地避免了Moved重定向，并为每个节点创建JedisPool</li><li>至此就可以用来进行命令操作</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cluster-7.png" alt="img"></p><h2 id="更加深入-1"><a href="#更加深入-1" class="headerlink" title="更加深入"></a>更加深入</h2><h3 id="为什么Redis-Cluster的Hash-Slot-是16384？"><a href="#为什么Redis-Cluster的Hash-Slot-是16384？" class="headerlink" title="为什么Redis Cluster的Hash Slot 是16384？"></a>为什么Redis Cluster的Hash Slot 是16384？</h3><p>我们知道一致性hash算法是2的16次方，为什么hash slot是2的14次方呢？</p><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 <em> 8 (8 bit) </em> 1024(1k) = 16K），也就是说使用2k的空间创建了16k的槽数。</p><p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（8 <em> 8 (8 bit) </em> 1024(1k) =65K），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。</p><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢？"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢？" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢？"></a>为什么Redis Cluster中不建议使用发布订阅呢？</h3><p>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会严重消耗带宽，不建议使用。（虽然官网上讲有时候可以使用Bloom过滤器或其他算法进行优化的）</p><h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ol><li>数据分片，实现大规模数据存储。</li><li>负载均衡，提高系统性能。</li><li>自动故障转移，提高高可用性。</li></ol><p><strong>缺点</strong>：</p><ol><li>配置和管理较复杂。</li><li>一些复杂的多键操作可能受到限制。</li></ol><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>Cluster模式适用于以下场景：</p><ol><li>大规模数据存储：通过数据分片，突破单节点内存限制。</li><li>高性能要求场景：通过负载均衡，提高系统性能。</li><li>高可用性要求场景：通过自动故障转移，确保服务的持续可用。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了Redis的三大集群模式：主从复制、哨兵模式和Cluster模式。每种模式都有其特点和应用场景，具体如下：</p><ol><li><strong>主从复制模式</strong>：适用于数据备份和读写分离场景，配置简单，但在主节点故障时需要手动切换。</li><li><strong>哨兵模式</strong>：在主从复制的基础上实现自动故障转移，提高高可用性，适用于高可用性要求较高的场景。</li><li><strong>Cluster模式</strong>：通过数据分片和负载均衡实现大规模数据存储和高性能，适用于大规模数据存储和高性能要求场景。</li></ol><p>在实际应用中，可以根据系统的需求和特点选择合适的Redis集群模式，以实现高可用性、高性能和大规模数据存储。</p><blockquote><p>碎碎念阶段：</p><p>今天是个好日子，虽然天气不是很好，但最起码我出门的时候天气一直都还不错。拍了张无敌的照片，就放做本文的封面吧。</p><p>今天有参加了一个面试，不太明白为什么会出现这种情况，就问了一个技术相关的问题，答的不是很好，感觉永远都想不到面试官会问什么问题。字节今天下午约了下周二的面试，应该是要到实习时间了，被别人鸽了。不知道那一场面试有会以什么问题结束我的大厂梦呢。感觉面试都快PTSD了，一想到面试就开始心慌。祝我好运吧，毕竟之前高考后我的运气就变得好了一点。希望今年也能这样吧。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6997944007812710414">https://juejin.cn/post/6997944007812710414</a></li><li><a href="https://www.cnblogs.com/yangyixin/p/17436853.html">https://www.cnblogs.com/yangyixin/p/17436853.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html</a></li><li><a href="https://www.cnblogs.com/wzh2010/p/15886799.html">https://www.cnblogs.com/wzh2010/p/15886799.html</a></li><li><a href="https://www.cnblogs.com/yidengjiagou/p/17345831.html">https://www.cnblogs.com/yidengjiagou/p/17345831.html</a></li></ul><p>实际操作方面可以看下面的文章</p><ul><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/36%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/36%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/37%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/37%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/38%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/38%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/39%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/39%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8a%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/40%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/40%20%e5%ae%9e%e6%88%98%ef%bc%9aRedis%20%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%ef%bc%88%e4%b8%8b%ef%bc%89.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件开发通常会提到一个名词 “三高”，即高并发、高性能、高可用。&lt;/p&gt;
&lt;p&gt;具体的指标定义，如：高并发方面要求QPS 大于 10万；高性能方面要求请求延迟小于 100 ms；高可用方面要高于 99.99%。&lt;/p&gt;
&lt;p&gt;在前面学习 Redis 时，我们也可以看出 Re</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文——基础篇（二）</title>
    <link href="http://example.com/2024/06/12/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2024/06/12/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-06-12T13:42:11.000Z</published>
    <updated>2024-06-12T16:24:35.104Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 Java 基础 常见八股文的第二篇，主要内容是关于面向对象的，非常重要，一点一点来看吧。</p><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h2><ul><li><strong>⾯向过程</strong> ：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。</li><li><strong>⾯向对象</strong> ：面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。</li></ul><p>用一个比喻：面向过程是编年体；面向对象是纪传体。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-10.png" alt="面向对象和面向过程的区别"></p><h2 id="面向对象编程有哪些特性？"><a href="#面向对象编程有哪些特性？" class="headerlink" title="面向对象编程有哪些特性？"></a>面向对象编程有哪些特性？</h2><p>面向对象编程有三大特性：封装、继承、多态。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-20240330115129.png" alt="二哥的 Java 进阶之路"></p><ul><li><p><strong>封装</strong>：封装是指将数据（属性，或者叫字段）和操作数据的方法（行为）捆绑在一起，形成一个独立的对象（类的实例）。</p><p>封装是把一个对象的属性私有化，同时提供一些可以被外界访问的方法。</p></li><li><p><strong>继承</strong>：继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。以提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p></li><li><p><strong>多态</strong>：多态允许不同类的对象对同一消息做出响应，但表现出不同的行为（即方法的多样性）。</p><p>多态其实是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象类型的不同产生不同的结果。</p><p>多态的前置条件有三个：</p><ul><li>子类继承父类</li><li>子类重写父类的方法</li><li>父类引用指向子类的对象</li></ul></li></ul><h2 id="多态解决了什么问题？"><a href="#多态解决了什么问题？" class="headerlink" title="多态解决了什么问题？"></a>多态解决了什么问题？</h2><p>多态的目的是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。比如说动态绑定，允许在程序在运行时再确定调用的是子类还是父类的方法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/extends-bigsai-2bf1876f-0c1c-4e83-8721-e6f48d6451c0.png" alt="bigsai：封装继承多态"></p><h2 id="访问修饰符-public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符-public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符 public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符 public、private、protected、以及不写（默认）时的区别？</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-12.png" alt="访问修饰符和可见性"></p><h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><p>一个类只能继承一个抽象类；但一个类可以实现多个接口。所以我们在新建线程类的时候一般推荐使用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。</p><p>抽象类符合 is-a 的关系，而接口更像是 has-a 的关系，比如说一个类可以序列化的时候，它只需要实现 Serializable 接口就可以了，不需要去继承一个序列化类。</p><p>抽象类更多地是用来为多个相关的类提供一个共同的基础框架，包括状态的初始化，而接口则是定义一套行为标准，让不同的类可以实现同一接口，提供行为的多样化实现。</p><h3 id="抽象类可以定义构建函数吗？"><a href="#抽象类可以定义构建函数吗？" class="headerlink" title="抽象类可以定义构建函数吗？"></a>抽象类可以定义构建函数吗？</h3><p>可以，抽象类可以有构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);  <span class="comment">// 调用抽象类的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口可以定义构建函数吗？"><a href="#接口可以定义构建函数吗？" class="headerlink" title="接口可以定义构建函数吗？"></a>接口可以定义构建函数吗？</h3><p>不能，接口主要用于定义一组方法规范，没有具体的实现细节。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-20240512090855.png" alt="二哥的 Java 进阶之路：接口不能定义构造方法"></p><h3 id="继承和抽象的区别？"><a href="#继承和抽象的区别？" class="headerlink" title="继承和抽象的区别？"></a>继承和抽象的区别？</h3><p>继承是一种允许子类继承父类属性和方法的机制。通过继承，子类可以重用父类的代码。</p><p>抽象是一种隐藏复杂性和只显示必要部分的技术。在面向对象编程中，抽象可以通过抽象类和接口实现。</p><h2 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h2><ol><li><strong>从语法形式上看</strong>：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li><strong>从变量在内存中的存储⽅式来看</strong>：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。</li><li><strong>从变量在内存中的⽣存时间上看</strong>：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。</li><li><strong>成员变量如果没有被赋初值</strong>：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。</li></ol><h2 id="静态变量和实例变量的区别？静态方法、实例方法呢？"><a href="#静态变量和实例变量的区别？静态方法、实例方法呢？" class="headerlink" title="静态变量和实例变量的区别？静态方法、实例方法呢？"></a>静态变量和实例变量的区别？静态方法、实例方法呢？</h2><blockquote><p>静态变量和实例变量的区别？</p></blockquote><p><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。</p><p><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><blockquote><p>静态⽅法和实例⽅法有何不同?</p></blockquote><p>类似地。</p><p><strong>静态方法</strong>：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”<strong>类名.⽅法名</strong>“的⽅式，也可以使⽤”<strong>对象名.⽅法名</strong>“的⽅式。静态方法里不能访问类的非静态成员变量和方法。</p><p><strong>实例⽅法</strong>：依存于类的实例，需要使用”<strong>对象名.⽅法名</strong>“的⽅式调用；可以访问类的所有成员变量和方法。</p><h2 id="final、finally、finalize"><a href="#final、finally、finalize" class="headerlink" title="final、finally、finalize"></a>final、finally、finalize</h2><ul><li><p><code>final</code>：final 是一个修饰符，可以修饰类、方法和变量。</p><ul><li>当 final 修饰一个类时，表明这个类不能被继承。比如，String 类、Integer 类和其他包装类都是用 final 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（Override）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 final 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。但是引用指向的对象内容可以改变。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-13.png" alt="三分恶面渣逆袭：final修饰变量"></p></li><li><p><code>finally</code>： 是 Java 中异常处理的一部分，用来创建 try 块后面的 finally 块。无论 try 块中的代码是否抛出异常，finally 块中的代码总是会被执行。通常，finally 块被用来释放资源，如关闭文件、数据库连接等。</p></li><li><p><code>finalize</code>： 是 object 类的一个方法，用于在垃圾回收器将对象从内存中清除出去之前作业写必要的清理工作。</p><p>这个方法在垃圾回收器准备释放对象占用的内存之前被自动调用。我们不能显式地调用 finalize 方法，因为它总是由垃圾回收器在适当的时间自动调用。</p></li></ul><h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p>我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/shallow%2526deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p><h2 id="Java-是值传递，还是引用传递？"><a href="#Java-是值传递，还是引用传递？" class="headerlink" title="Java 是值传递，还是引用传递？"></a>Java 是值传递，还是引用传递？</h2><p>Java 是值传递，不是引用传递。</p><p>当一个对象被作为参数传递到方法中时，参数的值就是该对象的引用。引用的值是对象在堆中的地址。</p><p>对象是存储在堆中的，所以传递对象的时候，可以理解为把变量存储的对象地址给传递过去。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-14.png" alt="三分恶面渣逆袭：Java引用数据值传递示意图"></p><h3 id="引用类型的变量有什么特点？"><a href="#引用类型的变量有什么特点？" class="headerlink" title="引用类型的变量有什么特点？"></a>引用类型的变量有什么特点？</h3><p>引用类型的变量存储的是对象的地址，而不是对象本身。因此，引用类型的变量在传递时，传递的是对象的地址，也就是说，传递的是引用的值。</p><h2 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h2><p>该问题考察 JVM、GC等知识。</p><ol><li>强引用：只要引用关系还在，对象就永远不会被回收。强引用其实就是指普通对象的引用，只要还有引用关系存在，就表示对象还活着，垃圾回收器就无法回收这一类对象。只有在没有其他引用关系或者超过引用作用域，再或者将对象引用强制赋值为 null 的情况下，垃圾回收器才会回收这个对象。</li><li>软引用：非必须存活的对象，JVM 会在内存溢出前对其进行回收。软引用是一种相对于强引用来说弱一些的引用。可以让对象豁免一些垃圾回收的操作。只有当JVM判断内存不足的时候，才会试图回收引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足的时候就会清理掉。这样就可以保证在使用缓存的同时，不会耗尽内存。</li><li>弱引用：非必须存活的对象，不管内存是否够用，下次GC一定回收。弱引用是相对于强引用而言的，它是在允许存在引用关联的情况下能被回收的对象。在垃圾回收线程扫描它所管辖的内存区域的过程中，一旦发现只具有弱引用的对象，不管当前的内存空间是否足够，垃圾回收器都会回收这个对象。</li><li>虚引用：等同于没有引用，对象被回收时会收到通知。虚引用不会决定对象的生命周期，它提供一种确保对象被“finalize”以后去做某些事情的机制。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入与之关联的引用队列中，程序可以通过判断引用队列是否已经加入虚引用来决定被引用对象是否要被垃圾回收器回收。然后，我们就可以在引用对象被回收之前执行一些必要的操作。所以，虚引用必须和引用队列一起使用。</li></ol><p>举个例子：</p><ul><li>强引用就好比电视剧中的男主角，怎么都死不了。</li><li>软引用就像女主角，虽有一段经历，但还是没走到最后。</li><li>弱引用就是男二号，注定是用来牺牲的。</li><li>虚引用就是路人甲了。</li></ul><h1 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h1><h2 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-对象的创建过程"><a href="#Java-对象的创建过程" class="headerlink" title="Java 对象的创建过程"></a>Java 对象的创建过程</h2><p>在实例化一个对象的时候，JVM 首先会去<strong>检查目标对象是否已经被加载并初始化</strong>了，如果没有，则 JVM 需要立刻去加载目标类，然后调用目标类的构造器完成初始化。目标类的加载是通过类加载器来实现的，主要就是把一个类加载到内存里面。</p><p>然后，初始化主要是对目标类里面的静态变量、成员变量、静态代码块进行初始化。当目标类被初始化以后，就可以从常量池里面找到对应的类元信息，并且目标对象的大小在类加载之后就已经确定了，所以这个时候就需要为新创建的对象，根据目标对象的大小在堆内存里面分配内存空间。</p><p>内存分配的方式一般有两种，一种是指针碰撞，另一种是空闲列表，JVM 会根据 Java 堆内存是否规整来决定内存分配方式。<br>接下来，JVM 会把目标对象里面的普通成员变量初始化为零值，比如 int 类型初始化为0.</p><p>对象类型初始化为null（类变量在类加载的准备阶段就已经初始化过了）。这一步操作主要是保证对象里面的实例字段不用初始化就可以直接使用，也就是程序能够获得这些字段对应数据类型的零值。</p><p>然后，JVM 还需要对目标对象的对象头做一些设置，比如对象所属的类元信息、对象的GC 分代年龄、hashCode、锁标记等。</p><p>完成这些步骤以后，对于 JVM水说，新对象的创建工作就完成了、但是对于 Java 语言来说，对象创建才算开始。</p><p>接下来要做的，就是执行目标对象内部生成的 init 方法，初始化成员变量的值、执行构造块，最后执行目标对象的构建方法，完成对象的构建。</p><p>其中，init 方法是 Java 文件编译之后在字节码文件中生成的，它是一个实例构造器，这个构造器会把语句块、变量初始化、调用父类构造器等操作组织在一起。所以调用 init 方法能够完成一系列初始化动作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fb99e86aaf36945df1a34b11d4fd0da.jpg" alt="fb99e86aaf36945df1a34b11d4fd0da"></p><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a><code>==</code> 和 <code>equals()</code> 的区别</h2><p><code>==</code> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a><code>hashCode</code></h2><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/java-hashcode-method.png" alt="hashCode() 方法"></p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>的值默认时 JVM 使用随机数生成的，两个不同的对象可能会生成相同的 <code>hashCode</code>。</p><ul><li><strong>为什么要提供 <code>hashCode()</code> 方法？</strong></li></ul><p>看《Head First Java》中的这一段：</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><ul><li><strong>为什么要同时提供这两个方法？</strong></li></ul><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><ul><li><strong>那为什么不只提供 <code>hashCode</code> 方法？</strong></li></ul><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><ul><li><strong>为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></li></ul><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h2 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</h2><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h2 id="一个空的-Object-对象占多大内存？"><a href="#一个空的-Object-对象占多大内存？" class="headerlink" title="一个空的 Object 对象占多大内存？"></a>一个空的 Object 对象占多大内存？</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612231739612.png" alt="image-20240612231739612"></p><ol><li>对象头，包括 Markword、类元指针、数组长度。其中 Markword 用来存储对象运行时的相关数据，比如 hashCode、GC 分代年龄等。在64位操作系统中占8字节，在32位操作系统中占4字节。类元指针指向当前实例对象所属哪个类，在开启压缩指针的情况下占4字节，未开启则占8字节。数组长度只有对象数组才会存在，占4字节。</li><li>实例数据，主要用来存储对象中的字段信息。</li><li>对齐填充，用来补充实现 Java 对象大小的倍数对齐。在JVM 中，Java 对象的大小需要按照8字节或者8字节的倍数来对齐，从而避免伪共享问题。</li></ol><p>根据以上分析，我们来总结一下。</p><ol><li>一个Java 空对象，在开启压缩指针的情况下，占用12字节。其中，Markword 占8字节、类元指针占4字节。但是为了避免伪共享问题，JVM会按照8字节的倍数进行填充，所以会在对齐填充区填充4字节，变成16字节。</li><li>在关闭压缩指针的情况下，Object 默认会占用16字节。其中，Markword 占8字节，类元指针占4字节，对齐填充占4字节。16字节正好是8的整数倍，因此不需要填充。</li></ol><p>所以结论是，一般情况下，一个空的 Java Object 对象占用 16 字节的内存空间。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><h3 id="值可变性"><a href="#值可变性" class="headerlink" title="值可变性"></a>值可变性</h3><p><code>String</code> 是不可变的。因此每次修改 String 的值，都会产生一个新的对象。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，所以都是<strong>可变类</strong>，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全方面"><a href="#线程安全方面" class="headerlink" title="线程安全方面"></a>线程安全方面</h3><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p><p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h3><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。性能最差。</p><p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。性能第二。</p><p>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="数据存储方面"><a href="#数据存储方面" class="headerlink" title="数据存储方面"></a>数据存储方面</h3><p><code>String</code> 存储在<strong>字符串常量池</strong>中，<code>StringBuilder</code> 与 <code>StringBuffer</code> 存储在<strong>堆内存</strong>中。</p><h3 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a><strong>对于三者使用的总结：</strong></h3><ul><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ul><h2 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h2><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol></blockquote><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><h3 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h3><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure><p>上面的代码对应的字节码如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20220422161637929.png" alt="img"></p><p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20220422161320823.png" alt="img"></p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20220422162327415.png" alt="img"></p><p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 <a href="https://openjdk.org/jeps/280">JEP 280open in new window</a> 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。可以看看<a href="https://juejin.cn/post/7182872058743750715">这篇文章</a>。</p><h2 id="String-s1-new-String-“hello”-这句话创建了几个字符串对象？-字符串常量池"><a href="#String-s1-new-String-“hello”-这句话创建了几个字符串对象？-字符串常量池" class="headerlink" title="String s1 = new String(“hello”);这句话创建了几个字符串对象？|| 字符串常量池"></a>String s1 = new String(“hello”);这句话创建了几个字符串对象？|| 字符串常量池</h2><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>String s1 = new String(“abc”);这句话创建了几个字符串对象？</strong></p><p>会创建 一个 或 两个 字符串对象。看看详情：</p><blockquote><p>首先，这个语句里面有一个 new关键字，这个关键字是在程序运行时，根据已经加载的系统类 String，在堆内存里面实例化的一个字符串对象，如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/144a58947a1f84578369ffbe81fde1d.jpg" alt="144a58947a1f84578369ffbe81fde1d" style="zoom: 25%;" /></p><p>然后，在这个 String 的构造方法里面，传递了一个 hello字符串，因为 String 里面的字符串成员变量是 final 修饰的，所以它是一个字符串常量。<br>接下来，JVM 会用字面量hello 去字符串常量池里面试图获取它对应的 String 对象引用，如果获取不到，就会在堆内存里面创建一个 hello 的 String 对象，并且把引用保存到字符串常量池里面。<br>后续如果再有字面量 hello 的定义，因为字符串常量池里面己经存在了字面量 hello的引用，所以只需要从常量池里面获取对应的引用就可以了，不需要再创建。<br>所以，对于这个问题，分以下两种情况：</p><ol><li>如果 hello这个字符串常量不存在，则创建两个对象，分别是hello这个字符串常量，以及 new String<br>这个实例对象。</li><li>如果 hello这个字符串常量存在，则只会创建一个对象。</li></ol></blockquote><p>看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span> + <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hel&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s5.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;h&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;ello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> s7 + s8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s9);<span class="comment">//false</span></span><br><span class="line">System.out.println(s4 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s6);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>接下来简单分析一下，由于s2 指向的字面量 hello 在常量池中已经存在（s1 先于s2），于是JVM 就返回这个字面量绑定的引用，所以 <code>s1 == s2</code>。</p><p>s3中字面量的拼接其实就是hello，在编译期间就已经对它进行了优化，所以s1 和 s3 也是相等的。</p><p>S4 中的new String（”lo”）生成了两个对象：lo 和 new String（”lo”）。lo存在于字符串常量池中，new String（”lo”）存在于堆中，String s4 = “hel” + new String（”lo”）实质上是两个对象的相加，编译器不会进行优化，相加的结果存在于堆中，而s1 存在于字符串常量池中，当然不相等。<code>s1 == s9</code>的原理也一样。</p><p>对于 s4 == s5，因为两个相加的结果都在堆中，不用说，肯定不相等。</p><p>对于 s1 == s6，s5.intern()方法能使一个位于堆中的字符串，在运行期间动态地加入字符串常量池（字符串常量池的内容是在程序启动的时候就已经加载好了的）。如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用；否则，复制一份该字面量到字符串常量池并返回它的引用。因此s1 ==s6输出 true。</p><blockquote><p><strong>常量折叠</strong></p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+” 拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节内容比较杂乱，但基本都是 Java 基础中的重点，而且会对实际开发有很多启发，需要着重记忆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是 Java 基础 常见八股文的第二篇，主要内容是关于面向对象的，非常重要，一点一点来看吧。&lt;/p&gt;
&lt;h1 id=&quot;面向对象基础&quot;&gt;&lt;a href=&quot;#面向对象基础&quot; class=&quot;headerlink&quot; title=&quot;面向对象基础&quot;&gt;&lt;/a&gt;面向对象基础&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Redis事件机制：高效运行的秘密武器</title>
    <link href="http://example.com/2024/06/12/Redis%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A7%98%E5%AF%86%E6%AD%A6%E5%99%A8/"/>
    <id>http://example.com/2024/06/12/Redis%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A7%98%E5%AF%86%E6%AD%A6%E5%99%A8/</id>
    <published>2024-06-12T12:35:25.000Z</published>
    <updated>2024-06-12T13:36:03.568Z</updated>
    
    <content type="html"><![CDATA[<p>对，没错，这又是一篇讲为什么 Redis 如此之快的文章。不过这次的内容于<a href="https://zxh3032.github.io/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/">上一篇文章</a>不一样，本文将聚焦在 Redis 的事件机制的基础概念和实现，不在过多提及它对 Redis 速度的影响。</p><p>我在之前的文章中多次提过，Redis 是单线程的，你是否想过，一个线程要如何处理来自各个客户端的各种请求呢？它忙的过来吗？</p><p>了解 Redis 的都知道，它不光忙得过来，还做的井井有条。其中就多亏了 IO 多路复用，不仅仅是它，事件机制在其中也是一个不错的设计。</p><p>关于 IO 多路复用，我们在之前的文章中也提到过很多次了，所以这里就只聚焦在 Redis 的事件机制上。</p><h1 id="如果是你，会怎么做？"><a href="#如果是你，会怎么做？" class="headerlink" title="如果是你，会怎么做？"></a>如果是你，会怎么做？</h1><p>让我们来设计一个 redis，我们要怎么处理请求连接呢？</p><p>最笨的方法，那就是来一个客户端就 <code>accept</code> 一次，然后有什么请求就做什么事，先来先做。显然，这样做别说一个线程了，就算有十个线程都不够用的，太慢了。</p><p>我们还可以这样设计，来一个我就单独开设一个线程处理它，相当于你一来我就单独找一个人为你服务，而服务的人最终会将请求给到一个处理中心，让处理中心统一去处理，然后将结果返回。但显然 Redis 没有那么多资源让你浪费。</p><p>各种设计都不能满足要求，那就摇人，叫大哥——IO多路复用。至少他能帮我解决前面服务的问题，fd 我就不管了，直接告诉我哪些人来了，并且告诉我有事的是哪些人。</p><p>既然 epoll_wait 能 告诉我们有那些 socket 已经就绪，那么我们就处理就绪的这些就可以了。但我们需要一个合理的机制来帮我们来优雅的处理他们，毕竟 Redis 后面只有个单线程在处理。由于处理没这么快，肯定需要一个地方来存放未处理的这些事件，那很合理就能想到需要一个类似 buffer 的东西。</p><p>所以，对于这个事件机制，我第一个想法就是弄个队列，或者 ringbuffer 来搞，那不就是一个生产消费者模型吗？</p><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>Redis中的事件驱动库只关注网络IO，以及定时器。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><p>事件驱动库的代码主要是在<code>src/ae.c</code>中实现的，其示意图如下所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612205406918.png" alt="image-20240612205406918"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件：Redis-的特工队"><a href="#文件事件：Redis-的特工队" class="headerlink" title="文件事件：Redis 的特工队"></a>文件事件：Redis 的特工队</h2><blockquote><p>Redis基于<strong>Reactor模式</strong>开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p></blockquote><p><strong>Redis 事件想用框架 ae_event 及文件事件处理器</strong></p><p>Redis并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。事件响应框架一般都采用该架构，比如 netty 和 libevent。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-2.png" alt="img"></p><p>如下图所示，文件事件处理器有四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器以及事件处理器。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-3.png" alt="img"></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 <code>accept</code>、<code>read</code>、<code>write</code>和 <code>close</code> 等操作时，就会产生一个文件事件。因为 Redis 通常会连接多个套接字，所以多个文件事件有可能并发的出现。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件派发器传递那些产生了事件的套接字。</p><p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生的套接字都放到同一个队列(也就是后文中描述的aeEventLoop的fired就绪事件表)里边，然后文件事件处理器会以有序、同步、单个套接字的方式处理该队列中的套接字，也就是处理就绪的文件事件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-4.png" alt="img"></p><p>所以，一次 Redis 客户端与服务器进行连接并且发送命令的过程如上图所示。</p><ul><li>客户端向服务端发起<strong>建立 socket 连接的请求</strong>，那么监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行。处理器会对客户端的连接请求</li><li>进行<strong>应答</strong>，然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器关联。</li><li>客户端建立连接后，向服务器<strong>发送命令</strong>，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行，处理器读取客户端命令，然后传递给相关程序去执行。</li><li><strong>执行命令获得相应的命令回复</strong>，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器将命令回复全部写入到套接字中。</li></ul><p>其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p><h2 id="时间事件：Redis的时间旅行者"><a href="#时间事件：Redis的时间旅行者" class="headerlink" title="时间事件：Redis的时间旅行者"></a>时间事件：Redis的时间旅行者</h2><blockquote><p>Redis 的时间事件分为以下两类：</p></blockquote><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 的时间事件的具体定义结构如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 全局唯一ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="comment">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="comment">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    <span class="comment">/* 时间处理器 */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    <span class="comment">/* 事件结束回调函数，析构一些资源*/</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="comment">/* 私有数据 */</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="comment">/* 前驱节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">/* 后继节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：</p><ul><li>如果返回值是 <code>AE_NOMORE</code>，那么这个事件是一个定时事件，该事件在达到后删除，之后不会再重复。</li><li>如果返回值是非 <code>AE_NOMORE</code> 的值，那么这个事件为周期性事件，当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 when 属性进行更新，让这个事件在一段时间后再次达到。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-5.png" alt="img"></p><p>服务器所有的时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能。</p><h1 id="aeEventLoop的具体实现"><a href="#aeEventLoop的具体实现" class="headerlink" title="aeEventLoop的具体实现"></a><code>aeEventLoop</code>的具体实现</h1><blockquote><p>介绍完文件事件和时间事件，我们接下来看一下 <code>aeEventLoop</code>的具体实现</p></blockquote><h2 id="创建事件管理器"><a href="#创建事件管理器" class="headerlink" title="创建事件管理器"></a>创建事件管理器</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器<code>aeEventLoop</code>对象。</p><p>函数<code>aeCreateEventLoop</code>将创建一个事件管理器，主要是初始化 <code>aeEventLoop</code>的各个属性值，比如events、fired、timeEventHead和apidata：</p><ul><li>首先创建<code>aeEventLoop</code>对象。</li><li>初始化未就绪文件事件表、就绪文件事件表。events指针指向未就绪文件事件表、fired指针指向就绪文件事件表。表的内容在后面添加具体事件时进行初变更。</li><li>初始化时间事件列表，设置<code>timeEventHead</code>和<code>timeEventNextId</code>属性。</li><li>调用<code>aeApiCreate</code> 函数创建epoll实例，并初始化 <code>apidata</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *<span class="title function_">aeCreateEventLoop</span><span class="params">(<span class="type">int</span> setsize)</span> &#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* 创建事件状态结构 */</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* 创建未就绪事件表、就绪事件表 */</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* 设置数组大小 */</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    <span class="comment">/* 初始化执行最近一次执行时间 */</span></span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 初始化时间事件结构 */</span></span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 将多路复用io与事件管理器关联起来 */</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* 初始化监听事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line">err:</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aeApiCreate</code> 函数首先创建了<code>aeApiState</code>对象，初始化了epoll就绪事件表；然后调用epoll_create创建了epoll实例，最后将该<code>aeApiState</code>赋值给<code>apidata</code>属性。</p><p><code>aeApiState</code>对象中epfd存储epoll的标识，events是一个epoll就绪事件数组，当有epoll事件发生时，所有发生的epoll事件和其描述符将存储在这个数组中。这个就绪事件数组由应用层开辟空间、内核负责把所有发生的事件填充到该数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 初始化epoll就绪事件表 */</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建 epoll 实例 */</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 事件管理器与epoll关联 */</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* epoll_event 实例描述符*/</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="comment">/* 存储epoll就绪事件表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br></pre></td></tr></table></figure><h2 id="创建文件事件"><a href="#创建文件事件" class="headerlink" title="创建文件事件"></a>创建文件事件</h2><p><code>aeFileEvent</code>是文件事件结构，对于每一个具体的事件，都有读处理函数和写处理函数等。Redis 调用<code>aeCreateFileEvent</code>函数针对不同的套接字的读写事件注册对应的文件事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 监听事件类型掩码,值可以是 AE_READABLE 或 AE_WRITABLE */</span></span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="comment">/* 读事件处理器 */</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    <span class="comment">/* 写事件处理器 */</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="comment">/* 多路复用库的私有数据 */</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"><span class="comment">/* 使用typedef定义的处理器函数的函数类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">aeFileProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, </span></span><br><span class="line"><span class="params"><span class="type">int</span> fd, <span class="type">void</span> *clientData, <span class="type">int</span> mask)</span>;</span><br></pre></td></tr></table></figure><p>比如说，Redis 进行主从复制时，从服务器需要主服务器建立连接，它会发起一个 socekt连接，然后调用<code>aeCreateFileEvent</code>函数针对发起的socket的读写事件注册了对应的事件处理器，也就是syncWithMaster函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/* 符合aeFileProc的函数定义 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syncWithMaster</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;....&#125;</span><br></pre></td></tr></table></figure><p><code>aeCreateFileEvent</code>的参数fd指的是具体的socket套接字，proc指fd产生事件时，具体的处理函数，<code>clientData</code>则是回调处理函数时需要传入的数据。</p><p><code>aeCreateFileEvent</code>主要做了三件事情：</p><ul><li>以fd为索引，在events未就绪事件表中找到对应事件。</li><li>调用<code>aeApiAddEvent</code>函数，该事件注册到具体的底层 I/O 多路复用中，本例为epoll。</li><li>填充事件的回调、参数、事件类型等参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">                       aeFileProc *proc, <span class="type">void</span> *clientData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 取出 fd 对应的文件事件结构, fd 代表具体的 socket 套接字 */</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    <span class="comment">/* 监听指定 fd 的指定事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    <span class="comment">/* 置文件事件类型，以及事件的处理器 */</span></span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    <span class="comment">/* 私有数据 */</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上文所说，<strong>Redis 基于的底层 I/O 多路复用库有多套</strong>，所以<code>aeApiAddEvent</code>也有多套实现，下面的源码是epoll下的实现。其核心操作就是调用epoll的epoll_ctl函数来向epoll注册响应事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">/* 如果 fd 没有关联任何事件，那么这是一个 ADD 操作。如果已经关联了某个/某些事件，那么这是一个 MOD 操作。 */</span></span><br><span class="line">    <span class="type">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册事件到 epoll */</span></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">/* 调用epoll_ctl 系统调用，将事件加入epoll中 */</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>因为 Redis 中同时存在文件事件和时间事件两个事件类型，所以服务器必须对这两个事件进行调度，决定何时处理文件事件，何时处理时间事件，以及如何调度它们。</p><p><code>aeMain</code>函数以一个无限循环不断地调用<code>aeProcessEvents</code>函数来处理所有的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="comment">/* 如果有需要在事件处理前执行的函数，那么执行它 */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">/* 开始处理事件*/</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>aeProcessEvents</code>的伪代码，它会首先计算距离当前时间最近的时间事件，以此计算一个超时时间；然后调用<code>aeApiPoll</code>函数去等待底层的I/O多路复用事件就绪；<code>aeApiPoll</code>函数返回之后，会处理所有已经产生文件事件和已经达到的时间事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">/* 获取到达时间距离当前时间最接近的时间事件*/</span></span><br><span class="line">    time_event = aeSearchNearestTimer();</span><br><span class="line">    <span class="comment">/* 计算最接近的时间事件距离到达还有多少毫秒*/</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now();</span><br><span class="line">    <span class="comment">/* 如果事件已经到达，那么remaind_ms为负数，将其设置为0 */</span></span><br><span class="line">    <span class="keyword">if</span> (remaind_ms &lt; <span class="number">0</span>) remaind_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 根据 remaind_ms 的值，创建 timeval 结构*/</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms);</span><br><span class="line">    <span class="comment">/* 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 结构决定，如果remaind_ms 的值为0，则aeApiPoll 调用后立刻返回，不阻塞*/</span></span><br><span class="line">    <span class="comment">/* aeApiPoll调用epoll_wait函数，等待I/O事件*/</span></span><br><span class="line">    aeApiPoll(timeval);</span><br><span class="line">    <span class="comment">/* 处理所有已经产生的文件事件*/</span></span><br><span class="line">    processFileEvents();</span><br><span class="line">    <span class="comment">/* 处理所有已经到达的时间事件*/</span></span><br><span class="line">    processTimeEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>aeApiAddEvent</code>类似，<code>aeApiPoll</code>也有多套实现，它其实就做了两件事情，调用<code>epoll_wait</code>阻塞等待epoll的事件就绪，超时时间就是之前根据最快达到时间事件计算而来的超时时间；然后将就绪的epoll事件转换到fired就绪事件。<code>aeApiPoll</code>就是上文所说的I/O多路复用程序。具体过程如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-event-6.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="type">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 调用epoll_wait函数，等待时间为最近达到时间事件的时间计算而来。</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 有至少一个事件就绪？</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">/*为已就绪事件设置相应的模式，并加入到 eventLoop 的 fired 数组中*/</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> =</span> state-&gt;events+j;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN)</span><br><span class="line">        mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT)</span><br><span class="line">        mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) </span><br><span class="line">        mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP)</span><br><span class="line">        mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">/* 设置就绪事件表元素 */</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回已就绪事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processFileEvent是处理就绪文件事件的伪代码，也是上文所述的文件事件分派器，它其实就是遍历fired就绪事件表，然后根据对应的事件类型来调用事件中注册的不同处理器，读事件调用rfileProc，而写事件调用wfileProc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processFileEvent</span><span class="params">(<span class="type">int</span> numevents)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">/* 从已就绪数组中获取事件 */</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> fired = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line">            <span class="comment">/* 读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">/* 调用读处理函数 */</span></span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 写事件. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而processTimeEvents是处理时间事件的函数，它会遍历<code>aeEventLoop</code>的事件事件列表，如果时间事件到达就执行其timeProc函数，并根据函数的返回值是否等于AE_NOMORE来决定该时间事件是否是周期性事件，并修改器到达时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxId;</span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">    ....</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 遍历时间事件链表 */</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="type">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 删除需要删除的时间事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* id 大于最大maxId,是该循环周期生成的时间事件，不处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="comment">/* 事件已经到达，调用其timeProc函数*/</span></span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* 如果返回值不等于 AE_NOMORE,表示是一个周期性事件，修改其when_sec和when_ms属性*/</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 一次性事件，标记为需删除，下次遍历时会删除*/</span></span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><p>当不在需要某个事件时，需要把事件删除掉。例如: 如果fd同时监听读事件、写事件。当不在需要监听写事件时，可以把该fd的写事件删除。</p><p>aeDeleteEventLoop函数的执行过程总结为以下几个步骤</p><ul><li>根据fd在未就绪表中查找到事件</li><li>取消该fd对应的相应事件标识符</li><li>调用aeApiFree函数，内核会将epoll监听红黑树上的相应事件监听取消。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那我们通过 Redis 的事件机制能学到什么呢？</p><ol><li>这个事件机制的模型很通用也很清晰，包含：接收、循环、处理，三个部分，很标准的设计</li><li>其中对于任务的处理有一个专门的分配器去分配，这在很多 handler 的设计中非常实用，熟悉 java 的同学应该知道 DispatcherServlet 没错这样的模型会更加的清晰</li><li>易于扩展，这里的扩展有两方面一方面是对于处理器的扩展，之后有其他事件类型只需要增加事件处理器就可以了；而另一方面这里的扩展还包括了多线程的扩展，方便了同时支持多个事件的处理。<br>其实，Redis 的事件机制是一个标准的 <strong>Reactor模式</strong> 是一种基于事件驱动的设计模式，所以我们更多的是要学到这样设计模式，来运用到以后的编码中，可以更清晰也易扩展。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://betterprogramming.pub/internals-workings-of-redis-718f5871be84">https://betterprogramming.pub/internals-workings-of-redis-718f5871be84</a></li><li><a href="https://www.linkinstars.com/post/2b007902.html">https://www.linkinstars.com/post/2b007902.html</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对，没错，这又是一篇讲为什么 Redis 如此之快的文章。不过这次的内容于&lt;a href=&quot;https://zxh3032.github.io/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis消息队列：你的数据，随时待命</title>
    <link href="http://example.com/2024/06/11/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%9A%8F%E6%97%B6%E5%BE%85%E5%91%BD/"/>
    <id>http://example.com/2024/06/11/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%9A%8F%E6%97%B6%E5%BE%85%E5%91%BD/</id>
    <published>2024-06-11T15:07:23.000Z</published>
    <updated>2024-06-12T12:21:38.015Z</updated>
    
    <content type="html"><![CDATA[<p>现如今的互联网应用大多是采用分布式系统机构设计的，所以<strong>消息队列</strong>已经逐渐成为企业应用系统内部通信的核心手段，它具有<strong>低耦合、可靠投递、广播、流量控制、最终一致性</strong>等一系列功能。</p><p>当前使用较多的 消息队列 有 <code>RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ</code> 等，而部分数据库如 Redis、MySQL 以及 phxsql ，如果硬搞的话，其实也可实现消息队列的功能。</p><p>可能有人觉得，各种开源的 MQ 已经足够使用了，为什么需要用 Redis 实现 MQ 呢?</p><p>有些简单的业务场景，可能不需要重量级的 MQ 组件(相比 Redis 来说，Kafka 和 RabbitMQ 都算是重量级的消息队列)</p><p>那你有考虑过用 Redis 做消息队列吗?</p><p>这一章，我会结合消息队列的特点和 Redis 做消息队列的使用方式，以及实际项目中的使用，来探讨下 Redis 消息队列的方案。</p><h1 id="消息队列是什么？"><a href="#消息队列是什么？" class="headerlink" title="消息队列是什么？"></a>消息队列是什么？</h1><p>消息队列是指利用<strong>高效可靠</strong>的消息传递机制<strong>进行与平台无关</strong>的数据交流，并基于数据通信来进行分布式系统的集成。</p><p>通过提供<strong>消息传递</strong>和<strong>消息排队</strong>模型，它可以在<strong>分布式环境</strong>下提供 应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步 等等功能，其作为<strong>分布式系统架构</strong>中的一个重要组件，有着举足轻重的地位。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d215809a9e90cbfc765470545e496c35.jpg" alt="img"></p><p>现在回顾一下，我们使用的消息队列一般有什么样的特点：</p><ul><li>三个角色：生产者、消费者 和 消息处理中心。</li><li>异步处理模式：生产者将消息发送到一条虚拟的通道(消息队列)上，而无需等待响应。消费者则订阅或是监听该通道，取出消息。两者互不干扰，甚至都不用同时在线，也就是我们说的松耦合。</li><li>可靠性：消息要可以保证不丢失、不重复消费、有时可能还需要顺序性的保证。</li></ul><p>撇开我们常用的消息中间件不说， Redis 的哪些数据类型可以满足 MQ 的常规需求~~</p><h1 id="Redis-如何实现消息队列？"><a href="#Redis-如何实现消息队列？" class="headerlink" title="Redis 如何实现消息队列？"></a>Redis 如何实现消息队列？</h1><p>思来想去，也就只有 List 和 Stream 两种数据类型，可以实现消息队列的这些需求，当然，Redis 还提供了 发布/订阅(pub/sub) 模式。</p><p>下面我们一一来看。</p><h2 id="List-实现消息队列"><a href="#List-实现消息队列" class="headerlink" title="List 实现消息队列"></a>List 实现消息队列</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。</p><p>所以常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/50837e00-6f6b-11ea-8377-13f07d2f46fb" alt="list存取图.png"></p><p>List 使用命令的方式实现消息队列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mq &quot;hello&quot; #推送消息 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush mq &quot;msg&quot; #推送消息 msg</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 hello</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 msg</span><br><span class="line">&quot;mq&quot;</span><br></pre></td></tr></table></figure><p>其中，mq 就相当于频道名称 channel，而 lpush 用于生产消息， rpop 拉取消息。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>接下来我们用 Java 代码的方式来实现 List 形式的消息队列，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMQExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;mq&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收到了消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收到消息：Hello, List.</span><br></pre></td></tr></table></figure><p>我们使用无限循环来获取队列中的数据，这样就可以实时地获取相关信息了，但这样会带来另一个新的问题，当队列中如果没有数据的情况下，无限循环会一直消耗系统的资源，这时候我们可以使用 brpop 替代 rpop 来完美解决这个问题。</p><p>b 是 blocking 的缩写，表示<strong>阻塞读</strong>，也就是当队列没有数据时，它会进入休眠状态，当有数据进入队列之后，它才会“苏醒”过来执行读取任务，这样就可以解决 while 循环一直执行消耗系统资源的问题了，改良版代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMQExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 消费者 改良版</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; bConsumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 2.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 3.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者（阻塞版）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞读</span></span><br><span class="line">            <span class="keyword">for</span> (String item : jedis.brpop(<span class="number">0</span>,<span class="string">&quot;mq&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 读取到相关数据，进行业务处理</span></span><br><span class="line">                System.out.println(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，brpop() 方法的第一个参数是设置超时时间的，设置 0 表示一直阻塞。</p><h3 id="可靠队列模式-ack-机制"><a href="#可靠队列模式-ack-机制" class="headerlink" title="可靠队列模式 | ack 机制"></a><strong>可靠队列模式 | ack 机制</strong></h3><p>以上方式中， List 队列中的消息一经发送出去，便从队列里删除。如果由于网络原因消费者没有收到消息，或者消费者在处理这条消息的过程中崩溃了，就再也无法还原出这条消息。究其原因，就是缺少消息确认机制。</p><p>为了保证消息的可靠性，消息队列都会有完善的消息确认机制(Acknowledge)，即消费者向队列报告消息已收到或已处理的机制。</p><p>Redis List 怎么搞一搞呢?</p><p>有两个命令， RPOPLPUSH、BRPOPLPUSH (阻塞)从一个 list 中获取消息的同时把这条消息复制到另一个 list 里(可以当做备份)，而且这个过程是原子的。</p><p>这样我们就可以在业务流程安全结束后，再删除队列元素，实现消息确认机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myqueue one </span><br><span class="line">(integer) 1 </span><br><span class="line">127.0.0.1:6379&gt; rpush myqueue two </span><br><span class="line">(integer) 2 </span><br><span class="line">127.0.0.1:6379&gt; rpush myqueue three </span><br><span class="line">(integer) 3 </span><br><span class="line">127.0.0.1:6379&gt; rpoplpush myqueue queuebak </span><br><span class="line">&quot;three&quot; </span><br><span class="line">127.0.0.1:6379&gt; lrange myqueue 0 -1 </span><br><span class="line">1) &quot;one&quot; </span><br><span class="line">2) &quot;two&quot; </span><br><span class="line">127.0.0.1:6379&gt; lrange queuebak 0 -1 </span><br><span class="line">1) &quot;three&quot; </span><br><span class="line">1.2.3.4.5.6.7.8.9.10.11.12.13.</span><br></pre></td></tr></table></figure><p><a href="https://s2.51cto.com/oss/202101/12/ee1d7097728566b6c3782d9c26b6bbd0.jpg"><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ee1d7097728566b6c3782d9c26b6bbd0.jpg" alt="img"></a></p><p>之前做过的项目中就有用到这样的方式去处理数据，数据标识从一个 List 取出后放入另一个 List，业务操作安全执行完成后，再去删除 List 中的数据，如果有问题的话，很好回滚。</p><p>当然，还有更特殊的场景，可以通过 zset 来实现延时消息队列，原理就是将消息加到 zset 结构后，将要被消费的时间戳设置为对应的 score 即可，只要业务数据不会是重复数据就 OK。</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>List 优点：</p><ul><li>消息可以被持久化，借助 Redis 本身的持久化（AOF、RDB 或者是混合持久化），可以有效的保存数据；</li><li>消费者可以积压消息，不会因为客户端的消息过多而被强行断开。</li></ul><p>List 缺点：</p><ul><li>消息不能被重复消费，一个消息消费完就会被删除；</li><li>没有主题订阅的功能。</li></ul><p>ZSet 优点：</p><ul><li>支持消息持久化；</li><li>相比于 List 查询更方便，ZSet 可以利用 score 属性很方便的完成检索，而 List 则需要遍历整个元素才能检索到某个值。</li></ul><p>ZSet 缺点：</p><ul><li>ZSet 不能存储相同元素的值，也就是如果有消息是重复的，那么只能插入一条信息在有序集合中；</li><li>ZSet 是根据 score 值排序的，不能像 List 一样，按照插入顺序来排序；</li><li>ZSet 没有向 List 的 brpop 那样的阻塞弹出的功能。</li></ul><h2 id="订阅与发布实现消息队列"><a href="#订阅与发布实现消息队列" class="headerlink" title="订阅与发布实现消息队列"></a>订阅与发布实现消息队列</h2><p>我们都知道消息模型有两种</p><ul><li>点对点：Point-to-Point(P2P)</li><li>发布订阅：Publish/Subscribe(Pub/Sub)</li></ul><p>List 实现方式其实就是点对点的模式，下边我们再看下 Redis 的发布订阅模式(消息多播)，这才是“根正苗红”的 Redis MQ。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612194335222.png" alt="image-20240612194335222"></p><h3 id="普通订阅与发布"><a href="#普通订阅与发布" class="headerlink" title="普通订阅与发布"></a>普通订阅与发布</h3><p>消息队列有两个重要的角色，一个是发送者，另一个就是订阅者，对应的命令如下：</p><ul><li>发布消息：publish channel “message”</li><li>订阅消息：subscribe channel</li></ul><p>下面我们来看具体的命令实现。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612195223104.png" alt="image-20240612195223104"></p><p>上方订阅频道 channel，下方在频道 channel 中发布消息。</p><p>此命令支持订阅一个或多个频道的命令，也就是说一个订阅者可以订阅多个频道。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612195632980.png" alt="image-20240612195632980"></p><p><strong>订阅消息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel ...]</span><br></pre></td></tr></table></figure><p><strong>发送消息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure><p>最后的返回值表示成功发送给几个订阅方，1 表示成功发给了一个订阅者，这个数字可以是 0~n，这是由订阅者的数量决定的。</p><h3 id="主题订阅"><a href="#主题订阅" class="headerlink" title="主题订阅"></a>主题订阅</h3><p>上面介绍了普通的订阅与发布模式，但如果我要订阅某一个类型的消息就不适用了，例如我要订阅日志类的消息队列，它们的命名都是 logXXX，这个时候就需要使用 Redis 提供的另一个功能 Pattern Subscribe 主题订阅，这种方式可以使用 <code>*</code> 来匹配多个频道，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c071d520-6905-11ea-bfcb-156eb66fb883" alt="主题订阅2.png"></p><p>主题模式的具体实现代码如下，订阅者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe log_* #主题订阅 log_*</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_user&quot; #接收到频道 log_user 的消息推送</span><br><span class="line">4) &quot;user message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_sys&quot; #接收到频道 log_sys 的消息推送</span><br><span class="line">4) &quot;sys message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_db&quot; #接收到频道 log_db 的消息推送</span><br><span class="line">4) &quot;db message&quot;</span><br></pre></td></tr></table></figure><p>从上面的运行结果，可以看出使用命令 <code>psubscribe log_*</code> 可以接收到所有频道包含 log_XXX 的消息。</p><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psubscribe <span class="keyword">pattern</span> [<span class="keyword">pattern</span> ...]</span><br></pre></td></tr></table></figure><p>生产者的代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish log_user &quot;user message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_sys &quot;sys message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_db &quot;db message&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面我们使用 Jedis 实现普通的发布订阅模式和主题订阅的功能。</p><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a><strong>普通模式</strong></h4><p>消费者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 接收并处理消息</span></span><br><span class="line">    jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 推送消息</span></span><br><span class="line">    jedis.publish(<span class="string">&quot;channel&quot;</span>, <span class="string">&quot;Hello, channel.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布者和订阅者模式运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程作为消费者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure><h4 id="主题订阅模式"><a href="#主题订阅模式" class="headerlink" title="主题订阅模式"></a><strong>主题订阅模式</strong></h4><p>主题订阅模式的生产者的代码是一样，只有消费者的代码是不同的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    jedis.psubscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> &#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(pattern + <span class="string">&quot; 主题 | 频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题模式运行代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; pConsumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel* 主题 | 频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>发布订阅模式存在以下两个缺点：</p><ol><li>无法持久化保存消息，如果 Redis 服务器宕机或重启，那么所有的消息将会丢失；</li><li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li></ol><p>然而这些缺点在 Redis 5.0 添加了 Stream 类型之后会被彻底的解决。</p><p>除了以上缺点外，发布订阅模式还有另一个需要注意问题：当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</p><h3 id="Pub-Sub-常用命令："><a href="#Pub-Sub-常用命令：" class="headerlink" title="Pub/Sub 常用命令："></a>Pub/Sub 常用命令：</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">PSUBSCRIBE</td><td style="text-align:left">PSUBSCRIBE pattern [pattern …]</td><td style="text-align:left">订阅一个或多个符合给定模式的频道</td></tr><tr><td style="text-align:left">PUBSUB</td><td style="text-align:left">PUBSUB subcommand [argument [argument …]]</td><td style="text-align:left">查看订阅与发布系统状态</td></tr><tr><td style="text-align:left">PUBLISH</td><td style="text-align:left">PUBLISH channel message</td><td style="text-align:left">将信息发送到指定的频道</td></tr><tr><td style="text-align:left">PUNSUBSCRIBE</td><td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]</td><td style="text-align:left">退订所有给定模式的频道</td></tr><tr><td style="text-align:left">SUBSCRIBE</td><td style="text-align:left">SUBSCRIBE channel [channel …]</td><td style="text-align:left">订阅给定的一个或多个频道的信息</td></tr><tr><td style="text-align:left">UNSUBSCRIBE</td><td style="text-align:left">UNSUBSCRIBE [channel [channel …]]</td><td style="text-align:left">指退订给定的频道</td></tr></tbody></table></div><h2 id="Stream-实现消息队列"><a href="#Stream-实现消息队列" class="headerlink" title="Stream 实现消息队列"></a>Stream 实现消息队列</h2><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式 PubSub，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>列表实现消息队列的方式不能重复消费，一个消息消费完就会被删除；</li><li>有序集合消息队列的实现方式不能存储相同 value 的消息，并且不能阻塞读取消息。</li></ul><p>并且以上三种方式在实现消息队列时，只能存储单 value 值，也就是如果你要存储一个对象的情况下，必须先序列化成 JSON 字符串，在读取之后还要反序列化成对象才行，这也给用户的使用带来的不便，基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它借鉴了 Kafka 的设计思路，它支持消息的持久化和消息轨迹的消费，支持 ack 确认消息的模式，让消息队列更加的稳定和可靠。</p><p>接下来我们先来了解 Stream 自身的一些特性，然后在综合 Stream 的特性，结合 Java 代码完整的实现一个完美的消息队列示例。</p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>Stream 既然是一个数据类型，那么和其他数据类型相似，它也有一些自己的操作方法，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述</th><th style="text-align:left">用法</th></tr></thead><tbody><tr><td style="text-align:left">添加消息到末尾，保证有序，可以自动生成唯一ID</td><td style="text-align:left">XADD key ID field value [field value …]</td></tr><tr><td style="text-align:left">对流进行修剪，限制长度</td><td style="text-align:left">XTRIM key MAXLEN [~] count</td></tr><tr><td style="text-align:left">删除消息</td><td style="text-align:left">XDEL key ID [ID …]</td></tr><tr><td style="text-align:left">获取流包含的元素数量，即消息长度</td><td style="text-align:left">XLEN key</td></tr><tr><td style="text-align:left">获取消息列表，会自动过滤已经删除的消息</td><td style="text-align:left">XRANGE key start end [COUNT count]</td></tr><tr><td style="text-align:left">以阻塞或非阻塞方式获取消息列表</td><td style="text-align:left">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id [id …]</td></tr><tr><td style="text-align:left">创建消费者组</td><td style="text-align:left">XGROUP [CREATE key groupname id-or-] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</td></tr><tr><td style="text-align:left">读取消费者组中的消息</td><td style="text-align:left">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key …] ID [ID …]</td></tr><tr><td style="text-align:left">将消息标记为”已处理”</td><td style="text-align:left">XACK key group ID [ID …]</td></tr><tr><td style="text-align:left">为消费者组设置新的最后递送消息ID</td><td style="text-align:left">XGROUP SETID [CREATE key groupname id-or-] [DESTROY key groupname]</td></tr><tr><td style="text-align:left">删除消费者</td><td style="text-align:left">XGROUP DELCONSUMER [CREATE key groupname id-or-] [DESTROY key groupname]</td></tr><tr><td style="text-align:left">删除消费者组</td><td style="text-align:left">XGROUP DESTROY [CREATE key groupname id-or-] [DESTROY key groupname] [DEL</td></tr><tr><td style="text-align:left">显示待处理消息的相关信息</td><td style="text-align:left">XPENDING key group [start end count] [consumer]</td></tr><tr><td style="text-align:left">查看流和消费者组的相关信息</td><td style="text-align:left">XINFO [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]</td></tr><tr><td style="text-align:left">打印流信息</td><td style="text-align:left">XINFO STREAM [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]</td></tr></tbody></table></div><p>具体使用如下所述。</p><h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a><strong>添加消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis age 10</span><br><span class="line">&quot;1580880750844-0&quot; #结果返回的是消息 id</span><br></pre></td></tr></table></figure><p>其中 <code>*</code> 表示使用 Redis 的规则：时间戳 + 序号的方式自动生成 ID，用户也可以自己指定 ID。</p><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xadd <span class="keyword">key</span> ID field <span class="type">string</span> [field <span class="type">string</span> ...]</span><br></pre></td></tr></table></figure><h4 id="查询消息的长度"><a href="#查询消息的长度" class="headerlink" title="查询消息的长度"></a><strong>查询消息的长度</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlen <span class="keyword">key</span></span><br></pre></td></tr></table></figure><h4 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a><strong>删除消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis</span><br><span class="line">&quot;1580881585129-0&quot; #消息 ID</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xdel key 1580881585129-0 #删除消息，根据 ID</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdel key ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持删除一条或多条消息，根据消息 ID。</p><h4 id="删除整个-Stream"><a href="#删除整个-Stream" class="headerlink" title="删除整个 Stream"></a><strong>删除整个 Stream</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key #删除整个 Stream</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">del</span> key <span class="selector-attr">[key ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个 Stream。</p><h4 id="查询区间消息"><a href="#查询区间消息" class="headerlink" title="查询区间消息"></a><strong>查询区间消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xrange mq - +</span><br><span class="line">1) 1) &quot;1580882060464-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;redis&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;10&quot;</span><br><span class="line">2) 1) &quot;1580882071524-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;java&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>其中：<code>-</code> 表示第一条消息，<code>+</code> 表示最后一条消息。</p><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xrange key <span class="keyword">start</span> <span class="keyword">end</span> [COUNT count]</span><br></pre></td></tr></table></figure><h4 id="查询某个消息之后的消息"><a href="#查询某个消息之后的消息" class="headerlink" title="查询某个消息之后的消息"></a><strong>查询某个消息之后的消息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 streams mq 1580882060464-0</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580882071524-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;java&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>在名称为 mq 的 Stream 中，从消息 ID 为 1580882060464-0 的，往后查询一条消息。</p><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xread <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[BLOCK milliseconds]</span> STREAMS key <span class="selector-attr">[key ...]</span> ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure><p>此命令提供了阻塞读的参数 block，我们可以使用它读取从当前数据以后新增数据，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br></pre></td></tr></table></figure><p>其中 <code>block 0</code> 表示一直阻塞，<code>$</code> 表示从最后开始读取，这个时候新开一个命令行插入一条数据，此命令展示的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mq * name sql age 20 #新窗口添加数据</span><br><span class="line">&quot;1580890737890-0&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞读取到的新数据</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580890737890-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;sql&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">(36.37s)</span><br></pre></td></tr></table></figure><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 Stream 消费分组实现消息队列的功能和列表方式的消息队列比较相似，使用 xadd 命令和 xread 循环读取就可以实现基础版的消息队列，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id</span> <span class="operator">=</span> jedis.xadd(<span class="string">&quot;mq&quot;</span>, <span class="literal">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，new StreamEntryID().LAST_ENTRY 标识获取当前时间以后的新增消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(<span class="string">&quot;mq&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().LAST_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xread(<span class="number">1</span>, <span class="number">120</span> * <span class="number">1000</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID());</span><br><span class="line">                <span class="comment">// 使用 Gson 来打印 JSON 格式的消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息添加成功 ID：1580895735148-0</span><br><span class="line">读取到消息 ID：1580895735148-0</span><br><span class="line">内容：&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;10&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>以上代码需要特殊说明的是，我们使用 <code>new StreamEntryID().LAST_ENTRY</code> 来实现读取当前时间以后新增的消息，如果要从头读取历史消息把这行代码中的 <code>.LAST_ENTRY</code> 去掉即可。</p><p>还有一点需要注意，在 Jedis 框架中如果使用 jedis.xread() 方法来阻塞读取消息队列，第二个参数 long block 必须设置大于 0，如果设置小于 0，此阻塞条件就无效了，我查看了 jedis 的源码发现，它只有判断在大于 0 的时候才会设置阻塞属性，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    params[streamsIndex++] = Keyword.BLOCK.raw;</span><br><span class="line">    params[streamsIndex++] = Protocol.toByteArray(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 block 属性我们可以设置一个比较大的值来阻塞读取消息。</p><blockquote><p>所谓的阻塞读取消息指的是当队列中没有数据时会进入休眠模式，等有数据之后才会唤醒继续执行。</p></blockquote><h3 id="消息分组"><a href="#消息分组" class="headerlink" title="消息分组"></a>消息分组</h3><p><strong>创建消费者组</strong></p><p>xread 虽然可以扇形分发到 N 个客户端，然而，在某些问题中，我们想要做的不是向许多客户端提供相同的消息流，而是从同一流向许多客户端提供不同的消息子集。比如下图这样，三个消费者按轮训的方式去消费一个 Stream。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8bf0522cc8145d9a177b74c1f99716ae.jpg" alt="img"></p><p>前面我们也提到过，Redis Stream 借鉴了很多 Kafka 的设计。</p><ul><li>Consumer Group：有了消费组的概念，每个消费组状态独立，互不影响，一个消费组可以有多个消费者</li><li>last_delivered_id ：每个消费组会有个游标 last_delivered_id 在数组之上往前移动，表示当前消费组已经消费到哪条消息了</li><li>pending_ids ：消费者的状态变量，作用是维护消费者的未确认的 id。pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack。如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack，它就开始减少。这个 pending_ids 变量在 Redis 官方被称之为 PEL，也就是 Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240612200916341.png" alt="image-20240612200916341"></p><p>Stream 不像 Kafak 那样有分区的概念，如果想实现类似分区的功能，就要在客户端使用一定的策略将消息写到不同的 Stream。</p><ul><li>xgroup create：创建消费者组</li><li>xgreadgroup：读取消费组中的消息</li><li>xack：ack 掉指定消息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息，也可以自己指定</span> </span><br><span class="line">127.0.0.1:6379&gt; xgroup create mystream mygroup $ </span><br><span class="line">OK </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 查看流和消费者组的相关信息，可以查看流、也可以单独查看流下的某个组的信息</span> </span><br><span class="line">127.0.0.1:6379&gt; xinfo stream mystream </span><br><span class="line"> 1) &quot;length&quot; </span><br><span class="line"> 2) (integer) 4  # 共 4 个消息 </span><br><span class="line"> 3) &quot;radix-tree-keys&quot; </span><br><span class="line"> 4) (integer) 1 </span><br><span class="line"> 5) &quot;radix-tree-nodes&quot; </span><br><span class="line"> 6) (integer) 2 </span><br><span class="line"> 7) &quot;last-generated-id&quot; </span><br><span class="line"> 8) &quot;1609408943089-0&quot; </span><br><span class="line"> 9) &quot;groups&quot; </span><br><span class="line">10) (integer) 1  # 一个消费组 </span><br><span class="line">11) &quot;first-entry&quot; # 第一个消息 </span><br><span class="line">12) 1) &quot;1609405178536-0&quot; </span><br><span class="line">    2) 1) &quot;f5&quot; </span><br><span class="line">       2) &quot;v5&quot; </span><br><span class="line">13) &quot;last-entry&quot;  # 最后一个消息 </span><br><span class="line">14) 1) &quot;1609408943089-0&quot; </span><br><span class="line">    2) 1) &quot;f6&quot; </span><br><span class="line">       2) &quot;v6&quot; </span><br><span class="line">127.0.0.1:6379&gt;  </span><br></pre></td></tr></table></figure><p><strong>按消费组消费</strong></p><p>Stream 提供了 xreadgroup 指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息 ID。它同 xread 一样，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 PEL(正在处理的消息) 结构里，客户端处理完毕后使用 xack 指令通知服务器，本条消息已经处理完毕，该消息 ID 就会从 PEL 中移除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#  消费组 mygroup1 中的 消费者 c1 从 mystream 中 消费组数据 </span><br><span class="line"># &gt; 号表示从当前消费组的 last_delivered_id 后面开始读 </span><br><span class="line"># 每当消费者读取一条消息，last_delivered_id 变量就会前进 </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c1 count 1 streams mystream &gt; </span><br><span class="line">1) 1) &quot;mystream&quot; </span><br><span class="line">   2) 1) 1) &quot;1609727806627-0&quot; </span><br><span class="line">         2) 1) &quot;f1&quot; </span><br><span class="line">            2) &quot;v1&quot; </span><br><span class="line">            3) &quot;f2&quot; </span><br><span class="line">            4) &quot;v2&quot; </span><br><span class="line">            5) &quot;f3&quot; </span><br><span class="line">            6) &quot;v3&quot; </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c1 count 1 streams mystream &gt; </span><br><span class="line">1) 1) &quot;mystream&quot; </span><br><span class="line">   2) 1) 1) &quot;1609727818650-0&quot; </span><br><span class="line">         2) 1) &quot;f4&quot; </span><br><span class="line">            2) &quot;v4&quot; </span><br><span class="line"># 已经没有消息可读了             </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c1 count 2 streams mystream &gt; </span><br><span class="line">(nil) </span><br><span class="line"> </span><br><span class="line"># 还可以阻塞式的消费 </span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group mygroup1 c2 block 0 streams mystream &gt; </span><br><span class="line">µ1) 1) &quot;mystream&quot; </span><br><span class="line">   2) 1) 1) &quot;1609728270632-0&quot; </span><br><span class="line">         2) 1) &quot;f5&quot; </span><br><span class="line">            2) &quot;v5&quot; </span><br><span class="line">(89.36s) </span><br><span class="line"> </span><br><span class="line"># 观察消费组信息 </span><br><span class="line">127.0.0.1:6379&gt; xinfo groups mystream </span><br><span class="line">1) 1) &quot;name&quot; </span><br><span class="line">   2) &quot;mygroup1&quot; </span><br><span class="line">   3) &quot;consumers&quot; </span><br><span class="line">   4) (integer) 2  # 2个消费者 </span><br><span class="line">   5) &quot;pending&quot; </span><br><span class="line">   6) (integer) 3   # 共 3 条正在处理的信息还没有 ack </span><br><span class="line">   7) &quot;last-delivered-id&quot; </span><br><span class="line">   8) &quot;1609728270632-0&quot; </span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; xack mystream mygroup1 1609727806627-0  # ack掉指定消息 </span><br><span class="line">(integer) 1 </span><br></pre></td></tr></table></figure><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamGroupExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_STREAM_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq&quot;</span>; <span class="comment">// 流 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;g1&quot;</span>; <span class="comment">// 分组名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_CONSUMER_NAME</span> <span class="operator">=</span> <span class="string">&quot;c1&quot;</span>; <span class="comment">// 消费者 1 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_CONSUMER2_NAME</span> <span class="operator">=</span> <span class="string">&quot;c2&quot;</span>; <span class="comment">// 消费者 2 的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">        <span class="comment">// 创建消费组</span></span><br><span class="line">        createGroup(_STREAM_KEY, _GROUP_NAME);</span><br><span class="line">        <span class="comment">// 消费者 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 消费者 2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer2()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建消费分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stream    流 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 分组名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createGroup</span><span class="params">(String stream, String groupName)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        jedis.xgroupCreate(stream, groupName, <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 添加消息 1</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id</span> <span class="operator">=</span> jedis.xadd(_STREAM_KEY, <span class="literal">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">        <span class="comment">// 添加消息 2</span></span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="type">StreamEntryID</span> <span class="variable">id2</span> <span class="operator">=</span> jedis.xadd(_STREAM_KEY, <span class="literal">null</span>, map2);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="literal">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 1 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER2_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="literal">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 2 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息添加成功 ID：1580971482344-0</span><br><span class="line">消息添加成功 ID：1580971482415-0</span><br><span class="line">Consumer 1 读取到消息 ID：1580971482344-0 内容：&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;redis&quot;</span>&#125;</span><br><span class="line">Consumer 2 读取到消息 ID：1580971482415-0 内容：&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;java&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经对 Stream 实现消息队列有了基本的了解，由于笔者的 redis 版本较低，还不支持 Stream，所以对本小节的理解仅限于阅读层面，并未实际测试。</p><p>个人感觉，目前 Stream还是不能当作主流的 MQ 去使用，使用案例较少，所以仅限于学习一下就好了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节不想其他 Redis 学习是的内容，最重要的东西在我的电脑里面不能运行，所以都是看别人文章来学习的，好在Redis做消息队列并不会经常使用，也不是主流，仅限了解就好。</p><p>在业务上要避免过度复用一个 Redis。既用它做缓存、做计算，还拿它做消息队列，这样的话 Redis 会很累的。</p><p>今天又是在学习 Java 路上的一天，在深入学习 Java 之后，我的眼界好像一下子就被打开了，之前一直觉得在用 Go 写代码时只需要用 <code>go get ……</code> 就可以得到想要的工具包，还嫌弃Java麻烦。有了 Maven 也可以实现类似的效果，加上 Java 的各种工具包十分充足，会有更好的开发体验。</p><p>Java是世界上最好的开发语言.go</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.51cto.com/article/640335.html">https://www.51cto.com/article/640335.html</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/24%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e2%80%94%e2%80%94%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/24%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e2%80%94%e2%80%94%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/25%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%85%b6%e4%bb%96%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/25%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e5%85%b6%e4%bb%96%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/26%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8a%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/26%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8a%ef%bc%89.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/27%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8b%ef%bc%89.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/27%20%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%bb%88%e6%9e%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Stream%ef%bc%88%e4%b8%8b%ef%bc%89.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现如今的互联网应用大多是采用分布式系统机构设计的，所以&lt;strong&gt;消息队列&lt;/strong&gt;已经逐渐成为企业应用系统内部通信的核心手段，它具有&lt;strong&gt;低耦合、可靠投递、广播、流量控制、最终一致性&lt;/strong&gt;等一系列功能。&lt;/p&gt;
&lt;p&gt;当前使用较多的 消息</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文——基础篇（一）</title>
    <link href="http://example.com/2024/06/11/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2024/06/11/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-06-11T11:43:48.000Z</published>
    <updated>2024-06-12T13:53:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>从开始学习 Java 已经有一个多月了，但实际的学习时长应该也就不到一周，刚开始心血来潮苦学两天，发现单是基础内容就多如牛毛，相比于 Go 的简单语法，实在是太过复杂。</p><p>好在不是为了应付考试，所以就先了解了大概的语法内容，后续通过项目和算法题来熟练巩固知识。</p><p>关于八股文，这应该是 Java 最好找的学习资料了，但凡是与其他具体内容有关的知识基本都是收费的，感觉不如 Go (bushi)。今天就先记录一部分已经学过的知识吧，以免后面忘记了。</p><h1 id="基础概念和常识"><a href="#基础概念和常识" class="headerlink" title="基础概念和常识"></a>基础概念和常识</h1><p>本节学习 Java 的语言特性内容。</p><h2 id="Java-的语言特性"><a href="#Java-的语言特性" class="headerlink" title="Java 的语言特性"></a>Java 的语言特性</h2><p>Java 有很多优秀的特点，以下是几个比较突出的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-2.png" alt="Java语言特点"></p><ol><li>面型对象：封装、继承、多态。</li><li>平台无关性： Java 虚拟机实现平台无关性。</li><li>支持多线程：C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；</li><li>支持 JIT 编译：JIT 是 Just-In-Time 的缩写，指的是即时编译器，它可以在程序运行时将字节码转换为本地机器码来提高程序运行速度。</li></ol><p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天依然有很多人觉得跨平台是 Java 最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p><h2 id="JVM、JDK-和-JRE"><a href="#JVM、JDK-和-JRE" class="headerlink" title="JVM、JDK 和 JRE"></a>JVM、JDK 和 JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节吗的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言<code>“一次编译，随处可以运行”</code>的关键所在。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言"></p><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><hr><p>也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/jdk-include-jre.png" alt="JDK 包含 JRE"></p><p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ <a href="http://openjdk.java.net/jeps/282">jlinkopen in new window</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。</p><p>在 <a href="https://javaguide.cn/java/new-features/java9.html">Java 9 新特性概览open in new window</a>这篇文章中：</p><blockquote><p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p></blockquote><p>也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的 JRE。</p><p>定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的。</p><h2 id="什么是字节码？字节码的好处是什么？"><a href="#什么是字节码？字节码的好处是什么？" class="headerlink" title="什么是字节码？字节码的好处是什么？"></a>什么是字节码？字节码的好处是什么？</h2><p>所谓的字节码，就是 Java 程序经过编译之类产生的 <code>.class</code> 文件，字节码不面向任何特定的处理器，只面向虚拟机，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-4.png" alt="Java程序执行过程"></p><p>只需要把 Java 程序编译成 Java 虚拟机能识别的 Java 字节码，不同的平台安装对应的 Java 虚拟机，这样就可以可以实现 Java 语言的平台无关性。</p><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p><blockquote><p>HotSpot（热点代码） 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p></blockquote><p>下面这张图是 JVM 的大致结构模型。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/jvm-rough-structure-model.png" alt="JVM 的大致结构模型"></p><h2 id="“编译与解释并存”？"><a href="#“编译与解释并存”？" class="headerlink" title="“编译与解释并存”？"></a>“编译与解释并存”？</h2><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。</p><p>简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/compiled-and-interpreted-languages.png" alt="编译型语言和解释型语言"></p><p>比如，你想读一本外国的小说，你可以找一个翻译人员帮助你翻译，有两种选择方式，你可以先等翻译人员将全本的小说（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须再经过 JVM 解释成操作系统能识别的机器码，再由操作系统执行。因此，我们可以认为 Java 语言<strong>编译</strong>与<strong>解释</strong>并存。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240611202213215.png" alt="image-20240611202213215"></p><h2 id="AOT是什么？AOT有什么优点？为什么不全部使用AOT？"><a href="#AOT是什么？AOT有什么优点？为什么不全部使用AOT？" class="headerlink" title="AOT是什么？AOT有什么优点？为什么不全部使用AOT？"></a>AOT是什么？AOT有什么优点？为什么不全部使用AOT？</h2><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p><strong>JIT 与 AOT 两者的关键指标对比</strong>:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/jit-vs-aot.png" alt="JIT vs AOT">JIT vs AOT</p><p>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>提到 AOT 就不得不提 <a href="https://www.graalvm.org/">GraalVMopen in new window</a> 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。</p><p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><p>本节记录 Java 中一些基础数据类型相关的问题。</p><h2 id="什么是自动拆箱-装箱？"><a href="#什么是自动拆箱-装箱？" class="headerlink" title="什么是自动拆箱/装箱？"></a>什么是自动拆箱/装箱？</h2><ul><li><strong>装箱</strong>：将基本数据类型转换为包装类型（Byte、Short、Integer、Long、Float、Double、Character、Boolean）。</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-8.png" alt="三分恶面渣逆袭:装箱和拆箱">三分恶面渣逆袭:装箱和拆箱</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>上面这两行代码对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h2 id="为什么有了基本类型还要设计包装类型？"><a href="#为什么有了基本类型还要设计包装类型？" class="headerlink" title="为什么有了基本类型还要设计包装类型？"></a>为什么有了基本类型还要设计包装类型？</h2><blockquote><p>Java 一共设计了八种基础类型，每一种基础类型都会对应着唯一的包装类，为什么要这样设计，不是多此一举吗？</p></blockquote><p>在 Java 里面，之所以要对基础类型设计一个对应的封装类型，是因为 Java 本身是一门面向对象的语言，对象是 Java 的基础操作单元，我们时时刻刻都在创建对象，也随时都在使用对象，很多时候传递数据也需要对象，不如 <code>ArrayList、HashMap</code> 这些集合，只能存储对象类型，因此封装类型存在的意义还是很大的。</p><p>此外，封装类型还有很多好处，如安全性好，可以避免外部操作随意修改成员变量的值，保证了成员变量和数据传递的安全性；隐藏了实现细节，对使用者更加友好，只需要调用对象提供的方法就可以完成对应的操作</p><p>在定义基础数据类型时，我们可以直接定义一个变量名并赋值；但是包装类型需要使用 <code>new</code> 关键字创建对象基本类型。当两种类型混合使用时，Java 会自动通过拆箱和封箱实现类型转换。</p><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p> 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><h2 id="包装类型的缓存机制（享元模式）"><a href="#包装类型的缓存机制（享元模式）" class="headerlink" title="包装类型的缓存机制（享元模式）"></a>包装类型的缓存机制（享元模式）</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><hr><p>正是由于这个特性，衍生出另外一个经典的面试题。</p><h3 id="为什么-1000-1000为-false，100-100为true？"><a href="#为什么-1000-1000为-false，100-100为true？" class="headerlink" title="为什么 1000==1000为 false，100==100为true？"></a>为什么 <code>1000==1000</code>为 false，<code>100==100</code>为true？</h3><p>还记得 integer 的缓存范围吗？[-128, 127]，而 1000 超过了它的缓存范围，则会重新创建一个新的对象。而 <code>==</code> 比较的又是两个标识符引用的对象是否相同，所以才会出现这么一个看起来没问题的问题。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>本节记录有关变量的问题。</p><h2 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h2><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p><p><strong>为什么成员变量有默认值？</strong></p><ol><li>先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</li><li>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</li><li>对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。</li></ol><h2 id="静态变量有什么用？"><a href="#静态变量有什么用？" class="headerlink" title="静态变量有什么用？"></a>静态变量有什么用？</h2><p>静态变量也就是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p><p>静态变量是通过类名来访问的，例如<code>StaticVariableExample.staticVar</code>（如果被 <code>private</code>关键字修饰就无法这样访问了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h2><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>《Java 核心技术》这本书是这样介绍重载的：</p><blockquote><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>Java 允许重载任何方法， 而不只是构造器方法。</p></blockquote><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><div class="table-container"><table><thead><tr><th><strong>区别点</strong></th><th><strong>重载</strong></th><th><strong>重写</strong></th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table></div><p><strong>方法的重写要遵循“两同两小一大”</strong></p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超人&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Hero <span class="title function_">hero</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title class_">SuperMan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SuperMan <span class="title function_">hero</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面就简单写了一些在初学 Java 时了解到的一些八股文的内容，当然这只是非常皮毛的一部分。重要内容还是要到面向对象开始之后才行，慢慢来吧。</p><p>汇报一下现在的学习进度，现在开始跟着黑马的视频基本了解一下 Java 开发时会用到的框架，像 JavaWeb、Spring Boot、Mybatis等等，不得不说，想要从头学一个东西确实很难，光是配置环境我就被整的焦头烂额。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从开始学习 Java 已经有一个多月了，但实际的学习时长应该也就不到一周，刚开始心血来潮苦学两天，发现单是基础内容就多如牛毛，相比于 Go 的简单语法，实在是太过复杂。&lt;/p&gt;
&lt;p&gt;好在不是为了应付考试，所以就先了解了大概的语法内容，后续通过项目和算法题来熟练巩固知识。&lt;</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Why Java? Why not Java?</title>
    <link href="http://example.com/2024/06/10/Why%20Java%20Why%20not%20Java/"/>
    <id>http://example.com/2024/06/10/Why%20Java%20Why%20not%20Java/</id>
    <published>2024-06-10T08:57:14.000Z</published>
    <updated>2024-06-10T12:42:36.417Z</updated>
    
    <content type="html"><![CDATA[<p>对的，没错，这是一篇记录笔者从零开始学习 Java 的博客，后面还会有更多关于 Java 的博客被记录。</p><p>关于 Java 学习过程中的那些基础知识，在这里就不过多的去介绍了，没什么意义，更多还是去聊一下面向对象或者一些新奇的东西。</p><p>既然是开篇之作，还是多写一点轻松的内容，其实就是还没有总结完。所以文本就简单写一下我对 Java 的认识吧。</p><h1 id="我与-Java"><a href="#我与-Java" class="headerlink" title="我与 Java"></a>我与 Java</h1><p>关于 Java，应该是除了 C++ 之外我最先了解到的编程语言了，其实在大一上没结束的时候我就已经开始准备选择一个语言进行学习，为以后找工作打算了。</p><p>大一的我提起 Java，觉得不够有趣，选择 Python；大二的我提起 Java，嗤之以鼻，想着学了它，那我和大专的学生有什么区别；大三的我提起 Java，想到被 Go 语言的实习打击的惨样，悲从中来，后悔没有早点学。呜呜呜……</p><p>就像这个系列里的分类一样，我对 Java 的态度从”Java？狗都不学“ 到 ”Java！！！世界上最好的语言“。很抽象，但没办法。</p><hr><p>不知道你有没有想过，世界上有那么多编程语言，每种语言都有自己的特性，为什么 Java 能如此流行，在各行各业都被广泛使用，兴趣才是学习的第一动力，所以还是应该先了解一下 Java 的历史和设计哲学。</p><h1 id="Java-的诞生"><a href="#Java-的诞生" class="headerlink" title="Java 的诞生"></a>Java 的诞生</h1><p>计算机业内一般认为：B 语言导致了 C 语言的诞生，C 语言演变出了 C++，而 C++ 会被 Java 语言所打败。是什么导致了 Java 的诞生？想要解决这个问题，我们先来看看 Java 的前辈们。</p><h2 id="C-语言的诞生"><a href="#C-语言的诞生" class="headerlink" title="C 语言的诞生"></a>C 语言的诞生</h2><p>C 语言的产生是人们追求结构化、高效率、高级语言的结果，它可以替代汇编进行开发，它的出现改变了人们之前的编程方法和思路。</p><p>C 语言的出现解决了之前语言的各种不足，比如：FORTRAN 高效但不适用于编写系统程序。BASIC 虽然容易学习，但是功能不够强大。汇编高效，但是学习成本很大，且很难调试。</p><p>另外，C 语言之前的语言没有考虑结构化设计。它们大量使用 <code>GOTO</code> 语句来对程序进行控制。这样做的结果是<strong>程序极其混乱</strong>，各种跳转和条件分支交织在一起极大地影响了程序的可读性。人们解决该问题的愿望非常强烈，且日益迫切。20世界70年代初，计算机革命开始，人们对于软件的需求日益增加，使用当时的语言开发软件已经无法满足需求。人们在此期间进行了很多的尝试，但是没有发明出更好的语言。直到一个新机遇的到来：<strong>计算机硬件资源的富余</strong>。由于计算机硬件的增多，程序员可以随意的使用计算机，随意进行各种尝试，这就给了他们开发自己工具的机会。后来Ken Thompson (同样是 Go 语言之父) 发明了 B 语言，B 语言演化到了 C 语言。1989年美国国家标准化组织制定了 C 语言的标准，C 语言被正式标准化。C 语言是由程序员对编程实践的总结而发明出来的，它能够解决早期语言的种种缺陷。</p><h2 id="C-的诞生"><a href="#C-的诞生" class="headerlink" title="C++ 的诞生"></a>C++ 的诞生</h2><p>C语言被用的好好的，为何出现了C++呢？原因是C语言太复杂了。当一个工程项目达到一定规模之后，使用结构化编程方法，编程人员就无法对它的复杂性进行有效管理。20世纪80年代初期，许多工程项目的复杂性都超过了结构化方法的极限。为了解决这个问题，面向对象诞生了。<strong>面向对象的特性：继承，封装，多态</strong>是用来帮助组织复杂程序的编程方法。因此出现了C++，C++ 的产生是基于 C 的，它包含了 C 的所有特征，属性和优点。</p><h2 id="Java出现的时机到了"><a href="#Java出现的时机到了" class="headerlink" title="Java出现的时机到了"></a>Java出现的时机到了</h2><p>在20世纪80年代末到90年代初，使用面向对象的 C++ 语言占主导地位。然而，推动计算机语言进化的力量正在酝酿。万维网（WWW）和Internet在随后的几年达到了临界状态，这就促成了编程的另一场革命。</p><h3 id="Java-诞生"><a href="#Java-诞生" class="headerlink" title="Java 诞生"></a>Java 诞生</h3><p>由于嵌入式系统的发展，人们对一种独立于平台的语言更加渴望，这种语言可以嵌入微波炉，遥控器等各种家用电器设备的软件。用作控制器芯片的CPU是多种多样的，但是C和C++只能对特定目标进行编译。比如某个CPU要编译C++代码，那么就要创建一个针对该CPU的C++编译器，而创建编译器是一项耗时耗长，耗资大的工作。为了解决这个问题，Gosling和其他人一直在开发一种可移植，跨平台的语言。该语言能够生成运行于不同环境，不同CPU芯片上的代码。经过不懈的努力，在1991年被James Gosling，Patrick Naughton，Chris Warth，Ed Frank和Mike Sheridan发明出来。第一版花了18个月。刚开始叫 Oak，于1995年更名为 Java。</p><blockquote><p>有趣的知识：JAVA其实是印度尼西亚一座岛屿的名称，中文名也叫爪哇，因盛产咖啡而出名。据说许多程序设计师工作之余都喜欢来一杯热腾腾的香浓咖啡，，并从中得到灵感，JAVA的寓意是为世人端上一杯热咖啡，因此JAVA的logo就是一个热气腾腾的咖啡形状。</p><p>  Oak正是由JAVA之父James Gosling领导的绿色计划(Green Project)中的产品，在1995年更名为JAVA，并在SunWord大会上正式提出了”Write Once，Run Anywhere”口号。<strong>岁月如流，转眼间距离第一个JAVA版本诞生到现在已经20多年的时间，通过下面的时间线，一起回顾那些年我们学习过的JAVA。</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d30e34758a114691af5f058489b158df%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211129234040459"></p><h3 id="Java-流行"><a href="#Java-流行" class="headerlink" title="Java 流行"></a>Java 流行</h3><p>在万维网（WWW）出现之前Java处于有用、默默无闻的用于电子消费品编程的状态。然而由于万维网的出现，Java被推到了计算机语言的设计的最前沿，<strong>因为万维网也需要可移植的程序。</strong></p><p>因特网是由不同的、分布式的系统组成，其中包含各种类型的计算机，操作系统和CPU。尽管许多类型的平台都可以与因特网连接，但是用户仍然希望他们能够运行同样的程序。</p><p>1993年，Java设计小组的成员发现解决嵌入式控制器可移植性的方法，也可以用来解决因特网的代码的可移植性问题。也就是Java不仅可以用来解决小范围的问题，也可以用来解决大范围的问题。这样他们将Java的重心由电子消费品，转移到Internet编程上。</p><h1 id="Java-能够长久不衰的原因"><a href="#Java-能够长久不衰的原因" class="headerlink" title="Java 能够长久不衰的原因"></a>Java 能够长久不衰的原因</h1><p>从1995年在Sun World大会上的1.0版本正式提出“Write Once,Run Anywhere”到现在常年占据编程语言流行排行榜Top3，JAVA为什么能够如此受欢迎？下面我们就来盘点盘点！</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>所谓面向对象指的是在进行程序开发时将应用程序的数据及操作方法封装成一个便于我们理解的”对象”的特性，使我们在开发过程能够更易理解、并实现信息的封装及模块化。</p><p>简单讲就是一个程序就可以被抽象成一个人，一个人会有两个眼睛、一个嘴巴等属性，可以有吃饭、行走等行为，程序也可以抽象成类似的属性和行为。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240610203303974.png" alt="image-20240610203303974"></p><h2 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h2><p>说一个东西简不简单其实是需要有东西对比才能够体现出来，了解或者学习过其他语言(如C++)的小伙伴就知道，JAVA中大体上语法和C++相类似，但是C++中一些比较难以理解、容易混淆的概念在JAVA中是没有的(如指针)，JAVA是通过一种更清楚、更易理解的方式(即引用)来实现这些容易让人混淆的概念，所以对比起来就会感觉JAVA是更加简单的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d7c27d9ddd7d45788812403d93d407b3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211130233811412"></p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p><strong>跨平台指的是使用JAVA语言开发的程序能够运行在不同的软件平台和硬件平台上。</strong> 程序最终的执行是需要转成计算机硬件的机器指令来执行，而不同操作系统的、不同的计算机硬件是存在差异的，因此专门为某一种计算机硬件或者软件开发的程序直接放在另一个计算机硬件上是无法执行的(就像让大人穿小孩子的衣服，撑爆了也穿不进去)，至少需要做移植操作，比如有些在Windows系统上编译的应用程序是无法直接拿到Unix系统上运行的。</p><p>想要解决这个问题，则需要程序语言不依赖于特定的操作系统或硬件，JAVA语言则正好满足这个条件，<strong>JAVA中引入了虚拟机概念，JVM实现了不同平台的JAVA接口，屏蔽了底层硬件的差异性，JAVA编译器将JAVA语言开发的程序编程成与计算机结构无关的字节码(也就是我们常说的class文件),只要安装了JAVA虚拟机，JAVA应用程序就可以在相应的环境下被执行。</strong>因此，Java 也有着“一次编译，到处运行”的顺口溜。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-5.png" alt="编译与解释"></p><h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p><strong>何为健壮性：通俗理解含义是软件(程序)对于规范要求以外的输入能够判断出这个输入不符合规范要求，并能有合理的处理方式。</strong> 比如：一个字段取值只允许为数组和字母，但是用户却输入了中文，此时，对于规范以外(非数组和字母)的输入，程序需要能够作出合理的响应(如提示用户输入不符合规范)，而不是直接报错或者无响应。</p><p>再举个通俗的例子：你到银行提款机取钱，但是输入密码后提款机就卡死了，该怎么办？这时候你可以请求柜员帮助，柜员可以理解为银行为异常情况提供了一个兜底方案，这时候你肯定会给银行好评，因为如果没有柜员，提款机卡死后你除了等待就无法做其他事情，想要拿回银行卡就可能需要等到银行派专门人来才行，这时候用户体验就会非常差，程序亦是如此。</p><p>使用JAVA语言编写的程序则具有这方面的特性。<strong>首先JAVA语言程序会在编译和运行时对可能出现的问题进行检查，减少因未知原因导致程序崩溃的情况。同时，JAVA语言提供了异常处理机制，它能够在编译时提示未被处理异常或者为运行抛出异常提供兜底方案，防止程序崩溃。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240610203738049.png" alt=""></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>JAVA可以说是一种安全的网络语言，它屏蔽了指针类型，对内存的操作通过对象实例实现，同时，JAVA还在编译、解释层面进行了安全性的保证。</p><p>如：在编译层，JAVA会进行各种语法检测，不满足语法的写法在编译时报错无法被解释执行，在解释层，会对JAVA程序编译出来的字节码校验，同时还会进行代码段格式、类型转换是否合法等方面的检查，从而保障程序执行的一个安全性。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8278d53ec1924334a91697ed46d83ba2%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211201220414352"></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>随着科技的发展，人们对软件的使用体验有了更高的要求，响应速度就是其中非常重要的指标。JAVA内置了多线程的支持，通过多线程，计算机可以同时处理多个任务，因为处理器处速度远快于人接受信息的速度，人们会感觉软件的响应非常快，用户体验非常好。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/19953134ae51449eafd911ada0b9df85%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211201221700156"></p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>JAVA的可移植性主要与它的跨平台(平台无关性)有关，JAVA中的类库也实现了与平台无关的接口，从而具有了可移植性。JAVA的编译器也是使用JAVA语言编写的(源码可查看：<a href="https://link.juejin.cn?target=http%3A%2F%2Fhg.openjdk.java.net%2Fjdk6%2Fjdk6%2Flangtools%2Ffile%2F779c45081059%2Fsrc%2Fshare%2Fclasses%2Fcom%2Fsun%2Ftools%2Fjavac">JAVA编译器实现</a>)，解释器则是由标准的C实现，所以整个JAVA系统都具有可移植性。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/800b98d785ea421e97439302cf8a046f%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image-20211201222423285"></p><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><p>JAVA中基础的单元就是类，类可以是开发者自定义，也可以是引用第三方定义好的类库，<strong>在JAVA中，类是运行时动态进行状态的，因此对类库添加新的属性和方法无序重新编译程序，这样JAVA就实现了动态维护程序和引用的类库。</strong></p><p>而C/C++则是在编译时将相应的函数库或类库中使用到的类、函数生成机器码，如果后续类库升级如添加了新的函数，则C/C++程序想要使用类库中新增的功能，需要对程序进行重新修改、编译。</p><h2 id="社区活跃度高、文档齐全"><a href="#社区活跃度高、文档齐全" class="headerlink" title="社区活跃度高、文档齐全"></a>社区活跃度高、文档齐全</h2><p>这个特点是得益于前面的描述的8个特点，正是因为JAVA语言有简单、跨平台等特性，才会吸引大量的开发者，社区的活跃度才会高，层层嵌套，所以JAVA才会流行至今。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>什么？你要学 Java？你为什么学 Java？</p><p>这是我的朋友们在知道我开始学 Java 之后问的最多的问题，在开始学之前，我们问了自己很多次这些问题。我为什么要从头开始学 Java？实在是现如今几乎所有公司都在使用 Java 这门语言，它好像一个无所不能的神，统治者国内的大小公司。</p><p>Go 语言绝对算得上目前为止我最喜欢得一个编程语言了，这一是我坚持学习时间最长得语言，但是找了三个月的实习，实在是太艰难了，大厂只有几家可以投，大多数科技公司都不会使用 Go 语言进行开发，小厂就更不用提了，所有的加在一起估计都没有 Java 的零头多。我毕竟不是一个理想主义者，还是务实一点的。</p><p>其实如果不是时间紧张，我应该也会对 Java 感兴趣，但是学习时间实在是太短了，而且暂时还没有找到很好的教程，只能像一个没头苍蝇一样到处乱撞。在更加深入学习之前，还是要先摆平心态。</p><p>本文到此就正式结束了，其实就是想说一下我要开始学 Java 了，最近几天要整理一下基础的知识点，在下一篇博客中记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对的，没错，这是一篇记录笔者从零开始学习 Java 的博客，后面还会有更多关于 Java 的博客被记录。&lt;/p&gt;
&lt;p&gt;关于 Java 学习过程中的那些基础知识，在这里就不过多的去介绍了，没什么意义，更多还是去聊一下面向对象或者一些新奇的东西。&lt;/p&gt;
&lt;p&gt;既然是开篇之作</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis家族再添新成员：探索Bitmaps、HyperLogLog和Geo的魅力</title>
    <link href="http://example.com/2024/06/10/Redis%E5%AE%B6%E6%97%8F%E5%86%8D%E6%B7%BB%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%8E%A2%E7%B4%A2Bitmaps%E3%80%81HyperLogLog%E5%92%8CGeo%E7%9A%84%E9%AD%85%E5%8A%9B/"/>
    <id>http://example.com/2024/06/10/Redis%E5%AE%B6%E6%97%8F%E5%86%8D%E6%B7%BB%E6%96%B0%E6%88%90%E5%91%98%EF%BC%9A%E6%8E%A2%E7%B4%A2Bitmaps%E3%80%81HyperLogLog%E5%92%8CGeo%E7%9A%84%E9%AD%85%E5%8A%9B/</id>
    <published>2024-06-10T07:40:09.000Z</published>
    <updated>2024-06-10T08:53:02.875Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的博客中，我们已经学习了 Redis 中的五种基础数据结构和六种底层数据结构。随着 Redis 在江湖上的名气越来越大，又有不少的英雄豪杰加入了 Redis 这一大帮派。</p><p>这个家族又迎来了三位新的成员：Bitmaps、HyperLogLog 和 Geo，三者各怀绝技，进一步巩固了Redis在数据江湖中的地位。</p><p>接下来就让我们来看一下这三位的实力把。</p><h1 id="Bitmaps-：位操作的巧匠"><a href="#Bitmaps-：位操作的巧匠" class="headerlink" title="Bitmaps ：位操作的巧匠"></a>Bitmaps ：位操作的巧匠</h1><p>根据官网介绍：</p><blockquote><p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p><p>Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。</p></blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p><h2 id="用来解决什么问题？"><a href="#用来解决什么问题？" class="headerlink" title="用来解决什么问题？"></a>用来解决什么问题？</h2><p>思考一个问题，在一个场景下，我们需要存储大规模的布尔数据类型，比如用户的签到信息、用户是否在线、某个时间段用户是否观看了某个视频等等。使用传统的数据结构可能会消耗大量的内存。</p><p>那要怎么实现我们想要的功能？</p><p>使用 <code>Bitmaps</code> 。bitmap 最大的优势之一是存储信息时，它经常可以极大的节省空间。例如，一个用户的系统中，使用递增的 id 来表示不同的用户，这时候 bitmap 使用 512MB 内存就可以记录 40 亿用户的一个比特信息（例如，1是男生，0是女生，一个男生的id为19，那么这个 bitmap 的第 19 位就是 1）。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="img"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之前值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 …</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td></tr></tbody></table></div><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>查看某一天是否有打卡！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>统计操作，统计 打卡的天数！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p><ul><li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><h1 id="HyperLogLog：基数估计的神算"><a href="#HyperLogLog：基数估计的神算" class="headerlink" title="HyperLogLog：基数估计的神算"></a>HyperLogLog：基数估计的神算</h1><h2 id="为什么要使用-HyperLogLog"><a href="#为什么要使用-HyperLogLog" class="headerlink" title="为什么要使用 HyperLogLog"></a>为什么要使用 <code>HyperLogLog</code></h2><p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p><p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p><p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p><p>HLL 具有以下几个特点：</p><ul><li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li><li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li><li>误差可以被设置辅助计算因子进行降低。</li></ul><p>Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p><ul><li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element <span class="selector-attr">[element ...]</span></span><br></pre></td></tr></table></figure><p>此命令支持添加一个或多个元素至 HLL 结构中。</p><h4 id="统计不重复的元素"><a href="#统计不重复的元素" class="headerlink" title="统计不重复的元素"></a><strong>统计不重复的元素</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p><p>相关语法：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持统计一个或多个 HLL 结构。</p><h4 id="合并一个或多个-HLL-至新结构"><a href="#合并一个或多个-HLL-至新结构" class="headerlink" title="合并一个或多个 HLL 至新结构"></a><strong>合并一个或多个 HLL 至新结构</strong></h4><p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd k &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd k2 &quot;redis&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge k3 k k2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount k3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey <span class="selector-attr">[sourcekey ...]</span></span><br></pre></td></tr></table></figure><p><strong>pfmerge 使用场景</strong></p><p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>接下来我们使用 Java 代码来实现 HLL 的三个基础功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HyperLogLogExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计元素</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> jedis.pfcount(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印统计元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k：&quot;</span> + count);</span><br><span class="line">        <span class="comment">// 合并 HLL</span></span><br><span class="line">        jedis.pfmerge(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印新 HLL</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k2：&quot;</span> + jedis.pfcount(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k：2</span><br><span class="line">k2：2</span><br></pre></td></tr></table></figure><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>HyperLogLog 算法来源于论文 <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</em></a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p><p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p><ul><li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li><li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li><li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li></ul><p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p><p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p><p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p><blockquote><p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500‬ 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1⁄1000+1⁄100000)≈1998 元，显然此算法更符合实际平均数。</p></blockquote><p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文。</p><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p><ul><li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul><h1 id="Geo：地理位置的游侠"><a href="#Geo：地理位置的游侠" class="headerlink" title="Geo：地理位置的游侠"></a>Geo：地理位置的游侠</h1><p>受过高等教育的我们都知道，我们所处的任何位置都可以用经度和纬度来标识，经度的范围 -180 到 180，纬度的范围为 -90 到 90。纬度以赤道为界，赤道以南为负数，赤道以北为正数；经度以本初子午线（英国格林尼治天文台）为界，东边为正数，西边为负数。</p><p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，GEO 本质上是基于 ZSet 实现的。</p><p>关于 GEO 的命令不多，主要包含以下 6 个：</p><ol><li>geoadd：添加地理位置</li><li>geopos：查询位置信息</li><li>geodist：距离统计</li><li>georadius：查询某位置内的其他成员信息</li><li>geohash：查询位置的哈希值</li><li>zrem：删除地理位置</li></ol><p>下面我们分别来看这些命令的使用。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="添加地理位置"><a href="#添加地理位置" class="headerlink" title="添加地理位置"></a><strong>添加地理位置</strong></h3><p>我们先用百度地图提供的经纬度查询工具，地址：</p><blockquote><p><a href="http://api.map.baidu.com/lbsapi/getpoint/index.html">http://api.map.baidu.com/lbsapi/getpoint/index.html</a></p></blockquote><p>如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/assets/c91f60b0-63a2-11ea-99a6-09fef5109e7b" alt="百度经纬度查询工具.png"></p><p>找了以下 4 个地点，添加到 Redis 中：</p><ol><li>天安门：116.404269,39.913164</li><li>月坛公园：116.36,39.922461</li><li>北京欢乐谷：116.499705,39.874635</li><li>香山公园：116.193275,39.996348</li></ol><p>代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd site 116.404269 39.913164 tianan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.36 39.922461 yuetan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.499705 39.874635 huanle</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.193275 39.996348 xiangshan</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude <span class="keyword">member</span> [longitude latitude <span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>重点参数说明如下：</p><ul><li>longitude 表示经度</li><li>latitude 表示纬度</li><li>member 是为此经纬度起的名字</li></ul><p>此命令支持一次添加一个或多个位置信息。</p><h3 id="查询位置信息"><a href="#查询位置信息" class="headerlink" title="查询位置信息"></a><strong>查询位置信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos site tianan</span><br><span class="line">1) 1) &quot;116.40541702508926392&quot;</span><br><span class="line">   2) &quot;39.91316289865137179&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持查看一个或多个位置信息。</p><h3 id="距离统计"><a href="#距离统计" class="headerlink" title="距离统计"></a><strong>距离统计</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist site tianan yuetan km</span><br><span class="line">&quot;3.9153&quot;</span><br></pre></td></tr></table></figure><p>可以看出天安门距离月坛公园的直线距离大概是 3.9 km，我们打开地图使用工具测试一下咱们的统计结果是否准确，如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/assets/de8bb110-63a2-11ea-b997-6566d32f1735" alt="天安门到月坛公园距离统计图.png"></p><p>可以看出 Redis 的统计和使用地图工具统计的距离是完全吻合的。</p><blockquote><p>注意：此命令统计的距离为两个位置的直线距离。</p></blockquote><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 <span class="selector-attr">[unit]</span></span><br></pre></td></tr></table></figure><p>unit 参数表示统计单位，它可以设置以下值：</p><ul><li>m：以米为单位，默认单位；</li><li>km：以千米为单位；</li><li>mi：以英里为单位；</li><li>ft：以英尺为单位。</li></ul><h3 id="查询某位置内的其他成员信息"><a href="#查询某位置内的其他成员信息" class="headerlink" title="查询某位置内的其他成员信息"></a><strong>查询某位置内的其他成员信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>此命令的意思是查询天安门（116.405419,39.913164）附近 5 公里范围内的成员列表。</p><p>相关语法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">georadius</span> <span class="selector-tag">key</span> <span class="selector-tag">longitude</span> <span class="selector-tag">latitude</span> <span class="selector-tag">radius</span> <span class="selector-tag">m</span>|<span class="selector-tag">km</span>|<span class="selector-tag">ft</span>|<span class="selector-tag">mi</span> <span class="selector-attr">[WITHCOORD]</span> <span class="selector-attr">[WITHDIST]</span> <span class="selector-attr">[WITHHASH]</span> <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[ASC|DESC]</span></span><br></pre></td></tr></table></figure><p>可选参数说明如下。</p><p><strong>1. WITHCOORD</strong></p><p>说明：返回满足条件位置的经纬度信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withcoord</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) 1) &quot;116.40426903963088989&quot;</span><br><span class="line">      2) &quot;39.91316289865137179&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) 1) &quot;116.36000186204910278&quot;</span><br><span class="line">      2) &quot;39.92246025586381819&quot;</span><br></pre></td></tr></table></figure><p><strong>2. WITHDIST</strong></p><p>说明：返回满足条件位置与查询位置的直线距离。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br></pre></td></tr></table></figure><p><strong>3. WITHHASH</strong></p><p>说明：返回满足条件位置的哈希信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withhash</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) (integer) 4069885552230465</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) (integer) 4069879797297521</span><br></pre></td></tr></table></figure><p><strong>4. COUNT count</strong></p><p>说明：指定返回满足条件位置的个数。</p><p>例如，指定返回一条满足条件的信息，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km count 1</span><br><span class="line">1) &quot;tianan&quot;</span><br></pre></td></tr></table></figure><p><strong>5. ASC|DESC</strong></p><p>说明：从近到远|从远到近排序返回。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km desc</span><br><span class="line">1) &quot;yuetan&quot;</span><br><span class="line">2) &quot;tianan&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km asc</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>当然以上这些可选参数也可以一起使用，例如以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist desc</span><br><span class="line">1) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br><span class="line">2) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br></pre></td></tr></table></figure><p><strong>5. 查询哈希值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash site tianan</span><br><span class="line">1) &quot;wx4g0cgp000&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持查询一个或多个地址的哈希值。</p><p><strong>6. 删除地理位置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem site xiaoming</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个位置信息。</p><h2 id="代码实战-1"><a href="#代码实战-1" class="headerlink" title="代码实战"></a>代码实战</h2><p>下面我们用 Java 代码，来实现查询附近的人，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoCoordinate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoRadiusResponse;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoUnit;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeoHashExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, GeoCoordinate&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加小明的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoming&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.404269</span>, <span class="number">39.913164</span>));</span><br><span class="line">        <span class="comment">// 添加小红的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaohong&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.36</span>, <span class="number">39.922461</span>));</span><br><span class="line">        <span class="comment">// 添加小美的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaomei&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.499705</span>, <span class="number">39.874635</span>));</span><br><span class="line">        <span class="comment">// 添加小二</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoer&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoCoordinate</span>(<span class="number">116.193275</span>, <span class="number">39.996348</span>));</span><br><span class="line">        jedis.geoadd(<span class="string">&quot;person&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询小明和小红的直线距离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小明和小红相距：&quot;</span> + jedis.geodist(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xiaohong&quot;</span>, GeoUnit.KM) + <span class="string">&quot; KM&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询小明附近 5 公里的人</span></span><br><span class="line">        List&lt;GeoRadiusResponse&gt; res = jedis.georadiusByMemberReadonly(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, GeoUnit.KM);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明附近的人：&quot;</span> + res.get(i).getMemberByString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明和小红相距：3.9153 KM</span><br><span class="line">小明附近的人：xiaohong</span><br></pre></td></tr></table></figure><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>Redis 中的 GEO 经典使用场景如下：</p><ol><li>查询附近的人、附近的地点等；</li><li>计算相关的距离信息。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是 Redis 后续新增的三种数据结构的介绍和基本使用方法。在实际开发中，我们要实现的很多功能其实都要用到这三种数据结构。其实博客项目看似好像是一个烂大街的玩具，但其实如果真的要开发一款能推向市场的博客系统，还是要费很大的功夫的。</p><p>越往深处学就会发现它们的应用就在我们身边，这可能就是计算机不好入行的原因吧，刚开始学的全是一些抽象的东西，想要去实现一个我们平常使用的功能基本是不可能的，只有在深入学习各种框架、技术之后才能更好地理解身边的技术实现。</p><p>今天写的这几篇博客其实都有一点抽象，主要是因为之前在学 Redis 时，因为刚入门，所以很多东西都要去深入学习，最近几天看到的内容都是一个功能的实现，没有深挖的内容，所以在记录博客时就直接照着别人的总结写了一遍。你说这有用吗，应该比直接看一遍有用。</p><p>这两天都在学 Java 的基础知识，感觉和 Go 差的太多了，很麻烦，东西很杂。昨晚想通了一个问题，既然决定直接备战秋招了，时间还有差不多两三个月，其实可以不用那么急躁，囫囵吞枣式的学习只会带来更快的遗忘。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%9f%a5%e8%af%a2%e9%99%84%e8%bf%91%e7%9a%84%e4%ba%ba%e2%80%94%e2%80%94GEO.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%9f%a5%e8%af%a2%e9%99%84%e8%bf%91%e7%9a%84%e4%ba%ba%e2%80%94%e2%80%94GEO.md</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e4%bc%98%e7%a7%80%e7%9a%84%e5%9f%ba%e6%95%b0%e7%bb%9f%e8%ae%a1%e7%ae%97%e6%b3%95%e2%80%94%e2%80%94HyperLogLog.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e4%bc%98%e7%a7%80%e7%9a%84%e5%9f%ba%e6%95%b0%e7%bb%9f%e8%ae%a1%e7%ae%97%e6%b3%95%e2%80%94%e2%80%94HyperLogLog.md</a></p><p><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">https://javaguide.cn/database/redis/redis-data-structures-02.html</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的博客中，我们已经学习了 Redis 中的五种基础数据结构和六种底层数据结构。随着 Redis 在江湖上的名气越来越大，又有不少的英雄豪杰加入了 Redis 这一大帮派。&lt;/p&gt;
&lt;p&gt;这个家族又迎来了三位新的成员：Bitmaps、HyperLogLog 和 Geo，</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>分页与过滤：Redis中的渐进式数据处理妙招</title>
    <link href="http://example.com/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/"/>
    <id>http://example.com/2024/06/10/%E5%88%86%E9%A1%B5%E4%B8%8E%E8%BF%87%E6%BB%A4%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A6%99%E6%8B%9B/</id>
    <published>2024-06-10T07:35:36.000Z</published>
    <updated>2024-06-10T08:53:02.865Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容就先有一篇小故事来引出吧。</p><h1 id="一个问题引发的「血案」"><a href="#一个问题引发的「血案」" class="headerlink" title="一个问题引发的「血案」"></a>一个问题引发的「血案」</h1><p>曾经发生过这样一件事，我们的 Redis 服务器存储了海量的数据，其中登录用户信息是以 user_token_id 的形式存储的。运营人员想要当前所有的用户登录信息，然后悲剧就发生了：因为我们的工程师使用了 <code>keys user_token_*</code> 来查询对应的用户，结果导致 Redis 假死不可用，以至于影响到线上的其他业务接连发生问题，然后就收到了一堆的系统预警短信。并且这个假死的时间是和存储的数据成正比的，数据量越大假死的时间就越长，导致的故障时间也越长。</p><p>那如何避免这个问题呢？</p><h1 id="问题的解决方法"><a href="#问题的解决方法" class="headerlink" title="问题的解决方法"></a>问题的解决方法</h1><p>在 Redis 2.8 之前，我们只能使用 keys 命令来查询我们想要的数据，但这个命令存在两个缺点：</p><ol><li>此命令没有分页功能，我们只能一次性查询出所有符合条件的 key 值，如果查询结果非常巨大，那么得到的输出信息也会非常多；</li><li>keys 命令是遍历查询，因此它的查询时间复杂度是 o(n)，所以数据量越大查询时间就越长。</li></ol><p>然而，比较幸运的是在 Redis 2.8 时推出了 Scan，解决了我们这些问题，下面来看 Scan 的具体使用。</p><h1 id="Scan命令使用"><a href="#Scan命令使用" class="headerlink" title="Scan命令使用"></a><code>Scan</code>命令使用</h1><p>我们先来模拟海量数据，使用 Pipeline 添加 10w 条数据，Java 代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加 10w 条数据</span></span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100001</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;user_token_&quot;</span> + i, <span class="string">&quot;id&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据插入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来查询用户 id 为 9999* 的数据，Scan 命令使用如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match user_token_9999* count 10000</span><br><span class="line">1) &quot;127064&quot;</span><br><span class="line">2) 1) &quot;user_token_99997&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 127064 match user_token_9999* count 10000</span><br><span class="line">1) &quot;1740&quot;</span><br><span class="line">2) 1) &quot;user_token_9999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1740 match user_token_9999* count 10000</span><br><span class="line">1) &quot;21298&quot;</span><br><span class="line">2) 1) &quot;user_token_99996&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 21298 match user_token_9999* count 10000</span><br><span class="line">1) &quot;65382&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 65382 match user_token_9999* count 10000</span><br><span class="line">1) &quot;78081&quot;</span><br><span class="line">2) 1) &quot;user_token_99998&quot;</span><br><span class="line">   2) &quot;user_token_99992&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 78081 match user_token_9999* count 10000</span><br><span class="line">1) &quot;3993&quot;</span><br><span class="line">2) 1) &quot;user_token_99994&quot;</span><br><span class="line">   2) &quot;user_token_99993&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3993 match user_token_9999* count 10000</span><br><span class="line">1) &quot;13773&quot;</span><br><span class="line">2) 1) &quot;user_token_99995&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 13773 match user_token_9999* count 10000</span><br><span class="line">1) &quot;47923&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 47923 match user_token_9999* count 10000</span><br><span class="line">1) &quot;59751&quot;</span><br><span class="line">2) 1) &quot;user_token_99990&quot;</span><br><span class="line">   2) &quot;user_token_99991&quot;</span><br><span class="line">   3) &quot;user_token_99999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 59751 match user_token_9999* count 10000</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) (empty list or set)</span><br></pre></td></tr></table></figure><p>从以上的执行结果，我们看出两个问题：</p><ol><li>查询的结果为空，但游标值不为 0，表示遍历还没结束；</li><li>设置的是 count 10000，但每次返回的数量都不是 10000，且不固定，这是因为 count 只是限定服务器单次遍历的字典槽位数量（约等于），而不是规定返回结果的 count 值。</li></ol><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>cursor：光标位置，整数值，从 0 开始，到 0 结束，查询结果是空，但游标值不为 0，表示遍历还没结束；</li><li>match pattern：正则匹配字段；</li><li>count：限定服务器单次遍历的字典槽位数量（约等于），只是对增量式迭代命令的一种提示（hint），并不是查询结果返回的最大数量，它的默认值是 10。</li></ul><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>本文我们使用 Java 代码来实现 Scan 的查询功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanParams;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 定义 match 和 count 参数</span></span><br><span class="line">        <span class="type">ScanParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanParams</span>();</span><br><span class="line">        params.count(<span class="number">10000</span>);</span><br><span class="line">        params.match(<span class="string">&quot;user_token_9999*&quot;</span>);</span><br><span class="line">        <span class="comment">// 游标</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ScanResult&lt;String&gt; res = jedis.scan(cursor, params);</span><br><span class="line">            <span class="keyword">if</span> (res.getCursor().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 表示最后一条</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = res.getCursor(); <span class="comment">// 设置游标</span></span><br><span class="line">            <span class="keyword">for</span> (String item : res.getResult()) &#123;</span><br><span class="line">                <span class="comment">// 打印查询结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;查询结果：&quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询结果：user_token_99997</span><br><span class="line">查询结果：user_token_9999</span><br><span class="line">查询结果：user_token_99996</span><br><span class="line">查询结果：user_token_99998</span><br><span class="line">查询结果：user_token_99992</span><br><span class="line">查询结果：user_token_99994</span><br><span class="line">查询结果：user_token_99993</span><br><span class="line">查询结果：user_token_99995</span><br><span class="line">查询结果：user_token_99990</span><br><span class="line">查询结果：user_token_99991</span><br><span class="line">查询结果：user_token_99999</span><br></pre></td></tr></table></figure><h1 id="Scan-相关命令"><a href="#Scan-相关命令" class="headerlink" title="Scan 相关命令"></a>Scan 相关命令</h1><p>Scan 是一个系列指令，除了 Scan 之外，还有以下 3 个命令：</p><ol><li>HScan 遍历字典游标迭代器</li><li>SScan 遍历集合的游标迭代器</li><li>ZScan 遍历有序集合的游标迭代器</li></ol><p>来看这些命令的具体使用。</p><h2 id="HScan-使用"><a href="#HScan-使用" class="headerlink" title="HScan 使用"></a><strong>HScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan myhash 0 match k2* count 10</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;k2&quot;</span><br><span class="line">   2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h2 id="SScan-使用"><a href="#SScan-使用" class="headerlink" title="SScan 使用"></a><strong>SScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan myset 0 match v2* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h2 id="ZScan-使用"><a href="#ZScan-使用" class="headerlink" title="ZScan 使用"></a><strong>ZScan 使用</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan zset 0 match red* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;redis&quot;</span><br><span class="line">   2) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscan key <span class="attribute">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure><h1 id="Scan-说明"><a href="#Scan-说明" class="headerlink" title="Scan 说明"></a>Scan 说明</h1><p>官方对 Scan 命令的描述信息如下。</p><h2 id="Scan-guarantees"><a href="#Scan-guarantees" class="headerlink" title="Scan guarantees"></a><strong>Scan guarantees</strong></h2><blockquote><p>The SCAN command, and the other commands in the SCAN family, are able to provide to the user a set of guarantees associated to full iterations.</p><ul><li>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point SCANreturned it to the user.</li><li>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, SCAN ensures that this element will never be returned.</li></ul><p>However because SCAN has very little state associated (just the cursor) it has the following drawbacks:</p><ul><li>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</li><li>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</li></ul></blockquote><p>官方文档地址：</p><blockquote><p><a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p></blockquote><p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p><ul><li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li><li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li></ul><p>然后，Scan 命令包含以下缺点：</p><ul><li>一个元素可能被返回多次，需要客户端来实现去重；</li><li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本文我们可以知道 Scan 包含以下四个指令：</p><ol><li>Scan：用于检索当前数据库中所有数据；</li><li>HScan：用于检索哈希类型的数据；</li><li>SScan：用于检索集合类型中的数据；</li><li>ZScan：由于检索有序集合中的数据。</li></ol><p>Scan 具备以下几个特点：</p><ol><li>Scan 可以实现 keys 的匹配功能；</li><li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li><li>Scan 提供了 count 参数，可以规定遍历的数量；</li><li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li><li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li><li>单次返回空值且游标不为 0，说明遍历还没结束；</li><li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li><li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li></ol><p>本文内容与上面那篇文章有着相同的情况，内容较少，所以只读了一篇文章，贴在上面。</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/21%20%e6%b8%b8%e6%a0%87%e8%bf%ad%e4%bb%a3%e5%99%a8%ef%bc%88%e8%bf%87%e6%bb%a4%e5%99%a8%ef%bc%89%e2%80%94%e2%80%94Scan.md">原文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文的主要内容就先有一篇小故事来引出吧。&lt;/p&gt;
&lt;h1 id=&quot;一个问题引发的「血案」&quot;&gt;&lt;a href=&quot;#一个问题引发的「血案」&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的「血案」&quot;&gt;&lt;/a&gt;一个问题引发的「血案」&lt;/h1&gt;&lt;p&gt;曾经发生过这</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>深入解析管道（Pipelining）：提升性能的利器</title>
    <link href="http://example.com/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/"/>
    <id>http://example.com/2024/06/10/%E7%AE%A1%E9%81%93%EF%BC%88Pipelining%EF%BC%89%EF%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%A9%E5%99%A8-1/</id>
    <published>2024-06-10T07:35:11.000Z</published>
    <updated>2024-06-10T08:53:02.875Z</updated>
    
    <content type="html"><![CDATA[<p>管道技术 (Pipeline) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p><p>通常情况下 Redis 都是单行执行的，客户端先向服务期发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。但是当出现大批量请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p><p>普通命令模式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/30beb330-63a1-11ea-9c08-6f91e6eaabb6" alt="普通模式.png"></p><p>管道模式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b5d1f60-63a1-11ea-8be0-ebada4c42c48" alt="管道模式.png"></p><blockquote><p>小贴士：管道中命令越多，管道技术的作用就更大，相比于普通模式来说执行效率就越高。</p></blockquote><h1 id="管道解决了什么问题？"><a href="#管道解决了什么问题？" class="headerlink" title="管道解决了什么问题？"></a>管道解决了什么问题？</h1><p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><p>这里介绍使用采用Java语言。</p><p>首先先获取 Pipeline 对象，再为 Pipeline 对象设置需要执行的命令，最后再使用 sync() 方法或 syncAndReturnAll() 方法来统一执行这些命令，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            pipe.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：297毫秒</span><br></pre></td></tr></table></figure><p>如果要接收管道所有命令的执行结果，可使用 syncAndReturnAll() 方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipe</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令并返回结果</span></span><br><span class="line">        List&lt;Object&gt; res = pipe.syncAndReturnAll();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : res) &#123;</span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道技术-VS-普通命令"><a href="#管道技术-VS-普通命令" class="headerlink" title="管道技术 VS 普通命令"></a>管道技术 VS 普通命令</h3><p>上面使用管道技术执行一个 for 循环所用的时间为 297 毫秒，接下来我们用普通的命令执行此循环，看下程序的执行时间，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            jedis.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行耗时：17276毫秒</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>从上面的结果可以看出，管道的执行时间是 297 毫秒，而普通命令执行时间是 17276 毫秒，管道技术要比普通的执行快了 58 倍。</p><h3 id="管道技术需要注意的事项"><a href="#管道技术需要注意的事项" class="headerlink" title="管道技术需要注意的事项"></a>管道技术需要注意的事项</h3><p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p><ul><li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li><li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li><li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率，但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p><p>本文并非笔者自己所写，由于此知识点内容较少，没必要阅读过多资料，所以选择了一个内容不错的文章来学习。这里就把学习的文章的内容放进来了。</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/19%20Redis%20%e7%ae%a1%e9%81%93%e6%8a%80%e6%9c%af%e2%80%94%e2%80%94Pipeline.md">原文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;管道技术 (Pipeline) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。&lt;/p&gt;
&lt;p&gt;通常情况下 Redis 都是单行执行的，客户端先向服务期发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis为何快得飞起？解密闪电侠的内存魔法</title>
    <link href="http://example.com/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/"/>
    <id>http://example.com/2024/06/08/Redis%E4%B8%BA%E4%BD%95%E5%BF%AB%E5%BE%97%E9%A3%9E%E8%B5%B7%EF%BC%9F%E8%A7%A3%E5%AF%86%E9%97%AA%E7%94%B5%E4%BE%A0%E7%9A%84%E5%86%85%E5%AD%98%E9%AD%94%E6%B3%95/</id>
    <published>2024-06-08T11:53:26.000Z</published>
    <updated>2024-06-08T12:28:35.348Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 为什么这么快，这是我在了解 Redis 之前最大的疑问，即使你只是刚刚听说 Redis，对 Redis 的查询速度想必也是有所耳闻。</p><p>在没有深入学习之前，我只会回答因为 Redis 是依赖于内存实现的，所以速度快的飞起。但是，仅仅依靠内存，是不是就把设计人员费的心思给浪费了呢。</p><p>在了解为什么之前，我们先来看一下到底有多快。</p><p> 官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W/每秒</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E6%80%A7%E8%83%BD.png" alt="img"></p><h1 id="内存存储：速度的基础"><a href="#内存存储：速度的基础" class="headerlink" title="内存存储：速度的基础"></a>内存存储：速度的基础</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1697359566311-83361749-be9b-4c5a-982c-50fc07424fa7-20231023132823501.png" alt="img"></p><p>Redis 是一个内存数据库，<strong>它的数据存储在内存中，而计算机访问内存比起磁盘读写要快出数个数量级</strong>。因此，相较其他需要从磁盘读取数据的传统数据库而言，Redis 的速度要快得多。内存存储使Redis天生就具备了高速基因，这只是它快速的基础。</p><p>此外，由于数据直接从内存进行读写，而不必过多考虑如何将它们高效地保存到磁盘上（只有将数据以 RDB 的方式持久化时才会面对这个问题），这也使得 Redis 可以直接使用高效的底层数据结构。</p><h1 id="单线程模型：化繁为简的极致"><a href="#单线程模型：化繁为简的极致" class="headerlink" title="单线程模型：化繁为简的极致"></a>单线程模型：化繁为简的极致</h1><p>Redis 是单线程，主要是指 Redis 的网络IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</p><p>多线程必然会面临对于共享资源的访问，这时候通常的做法就是加锁，虽然是多线程，这时候就会变成串行的访问。也就是多线程编程模式会面临的共享资源的并发访问控制问题。</p><p>同时多线程也会引入同步原语来保护共享资源的并发访问，代码的可维护性和易读性将会下降。</p><p>Redis 的线程模型在不同版本有所不同：</p><ul><li><strong>2.0 版本</strong>：Redis 使用单个线程在事件循环中处理网络请求与执行操作指令，然后其他的后台线程负责释放 RDB/AOF 过程生成的临时文件资源与刷盘；</li><li><strong>4.0 版本</strong>：Redis 添加了一个线程，用于异步执行<code>UNLINK(异步删除指定键)</code>、<code>FLUSHALL ASYNC(清空所有 DB)</code>和<code>FLUSHDB ASYNC(清空指定 DB)</code>这些比较重的删除指令；</li><li><strong>6.0 版本</strong>：Redis 允许通过修改 <code>io-threads</code> 和 <code>io-threads-do-reads</code> 修改 IO 线程数。</li></ul><p>另外一提，读写指令要保持单线程，这个设计的理由是因为 CPU 对内存的操作已经足够高效，因此性能瓶颈不大可能来自于 CPU ，而主要来自于内存和网络 IO，因此执行命令的线程有一个足矣。</p><h1 id="非阻塞I-O：高并发处理的法宝"><a href="#非阻塞I-O：高并发处理的法宝" class="headerlink" title="非阻塞I/O：高并发处理的法宝"></a>非阻塞I/O：高并发处理的法宝</h1><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用 就是为了解决这个问题而出现的。</p><p>Linux 中的IO多路复用机制是指一个线程处理多个IO流。多路是指网络连接，复用指的是同一个线程。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个IO流的效果。</p><p>文件事件是对连接 socket 操作的一个抽象。当端口监听 socket 准备 accept 新连接，或者连接 socket 准备好读取请求、写入响应、关闭时，就会产生一个文件事件。IO 多路复用程序负责同时监听多个 socket，当这些 socket 产生文件事件时，就会触发事件通知，文件分派器就会感知并获取到这些事件。</p><p>虽然多个文件事件可能会并发出现，但 IO 多路复用程序总会将所有产生事件的 socket 放入一个队列中，通过这个队列，有序的把这些文件事件通知给文件分派器。</p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个的函数，他们定义了这个事件发生时，服务器应该执行的动作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-multiple.png" alt="redis"></p><p>Redis 封装了 4 种多路复用程序，每种封装实现都提供了相同的 API 实现。编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，这 3 个多路复用函数都直接使用系统内核内部的结构，可以服务数十万的文件描述符。</p><p>如果当前编译环境没有上述函数，就会选择 select 作为底层实现方案。select 方案的性能较差，事件发生时，会扫描全部监听的描述符，事件复杂度是 O(n)，并且只能同时服务有限个文件描述符，32 位机默认是 1024 个，64 位机默认是 2048 个，所以一般情况下，并不会选择 select 作为线上运行方案。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-choose-multiple.png" alt="redis"></p><h2 id="单线程处理-I-O-请求的性能瓶颈"><a href="#单线程处理-I-O-请求的性能瓶颈" class="headerlink" title="单线程处理 I/O 请求的性能瓶颈"></a>单线程处理 I/O 请求的性能瓶颈</h2><p><strong>1、后台 Redis 通过监听处理事件队列中的消息来通过单线程处理命令，如果一个命令的执行时间很久，就会影响整个 server 的性能；</strong></p><p>耗时的操作命令有下面几种：</p><ol><li>操作 bigkey：bigkey 在写入和删除的时候，需要的时间都会很长；</li><li>使用复杂度过高的命令；</li><li>大量 key 集中过期：Redis 的过期机制也是在主线程中执行的，大量 key 集中过期会导致处理一个请求时，耗时都在删除过期 key，耗时变长；</li><li>淘汰策略：淘汰策略也是在主线程执行的，当内存超过 Redis 内存上限后，每次写入都需要淘汰一些 key，也会造成耗时变长；</li><li>AOF刷盘开启 always 机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢 Redis 的性能；</li><li>主从全量同步生成 RDB：虽然采用 fork 子进程生成数据快照，但 fork 这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</li></ol><p>上面的这几种问题，我们在写业务的时候需要去避免，对于 bigkey，Redis 在4.0推出了 lazy-free 机制，把 bigkey 释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</p><p><strong>2、并发量非常大时，单线程读写客户端 IO 数据存在性能瓶颈</strong></p><p>使用 Redis 时，几乎不存在 CPU 成为瓶颈的情况， Redis 主要受限于内存和网络。随着硬件水平的提升，Redis 中的性能慢慢主要出现在网络 IO 的读写上。虽然采用 I/O 多路复用机制，但是读写客户端数据依旧是同步 IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</p><p>为了提升网络 IO 的读写性能，Redis 在6.0推出了多线程，同过多线程的 IO 来处理网络请求。不过需要注意的是这里的多线程仅仅是针对客户端的读写是并行的，Redis 处理事件队列中的命令，还是单线程处理的。</p><h1 id="高效的数据结构：内功深厚"><a href="#高效的数据结构：内功深厚" class="headerlink" title="高效的数据结构：内功深厚"></a>高效的数据结构：内功深厚</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1697468144147-9007849c-3b9e-412c-98f7-0ba7ac873d04.png" alt="img"></p><p>Redis 的高速很大程度上依赖于它丰富而高效的数据结构，而它们<strong>在底层实现上，都针对不同的使用场景进行了精心的设计和优化</strong>。</p><p>在 <a href="https://zxh3032.github.io/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/">Redis数据结构五兄弟：数据江湖的武林盟主</a>这篇博客中我们详细地分析了 Redis 中的五种基础数据结构以及其底层数据结构，可以非常清楚地看到，为了尽可能地将 Redis 的查询速度提高到极致，每一个基础数据结构的底层都用了最快的解决方案。具体内容可以去看那篇博客，这里就不细致讨论了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Redis为什么这么快？除了依赖内存存储，它还采用了单线程模型、非阻塞I/O、高效的数据结构、智能压缩和优化、以及多种高级特性。这些技术手段结合在一起，使得Redis成为了数据库界的速度王者。如果你还没用过Redis，赶紧试试吧，让它来为你的项目提速，体验飞一般的感觉！</p><p>关于本文讨论的这个内容，其实是一个在面试时经常会被问到的问题，内容其实并不多，主要是 Redis 设计时的一些特性，需要好好理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nageoffer.com/pages/cfb429/">https://nageoffer.com/pages/cfb429/</a></p><p><a href="https://github.com/boilingfrog/Go-POINT/blob/master/redis/1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E5%BF%AB.md#redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%95%88%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87">https://github.com/boilingfrog/Go-POINT/blob/master/redis/1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E5%BF%AB.md#redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%95%88%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 为什么这么快，这是我在了解 Redis 之前最大的疑问，即使你只是刚刚听说 Redis，对 Redis 的查询速度想必也是有所耳闻。&lt;/p&gt;
&lt;p&gt;在没有深入学习之前，我只会回答因为 Redis 是依赖于内存实现的，所以速度快的飞起。但是，仅仅依靠内存，是不是就</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis的键值过期和内存淘汰机制：内存的游戏</title>
    <link href="http://example.com/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <id>http://example.com/2024/06/08/Redis%E7%9A%84%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E6%B8%B8%E6%88%8F/</id>
    <published>2024-06-08T09:02:09.000Z</published>
    <updated>2024-06-08T11:11:53.416Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个 k-v 型数据库，我们所有的数据都是存放在内存中的，但是内存是有大小限制的，不可能无限制的增量。<br>想要把不需要的数据清理掉，一种办法是直接删除，这个咱们前面章节有详细说过；另外一种就是设置过期时间，缓存过期后，由Redis系统自行删除。<br>这边需要注意的是，缓存过期之后，并不是马上删除的，那Redis是怎么删除过期数据的呢？主要通过两个方式</p><ul><li>惰性删除</li><li>通过定时任务，定期选取部分数据删除</li></ul><p>但是无论是惰性删除还是定期删除，都可能存在删除不尽的情况，无法删除完全，还有就是 Redis 中的使用过程中，随着写数据的增加，Redis 中的内存不够用了，这时候就需要 Redis 的内存淘汰策略了。</p><p>Redis 的「内存淘汰策略」和「过期删除策略」，很容易混淆，这两个机制虽然都是做删除的操作，但是触发的条件和使用的策略都是不同的。</p><ul><li>Redis 过期策略指的是 Redis 使用那种策略，来删除已经过期的键值对；</li><li>Redis 内存淘汰机制指的是，当 Redis 运行内存已经超过 Redis 设置的最大内存之后，将采用什么策略来删除符合条件的键值对，以此来保障 Redis 高效的运行。</li></ul><p>下面还是来详细地看看这些内容以及实现原理吧。</p><h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><h2 id="如何设置过期时间？"><a href="#如何设置过期时间？" class="headerlink" title="如何设置过期时间？"></a>如何设置过期时间？</h2><p>先说一下对 key 设置过期时间的命令。 设置 key 过期时间的命令一共有 4 个：</p><ul><li><code>expire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期；</li><li><code>pexpire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。</li><li><code>expireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；</li><li><code>pexpireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）</li></ul><p>当然，在设置字符串时，也可以同时对 key 设置过期时间，共有 3 种命令：</p><ul><li><code>set &lt;key&gt; &lt;value&gt; ex &lt;n&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到秒）；</li><li><code>set &lt;key&gt; &lt;value&gt; px &lt;n&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到毫秒）；</li><li><code>setex &lt;key&gt; &lt;n&gt; &lt;valule&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到秒）。</li></ul><p>如果你想查看某个 key 剩余的存活时间，可以使用 <code>TTL &lt;key&gt;</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置键值对的时候，同时指定过期时间位 60 秒</span></span><br><span class="line">&gt; setex key1 60 value1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 key1 过期时间还剩多少</span></span><br><span class="line">&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br><span class="line">&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 52</span><br></pre></td></tr></table></figure><p>如果突然反悔，取消 key 的过期时间，则可以使用 <code>PERSIST &lt;key&gt;</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消 key1 的过期时间</span></span><br><span class="line">&gt; persist key1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用完 persist 命令之后，</span></span><br><span class="line"><span class="comment"># 查下 key1 的存活时间结果是 -1，表明 key1 永不过期 </span></span><br><span class="line">&gt; ttl key1 </span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h2 id="如何判定-key-是否过期？"><a href="#如何判定-key-是否过期？" class="headerlink" title="如何判定 key 是否过期？"></a>如何判定 key 是否过期？</h2><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>过期字典存储在 redisDb 结构中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;    <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    ....</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>过期字典数据结构结构如下：</p><ul><li>过期字典的 key 是一个指针，指向某个键对象；</li><li>过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；</li></ul><p>过期字典的数据结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="img"></p><p>字典实际上是<strong>哈希表</strong>，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>过期键判断流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E8%BF%87%E6%9C%9F%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h2 id="过期删除策略有哪些？"><a href="#过期删除策略有哪些？" class="headerlink" title="过期删除策略有哪些？"></a>过期删除策略有哪些？</h2><p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p><ul><li>定时删除；</li><li>惰性删除；</li><li>定期删除；</li></ul><p>接下来，分别分析它们的优缺点。</p><blockquote><p>定时删除策略是怎么样的？</p></blockquote><p>定时删除策略的做法是，<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></p><p>定时删除策略的<strong>优点</strong>：</p><ul><li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li></ul><p>定时删除策略的<strong>缺点</strong>：</p><ul><li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li></ul><blockquote><p>惰性删除策略是怎么样的？</p></blockquote><p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>惰性删除策略的<strong>优点</strong>：</p><ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul><p>惰性删除策略的<strong>缺点</strong>：</p><ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li></ul><blockquote><p>定期删除策略是怎么样的？</p></blockquote><p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>定期删除策略的<strong>优点</strong>：</p><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul><p>定期删除策略的<strong>缺点</strong>：</p><ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><h3 id="Redis-过期删除策略是什么？"><a href="#Redis-过期删除策略是什么？" class="headerlink" title="Redis 过期删除策略是什么？"></a>Redis 过期删除策略是什么？</h3><p>前面介绍了三种过期删除策略，每一种都有优缺点，仅使用某一个策略都不能满足实际需求。</p><p>所以， <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><blockquote><p>Redis 是怎么实现惰性删除的？</p></blockquote><p>Redis 的惰性删除策略由 db.c 文件中的 <code>expireIfNeeded</code> 函数实现，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p><ul><li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 <code>lazyfree_lazy_expire</code> 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li><li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端；</li></ul><p>惰性删除的流程图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4.jpg" alt="img"></p><blockquote><p>Redis 是怎么实现定期删除的？</p></blockquote><p>再回忆一下，定期删除策略的做法：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><ol><li><p>这个间隔检查的时间是多长呢？</p><p>在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p><p>特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 进行过期检查。</p></li><li><p>随机抽查的数量是多少呢？</p><p>我查了下源码，定期删除的实现在 expire.c 文件下的 <code>activeExpireCycle</code> 函数中，其中随机抽查的数量由 <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code> 定义的，它是写死在代码中的，数值是 20。</p><p>也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。</p></li></ol><p>接下来，详细说说 Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。</p><p>那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><p>针对定期删除的流程，我写了个伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//已过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//随机抽取的数量</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 从过期字典中随机抽取 1 个 key</span></span><br><span class="line">        <span class="comment">//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过时间限制则退出</span></span><br><span class="line">    <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>定期删除的流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h2 id="从库是否会脏读到主键创建地过期键"><a href="#从库是否会脏读到主键创建地过期键" class="headerlink" title="从库是否会脏读到主键创建地过期键"></a>从库是否会脏读到主键创建地过期键</h2><p>阅读惰性删除和定期删除的源码阅读中，我们可以发现，从库对于主库的过期键是不能主动进行删除的。如果一个主库创建的过期键值对，已经过期了，主库在进行定期删除的时候，没有及时的删除掉，这时候从库请求了这个键值对，当执行惰性删除的时候，因为是主库创建的键值对，这时候是不能在从库中删除的，那么是不是就意味着从库会读取到已经过期的数据呢？</p><p>答案肯定不是的。</p><blockquote><p><em>How Redis replication deals with expires on keys Redis expires allow keys to have a limited time to live. Such a feature depends on the ability of an instance to count the time, however Redis slaves correctly replicate keys with expires, even when such keys are altered using Lua scripts. To implement such a feature Redis cannot rely on the ability of the master and slave to have synchronized clocks, since this is a problem that cannot be solved and would result into race conditions and diverging data sets, so Redis uses three main techniques in order to make the replication of expired keys able to work: 1.Slaves don’t expire keys, instead they wait for masters to expire the keys. When a master expires a key (or evict it because of LRU), it synthesizes a DEL command which is transmitted to all the slaves. 2.However because of master-driven expire, sometimes slaves may still have in memory keys that are already logically expired, since the master was not able to provide the DEL command in time. In order to deal with that the slave uses its logical clock in order to report that a key does not exist only for read operations that don’t violate the consistency of the data set (as new commands from the master will arrive). In this way slaves avoid to report logically expired keys are still existing. In practical terms, an HTML fragments cache that uses slaves to scale will avoid returning items that are already older than the desired time to live. 3.During Lua scripts executions no keys expires are performed. As a Lua script runs, conceptually the time in the master is frozen, so that a given key will either exist or not for all the time the script runs. This prevents keys to expire in the middle of a script, and is needed in order to send the same script to the slave in a way that is guaranteed to have the same effects in the data set. Once a slave is promoted to a master it will start to expire keys independently, and will not require any help from its old master.</em></p></blockquote><p>上面是官方文档中针对这一问题的描述</p><p>大概意思就是从节点不会主动删除过期键，从节点会等待主节点触发键过期。当主节点触发键过期时，主节点会同步一个del命令给所有的从节点。</p><p>因为是主节点驱动删除的，所以从节点会获取到已经过期的键值对。从节点需要根据自己本地的逻辑时钟来判断减值是否过期，从而实现数据集合的一致性读操作。</p><p>我们知道 Redis 中的过期策略是惰性删除和定期删除，所以每个键值的操作，都会使用惰性删除来检查是否过期，然后判断是否可以进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/db.c#L1541</span></span><br><span class="line"><span class="comment">// 当访问到 key 的时候，会调用这个函数，因为有的 key 虽然已经过期了，但是还可能存在于内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 仍然有效，函数返回值为0，否则，如果 key 过期，函数返回1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从库的过期是主库控制的，是不会进行删除操作的</span></span><br><span class="line">    <span class="comment">// 上面已经判断过是否到期了，所以这里的 key 肯定设计过期的 key ,不过如果是主节点创建的 key 从节点就不删除，只会返回已经过期了</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">// 删除 key </span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/db.c#L1485</span></span><br><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="type">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有过期</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lua 脚本执行的过程中不过期</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们正在执行一个命令，我们仍然希望使用一个不会改变的引用时间:在这种情况下，我们只使用缓存的时间，我们在每次调用call()函数之前更新。</span></span><br><span class="line">    <span class="comment">// 这样我们就避免了RPOPLPUSH之类的命令，这些命令可能会重新打开相同的键多次，如果下次调用会看到键过期，则会使已经打开的对象在下次调用中失效，而第一次调用没有。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况下，获取最新的时间</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否过期了</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定 key 的过期时间，如果没有过期则返回-1</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的惰性删除，对于主节点创建的过期 key ，虽然不能进行删除的操作，但是可以进行过期时间的判断，所以如果主库创建的过期键，如果主库没有及时进行删除，这时候从库可以通过惰性删除来判断键值对的是否过期，避免读取到过期的内容。</p><h1 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h1><p>前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b9ab9e10-6900-11ea-95ab-8f8eaf73a78b" alt="img"></p><h2 id="如何设置-Redis-最大运行内存？"><a href="#如何设置-Redis-最大运行内存？" class="headerlink" title="如何设置 Redis 最大运行内存？"></a>如何设置 Redis 最大运行内存？</h2><p>在配置文件 redis.conf 中，可以通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。 不同位数的操作系统，maxmemory 的默认值是不同的：</p><ul><li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li><li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li></ul><h2 id="Redis-淘汰机制有哪些？"><a href="#Redis-淘汰机制有哪些？" class="headerlink" title="Redis 淘汰机制有哪些？"></a>Redis 淘汰机制有哪些？</h2><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><em>1、不进行数据淘汰的策略</em></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p><p><em>2、进行数据淘汰的策略</em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><p>在<strong>设置了过期时间的数据</strong>中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在<strong>所有数据</strong>范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><blockquote><p>如何查看当前 Redis 使用的内存淘汰策略？</p></blockquote><p>可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;noeviction&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出，当前 Redis 使用的是 <code>noeviction</code> 类型的内存淘汰策略，它是 Redis 3.0 之后默认使用的内存淘汰策略，表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。</p><blockquote><p>如何修改 Redis 内存淘汰策略？</p></blockquote><p>设置内存淘汰策略有两种方法：</p><ul><li>方式一：通过“<code>config set maxmemory-policy &lt;策略&gt;</code>”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li><li>方式二：通过修改 Redis 配置文件修改，设置“<code>maxmemory-policy &lt;策略&gt;</code>”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li></ul><h2 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h2><p>除了随机删除和不删除之外，主要有两种淘汰算法：LRU 算法和 LFU 算法。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU 全称是<code>Least Recently Used</code>译为最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p><p>一般 LRU 算法的实现基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可。</p><p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间，Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p><h4 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h4><p>Redis 在源码中对于每个键值对中的值，会使用一个 redisObject 结构体来保存指向值的指针，这里先来看下 redisObject 的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/server.h#L673</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 这里保存 </span></span><br><span class="line">    <span class="comment">// LRU时间(相对于全局LRU时钟)</span></span><br><span class="line">    <span class="comment">// LFU数据 (低 8 bits 作为计数器,用 24 bits 中的高 16 bits，记录访问的时间戳)</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>当一个键值对被创建的时候，就会记录下更新的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/object.c#L41  </span></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存替换策略是LFU，那么将lru变量设置为LFU的计数值</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是 lru </span></span><br><span class="line">    <span class="comment">// 调用LRU_CLOCK函数获取LRU时钟值</span></span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时一个键值对被访问的时候记录的时间也会被更新，当一个键值对被访问时，访问操作最终都会调用 lookupKey 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/db.c#L63</span></span><br><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the access time for the ageing algorithm.</span></span><br><span class="line"><span class="comment">         * Don&#x27;t do it if we have a saving child, as this will trigger</span></span><br><span class="line"><span class="comment">         * a copy on write madness. */</span></span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 LRU 更新 lru 的时间</span></span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们分别看了，创建和访问一个键值对的代码，每次操作，redisObject 中记录的 lru 时间就会被同步的更新</p><p>Redis 会判断当前内存的使用情况，如果超过了 maxmemory 配置的值，就会触发新的内存淘汰了</p><p>如果内存超过了 maxmemory 的值，这时候还需要去计算需要释放的内存量，这个释放的内存大小等于已使用的内存量减去 maxmemory。不过，已使用的内存量并不包括用于主从复制的复制缓冲区大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L512</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; (<span class="type">long</span> <span class="type">long</span>)mem_tofree) &#123;</span><br><span class="line">        <span class="type">int</span> j, k, i;</span><br><span class="line">        <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don&#x27;t want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="comment">// 根据淘汰策略，决定使用全局哈希表还是设置了过期时间的key的哈希表</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将选择的哈希表dict传入evictionPoolPopulate函数，同时将全局哈希表也传给evictionPoolPopulate函数</span></span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来填充evictionPool</span></span><br><span class="line"><span class="comment">// 按升序插入键，所以空闲时间小的键在左边，空闲时间高的键在右边。</span></span><br><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L145</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">evictionPoolPopulate</span><span class="params">(<span class="type">int</span> dbid, dict *sampledict, dict *keydict, <span class="keyword">struct</span> evictionPoolEntry *pool)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line"></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将元素插入池中。 首先，找到第一个空闲时间小于我们空闲时间的空桶或第一个填充的桶。</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can&#x27;t insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理淘汰的数据，Redis 中提供了一个数组 EvictionPoolLRU，用来保存待淘汰的候选键值对。这个数组的元素类型是 evictionPoolEntry 结构体，该结构体保存了待淘汰键值对的空闲时间 idle、对应的 key 等信息。</p><p>可以看到上面的上面会选取一定的过期键，然后插入到 EvictionPoolLRU 中</p><p>dictGetSomeKeys 函数采样的 key 的数量，是由 redis.conf 中的配置项 maxmemory-samples 决定的，该配置项的默认值是 5</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L55</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 待淘汰的键值对的空闲时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    <span class="comment">// 待淘汰的键值对的key</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    <span class="comment">// 缓存的SDS对象</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="comment">// 待淘汰键值对的key所在的数据库ID</span></span><br><span class="line">    <span class="type">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span></span><br></pre></td></tr></table></figure><p>然后通过 evictionPoolPopulate 函数，进行采样，然后将采样数据写入到 EvictionPoolLRU 中，插入到 EvictionPoolLRU 中的数据是按照空闲时间从小到大进行排好序的</p><p>freeMemoryIfNeeded 函数会遍历一次 EvictionPoolLRU 数组，从数组的最后一个 key 开始选择，如果选到的 key 不是空值，那么就把它作为最终淘汰的 key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L512</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSafeToPerformEvictions()) <span class="keyword">return</span> EVICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> keys_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> mem_reported, mem_tofree;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mem_freed; <span class="comment">/* May be negative */</span></span><br><span class="line">    <span class="type">mstime_t</span> latency, eviction_latency;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> delta;</span><br><span class="line">    <span class="type">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="type">int</span> result = EVICT_FAIL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> EVICT_OK;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; (<span class="type">long</span> <span class="type">long</span>)mem_tofree) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="comment">// 从数组最后一个key开始查找</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="comment">// 当前key为空值，则查找下一个key</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从全局哈希表或是expire哈希表中，获取当前key对应的键值对；</span></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="comment">// 将当前key从EvictionPoolLRU数组删除</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="comment">// 如果当前key对应的键值对不为空，选择当前key为被淘汰的key</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">            delta = (<span class="type">long</span> <span class="type">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="comment">// 惰性删除</span></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 同步删除</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次选中一部分过期的键值对，每次淘汰最久没有使用的那个，如果释放的内存空间还不够，就会重复的进行采样，删除的过程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240608182614556.png" alt="image-20240608182614556"></p><h4 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h4><p>LRU 算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰，因此在 Redis 4.0 之后引入了 LFU 算法，下面我们一起来看。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU 全称是 <code>Least Frequently Used</code> 翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>LFU 解决了偶尔被访问一次之后，数据就不会被淘汰的问题，相比于 LRU 算法也更合理一些。</p><p>上面分析 LRU 的时候，聊到了 redisObject，Redis 在源码中对于每个键值对中的值，会使用一个 redisObject 结构体来保存指向值的指针。里面 <code>lru:LRU_BITS</code> 字段记录了 LRU 算法和 LFU 算法需要的时间和计数器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/lru%E5%AD%97%E6%AE%B5.png" alt="img"></p><ul><li>ldt 是用来记录 key 的访问时间戳；</li><li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li></ul><p>logc 并不是单纯的访问次数，而是<strong>访问频次（访问频率）</strong>，因为 <strong>logc 会随时间推移而衰减的</strong>。</p><p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/redis/redis/blob/6.2/src/evict.c#L298</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> &#123;</span><br><span class="line">    <span class="comment">// 等于255，不在进行次数的更新</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 计算一个随机数</span></span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="comment">// 计算当前访问次数和初始值的差值</span></span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据baseval和lfu_log_factor计算阈值p</span></span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 概率值小于阀值</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前访问次数小于255的时候，每次 <code>LFULogIncr</code> 函数会计算一个阈值 p，以及一个取值为 0 到 1 之间的随机概率值 r。如果概率 r 小于阈值 p，那么 <code>LFULogIncr</code> 函数才会将logc 加 1。否则的话，<code>LFULogIncr</code> 函数会返回当前的logc ，不做更新。</p><p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p><ol><li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li><li>然后，再按照一定概率增加 logc 的值</li></ol><p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p><ul><li><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，<code>lfu-decay-time</code> 值越大，衰减越慢；</li><li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，<code>lfu-log-factor</code> 值越大，logc 增长越慢。</li></ul><h4 id="使用-LFU-算法淘汰数据"><a href="#使用-LFU-算法淘汰数据" class="headerlink" title="使用 LFU 算法淘汰数据"></a><strong>使用 LFU 算法淘汰数据</strong></h4><p>LFU 处理数据淘汰和 LRU 方式差不多，这里回顾下 LRU 处理数据淘汰的过程</p><ul><li>1、调用 getMaxmemoryState 函数计算待释放的内存空间；</li><li>2、调用 evictionPoolPopulate 函数随机采样键值对，并插入到待淘汰集合 EvictionPoolLRU 中；</li><li>3、遍历待淘汰集合 EvictionPoolLRU，选择实际被淘汰数据，并删除。</li></ul><p>不同的是，LFU 算法在淘汰数据时，在第二步的 evictionPoolPopulate 函数中，使用了不同的方法来计算每个待淘汰键值对的空闲时间。</p><p>LRU 中 idle 记录的是它距离上次访问的空闲时间。</p><p>LFU 中 idle 记录的是用 255 减去键值对的 logc。也就是键值对访问次数越大，它的 idle 值就越小，反之 idle 值越大。</p><p><code>freeMemoryIfNeeded</code> 函数按照 idle 值从大到小，遍历 <code>EvictionPoolLRU</code> 数组，选择实际被淘汰的键值对时，它就能选出访问次数小的键值对了，也就是把访问频率低的键值对淘汰出去。</p><h3 id="为什么数据删除后内存占用还是很高？"><a href="#为什么数据删除后内存占用还是很高？" class="headerlink" title="为什么数据删除后内存占用还是很高？"></a>为什么数据删除后内存占用还是很高？</h3><p>Redis 中的内存可能会遇到这样一种情况，虽然进行了数据的删除，数据量已经不大了，但是使用 top 命令，发现 Redis 还是会占用大量的内存</p><p>因为，当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存。</p><p>但是这些内存可能是不连续的，对于不连续的小内存块，虽然是空闲内存，但是 Redis 却不能拿来用，会造成资源的浪费。</p><p>为什么会产生内存碎片呢？</p><h4 id="内存碎片如何产生？"><a href="#内存碎片如何产生？" class="headerlink" title="内存碎片如何产生？"></a>内存碎片如何产生？</h4><p><strong>1、内存分配器的分配策略</strong></p><p>内存分配器对于内存的分配，一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</p><p>Redis 可以使用 <code>libc、jemalloc、tcmalloc</code> 多种内存分配器来分配内存，默认使用 jemalloc。</p><p>jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如8字节、16字节、32字节、48字节，…, 2KB、4KB、8KB等。当程序申请的内存最接近某个固定值时，jemalloc会给它分配相应大小的空间。</p><p>这样的分配方式本身是为了减少分配次数。例如，Redis申请一个20字节的空间保存数据，jemalloc 就会分配 32 字节，此时，如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间了，因为刚才分配的32字节已经够用了，这就避免了一次分配操作。</p><p>减少了内存分配的次数，缺点就是增加了产生内存碎片的可能。</p><p><strong>2、键值对的删除更改操作</strong></p><p>Redis 中键值对会被修改和删除，这会导致空间的扩容和释放，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p><p>Redis中的值删除的时候，并没有把内存直接释放，交还给操作系统，而是交给了Redis内部有内存管理器。</p><p>Redis 中申请内存的时候，也是先看自己的内存管理器中是否有足够的内存可用。Redis的这种机制，提高了内存的使用率，但是会使 Redis 中有部分自己没在用，却不释放的内存，导致了内存碎片的发生。</p><h4 id="碎片率的意义"><a href="#碎片率的意义" class="headerlink" title="碎片率的意义"></a>碎片率的意义</h4><p><code>mem_fragmentation_ratio</code>的不同值，说明不同的情况。</p><ul><li>大于1：说明内存有碎片，一般在1到1.5之间是正常的；</li><li>大于1.5：说明内存碎片率比较大，需要考虑是否要进行内存碎片清理，要引起重视；</li><li>小于1：说明已经开始使用交换内存，也就是使用硬盘了，正常的内存不够用了，需要考虑是否要进行内存的扩容。</li></ul><p>可以使用 INFO memory 命令查看内存碎片率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO memory</span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:865672</span><br><span class="line">used_memory_human:845.38K</span><br><span class="line">used_memory_rss:8085504</span><br><span class="line">used_memory_rss_human:7.71M</span><br><span class="line">used_memory_peak:865672</span><br><span class="line">used_memory_peak_human:845.38K</span><br><span class="line">used_memory_peak_perc:100.01%</span><br><span class="line">used_memory_overhead:819226</span><br><span class="line">used_memory_startup:802056</span><br><span class="line">used_memory_dataset:46446</span><br><span class="line">used_memory_dataset_perc:73.01%</span><br><span class="line">allocator_allocated:995552</span><br><span class="line">allocator_active:1282048</span><br><span class="line">allocator_resident:3690496</span><br><span class="line">total_system_memory:1929736192</span><br><span class="line">total_system_memory_human:1.80G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.29</span><br><span class="line">allocator_frag_bytes:286496</span><br><span class="line">allocator_rss_ratio:2.88</span><br><span class="line">allocator_rss_bytes:2408448</span><br><span class="line">rss_overhead_ratio:2.19</span><br><span class="line">rss_overhead_bytes:4395008</span><br><span class="line">mem_fragmentation_ratio:9.80</span><br><span class="line">mem_fragmentation_bytes:7260856</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:16986</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure><p>mem_fragmentation_ratio 表示的就是内存碎片率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_fragmentation_ratio = used_memory_rss/ used_memory</span><br></pre></td></tr></table></figure><p>used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；而 used_memory 是 Redis 为了保存数据实际申请使用的空间。</p><h4 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h4><p>Redis服务器重启后，Redis会将没用的内存归还给操作系统，碎片率会降下来；</p><p>4.0 版本的 Redis 引入了自动内存碎片清理的功能。</p><p>自动碎片清理，只要设置了如下的配置，内存就会自动清理了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set activedefrag yes</span><br></pre></td></tr></table></figure><p>不过对于具体什么时候开始，受下面两个参数的控制，只要一个不满足就停止自动清理</p><ul><li>active-defrag-ignore-bytes 100mb：表示内存碎片的字节数达到100MB时，开始清理；</li><li>active-defrag-threshold-lower 10：表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。</li></ul><p>为了保证清理过程中对 CPU 的影响，还设置了两个参数，分别用于控制清理操作占用的CPU时间比例的上、下限，既保证清理工作能正常进行，又避免了降低Redis性能。</p><ul><li>active-defrag-cycle-min 25： 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；</li><li>active-defrag-cycle-max 75：表示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。 </li></ul><p>如果你对自动清理的效果不满意，可以使用如下命令，直接试下手动碎片清理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory purge</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis 使用的过期删除策略是「惰性删除+定期删除」，删除的对象是已过期的 key。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p>内存淘汰策略是解决内存过大的问题，当 Redis 的运行内存超过最大运行内存时，就会触发内存淘汰策略，Redis 4.0 之后共实现了 8 种内存淘汰策略，我也对这 8 种的策略进行分类，如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p>Redis 一切操作都是为了保证高效、灵活地利用内存，提供飞快的读写速度。希望你看完这篇文章，对 Redis 的键值过期操作和内存淘汰机制有了一个轻松愉快的了解。记住，Redis 虽然是个内存管理高手，但也需要你合理设置过期时间和选择合适的淘汰策略，这样才能愉快地玩耍下去！</p><p>更加深入的东西还是需要通过源码来进行学习，仅仅通过别人的博客还是学不到深入的内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/23%20%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6%e4%b8%8e%e7%ae%97%e6%b3%95.md">内存淘汰机制与算法</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/17%20Redis%20%e9%94%ae%e5%80%bc%e8%bf%87%e6%9c%9f%e6%93%8d%e4%bd%9c.md">键值过期操作</a></p><p><a href="https://www.xiaolincoding.com/redis/module/strategy.html">Redis 过期删除策略和内存淘汰策略有什么区别？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 是一个 k-v 型数据库，我们所有的数据都是存放在内存中的，但是内存是有大小限制的，不可能无限制的增量。&lt;br&gt;想要把不需要的数据清理掉，一种办法是直接删除，这个咱们前面章节有详细说过；另外一种就是设置过期时间，缓存过期后，由Redis系统自行删除。&lt;br&gt;这边</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务的深潜之旅：像个老司机一样操作数据！</title>
    <link href="http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/"/>
    <id>http://example.com/2024/06/08/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%BD%9C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%83%8F%E4%B8%AA%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81/</id>
    <published>2024-06-08T07:57:12.000Z</published>
    <updated>2024-06-08T11:11:53.406Z</updated>
    
    <content type="html"><![CDATA[<p>在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。</p><p>那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？</p><p>为了解开这些疑问，也为了能更加熟练地掌握 Redis，成为一个老司机。今天，我们就来学习 Redis 事务相关的内容。</p><h1 id="什么是Redis事务？"><a href="#什么是Redis事务？" class="headerlink" title="什么是Redis事务？"></a>什么是Redis事务？</h1><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h1 id="事务的基本使用"><a href="#事务的基本使用" class="headerlink" title="事务的基本使用"></a>事务的基本使用</h1><p>事务在其他语言中，一般分为以下三个阶段：</p><ul><li>开启事务——Begin Transaction</li><li>执行业务代码，提交事务——Commit Transaction</li><li>业务处理中出现异常，回滚事务——Rollback Transaction</li></ul><p>以 Java 中的事务执行为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 中的事务从开始到结束也是要经历三个阶段：</p><ul><li>开启事务</li><li>命令入列</li><li>执行事务/放弃事务</li></ul><p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p><p>下面一一介绍关于事务的命令。</p><h2 id="MULTI：聚会的开场白"><a href="#MULTI：聚会的开场白" class="headerlink" title="MULTI：聚会的开场白"></a>MULTI：聚会的开场白</h2><p>multi 命令用于开启事务，实现代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f2898390-5ddf-11ea-9d6d-67bd1a14f4fe" alt="img"></p><p>当客户端是非事务状态时，使用 multi 命令，客户端会返回结果 OK，如果客户端已经是事务状态，再执行 multi 命令会提示 multi 命令不能嵌套的错误，但不会终止客户端为事务的状态，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3aa4ae70-5de0-11ea-9d6d-67bd1a14f4fe" alt="img"></p><h2 id="常规命令：聚会人员入场"><a href="#常规命令：聚会人员入场" class="headerlink" title="常规命令：聚会人员入场"></a>常规命令：聚会人员入场</h2><p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>执行流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/68d8d640-5de0-11ea-9d6d-67bd1a14f4fe" alt="img"></p><p>命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p><h2 id="EXEC：行动的高潮"><a href="#EXEC：行动的高潮" class="headerlink" title="EXEC：行动的高潮"></a>EXEC：行动的高潮</h2><p>执行事务的命令是 exec，输入 exec 后会执行开启事务后的所有操作。执行事务示例代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e31a4ab0-5de0-11ea-9359-3b811418c7dd" alt="img"></p><h2 id="DISCARD：优雅的撤退"><a href="#DISCARD：优雅的撤退" class="headerlink" title="DISCARD：优雅的撤退"></a>DISCARD：优雅的撤退</h2><p>放弃事务的命令是 discard，有时候，事情并不像你预想的那样发展，你决定取消事务。DISCARD就是你的优雅撤退，所有的准备工作都被抛之脑后，大家都当做什么都没发生过一样。</p><p>放弃事务示例代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">discard</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>具体的执行流程和 exec 一致。</p><h2 id="WATCH：秘密特工的侦查"><a href="#WATCH：秘密特工的侦查" class="headerlink" title="WATCH：秘密特工的侦查"></a>WATCH：秘密特工的侦查</h2><p>WATCH就是你在事务前的小心侦查，确保一切都在你的掌控之中。如果有人试图偷偷溜进来搞破坏，WATCH会立刻发出警报，保护你的数据不被篡改。</p><p>watch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个<strong>监控项被修改</strong>了，那么<strong>整个事务</strong>就会<strong>终止执行</strong>。</p><p>watch 基本语法如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br></pre></td></tr></table></figure><p><code>watch</code> 示例代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p><p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 <code>get k</code> 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p><p>执行流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/191ad650-5de3-11ea-9e57-957b6467a3fc" alt="img"></p><p><strong>注意</strong>： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">(error) ERR WATCH inside MULTI is not allowed</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure><p>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</p><p>unwatch 示例如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">unwatch</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>以下是事务在 Java 中的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置键值</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启监视 watch</span></span><br><span class="line">        jedis.watch(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 开始事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="comment">// 命令入列</span></span><br><span class="line">        tx.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        tx.exec();</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事务出现错误的处理"><a href="#事务出现错误的处理" class="headerlink" title="事务出现错误的处理"></a>事务出现错误的处理</h1><p>事务执行中的错误分为以下三类：</p><ul><li>执行时才会出现的错误（简称：执行时错误）；</li><li>入列时错误，不会终止整个事务；</li><li>入列时错误，会终止整个事务。</li></ul><h2 id="执行时出错"><a href="#执行时出错" class="headerlink" title="执行时出错"></a>执行时出错</h2><p>执行命令解释如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/aa0ca950-5de2-11ea-9e6b-b3dcd9fe8595" alt="img"></p><p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p><h2 id="入列错误不会导致事务结束"><a href="#入列错误不会导致事务结束" class="headerlink" title="入列错误不会导致事务结束"></a>入列错误不会导致事务结束</h2><p>执行命令解释如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/cc4111f0-5de2-11ea-9e6b-b3dcd9fe8595" alt="img"></p><p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果。</p><h2 id="入列错误导致事务结束"><a href="#入列错误导致事务结束" class="headerlink" title="入列错误导致事务结束"></a>入列错误导致事务结束</h2><p>执行命令解释如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fd00c6a0-5de2-11ea-9d6f-15d639c92acd" alt="img"></p><p>当然可以！让我们详细探讨一下Redis事务的局限性，揭开这种“完美的幻觉”，看看有哪些实际中的限制和注意事项。</p><h1 id="Redis事务的局限：完美的幻觉？"><a href="#Redis事务的局限：完美的幻觉？" class="headerlink" title="Redis事务的局限：完美的幻觉？"></a>Redis事务的局限：完美的幻觉？</h1><p>Redis事务通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>和<code>DISCARD</code>等命令实现了一定程度上的事务处理。然而，与传统关系型数据库的事务机制相比，Redis事务仍然存在一些局限性。</p><h2 id="乐观锁的陷阱"><a href="#乐观锁的陷阱" class="headerlink" title="乐观锁的陷阱"></a>乐观锁的陷阱</h2><p><strong>概念：</strong> Redis通过<code>WATCH</code>命令实现乐观锁。<code>WATCH</code>命令用于监视一个或多个键，当事务执行期间，如果这些键发生变化（例如被其他客户端修改），则事务会失败。</p><p><strong>局限性：</strong> </p><ul><li><strong>冲突频繁：</strong> 在高并发环境下，如果监视的键频繁被修改，事务成功的概率会降低，需要多次重试。</li><li><strong>数据竞争：</strong> 乐观锁适用于数据冲突较少的场景，对于高冲突的场景可能并不合适。</li></ul><h2 id="缺乏回滚机制"><a href="#缺乏回滚机制" class="headerlink" title="缺乏回滚机制"></a>缺乏回滚机制</h2><p><strong>概念：</strong> 在传统关系型数据库中，如果事务中的某个操作失败，可以回滚事务，撤销已经执行的操作。但是在Redis中，一旦执行<code>EXEC</code>命令，所有命令都会被依次执行，不支持部分回滚。</p><p><strong>局限性：</strong></p><ul><li><strong>不可中断：</strong> 一旦事务开始执行，无法中途停止或回滚已经成功的操作。</li><li><strong>操作不可逆：</strong> 如果事务中的某个操作失败，必须手动处理恢复或补救措施，不能依赖自动回滚。</li></ul><h1 id="更加深入的理解"><a href="#更加深入的理解" class="headerlink" title="更加深入的理解"></a>更加深入的理解</h1><h2 id="为什么-Redis-不支持回滚？"><a href="#为什么-Redis-不支持回滚？" class="headerlink" title="为什么 Redis 不支持回滚？"></a>为什么 Redis 不支持回滚？</h2><blockquote><p>如果你有使用关系式数据库的经验， 那么 “<strong>Redis 在事务失败时不进行回滚，而是继续执行余下的命令</strong>”这种做法可能会让你觉得有点奇怪。</p></blockquote><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， <strong>回滚并不能解决编程错误带来的问题</strong>。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p><h2 id="如何理解-Redis-与事务的-ACID？"><a href="#如何理解-Redis-与事务的-ACID？" class="headerlink" title="如何理解 Redis 与事务的 ACID？"></a>如何理解 Redis 与事务的 ACID？</h2><blockquote><p>一般来说，事务有四个性质称为ACID，分别是原子性，一致性，隔离性和持久性。这是基础，但是很多文章对Redis 是否支持ACID有一些异议，我觉的有必要梳理下：</p></blockquote><ul><li><strong>原子性 Atomicity</strong></li></ul><p>首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。</p><p>Redis官方文档给的理解是，<strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行</strong>。而不是完全成功。</p><ul><li><strong>一致性 Consistency</strong></li></ul><p>Redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非Redis进程意外终结。</p><ul><li><strong>隔离性 Isolation</strong></li></ul><p>Redis事务是严格遵守隔离性的，原因是Redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。</p><p>但是，Redis不像其它结构化数据库有隔离级别这种设计。</p><ul><li><strong>持久性 Durability</strong></li></ul><p><strong>Redis事务是不保证持久性的</strong>，这是因为Redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</p><p>关于 Redis 事务能不能保证 ACID这一问题，我在网上也是众说纷纭，但是在 <strong>一致性</strong> 和 <strong>隔离性</strong> 上，大家都保持着相同的看法，那就是能保证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 Redis 事务的全部内容了，内容并不多，没有在学习 MySQL 时的海量内容，也可以看出其实在 Redis 中并不会很频繁的使用到事务，算一个小知识点吧。</p><p>我是怎么得出这个结论的？因为小林coding写的八股文中都找不到和事务相关的内容，所以我断言它不重要。</p><p>前天晚上死活睡不着，熬了个通宵之后直接来了一个说走就走的旅行，岳阳还是很好玩的。不得不说，晚上确实是一个容易冲动消费的时间，纠结了两周的耳机还是买了，不过不知道为什么没有之前买东西的那种期待感了。</p><p>这里就不得不吐槽一下京东了，太呆瓜了，我在晚上冲动消费后，中午觉得这样不行所以决定退了，但是思考两分钟后又觉得得买，所以我就取消了我的取消申请，客服同意后，快递竟然还是被退回来。我联系客服，客服跟我说没办法了。然后我就又申请了退款，结果快递又开始配送了，不得不联系美女客服帮我退款。京东找个真人客服是真难。害的我还得再等一天。</p><p>昨天高考开始，竟然没刷到几个丢准考证和身份证的，看来今年的学生学聪明了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7203274235425505336">redis 事务能保证ACID吗</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html">Redis 事务</a></p><p><a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">Redis 事务解析</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/16%20Redis%20%e4%ba%8b%e5%8a%a1%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90.md">Redis事务深度解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习关系型数据库时，有一个非常重要的概念——事务，它扮演着关键的角色。它确保了数据操作的完整性、一致性、隔离性和持久性。&lt;/p&gt;
&lt;p&gt;那么你有没有想过，非关系型数据库 Redis 是如何处理并使用事务的呢？是否与关系型数据库一一致？又是否能保证 ACID？&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构五兄弟：数据江湖的武林盟主</title>
    <link href="http://example.com/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/"/>
    <id>http://example.com/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/</id>
    <published>2024-06-05T12:56:19.000Z</published>
    <updated>2024-06-06T04:48:58.607Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习 Redis 相关的知识，Redis 的五种基础数据结构。虽然在之前的博客中也有提到过这五种数据结构，当时赶着背东西，基本上就是从别人的八股文里抄的，所以还是重新学一下，重新记录加深记忆，正文开始。</p><p>在数据的江湖里，Redis无疑是那位神秘莫测、武功高强的武林盟主。今天，我们要介绍的就是Redis的五个顶级弟子（Redis 到现在已经有 9 种数据结构了），他们各怀绝技，行走江湖无往不利。话不多说，让我们一睹这五兄弟的风采！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我知道现在你已经迫不及待的想要了解这五个大侠了，但是在正式学习这些之前，我们先来了解一下 Redis 武林中的一些“潜规则”。</p><h2 id="Redis的两层数据结构简介"><a href="#Redis的两层数据结构简介" class="headerlink" title="Redis的两层数据结构简介"></a>Redis的两层数据结构简介</h2><p>Redis 为什么会有如此高的性能？这也是一个老生常谈的问题了，其中之一的原因就是它的每种数据结构都是经过专门设计的，并都有一种或多种数据结构来支持，依赖这些灵活的数据结构，来提升读取和写入的性能。</p><p>想要了解Redis的数据结构，可以从两个不同的层面来讨论它：</p><ol><li>第一个层面，是从使用者的角度，这一层面也是Redis暴露给外部的调用接口，比如：<ul><li>string</li><li>list</li><li>hash</li><li>set</li><li>sorted set</li></ul></li><li>第二个层面，是从内部实现的角度，属于更底层的实现，比如：<ul><li>dict</li><li>sds</li><li>ziplist</li><li>quicklist</li><li>skiplist</li><li>intset</li></ul></li></ol><p>本文会先从第一个层面来了解 Redis 的基础操作，再深入学习其底层原理。</p><h2 id="redisObject：两层数据结构的桥梁"><a href="#redisObject：两层数据结构的桥梁" class="headerlink" title="redisObject：两层数据结构的桥梁"></a><code>redisObject</code>：两层数据结构的桥梁</h2><h3 id="什么是redisObject？"><a href="#什么是redisObject？" class="headerlink" title="什么是redisObject？"></a>什么是<code>redisObject</code>？</h3><p>从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系，这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash, set, sorted set等。<br> 而从 Redis 内部实现的角度来看，database 内的这个映射关系是用一个 dict 来维护的。dict 的 key固定用一种数据结构来表达就够了，这就是动态字符串 sds；而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是 robj，全名是<code>redisObject</code>。</p><blockquote><p>举个例子：</p><ul><li><p>如果value是list类型，那么它的内部存储结构是一个quicklist或者是一个ziplist</p></li><li><p>如果value是string类型，那么它的内部存储结构一般情况下是一个sds。但如果string类型的value的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。</p></li></ul><p>所以，一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p></blockquote><h3 id="Redis-的数据结构定义"><a href="#Redis-的数据结构定义" class="headerlink" title="Redis 的数据结构定义"></a>Redis 的数据结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><strong>一个 robj 包含如下 5 个字段</strong></p><ul><li><p>type: 对象的数据类型。占4个bit。可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构</p></li><li><p>encoding: 对象的内部表示方式（也可以称为编码）。占4个 bit。可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。</p></li><li>lru: 做LRU替换算法用，占24个bit。这个不是我们这里讨论的重点，暂时忽略。</li><li>refcount: 引用计数。它允许robj对象在某些情况下被共享。</li><li>ptr: 数据指针。指向真正的数据。比如，一个代表string的 robj，它的 ptr 可能指向一个 sds 结构；一个代表 list 的 robj，它的 ptr 可能指向一个 quicklist。</li></ul><p><strong>encoding字段的说明</strong></p><p>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><blockquote><p>当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p><ul><li><p>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。</p></li><li><p>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。</p></li><li>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。</li></ul><p>当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p><ul><li>OBJ_ENCODING_HT: hash采用一个dict来表示</li><li>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示</li></ul></blockquote><p><strong>10种encoding的取值说明</strong></p><ul><li><p>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。</p></li><li><p>OBJ_ENCODING_INT: 表示成数字。实际用long表示。</p></li><li>OBJ_ENCODING_HT: 表示成dict。</li><li>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。</li><li>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。</li><li>OBJ_ENCODING_ZIPLIST: 表示成ziplist。</li><li>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。</li><li>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。</li><li>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。</li><li>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</li></ul><h3 id="robj-的作用"><a href="#robj-的作用" class="headerlink" title="robj 的作用"></a>robj 的作用</h3><ul><li><code>redisObject</code>就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪些第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist等），则通过不同的encoding来区分。可以说，robj是联结两个层面的数据结构的桥梁。</li><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li><li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/720b2e10a6cc4f009963d0af153a2351.png" alt="img"></p><p>好了，在了解完武林江湖的一些潜规则后，我们就可以正式进入这个江湖了，可以避免露头秒了。</p><h1 id="字符串（String）：一招制敌的快剑手"><a href="#字符串（String）：一招制敌的快剑手" class="headerlink" title="字符串（String）：一招制敌的快剑手"></a>字符串（String）：一招制敌的快剑手</h1><p>首先登场的是字符串，这位老大哥简直是个“快剑手”，动作迅捷、干脆利落。他就像是江湖上的独行侠，擅长简单直接的攻击方式。字符串可以存储任何类型的数据：文本、数字甚至二进制数据，只要你给的，他都能快速接住。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151104537-442214557.png" alt="img"></p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作，下面我们分别来看，后面其他数据结构也都会按照这样的顺序讲解。</p><h3 id="命令行操作方式"><a href="#命令行操作方式" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值</td></tr><tr><td>MSET key1 value1 key2 value2 …</td><td>设置一个或多个指定 key 的值</td></tr><tr><td>MGET key1 key2 …</td><td>获取一个或多个指定 key 的值</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值(整型和浮点型)增一</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值(整型和浮点型)减一</td></tr><tr><td>INCRBY/DECRBY key increment</td><td>将 key 中储存的数字值(整型和浮点型)加/减 increment</td></tr><tr><td>EXISTS key</td><td>判断指定 key 是否存在</td></tr><tr><td>DEL key（通用）</td><td>删除指定的 key</td></tr><tr><td>EXPIRE key seconds（通用）</td><td>给指定 key 设置过期时间</td></tr><tr><td>APPEND key value</td><td>给指定 key 后面追加值 value</td></tr></tbody></table></div><p>更多 Redis String 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=string">Redis 官网</a> 对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）"><a href="#代码操作方式（采用Go-Redis-V8-版本）" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p><strong>常用方法:</strong></p><ul><li>Keys():根据正则获取keys</li><li>Type():获取key对应值得类型</li><li>Del():删除缓存项</li><li>Exists():检测缓存项是否存在</li><li>Expire(),ExpireAt():设置有效期</li><li>TTL(),PTTL():获取有效期</li><li>DBSize():查看当前数据库key的数量</li><li>FlushDB():清空当前数据</li><li>FlushAll():清空所有数据库</li><li>Set():设置键缓存</li><li>SetEX():设置并指定过期时间</li><li>SetNX():设置并指定过期时间,仅当key不存在的时候才设置。</li><li>Get():获取键值</li><li>GetRange():字符串截取</li><li>Incr():增加+1</li><li>IncrBy():按指定步长增加</li><li>Decr():减少-1</li><li>DecrBy():按指定步长减少</li><li>Append():追加</li><li>StrLen():获取长度</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis String Set/Get 示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGetExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.Set 设置 key 如果设置为-1则表示永不过期</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;score&quot;</span>, <span class="number">100</span>, <span class="number">60</span>*time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;set score failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Get 获取已存在的Key其存储的值</span></span><br><span class="line">val1, err := rdb.Get(ctx, <span class="string">&quot;score&quot;</span>).Result() <span class="comment">// 获取其值</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get score failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;val1 -&gt; score ：%v\n&quot;</span>, val1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取一个不存在的值返回redis.Nil 则说明不存在</span></span><br><span class="line">val2, err := rdb.Get(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[ERROR] - Key [name] not exist&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get name failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exists() 方法用于检测某个key是否存在</span></span><br><span class="line">n, _ := rdb.Exists(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name key 存在!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name key 不存在!&quot;</span>)</span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;weiyi&quot;</span>, <span class="number">60</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line">val2, _ = rdb.Get(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;val2 -&gt; name : &quot;</span>, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.SetNX 当不存在key时将进行设置该可以并设置其过期时间</span></span><br><span class="line">val3, err := rdb.SetNX(ctx, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;weiyigeek&quot;</span>, <span class="number">0</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;set username failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;val3 -&gt; username: %v\n&quot;</span>, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.Keys() 根据正则获取keys, DBSize() 查看当前数据库key的数量.</span></span><br><span class="line">keys, _ := rdb.Keys(ctx, <span class="string">&quot;*&quot;</span>).Result()</span><br><span class="line">num, err := rdb.DBSize(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;All Keys : %v, Keys number : %v \n&quot;</span>, keys, num)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据前缀获取Key</span></span><br><span class="line">  vals, _ := rdb.Keys(ctx, <span class="string">&quot;user*&quot;</span>).Result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.Type() 方法用户获取一个key对应值的类型</span></span><br><span class="line">vType, err := rdb.Type(ctx, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;username key type : %v\n&quot;</span>, vType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.Expire()方法是设置某个时间段(time.Duration)后过期，ExpireAt()方法是在某个时间点(time.Time)过期失效.</span></span><br><span class="line">val4, _ := rdb.Expire(ctx, <span class="string">&quot;name&quot;</span>, time.Minute*<span class="number">2</span>).Result()</span><br><span class="line"><span class="keyword">if</span> val4 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name 过期时间设置成功&quot;</span>, val4)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name 过期时间设置失败&quot;</span>, val4)</span><br><span class="line">&#125;</span><br><span class="line">val5, _ := rdb.ExpireAt(ctx, <span class="string">&quot;username&quot;</span>, time.Now().Add(time.Minute*<span class="number">2</span>)).Result()</span><br><span class="line"><span class="keyword">if</span> val5 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;username 过期时间设置成功&quot;</span>, val5)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;username 过期时间设置失败&quot;</span>, val5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.TTL()与PTTL()方法可以获取某个键的剩余有效期</span></span><br><span class="line">userTTL, _ := rdb.TTL(ctx, <span class="string">&quot;user&quot;</span>).Result() <span class="comment">// 获取其key的过期时间</span></span><br><span class="line">usernameTTL, _ := rdb.PTTL(ctx, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;user TTL : %v, username TTL : %v\n&quot;</span>, userTTL, usernameTTL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.Del():删除缓存项与FlushDB():清空当前数据</span></span><br><span class="line">  <span class="comment">// 当通配符匹配的key的数量不多时，可以使用Keys()得到所有的key在使用Del命令删除。</span></span><br><span class="line">num, err = rdb.Del(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Del() : &quot;</span>, num)</span><br><span class="line">  <span class="comment">// 如果key的数量非常多的时候，我们可以搭配使用Scan命令和Del命令完成删除。</span></span><br><span class="line">  iter := rdb.Scan(ctx, <span class="number">0</span>, <span class="string">&quot;user*&quot;</span>, <span class="number">0</span>).Iterator()</span><br><span class="line">  <span class="keyword">for</span> iter.Next(ctx) &#123;</span><br><span class="line">    err := rdb.Del(ctx, iter.Val()).Err()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := iter.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.清空当前数据库，因为连接的是索引为0的数据库，所以清空的就是0号数据库</span></span><br><span class="line">flag, err := rdb.FlushDB(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;FlushDB() : &quot;</span>, flag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>redis数据库中字符串与整型操作实践</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringIntExample 数据类型演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringIntExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置字符串类型的key</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetRange ：字符串截取</span></span><br><span class="line"><span class="comment">// 注：即使key不存在，调用GetRange()也不会报错，只是返回的截取结果是空&quot;&quot;,可以使用fmt.Printf(&quot;%q\n&quot;, val)来打印测试</span></span><br><span class="line">val1, _ := rdb.GetRange(ctx, <span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">4</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: hello, value: %v\n&quot;</span>, val1) <span class="comment">//截取到的内容为: ello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append()表示往字符串后面追加元素，返回值是字符串的总长度</span></span><br><span class="line">length1, _ := rdb.Append(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot; Go Programer&quot;</span>).Result()</span><br><span class="line">val2, _ := rdb.Get(ctx, <span class="string">&quot;hello&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前缓存key的长度为: %v，值: %v \n&quot;</span>, length1, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置整形的key</span></span><br><span class="line">err = rdb.SetNX(ctx, <span class="string">&quot;number&quot;</span>, <span class="number">1</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Incr()、IncrBy()都是操作数字，对数字进行增加的操作</span></span><br><span class="line"><span class="comment">// Decr()、DecrBy()方法是对数字进行减的操作，和Incr正好相反</span></span><br><span class="line"><span class="comment">// incr是执行原子加1操作</span></span><br><span class="line">val3, _ := rdb.Incr(ctx, <span class="string">&quot;number&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Incr -&gt; key当前的值为: %v\n&quot;</span>, val3) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// incrBy是增加指定的数</span></span><br><span class="line">val4, _ := rdb.IncrBy(ctx, <span class="string">&quot;number&quot;</span>, <span class="number">6</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;IncrBy -&gt; key当前的值为: %v\n&quot;</span>, val4) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StrLen 也可以返回缓存key的长度</span></span><br><span class="line">length2, _ := rdb.StrLen(ctx, <span class="string">&quot;number&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;number 值长度: %v\n&quot;</span>, length2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031225.png" alt="字符串总结图.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Redis 3.2 之前 SDS 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031222.png" alt="字符串存储结构图.png"></p><p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* 已使用长度，1 字节存储 */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* 总长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">// 真正存储字符串的数据空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* 已使用长度，2 字节存储 */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* 已使用长度，4 字节存储 */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* 已使用长度，8 字节存储 */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p><p>确切地说，String在Redis中是用一个robj来表示的。</p><p>用来表示String的robj可能编码成3种内部表示：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把 string 存成了 int 型。</p><ul><li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；</li><li>如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li></ul><p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p><p><strong>为什么是 44 字节？</strong></p><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p><p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p><p>在前言部分就已经提到过 <code>redisObject</code> 了，其中的五个字段一共占据了 16 字节。</p><p>SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：SDS <em> TYPE </em> 5、SDS <em> TYPE </em> 8、SDS <em> TYPE </em> 16、SDS <em> TYPE </em> 32、SDS <em> TYPE </em> 64，在这些类型中最小的存储类型为 SDS <em> TYPE </em> ５，但 SDS <em> TYPE </em> ５ 类型会默认转成 SDS <em> TYPE </em> 8，以下源码可以证明，如下图所示：<img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031223.png" alt="SDS-0116-1.png"></p><p><strong>为什么转换？</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-2.png" alt="img"></p><p>可以看出，SDS <em> TYPE </em> 5类型根本就无法使用。</p><p>那我们直接来看 SDS <em> TYPE </em> 8 的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 <code>\0</code> 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031224.png" alt="44字节说明图.png"></p><h2 id="性能优势"><a href="#性能优势" class="headerlink" title="性能优势"></a>性能优势</h2><p>SDS 与 C 语言字符串比较相近，但拥有更过的优势：</p><ul><li>SDS 获取字符串长度时间复杂度 O(1)：因为 SDS 通过 len 字段来存储长度，使用时直接读取就可以；C 语言要想获取字符串长度需要遍历整个字符串，时间复杂度 O(N)。</li><li>SDS 能杜绝缓冲区的溢出：因为当 SDS API 要对 SDS 进行修改时，会先检查 SDS 的空间是否足够，如果不够的话 SDS 会自动扩容，So，不会造成缓冲区溢出。而 C 语言则不具备这个功能。</li><li>SDS 能减少修改字符串时带来的内存重分配次数：<ul><li>空间预分配：当 SDS 扩容时不只是会增加需要的空间大小，还会额外的分配一些未使用的空间。分配的规则是：如果分配后 SDS 的长度小于 1MB，那么会分配等于分配后 SDS 的大小的未使用空间，简单说就是，SDS 动态分配后是 16KB，那么就会多分配 16KB 的未使用空间；如果 小于 1MB，那么久分配 1MB 的未使用空间。</li><li>惰性空间释放： 惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，并不会立即内存重分配来回收多出来的字节，而是用 free 来记录未使用空间。</li></ul></li></ul><h3 id="空间预分配补进一步理解"><a href="#空间预分配补进一步理解" class="headerlink" title="空间预分配补进一步理解"></a>空间预分配补进一步理解</h3><p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf=&#39;Hello World again!\0....................&#39;</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p><p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p><p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p><h1 id="哈希（Hash）：万花筒般的博学者"><a href="#哈希（Hash）：万花筒般的博学者" class="headerlink" title="哈希（Hash）：万花筒般的博学者"></a>哈希（Hash）：万花筒般的博学者</h1><p>接下来出场的是哈希，哈希就像是一个学识渊博的百科全书，里面装着各种各样的知识点。你问他什么，他都能迅速找到并回答你。哈希非常适合存储对象类型的数据，每个字段都能独立操作，让你在管理数据时游刃有余。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031216.png" alt="哈希表存储结构.png"></p><h2 id="如何使用？-1"><a href="#如何使用？-1" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-1"><a href="#命令行操作方式-1" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置指定哈希表中指定字段的值</td></tr><tr><td>HSETNX key field value</td><td>只有指定字段不存在时设置指定字段的值</td></tr><tr><td>HMSET key field1 value1 field2 value2 …</td><td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td></tr><tr><td>HGET key field</td><td>获取指定哈希表中指定字段的值</td></tr><tr><td>HMGET key field1 field2 …</td><td>获取指定哈希表中一个或者多个指定字段的值</td></tr><tr><td>HGETALL key</td><td>获取指定哈希表中所有的键值对</td></tr><tr><td>HEXISTS key field</td><td>查看指定哈希表中指定的字段是否存在</td></tr><tr><td>HDEL key field1 field2 …</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HLEN key</td><td>获取指定哈希表中字段的数量</td></tr></tbody></table></div><p>更多 Redis Hash 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=hash">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-1"><a href="#代码操作方式（采用Go-Redis-V8-版本）-1" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>HSet():设置</li><li>HMset():批量设置</li><li>HGet():获取某个元素</li><li>HGetAll():获取全部元素</li><li>HDel():删除某个元素</li><li>HExists():判断元素是否存在</li><li>HLen():获取长度</li></ul><p><strong>简单示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// (1) HSet() 设置字段和值</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>&#125;)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;key5&quot;</span>: <span class="string">&quot;value5&quot;</span>, <span class="string">&quot;key6&quot;</span>: <span class="string">&quot;value6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) HMset():批量设置</span></span><br><span class="line">rdb.HMSet(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;WeiyiGeek&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">88</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;重庆&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) HGet() 获取某个元素</span></span><br><span class="line">address, _ := rdb.HGet(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="string">&quot;address&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser.address -&gt; &quot;</span>, address)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) HGetAll() 获取全部元素</span></span><br><span class="line">hmuser, _ := rdb.HGetAll(ctx, <span class="string">&quot;hmuser&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser :=&gt; &quot;</span>, hmuser)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) HExists 判断元素是否存在</span></span><br><span class="line">flag, _ := rdb.HExists(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="string">&quot;address&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;address 是否存在 hmuser 中: &quot;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) HLen() 获取长度</span></span><br><span class="line">length, _ := rdb.HLen(ctx, <span class="string">&quot;hmuser&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser hash 键长度: &quot;</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (7) HDel() 支持一次删除多个元素</span></span><br><span class="line">count, _ := rdb.HDel(ctx, <span class="string">&quot;huser&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;删除元素的个数: &quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来的三个小节将分别介绍 Redis 的哈希表、哈希表节点、以及字典的实现。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组    </span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值    </span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p></li><li><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p></li><li>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</li></ul><p>下图 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b00db9f0d5b742d777ee65a9de3a0f7a.png" alt="img"></p><h4 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h4><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><ul><li>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</li><li>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</li></ul><p>举个例子， 下图就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/051f340b7b501e61045e94542bf519e0.png" alt="img"></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis 中的字典由 dict.h/dict 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li><li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>下图 展示了一个普通状态下（没有进行 rehash）的字典：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0469efb2d1c938e7ae4650ed62c7f121.png" alt="img"></p><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>字典类型本质上是由数组和链表结构组成的，通常情况下字典类型会使用数组的方式来存储相关的数据，但发生<strong>哈希冲突</strong>时才会使用链表的结构来存储数据。</p><p><strong>Redis 计算索引值的方法是：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>类似 Java 的 HashMap，计算 key 的 hash 值，然后 hash &amp; (len - 1), 而 Redis 的 sizemask 就是 size - 1。</p><p><strong>什么是哈希冲突？发生哈希冲突怎么办？</strong></p><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为<strong>哈希冲突</strong>。</p><p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p><p>键值查询的流程如下：</p><ul><li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li><li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li></ul><p>键值查询流程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031218.png" alt="Redis-HashType-03.png"></p><h2 id="性能优势-1"><a href="#性能优势-1" class="headerlink" title="性能优势"></a>性能优势</h2><p>dict本质上是为了解决算法中的查找问题，是一个基于哈希表的算法，在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，查询的时间复杂度接近<strong>O(1)</strong>。它采用某个哈希函数并通过计算key从而找到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发<strong>重哈希（rehash）</strong>，为了避免扩容时一次性对所有key进行重哈希，Redis采用了一种称为<strong>渐进式重哈希（incremental rehash）</strong>的方法，将重哈希的操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着不断的操作，hash 表中的键值对可能会增多或减少，为了让哈希表的负载因子保持在一个范围内，需要对 hash 表进行扩容或收缩，收缩和扩容的过程就叫 rehash。rehash 过程如下：</p><ol><li>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）(ht 是字典中的 hash 表，上文有介绍)：</li><li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li><li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备</li></ol><p><strong>触发扩容的条件</strong>：</p><p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p><p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p><p><strong>渐进式 rehash</strong></p><p>rehash 时会将 ht[0] 所有的键值对迁移到 ht[1] 中，但这个动作不是一次性的，而是分多次、渐进式地完成。这样的所得原因时：当数据量大的时候一次性迁移会造成服务器在一段时间内定制服务。为了避免发生这样的事就出现了 <strong>渐进式 rehash</strong>。</p><p>主要的执行流程如下：</p><ul><li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li><li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li><li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li></ul><h1 id="列表（List）：风驰电掣的快马"><a href="#列表（List）：风驰电掣的快马" class="headerlink" title="列表（List）：风驰电掣的快马"></a>列表（List）：风驰电掣的快马</h1><p>第三位登场的是列表，这位兄弟简直就是江湖上的快马，擅长在前后两个方向上迅速移动。无论是队列还是栈，列表都能应付自如。最适合需要顺序操作的场景，比如任务队列或者消息队列。</p><p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031229.png" alt="列表类型使用-列表结构图.png"></p><h2 id="如何使用？-2"><a href="#如何使用？-2" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-2"><a href="#命令行操作方式-2" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>LPUSH key value1 value2 ..</td><td>在指定列表的头部（左边）添加一个或多个元素</td></tr><tr><td>RPUSH key value1 value2 …</td><td>在指定列表的尾部（右边）添加一个或多个元素</td></tr><tr><td>LSET key index value</td><td>将指定列表索引 index 位置的值设置为 value</td></tr><tr><td>LPOP key</td><td>移除并获取指定列表的第一个元素(最左边)</td></tr><tr><td>RPOP key</td><td>移除并获取指定列表的最后一个元素(最右边)</td></tr><tr><td>LLEN key</td><td>获取列表元素数量</td></tr><tr><td>LRANGE key start end</td><td>获取列表 start 和 end 之间 的元素</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151156374-72815148.png" alt="img"></p><p>更多 Redis List 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=list">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-2"><a href="#代码操作方式（采用Go-Redis-V8-版本）-2" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p><strong>常用方法:</strong></p><ul><li>LPush():将元素压入链表</li><li>LInsert():在某个位置插入新元素</li><li>LSet():设置某个元素的值</li><li>LLen():获取链表元素个数</li><li>LIndex():获取链表下标对应的元素</li><li>LRange():获取某个选定范围的元素集</li><li>LPop()从链表左侧弹出数据</li><li>LRem():根据值移除元素</li></ul><p><strong>简单示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 插入指定值到list列表中，返回值是当前列表元素的数量</span></span><br><span class="line"><span class="comment">// 使用LPush()方法将数据从左侧压入链表（后进先出）,也可以从右侧压如链表对应的方法是RPush()</span></span><br><span class="line">count, _ := rdb.LPush(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;插入到list集合中元素的数量: &quot;</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LInsert() 在某个位置插入新元素</span></span><br><span class="line"><span class="comment">// 在名为key的缓存项值为2的元素前面插入一个值，值为123 ， 注意只会执行一次</span></span><br><span class="line">_ = rdb.LInsert(ctx, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;before&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">123</span>).Err()</span><br><span class="line"><span class="comment">// 在名为key的缓存项值为2的元素后面插入一个值，值为321</span></span><br><span class="line">_ = rdb.LInsert(ctx, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;after&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">321</span>).Err()</span><br><span class="line"></span><br><span class="line"><span class="comment">// LSet() 设置某个元素的值</span></span><br><span class="line"><span class="comment">//下标是从0开始的</span></span><br><span class="line">val1, _ := rdb.LSet(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>, <span class="number">256</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;是否成功将下标为2的元素值改成256: &quot;</span>, val1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LLen() 获取链表元素个数</span></span><br><span class="line">length, _ := rdb.LLen(ctx, <span class="string">&quot;list&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前链表的长度为: %v\n&quot;</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LIndex() 获取链表下标对应的元素</span></span><br><span class="line">val2, _ := rdb.LIndex(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;下标为2的值为: %v\n&quot;</span>, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表左侧弹出数据</span></span><br><span class="line">val3, _ := rdb.LPop(ctx, <span class="string">&quot;list&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;弹出下标为0的值为: %v\n&quot;</span>, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRem() 根据值移除元素 lrem key count value</span></span><br><span class="line">n, _ := rdb.LRem(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>, <span class="string">&quot;256&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;移除了: %v 个\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding list</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p><ol><li><p>Redis3.2之前的底层实现方式：压缩列表ziplist 或者 双向循环链表linkedlist</p><p>当list存储的数据量较少时，会使用ziplist存储数据，也就是同时满足下面两个条件：</p><ul><li>列表中数据个数少于512个</li><li>list中保存的每个元素的长度小于 64 字节</li><li>当不能同时满足上面两个条件的时候，list就通过双向循环链表linkedlist来实现了</li></ul></li><li><p>Redis3.2及之后的底层实现方式：quicklist</p><p>quicklist是一个双向链表，而且是一个基于ziplist的双向链表，quicklist的每个节点都是一个ziplist，结合了双向链表和ziplist的优点。</p></li></ol><h3 id="数据类型-2"><a href="#数据类型-2" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>我们来看下 quicklist 的实现源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistLZF is a 4+N byte struct holding &#x27;sz&#x27; followed by &#x27;compressed&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;sz&#x27; is byte length of &#x27;compressed&#x27; field.</span></span><br><span class="line"><span class="comment"> * &#x27;compressed&#x27; is LZF data with total (compressed) length &#x27;sz&#x27;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span></span><br><span class="line"><span class="comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="type">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bookmarks are padded with realloc at the end of of the quicklist struct.</span></span><br><span class="line"><span class="comment"> * They should only be used for very big lists if thousands of nodes were the</span></span><br><span class="line"><span class="comment"> * excess memory usage is negligible, and there&#x27;s a real need to iterate on them</span></span><br><span class="line"><span class="comment"> * in portions.</span></span><br><span class="line"><span class="comment"> * When not used, they don&#x27;t add any memory overhead, but when used and then</span></span><br><span class="line"><span class="comment"> * deleted, some overhead remains (to avoid resonance).</span></span><br><span class="line"><span class="comment"> * The number of bookmarks used should be kept to minimum since it also adds</span></span><br><span class="line"><span class="comment"> * overhead on node deletion (searching for a bookmark to update). */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistBookmark</span> &#123;</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; quicklistBookmark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: -1 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor.</span></span><br><span class="line"><span class="comment"> * &#x27;bookmakrs are an optional feature that is used by realloc this struct,</span></span><br><span class="line"><span class="comment"> *      so that they don&#x27;t consume memory when not used. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure><p>这里定义了6个结构体:</p><ul><li><code>quicklistNode</code>：宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例。</li><li><code>quicklistLZF</code>：ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例。</li><li><code>quicklistBookmark</code>：在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>：这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间。</li><li><code>quicklistIter</code>是一个迭代器。</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下。</li></ul><p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：        </p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-31230.png" alt="列表类型使用-quicklist结构图.png"></p><p><strong>quicklist更多额外信息：</strong></p><p>下面是有关quicklist的更多额外信息:</p><ul><li><code>quicklist.fill</code>的值影响着每个链表结点中, ziplist的长度. <ol><li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li><li>-1 不超过4kb</li><li>-2 不超过 8kb</li><li>-3 不超过 16kb</li><li>-4 不超过 32kb</li><li>-5 不超过 64kb</li><li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li></ol></li><li><code>quicklist.compress</code>的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF <ol><li>0 表示不压缩, zl字段直接指向ziplist</li><li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>以此类推, 最大值为2^16</li></ol></li><li><code>quicklistNode.encoding</code>字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</li><li><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</li><li><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</li></ul><h4 id="zaplist"><a href="#zaplist" class="headerlink" title="zaplist"></a>zaplist</h4><p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，<strong>ziplist 数据结构</strong>如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-6.png" alt="img"></p><p>其中的字段含义如下：</p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数。</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作。</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到。</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255。</li></ul><p><strong>Entry 结构</strong></p><ul><li><strong>先看下源码中相关介绍</strong></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-7.png" alt="img"></p><p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p><ul><li><code>prevlen</code>：前一个entry的大小，编码方式见下文；</li><li><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</li><li><code>entry-data</code>：真是用于存储entry表示的数据；</li></ul><p><strong>第二种情况</strong>：在entry中存储的是int类型时，<code>encoding</code> 和<code>entry-data</code>会合并在<code>encoding</code>中表示，此时没有<code>entry-data</code>字段；</p><p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p><p>此时entry结构：<code>&lt;prevlen&gt; &lt;encoding&gt;</code></p><ul><li><strong>prevlen编码</strong></li></ul><p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构</span><br><span class="line">0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254</span><br></pre></td></tr></table></figure><ul><li><strong>encoding编码</strong></li></ul><p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p><p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><p><strong>存储string时</strong>：</p><p><code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p><p><code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p><p><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p><p><strong>存储int时</strong>：</p><p><code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；</p><p><code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32;</p><p><code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64;</p><p><code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；</p><p><code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；</p><p><code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p><p><code>|11111111|</code> 还记得zlend么？</p><ul><li><strong>源码中数据结构支撑</strong></li></ul><p>你可以看到为了操作上的简易实际还增加了几个属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><ul><li><code>prevrawlensize</code>表示 previous_entry_length字段的长度</li><li><code>prevrawlen</code>表示 previous_entry_length字段存储的内容</li><li><code>lensize</code>表示 encoding字段的长度</li><li><code>len</code>表示数据内容长度</li><li><code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li><li><code>encoding</code>表示数据类型</li><li><code>p</code>表示当前元素首地址</li></ul><p><strong>看个例子：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis_ziplist_sample.png" alt="Redis Ziplist Sample"></p><p>上图是一份真实的ziplist数据。我们逐项解读一下：</p><ul><li>这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</li><li>头4个字节（0x21000000）是按小端（little endian）模式存储的<code>&lt;zlbytes&gt;</code>字段。因此，这里<code>&lt;zlbytes&gt;</code>的值应该解析成0x00000021，用十进制表示正好就是33。</li><li>接下来4个字节（byte[4..7]）是<code>&lt;zltail&gt;</code>，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</li><li>再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</li><li>接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为”name”。</li><li>接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串”tielei”。</li><li>接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串”age”。</li><li>接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</li><li>最后1个字节（byte[32]）表示<code>&lt;zlend&gt;</code>，是固定的值255（0xFF）。</li></ul><p>总结一下，这个ziplist里存了4个数据项，分别为：</p><ul><li>字符串: “name”</li><li>字符串: “tielei”</li><li>字符串: “age”</li><li>整数: 20</li></ul><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="添加功能源码分析"><a href="#添加功能源码分析" class="headerlink" title="添加功能源码分析"></a>添加功能源码分析</h4><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        <span class="comment">// 在列表头部添加元素</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        <span class="comment">// 在列表尾部添加元素</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 quicklistPushHead 为例，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 在头部节点插入元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p><p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p><p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。 quicklistPushHead 执行流程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031232.png" alt="列表类型使用-插入流程图.png"></p><h4 id="删除功能源码分析"><a href="#删除功能源码分析" class="headerlink" title="删除功能源码分析"></a>删除功能源码分析</h4><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p><h5 id="单一元素删除"><a href="#单一元素删除" class="headerlink" title="单一元素删除"></a>单一元素删除</h5><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> &#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="type">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p><h5 id="区间元素删除"><a href="#区间元素删除" class="headerlink" title="区间元素删除"></a>区间元素删除</h5><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start 表示开始删除的下标，count 表示要删除的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="type">const</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> extent = count; </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// 删除的元素个数大于已有元素</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// 删除指定的元素个数</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// extent 为剩余需要删除的元素个数，</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> del;</span><br><span class="line">        <span class="type">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 删除整个 quicklistNode</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">           <span class="comment">// 删除本节点的所有元素</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除本节点部分元素</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line">        D(<span class="string">&quot;[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), &quot;</span></span><br><span class="line">          <span class="string">&quot;node count: %u&quot;</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余待删除元素的个数</span></span><br><span class="line">        extent -= del;</span><br><span class="line">        <span class="comment">// 下个 quicklistNode</span></span><br><span class="line">        node = next;</span><br><span class="line">        <span class="comment">// 从下个 quicklistNode 起始位置开始删除</span></span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p><p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p><h4 id="更多源码"><a href="#更多源码" class="headerlink" title="更多源码"></a>更多源码</h4><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p><ul><li>quicklistCreate：创建 quicklist；</li><li>quicklistInsertAfter：在某个元素的后面添加数据；</li><li>quicklistInsertBefore：在某个元素的前面添加数据；</li><li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li><li>quicklistReplaceAtIndex：替换某个元素。</li></ul><h2 id="性能优势-2"><a href="#性能优势-2" class="headerlink" title="性能优势"></a>性能优势</h2><p>quicklist有自己的优点， 也有缺点， 对于使用者来说， 其使用体验类似于线性数据结构， list作为最传统的双链表， 结点通过指针持有数据， 指针字段会耗费大量内存。 ziplist解决了耗费内存这个问题。 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配。 quicklist在两者之间做了一个平衡。 并且使用者可以通过自定义<code>quicklist.fill</code>， 根据实际业务情况， 经验主义调参。</p><h3 id="为什么-ziplist-特别省内存"><a href="#为什么-ziplist-特别省内存" class="headerlink" title="为什么 ziplist 特别省内存"></a>为什么 ziplist 特别省内存</h3><p>只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p><p>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</p><p>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</p><p>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</p><hr><p>结合了双向链表和ziplist的优点，quicklist就应运而生了。</p><h1 id="集合（Set）：独步天下的独行侠"><a href="#集合（Set）：独步天下的独行侠" class="headerlink" title="集合（Set）：独步天下的独行侠"></a>集合（Set）：独步天下的独行侠</h1><p>然后，我们的集合大师登场了！集合就像是江湖中的独行侠，天生不爱重复。他擅长处理那些独一无二的数据，无论是要去重还是计算交集并集，集合都能完美胜任。正是他那种独特的个性，让他在数据江湖中独步天下。</p><p>集合类型 (Set) 是一个无序并唯一的键值集合。之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储。</p><p>集合类型和列表类型的区别如下：</p><ul><li>列表可以存储重复元素，集合只能存储非重复元素；</li><li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151400257-695491959.png" alt="img"></p><h2 id="如何使用？-3"><a href="#如何使用？-3" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-3"><a href="#命令行操作方式-3" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SADD key member1 member2 …</td><td>向指定集合添加一个或多个元素</td></tr><tr><td>SMEMBERS key</td><td>获取指定集合中的所有元素</td></tr><tr><td>SCARD key</td><td>获取指定集合的元素数量</td></tr><tr><td>SISMEMBER key member</td><td>判断指定元素是否在指定集合中</td></tr><tr><td>SINTER key1 key2 …</td><td>获取给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 key2 …</td><td>将给定所有集合的交集存储在 destination 中</td></tr><tr><td>SUNION key1 key2 …</td><td>获取给定所有集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 key2 …</td><td>将给定所有集合的并集存储在 destination 中</td></tr><tr><td>SDIFF key1 key2 …</td><td>获取给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 key2 …</td><td>将给定所有集合的差集存储在 destination 中</td></tr><tr><td>SPOP key count</td><td>随机移除并获取指定集合中一个或多个元素</td></tr><tr><td>SRANDMEMBER key count</td><td>随机获取指定集合中指定数量的元素</td></tr></tbody></table></div><p>更多 Redis Set 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=set">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-3"><a href="#代码操作方式（采用Go-Redis-V8-版本）-3" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>SAdd():添加元素</li><li>SPop():随机获取一个元素</li><li>SRem():删除集合里指定的值</li><li>SSMembers():获取所有成员</li><li>SIsMember():判断元素是否在集合中</li><li>SCard():获取集合元素个数</li><li>SUnion():并集,SDiff():差集,SInter():交集</li></ul><p>Tips：集合数据的特征，元素不能重复保持唯一性, 元素无序不能使用索引(下标)操作</p><p><strong>简单示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 集合元素缓存设置</span></span><br><span class="line">keyname := <span class="string">&quot;Program&quot;</span></span><br><span class="line">mem := []<span class="type">string</span>&#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Delphi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Golang&quot;</span>&#125;</span><br><span class="line"><span class="comment">// //由于Golang已经被添加到Program集合中，所以重复添加时无效的</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> mem &#123;</span><br><span class="line">rdb.SAdd(ctx, keyname, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SCard() 获取集合元素个数</span></span><br><span class="line">total, _ := rdb.SCard(ctx, keyname).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;golang集合成员个数: &quot;</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPop() 随机获取一个元素 （无序性，是随机的）</span></span><br><span class="line">val1, _ := rdb.SPop(ctx, keyname).Result()</span><br><span class="line"><span class="comment">// SPopN()  随机获取多个元素.</span></span><br><span class="line">val2, _ := rdb.SPopN(ctx, keyname, <span class="number">2</span>).Result()</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSMembers() 获取所有成员</span></span><br><span class="line">val3, _ := rdb.SMembers(ctx, keyname).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;随机获取一个元素: %v , 随机获取多个元素: %v \n所有成员: %v\n&quot;</span>, val1, val2, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIsMember() 判断元素是否在集合中</span></span><br><span class="line">exists, _ := rdb.SIsMember(ctx, keyname, <span class="string">&quot;golang&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;golang 存在 Program 集合中.&quot;</span>) <span class="comment">// 注意:我们存入的是Golang而非golang</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;golang 不存在 Program 集合中.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SUnion():并集, SDiff():差集, SInter():交集</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;setB&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">union, _ := rdb.SUnion(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;并集&quot;</span>, union)</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line">diff, _ := rdb.SDiff(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;差集&quot;</span>, diff)</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">inter, _ := rdb.SInter(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;交集&quot;</span>, inter)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除集合中指定元素(返回成功)</span></span><br><span class="line">  n, _ := rdb.SRem(ctx, <span class="string">&quot;setB&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;f&quot;</span>).Result()</span><br><span class="line">  fmt.Println(<span class="string">&quot;已成功删除元素的个数: &quot;</span>,n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031226.png" alt="集合Set-hashtable.png"></p><p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储。</p><p>当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储：</p><ol><li>当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。 </li><li>当元素为非整数时，集合将会使用 hashtable 来存储。</li></ol><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>先看源码结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 <strong>encoding 属性</strong>的值：如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。下图是一个包含五个 int16_t 类型整数值的整数集合。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/46856dc6c841acc54dc4a4513eda1007.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-8.png" alt="img"></p><p>可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？</p><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ul><li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ul><p>整数集合<strong>不支持降级操作</strong>， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p><h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 添加元素到集合</span></span><br><span class="line"><span class="comment"> * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 字典类型</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// inset 数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转化为整数类型失败，使用字典类型存储</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未知编码(类型)</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p><h2 id="性能优势-3"><a href="#性能优势-3" class="headerlink" title="性能优势"></a>性能优势</h2><p>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p><p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p><h1 id="有序集合（Sorted-Set）：运筹帷幄的智者"><a href="#有序集合（Sorted-Set）：运筹帷幄的智者" class="headerlink" title="有序集合（Sorted Set）：运筹帷幄的智者"></a>有序集合（Sorted Set）：运筹帷幄的智者</h1><p>最后一位出场的是有序集合，这位兄弟简直是个运筹帷幄的智者。他不仅有集合哥的特质，还多了一项绝技：排序。每个成员都有一个分数，他可以根据分数将成员排序，非常适合排行榜、评分系统等场景。</p><p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p><p>当我们把学生的成绩存储在有序集合中时，它的存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031227.png" alt="学生存储值.png"></p><h2 id="如何使用？-4"><a href="#如何使用？-4" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-4"><a href="#命令行操作方式-4" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>ZADD key score1 member1 score2 member2 …</td><td>向指定有序集合添加一个或多个元素</td></tr><tr><td>ZCARD KEY</td><td>获取指定有序集合的元素数量</td></tr><tr><td>ZSCORE key member</td><td>获取指定有序集合中指定元素的 score 值</td></tr><tr><td>ZINTERSTORE destination numkeys key1 key2 …</td><td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td></tr><tr><td>ZUNIONSTORE destination numkeys key1 key2 …</td><td>求并集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZDIFF destination numkeys key1 key2 …</td><td>求差集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td></tr><tr><td>ZREVRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td></tr><tr><td>ZREVRANK key member</td><td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td></tr></tbody></table></div><p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=sorted-set">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-4"><a href="#代码操作方式（采用Go-Redis-V8-版本）-4" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>ZAdd():添加元素</li><li>ZIncrBy():增加元素分值</li><li>ZRange()、ZRevRange():获取根据score排序后的数据段</li><li>ZRangeByScore()、ZRevRangeByScore():获取score过滤后排序的数据段</li><li>ZCard():获取元素个数</li><li>ZCount():获取区间内元素个数</li><li>ZScore():获取元素的score</li><li>ZRank()、ZRevRank():获取某个元素在集合中的排名</li><li>ZRem():删除元素</li><li>ZRemRangeByRank():根据排名来删除</li><li>ZRemRangeByScore():根据分值区间来删除</li></ul><p><strong>简单示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zsetExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 有序集合成员与分数设置</span></span><br><span class="line"><span class="comment">// zSet类型需要使用特定的类型值*redis.Z，以便作为排序使用</span></span><br><span class="line">lang := []*redis.Z&#123;</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">90.0</span>, Member: <span class="string">&quot;Golang&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">98.0</span>, Member: <span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">95.0</span>, Member: <span class="string">&quot;Python&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">97.0</span>, Member: <span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">99.0</span>, Member: <span class="string">&quot;C/C++&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入ZSet类型</span></span><br><span class="line">num, err := rdb.ZAdd(ctx, <span class="string">&quot;language_rank&quot;</span>, lang...).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zadd failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zadd %d succ.\n&quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ZSet中的某一个元素顺序值增加: 把Golang的分数加10</span></span><br><span class="line">newScore, err := rdb.ZIncrBy(ctx, <span class="string">&quot;language_rank&quot;</span>, <span class="number">10.0</span>, <span class="string">&quot;Golang&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zincrby failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Golang&#x27;s score is %f now.\n&quot;</span>, newScore)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据分数排名取出元素:取分数最高的3个</span></span><br><span class="line">ret, err := rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;language_rank&quot;</span>, <span class="number">0</span>, <span class="number">2</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zrevrange failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zsetKey前3名热度的是: %v\n,Top 3 的 Memeber 与 Score 是:\n&quot;</span>, ret)</span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">fmt.Println(z.Member, z.Score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZRangeByScore()、ZRevRangeByScore():获取score过滤后排序的数据段</span></span><br><span class="line"><span class="comment">// 此处表示取95~100分的</span></span><br><span class="line">op := redis.ZRangeBy&#123;</span><br><span class="line">Min: <span class="string">&quot;95&quot;</span>,</span><br><span class="line">Max: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">ret, err = rdb.ZRangeByScoreWithScores(ctx, <span class="string">&quot;language_rank&quot;</span>, &amp;op).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zrangebyscore failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出全部成员及其score分数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;language_rank 键存储的全部元素:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">fmt.Println(z.Member, z.Score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p><h3 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h4><p>跳跃表（zskiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p><p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p><p> Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。</p><p><strong>跳跃表的实现原理：</strong></p><p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-9.png" alt="img"></p><p>如果我们增加如下两级索引，那么它搜索次数就变成了3次</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-10.png" alt="img"></p><h3 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>层</p><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p><p>下图分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ，以此类推。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d96fcb014a96af27bcebc26c724919dc.png" alt="img"></p><p>跨度</p><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：两个节点之间的跨度越大， 它们相距得就越远。指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</p><p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子， 下图用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/9ddac8937a38c8bb4a3a7850c1a8a188.png" alt=""></p><p>后退指针</p><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p><p>下图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bbfca4ed488e379585b9ea102757b232.png" alt="img"></p><p>分值和成员</p><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p>举个例子， 在下图所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &lt;= o2 &lt;= o3 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c62c33310c977b13d64a210dadbe0a13.png" alt="img"></p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/964cab7318119286f61ffb60a39d942b.png" alt="img"></p><p>但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a09e3a9836113e5a9da1ccaeeefb3241.png" alt="img"></p><p>zskiplist 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中节点的数量    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数    </span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</li><li>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</li><li>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</li></ul><h2 id="性能优势-4"><a href="#性能优势-4" class="headerlink" title="性能优势"></a>性能优势</h2><h3 id="为什么是跳跃表？而非红黑树？"><a href="#为什么是跳跃表？而非红黑树？" class="headerlink" title="为什么是跳跃表？而非红黑树？"></a>为什么是跳跃表？而非红黑树？</h3><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p><h3 id="kiplist与平衡树、哈希表的比较"><a href="#kiplist与平衡树、哈希表的比较" class="headerlink" title="kiplist与平衡树、哈希表的比较"></a>kiplist与平衡树、哈希表的比较</h3><p>来源于：<a href="https://www.jianshu.com/p/8ac45fd01548">https://www.jianshu.com/p/8ac45fd01548</a></p><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通过学习上面的内容，我们已经非常了解这五种数据结构的基本使用和内部原理了，那么在实际生产中到底要怎么用，每种数据结构的使用场景是什么，我们来看一下。</p><p>当然！下面是关于Redis五种基础数据结构的应用场景的详细介绍：</p><h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>缓存数据</strong>：字符串是缓存数据的最常用数据结构，比如缓存用户信息、产品详情等。</li><li><strong>计数器</strong>：使用INCR、DECR等命令，可以轻松实现各种计数功能，如网站访问量、点赞数等。</li><li><strong>会话存储</strong>：将用户会话信息存储在字符串中，便于快速读取和更新。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存用户信息</span></span><br><span class="line">SET user:<span class="number">1001</span> <span class="string">&quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数器：增加网站访问量</span></span><br><span class="line">INCR site:views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话存储：设置和获取用户会话</span></span><br><span class="line">SET session:<span class="number">12345</span> <span class="string">&quot;user_id:1001&quot;</span></span><br><span class="line">GET session:<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h2><h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>存储对象</strong>：哈希非常适合存储具有多个字段的对象，如用户信息、商品信息等。</li><li><strong>轻量级的数据存储</strong>：可以存储相对较小的数据，如配置项、状态信息等。</li><li><strong>减少内存消耗</strong>：对于多字段数据，使用哈希可以比字符串节省内存。</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储用户信息</span></span><br><span class="line">HSET user:<span class="number">1001</span> name <span class="string">&quot;John Doe&quot;</span> age <span class="number">30</span> email <span class="string">&quot;john@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的某个字段</span></span><br><span class="line">HGET user:<span class="number">1001</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的所有字段</span></span><br><span class="line">HGETALL user:<span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>任务队列</strong>：列表可以用作任务队列，支持从两端插入和删除元素。</li><li><strong>消息队列</strong>：可以用列表来实现简单的消息队列，保证消息的顺序性。</li><li><strong>日志存储</strong>：将日志条目存储在列表中，便于按时间顺序追加和读取。</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加任务到队列</span></span><br><span class="line">LPUSH task_queue <span class="string">&quot;Task1&quot;</span></span><br><span class="line">RPUSH task_queue <span class="string">&quot;Task2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列获取任务</span></span><br><span class="line">LPOP task_queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储日志条目</span></span><br><span class="line">RPUSH logs <span class="string">&quot;Log entry 1&quot;</span></span><br><span class="line">RPUSH logs <span class="string">&quot;Log entry 2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><h3 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>去重</strong>：集合天生不允许重复元素，非常适合用于去重场景。</li><li><strong>标签管理</strong>：适合存储用户标签、商品标签等。</li><li><strong>社交网络</strong>：可以用来管理好友关系、共同兴趣等。</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储用户标签</span></span><br><span class="line">SADD user:<span class="number">1001</span>:tags <span class="string">&quot;redis&quot;</span> <span class="string">&quot;database&quot;</span> <span class="string">&quot;nosql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在某标签</span></span><br><span class="line">SISMEMBER user:<span class="number">1001</span>:tags <span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有标签</span></span><br><span class="line">SMEMBERS user:<span class="number">1001</span>:tags</span><br></pre></td></tr></table></figure><h2 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h2><h3 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>排行榜</strong>：有序集合非常适合实现排行榜，按分数排序展示前N名用户。</li><li><strong>带权重的数据存储</strong>：适用于需要按权重排序的数据，如评分系统。</li><li><strong>延迟队列</strong>：可以根据分数（时间戳）实现延迟任务队列。</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户到排行榜</span></span><br><span class="line">ZADD leaderboard <span class="number">100</span> <span class="string">&quot;Alice&quot;</span> <span class="number">200</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取排行榜前N名</span></span><br><span class="line">ZRANGE leaderboard <span class="number">0</span> <span class="number">1</span> WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某用户的排名</span></span><br><span class="line">ZRANK leaderboard <span class="string">&quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><p>通过这些应用场景的介绍，相信你对Redis五种基础数据结构的使用有了更深入的了解。每种数据结构都有其独特的优势和适用场景，根据具体需求选择合适的数据结构可以大大提升系统的性能和效率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis数据结构五兄弟，各个身怀绝技，各有千秋。无论是字符串的快剑手、哈希的万花筒、列表的快马、集合的独行侠，还是有序集合的智者，他们都在数据江湖中扮演着不可或缺的角色。希望这篇介绍能让你对Redis的五种基础数据结构有一个更生动形象的了解。让我们一起在Redis的世界中，成为数据江湖的侠客吧！</p><p>哈哈，抽象的标题、抽象的开头和抽象的结尾，笔者实在是懒得去想这些东西要怎么写了，但是又想搞一篇有趣的文章，于是去请教了万能的人工智能 ChatGPt，还可以吧，描述很传神。</p><p>这篇博客真是史诗级的长度，光是看标题就看的眼花缭乱，本来只看了技术摘抄里的文章，觉得好像没有多少内容，还在感慨昨天没学什么东西。结果在搜索更多的资料时发现看的全是概述，重要的内容还没学，于是边学边写，太夸张了，不过还是学到了不少东西的。</p><p>在正式学习 Redis 底层之前，一直觉得 Redis 快就是因为它被存放在内存里，现在发现其实它每一处的设计都有考虑性能和效率。 </p><p>什么？你问为什么今天没有记录什么有趣的东西。</p><p>实在是因为最近一直都在闷着头学东西，也就没怎么去关心实习方面的事，不找实习，连烦恼都消失不见了。</p><p>终于知道为什么大家都讨厌HR了，老小子耍我，说要让技术经理加我的微信跟我面试，结果到现在都没有，骗子不得好死。还好我本来就没有抱希望。</p><p>不过昨天我的好舍友说把我的简历发给他的Leader看了，说不定能帮我找一个实习，不过以我的狗运气，应该不太可能。还是沉下心来学习吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98">Redis数据结构的基本使用和内部原理</a></p><p><a href="https://www.cnblogs.com/xiangningdeguang/p/16955355.html">数据结构的命令行用法</a></p><p><a href="https://www.cnblogs.com/timelesszhuang/p/go-redis.html">数据结构的Go 语言操作</a></p><p><a href="https://blog.csdn.net/a745233700/article/details/113449889">Redis 底层数据结构的概述</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">Redis 底层数据结构的详解</a></p><p><a href="https://xie.infoq.cn/article/78215ce2bb651e7079ea3c80b">Redis 底层数据结构的详解 2</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-dict.html">dict详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-sds.html">SDS详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-robj.html">robj详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-ziplist.html">ziplist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-quicklist.html">quicklist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">skiplist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-intset.html">intset详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天继续学习 Redis 相关的知识，Redis 的五种基础数据结构。虽然在之前的博客中也有提到过这五种数据结构，当时赶着背东西，基本上就是从别人的八股文里抄的，所以还是重新学一下，重新记录加深记忆，正文开始。&lt;/p&gt;
&lt;p&gt;在数据的江湖里，Redis无疑是那位神秘莫测、武</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：让你的数据不再“无疾而终”</title>
    <link href="http://example.com/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/"/>
    <id>http://example.com/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/</id>
    <published>2024-06-04T09:21:41.000Z</published>
    <updated>2024-06-04T11:03:27.376Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的出现，大大提高了我们的查询速度，因其将数据存在内存中，我们的查询速度得到了质的提升。也正是因为在内存中，如果服务器突然断电关机，再次开机后我们的数据也就荡然无存了，这会让我们很崩溃。如何解决？那就是 Redis 的持久化。</p><p>今天我要聊的就是 Redis 持久化。没错，就是那个让你的数据在服务器重启后依然坚挺的功能。不知道你有没有这种感觉：当你以为自己写的代码“永垂不朽”时，服务器重启却让一切化为乌有？别担心，Redis 持久化来拯救你！</p><h1 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h1><p>Redis是一个超级快的内存数据库，但问题来了，内存的特点是断电即失，所以Redis默认情况下，你的数据就像美梦一样——一觉醒来全没了。因此，Redis提供了持久化的功能，帮你把数据存储到硬盘上，这样就算是大风吹断电缆，你的数据也不会“风中凌乱”。</p><p>Redis 持久化拥有以下三种方式：</p><ul><li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li><li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li></ul><p>接下来，咱们一个一个聊。</p><h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p>RDB(Redis database)：实现方式是将存在 Redis 内存中的数据写入到 RDB 文件中保存到磁盘上从而实现持久化的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604174014416.png" alt="image-20240604174014416"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16530eac18882d66%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image1"></p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><p>触发rdb持久化的方式有2种，分别是<strong>手动触发</strong>和<strong>自动触发</strong></p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>Redis 中对于手动触发备份数据到 RDB 文件中，提供了两种方式</p><ol><li><p><code>save</code>: 在主线程中执行，不过这种会阻塞 Redis 服务进程；</p></li><li><p><code>bgsave</code>: 主线程会 fork 出一个子进程来负责处理 RDB 文件的创建，不会阻塞主线程的命令操作，这也是 Redis 中 RDB 文件生成的默认配置；</p></li></ol><p>对于 <code>save</code> 和 <code>bgsave</code> 这两种快照方式，服务端是禁止这两种方式同时执行的，防止产生竞争条件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604174933377.png" alt="image-20240604174933377"></p><p>具体流程如下：</p><ul><li>redis客户端执行<code>bgsave</code>命令或者自动触发<code>bgsave</code>命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就<code>fork</code>一个新的子进程进行持久化数据，<code>fork</code>过程是阻塞的，<code>fork</code>操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。</li></ul><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li>执行debug reload命令重新加载redis时也会触发<code>bgsave</code>操作；</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发<code>bgsave</code>操作；</li></ul><h2 id="redis-conf-中配置-RDB"><a href="#redis-conf-中配置-RDB" class="headerlink" title="redis.conf 中配置 RDB"></a>redis.conf 中配置 RDB</h2><p><strong>快照周期</strong>：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。</p><ul><li><strong>Redis中默认的周期新设置</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 周期性执行条件的设置格式为</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line"># 默认的设置为：</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 以下设置方式为关闭RDB快照功能</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照；</li><li>如果300秒内有10条Key信息发生变化，则进行快照；</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整。</li></ul><p>其他相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p><code>dbfilename</code>：RDB文件在磁盘上的名称。</p><p><code>dir</code>：RDB文件的存储路径。默认设置为“./”，也就是Redis服务的主目录。</p><p><code>stop-writes-on-bgsave-error</code>：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no。</p><p><code>rdbcompression</code>：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”。</p><p><code>rdbchecksum</code>：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no。</p><h2 id="快照时发生数据修改"><a href="#快照时发生数据修改" class="headerlink" title="快照时发生数据修改"></a>快照时发生数据修改</h2><ul><li><strong>由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢</strong>？</li></ul><p>RDB中的核心思路是<strong>Copy-on-Write</strong>，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-rdb-cow.png" alt="redis"></p><h2 id="多久做一次快照"><a href="#多久做一次快照" class="headerlink" title="多久做一次快照"></a>多久做一次快照</h2><p>对于快照，如果做的太频繁，可能会出现前一次快照还没有处理完成，后面的快照数据马上就进来了，同时过于频繁的快照也会增加磁盘的压力。</p><p>如果间隔时间过久，服务器在两次快照期间宕机，丢失的数据大小会随着快照间隔时间的增长而增加。</p><p>那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。</p><p>但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的<strong>空间开销问题</strong>。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？且看后文中4.0版本中引入的RDB和AOF的混合方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li><strong>缺点</strong><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p><h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><p>AOF(Append Only File)：通过保存数据库执行的命令来记录数据库的状态。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-aof.png" alt="redis"></p><p>AOF日志对数据库命令的保存顺序是，Redis 先执行命令，把数据写入内存，然后才记录日志。</p><p><strong>为什么采用写后日志？</strong></p><p>Redis 要求高性能，采用写日志有量方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作。</li></ul><h2 id="如何实现-AOF"><a href="#如何实现-AOF" class="headerlink" title="如何实现 AOF"></a>如何实现 AOF</h2><p>AOF 日志记录 Redis 的每个命令，步骤为：命令追加(append)、文件写入(write) 和文件同步(sync)。</p><ul><li><strong>命令追加：</strong>当 AOF 持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将执行的写命令追加到服务器的 <code>aof_buf</code> 缓冲区。</li><li><strong>文件写入和同步：</strong>关于何时将 <code>aof_buf</code> 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-4.jpg" alt="img"></p><p><code>Always</code>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p><p><code>Everysec</code>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p><p><code>No</code>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><hr><p><strong>三种写回策略的优缺点</strong></p><p>上面的三种写回策略体现了一个重要原则：<strong>trade-off</strong>，取舍，指在性能和可靠性保证之间做取舍。</p><p>关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的：</p><blockquote><p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p><p>这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p></blockquote><h2 id="redis-conf-中配置-AOF"><a href="#redis-conf-中配置-AOF" class="headerlink" title="redis.conf 中配置 AOF"></a>redis.conf 中配置 AOF</h2><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>以下是Redis中关于AOF的主要配置信息：</p><p><code>appendonly</code>：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p><p><code>appendfilename</code>：这个参数项很好理解了，就是AOF文件的名字。</p><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。</p><p>什么叫“真正执行”呢？还记得Linux操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中I/O队列的操作效率，应用程序提交的I/O操作请求一般是被放置在linux Page Cache中的，然后再由Linux操作系统中的策略自行决定正在写到磁盘上的时机。而Redis中有一个fsync()函数，可以将Page Cache中待写的数据真正写入到物理设备上，而缺点是频繁调用这个fsync()函数干预操作系统的既定策略，可能导致I/O卡顿的现象频繁 。</p><p>与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为everysec。</p><p><code>no-appendfsync-on-rewrite</code>：always和everysec的设置会使真正的I/O操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的Redis是没法解决的。为了尽量缓解这个情况，Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache（这段时间Redis还在接受客户端的各种写操作命令）。</p><p><code>auto-aof-rewrite-percentage</code>：上文说到在生产环境下，技术人员不可能随时随地使用“BGREWRITEAOF”命令去重写AOF文件。所以更多时候我们需要依靠Redis中对AOF文件的自动重写策略。Redis中对触发自动重写AOF文件的操作提供了两个设置：auto-aof-rewrite-percentage表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。</p><p><code>auto-aof-rewrite-min-size</code>：参考auto-aof-rewrite-percentage选项的介绍，auto-aof-rewrite-min-size设置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage和auto-aof-rewrite-min-size只是用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右。</p><h2 id="AOF-文件重写机制"><a href="#AOF-文件重写机制" class="headerlink" title="AOF 文件重写机制"></a>AOF 文件重写机制</h2><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供<strong>AOF文件重写机制</strong>来对AOF文件进行“瘦身”。</p><p>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-1.jpg" alt="img"></p><p>简单来讲就是多变一，就是把 AOF 中日志根据当前键值的状态，合并成一条操作命令。</p><p>重写之后的文件会保存到新的 AOF 文件中，这时候旧的 AOF 文件和新的 AOF 文件中键值对的状态是一样的。然后新的 AOF 文件会替换掉旧的 AOF 文件，这样 重写操作一直在进行，AOF 文件就不至于变的过大。</p><p><strong>AOF会阻塞吗？</strong></p><p>AOF重写过程是由后台进程<code>bgrewriteaof</code>来完成的。主线程<code>fork</code>出后台的<code>bgrewriteaof</code>子进程，<code>fork</code>会把主线程的内存拷贝一份给<code>bgrewriteaof</code>子进程，这里面就包含了数据库的最新数据。然后，<code>bgrewriteaof</code>子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>所以aof在重写时，在<code>fork</code>进程时是会阻塞住主线程的。</p><p><strong>AOF日志何时会重写？</strong></p><p>有两个配置项控制AOF重写的触发：</p><p><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。</p><p><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p><p><strong>重写日志时，有新数据写入咋整</strong>？</p><p>重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个  aof 日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：<code>bgrewriteaof</code>进程使用的日志文件）</p><p>而在<code>bgrewriteaof</code>子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。</p><p>最后通过修改文件名的方式，保证文件切换的原子性。</p><p>在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604183732936.png" alt="image-20240604183732936"></p><p><strong>为什么AOF重写不复用原AOF日志</strong>？</p><p>两方面原因：</p><ol><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li></ol><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>AOF 优点</strong></p><ul><li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li><li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li><li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li></ul><p><strong>AOF 缺点</strong></p><ul><li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li><li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li><li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li></ul><h1 id="RDB-和-AOF-混合方式"><a href="#RDB-和-AOF-混合方式" class="headerlink" title="RDB 和 AOF 混合方式"></a>RDB 和 AOF 混合方式</h1><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h1 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h1><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-5.png" alt="img"></p><ul><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ul><p>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h1 id="过期的键如何持久化"><a href="#过期的键如何持久化" class="headerlink" title="过期的键如何持久化"></a>过期的键如何持久化</h1><p>在生成 RDB 文件的过程中，如果一个键已经过期，那么其不会被保存到 RDB 文件中。在载入 RDB 的时候，要分两种情况：</p><ul><li>如果 Redis 以主服务器的模式运行，那么会对 RDB 中的键进行时间检查，过期的键不会被恢复到 Redis 中。</li><li>如果 Redis 以从服务器的模式运行，那么 RDB 中所有的键都会被载入，忽略时间检查。在从服务器与主服务器进行数据同步的时候，从服务器的数据会先被清空，所以载入过期键不会有问题。</li></ul><p>对于 AOF 来说，如果一个键过期了，那么不会立刻对 AOF 文件造成影响。因为 Redis 使用的是惰性删除和定期删除，只有这个键被删除了，才会往 AOF 文件中追加一条 DEL 命令。在重写 AOF 的过程中，程序会检查数据库中的键，已经过期的键不会被保存到 AOF 文件中。</p><p>在运行过程中，对于主从复制的 Redis，主服务器和从服务器对于过期键的处理也不相同：</p><ul><li>对于主服务器，一个过期的键被删除了后，会向从服务器发送 DEL 命令，通知从服务器删除对应的键；</li><li>从服务器接收到读取一个键的命令时，即使这个键已经过期，也不会删除，而是照常处理这个命令；</li><li>从服务器接收到主服务器的 DEL 命令后，才会删除对应的过期键。</li></ul><p>这样保证了数据的一致性，一个键值对存在于主服务器，也必然存在于从服务器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis 4.0中提出了一个混合使用 AOF 日志和内存快照的方法，如果想要保证数据不丢失，这是一个比较好的选择；</p><p>如果允许分钟级别的数据丢失，可以只使用RDB；</p><p>如果只用AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</p><p>行文至此，我只能说大概了解了 Redis 如何进行持久化，还是有一些地方不是很清楚，后续会去读其他的文章来解开我心中的疑惑。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ybyn/p/14157568.html">https://www.cnblogs.com/ybyn/p/14157568.html</a></li><li><a href="https://boilingfrog.github.io/2022/01/07/redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/#%E5%89%8D%E8%A8%80">https://boilingfrog.github.io/2022/01/07/redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/#%E5%89%8D%E8%A8%80</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html</a></li><li><a href="https://juejin.cn/post/6844903655527677960">https://juejin.cn/post/6844903655527677960</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/03%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94RDB.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/03%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94RDB.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/04%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94AOF.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/04%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94AOF.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/05%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/05%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis的出现，大大提高了我们的查询速度，因其将数据存在内存中，我们的查询速度得到了质的提升。也正是因为在内存中，如果服务器突然断电关机，再次开机后我们的数据也就荡然无存了，这会让我们很崩溃。如何解决？那就是 Redis 的持久化。&lt;/p&gt;
&lt;p&gt;今天我要聊的就是 Red</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis执行流程大揭秘：从命令到结果的奇幻之旅</title>
    <link href="http://example.com/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/"/>
    <id>http://example.com/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/</id>
    <published>2024-06-04T08:10:46.000Z</published>
    <updated>2024-06-04T09:13:31.122Z</updated>
    
    <content type="html"><![CDATA[<p>随着内卷这一情况的不断深化，在数据库方面只学习 MySQL 显然是不够的。那么效率极高的 Redis 就成为了学习首选，以至于现在熟练掌握 Redis 已经成为应届生的必备技能了。</p><p>笔者也是在一个多月前第一次接触到 Redis，期间断断续续地学了一点内容，但并不是深入系统的学习，只是去看了一下几个常见问题的八股文，太浮躁了。既然要直接准备秋招，那就还有大把的时间，所以今天开始系统地学习一下 Redis 相关的内容。</p><p>安装、运行这些最开始的东西就不多赘述了，毕竟操作 Redis 的代码也已经写了不少了。那除了这些以外，还有什么适合当作学习的第一步呢？</p><p>今天的文章将会深入 Redis 到底是如何执行我们输入的命令的。</p><h1 id="Redis-是怎么执行命令的？"><a href="#Redis-是怎么执行命令的？" class="headerlink" title="Redis 是怎么执行命令的？"></a>Redis 是怎么执行命令的？</h1><p>面对这个问题，大部分朋友心中的答案是：客户端发送命令给到服务端，服务端收到执行之后再处理将命令执行结果返回给客户端，简单来说如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9124af423f948eecb328a3ead95259b.png" alt="img"></p><p>显然这样的答案不能帮我们了解 Redis 的工作原理，还是看看更细节的过程吧。</p><h2 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h2><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604162911047.png" alt="image-20240604162911047"></p><h2 id="第一步：连接"><a href="#第一步：连接" class="headerlink" title="第一步：连接"></a>第一步：连接</h2><p>一切的开始，都是从客户端和Redis服务器之间的连接开始的。这就好比你和朋友约好了一起去探险，首先得打个电话确认一下。</p><ol><li><strong>客户端发送连接请求</strong>：客户端就像那个迫不及待的探险者，发出了一条连接请求。</li><li><strong>Redis服务器接受请求</strong>：Redis服务器则像是守门员，确认探险者的身份后，挥舞着双手迎接他们。</li></ol><p>在连接之前，我们先看一下 Redis 服务器的启动，这也是客户端能建立连接的前提。</p><p>Redis服务器启动后，需要经过一些列的初始化及配置的设置，比如状态参数、用户配置、初始化数据结构等，流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0652951979112aa1be062edf1d30223.jpg" alt="0652951979112aa1be062edf1d30223"></p><p>Redis 客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监听接客户端的 socket 连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 开启 Socket 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 【redis.h/redisServer】 中redisServer结构体存储Redis服务器的所有信息，包括但不限于数据库、</p><p>配置参数、命令表、监听端口与地址、客户端列表、若干统计信息、RDB与AOF持久化相关信息、主从复制相关信息、集群相关信息等。</p><p>而客户端连接服务器之前需要创建socket（一套固定的模式），然后根据设定的IP和端口号与服务器进行连接。</p><p>这里有个重要的知识点：在通过网络与redis服务器连接的普通客户端和lua脚本的客户端，服务器都会创建相对应的client 结构，用于记录他们的状态信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端在redisServer结构中的属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 存放普通客户端的列表</span></span><br><span class="line">    <span class="built_in">list</span> *clients;   <span class="comment">/* List of active clients */</span></span><br><span class="line">    <span class="comment">// 存放lua脚本客户端</span></span><br><span class="line">    client *lua_client;    <span class="comment">/* The &quot;fake client&quot; to query Redis from Lua */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Redis客户端其实有三种类型：1：负责执行Lua脚本的伪客户端，2：用来加载aof文件的伪客户端，3：通过网络连接的普通客户端</p></blockquote><p>到这里Redis客户端和服务端就完成连接，接下来继续看到底如何传输执行用户指令的！</p><h2 id="第二步：发送与解析"><a href="#第二步：发送与解析" class="headerlink" title="第二步：发送与解析"></a>第二步：发送与解析</h2><p>当连接建立后，客户端会发送命令给Redis服务器。这时候，就好像你给你的探险伙伴发出了一条魔法指令。</p><ol><li><p><strong>命令发送</strong>：你输入的命令就像是一封魔法信件，通过网络这个传送门，飞向Redis服务器。</p></li><li><p><strong>命令解析</strong>：Redis服务器收到信件后，会认真阅读（解析）你写的内容，确保每个字都理解无误。</p></li></ol><h3 id="客户端发送命令"><a href="#客户端发送命令" class="headerlink" title="客户端发送命令"></a>客户端发送命令</h3><p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于<strong>把服务器端的解析工作交给了每一个客户端</strong>，这样会很大程度的提高 Redis 的运行速度。</p><p>比如我们输入 <code>set xkey xiaoxu</code> 命令会转换成如下格式：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/13e2f2d81c17c4f91bea81ef096adcc1.png" alt="img"></p><p>你问上面的是什么意思，来看下面的解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*3        //参数个数是*开头，3个参数</span><br><span class="line">$3        //参数长度是$开头，命令长度</span><br><span class="line">SET       //命令名称SET</span><br><span class="line">$4        //参数长度是$开头，key长度</span><br><span class="line">xkey      //key的内容</span><br><span class="line">$6        //参数长度是$开头，value长度</span><br><span class="line">xiaoxu      //value内容</span><br><span class="line">参数个数是*开头，参数长度是$开头，每个参数通过\r\n隔开</span><br><span class="line">回复协议格式：</span><br><span class="line">* 状态回复（status reply）的第一个字节是 “+”，如：+ok\r\n</span><br><span class="line">* 错误回复（error reply）的第一个字节是 “-“，如：-ERR unknown command xxx\r\n</span><br></pre></td></tr></table></figure><h3 id="服务端读取命令"><a href="#服务端读取命令" class="headerlink" title="服务端读取命令"></a>服务端读取命令</h3><p>通过连接套接字让客户端的写入变得可读，服务端将读取协议内容，并存储到客户端的缓冲区，这里的缓冲区是client结构的输入缓冲区。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c722ffb11c89aa2bea50a9b31dd1f305.png" alt="img"></p><blockquote><p>每个连接到服务端的客户端，会保存在redisServer结构体中的clients链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 客户端状态的输入缓冲区，保存客户端的命令请求</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="comment">// 下面这两个是解析出来的命令和参数</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 一个是根据argv[0]解析出来的命令，一个是最后一次执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><p>接着会对输入缓冲区中的命令请求进行分析，提取解析出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/6634ecba67597fcf177bed53ec5cee4b.png" alt="img"></p><hr><p>这里插播一个小知识！</p><p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3d48b0f27f7c3338e76b109a7d02a8c7.png" alt="img"></p><h2 id="第三步：命令执行"><a href="#第三步：命令执行" class="headerlink" title="第三步：命令执行"></a>第三步：命令执行</h2><p>解析完命令之后，Redis服务器开始执行命令。这一过程就像是启动了一个巨大的魔法阵，能量开始在其中流动。</p><ol><li><strong>查找命令</strong>：Redis服务器会在它的魔法书（命令表）中找到相应的魔法（命令）来施展。</li><li><strong>执行命令</strong>：服务器根据魔法书中的指示，精准地执行命令。</li></ol><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><p>命令执行器根据客户端状态的<code>argv[0]</code>参数，在命令表中查找参数所指定的命令，本文中的<code>argv[0]</code>参数就是 set ，找到命令后保存到客户端状态的 cmd 属性。</p><blockquote><p><strong>命令表</strong>：其实就是一个字典，字典的键是命令名称，比如”set”、”get”、”del”；而值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2e4dfeda09bd4370c4cb7812d436d50f.png" alt="img"></p><p>SET命令的名字为”set”，实现函数为setCommand；命令的参数个数为-3，表示命令接受三个或以上数量的参数；命令的标识为”wm”，表示SET命令是一个写入命令。</p><p>GET命令的名字为 “get”，实现函数为getCommand函数；命令的参数个数为2，表示命令只接受两个参数；命令的标识为”r”，表示这是一个只读命令。</p><h3 id="执行准备：参数、权限、内存校验"><a href="#执行准备：参数、权限、内存校验" class="headerlink" title="执行准备：参数、权限、内存校验"></a>执行准备：参数、权限、内存校验</h3><p>获得了执行需要的命令、参数后，服务器还需要做一些校验：</p><p>命令校验：检查客户端状态的cmd指针是否指向NULL。</p><p>参数校验：根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确。</p><p>权限校验：检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令。</p><p>内存检测：如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行</p><p>其他校验..</p><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>服务器将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器执行命令时，只需要一个指向客户端状态的指针作为参数，调用实际执行函数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2b16c771057fbfe6cb2ca425e7bd1464.png" alt="img"></p><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端</p><h3 id="后续：命令、参数、AOF"><a href="#后续：命令、参数、AOF" class="headerlink" title="后续：命令、参数、AOF"></a><strong>后续：命令、参数、AOF</strong></h3><p>执行完毕后，会有一些后续操作，包括慢日志记录、redisCommand结构属性更新、AOF持久化记录、主从复制命令传播等。</p><h2 id="第四步：返回结果"><a href="#第四步：返回结果" class="headerlink" title="第四步：返回结果"></a>第四步：返回结果</h2><p>命令执行完毕后，Redis服务器会将结果通过网络传送回客户端。这就像是魔法信使带着宝贵的探险成果返回你的身边。</p><ol><li><strong>结果生成</strong>：执行完命令后，Redis服务器生成结果，就像是从宝箱中拿出了宝物。</li><li><strong>结果传送</strong>：通过网络传送门，结果迅速飞回客户端。</li><li><strong>客户端接收</strong>：最终，客户端收到结果，探险圆满成功！</li></ol><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>发送完毕后，回复处理器会清空客户端状态的输出缓冲区，为下一个命令请求做好准备。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604165654029.png" alt="image-20240604165654029"></p><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p><p>比如之前的 set xkey xiaoxu，服务器发送的 “+OK\r\n”，通过协议转换成 “OK\n”</p><hr><p>ok，到这里其实整个发送命令和接收回复的流程就完成了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604165949466.png" alt="image-20240604165949466"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们知道了一条Redis命令请求从发送到完成的步骤，答题如下：</p><ol><li>Redis客户端发送命令请求到服务器</li><li>服务器读取命令请求，解析命令参数</li><li>命令执行器根据命令参数查找命令的实际实现函数，然后执行，接着回复执行结果给客户端</li></ol><p>服务器的Server结构使用Clients链表来链接多个客户端的状态，包括我们的输入请求和输出结果、解析的命令参数等。</p><p>进入到闲聊部分，最近两天好像并没有什么有意思的事情发生，再决定不找实习之后反倒有几家公司找我要简历，当然还是老样子，要过简历之后就开始已读不回了，有时候想想当一个 HR 好爽啊，可以随时耍求职的人玩。好在我的心态已经放平了。</p><p>你问这么抽象的标题是怎么想出来的。对，就是ChatGPT给的，我觉得很好，优点标题党的意思了，营销号要失业了。</p><p>为了秋招顺利，我还是觉得要学一下 Java 的东西，只凭 Go 还是优点不安心。先把前段时间积压的东西学完，然后学着做一个项目。</p><p>对了，这一段时间的网络奇差无比，这样不好。月初有钱了，又想要冲动消费了，今天去看了苹果的头戴耳机，有点心动了，怎么办，克制一下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/01%20Redis%20%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/01%20Redis%20%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84.md</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2311065">https://cloud.tencent.com/developer/article/2311065</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着内卷这一情况的不断深化，在数据库方面只学习 MySQL 显然是不够的。那么效率极高的 Redis 就成为了学习首选，以至于现在熟练掌握 Redis 已经成为应届生的必备技能了。&lt;/p&gt;
&lt;p&gt;笔者也是在一个多月前第一次接触到 Redis，期间断断续续地学了一点内容，但并</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>细说空结构体：Go语言中的奇妙用途</title>
    <link href="http://example.com/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/"/>
    <id>http://example.com/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/</id>
    <published>2024-06-03T08:44:19.000Z</published>
    <updated>2024-06-11T15:57:30.143Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，正常的 <code>struct</code> 就是一个普通的内存块，必定是要占用一块内存的，并且结构体的大小是要经过边界，长度是对其的。</p><p>当你需要一个结构体，但是却丝毫不关系里面的内容，声明一个最小的结构体，也需要占用 1 字节，这是就要用到今天的主角——空结构体了。</p><p>“空结构体”是不占内存的，size 为 0；运行下面的代码可以得出，空结构体是不占用内存的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上来讲，使用空结构体的初衷只有一个：节省内存，但是更多的情况，节省的内存其实很有限，这种情况使用空结构体的考量其实是：<strong>根本不关心结构体变量的值</strong>。</p><h1 id="什么原理"><a href="#什么原理" class="headerlink" title="什么原理"></a>什么原理</h1><h2 id="特殊变量：zerobase"><a href="#特殊变量：zerobase" class="headerlink" title="特殊变量：zerobase"></a>特殊变量：<code>zerobase</code></h2><p>空结构体时没有内存大小的结构体。这句话是没有错，但是更准确的来说，其实是有一个特殊起点的，那就是 <code>zerobase</code> 变量，这是一个  <code>uintptr</code> 全局变量，占用 8 个字节。</p><p>当在任何地方定义无数个 <code>struct &#123;&#125;</code> 类型的变量，编译器都只是把这个 <code>zerobase</code> 变量的地址给出去。换句话说，在 GO 里面，涉及到所有内存 size 为 0 的内存分配，那么就是用的同一个地址 <code>&amp;zerobase</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">c := emptyStruct&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">0x57bb60</span><br><span class="line">0x57bb60</span><br><span class="line">0x57bb60</span><br></pre></td></tr></table></figure><p>无论如何定义空结构体，其变量都是一样的。</p><h2 id="内存特殊管理"><a href="#内存特殊管理" class="headerlink" title="内存特殊管理"></a>内存特殊管理</h2><p>编译器在编译期间，识别到 <code>struct &#123;&#125;</code> 这种特殊类型的内存分配，会统统分配出 <code>runtime.zerobase</code> 的地址出去，这个代码逻辑是在 <code>mallocgc</code> 函数里面：</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 分配 size 为 0 的结构体，把全局变量 zerobase 的地址给出去即可；</span></span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br></pre></td></tr></table></figure><p>golang 使用 <code>mallocgc</code> 分配内存的时候，如果 size 为 0 的时候，统一返回的都是全局变量 <code>zerobase</code> 的地址。</p><p>有这种全局唯一的特殊的地址也方便后面一些逻辑的特殊处理。</p><h1 id="定义的各种姿势"><a href="#定义的各种姿势" class="headerlink" title="定义的各种姿势"></a>定义的各种姿势</h1><h2 id="原生定义"><a href="#原生定义" class="headerlink" title="原生定义"></a>原生定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>struct&#123;&#125;</code> 可以就认为是一种类型，a 变量就是 <code>struct &#123;&#125;</code> 类型的一种变量，地址为 <code>runtime.zerobase</code> ，大小为 0 ，不占内存。</p><h2 id="重定义类型"><a href="#重定义类型" class="headerlink" title="重定义类型"></a>重定义类型</h2><p>golang 使用 <code>type</code>  关键字定义新的类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义出来的 <code>emptyStruct</code>  是新的类型，具有对应的 <code>type</code> 结构，但是性质 <code>struct&#123;&#125;</code> 完全一致，编译器对于 <code>emptryStruct</code> 类型的内存分配，也是直接给 <code>zerobase</code> 地址的。</p><h2 id="匿名嵌套类型"><a href="#匿名嵌套类型" class="headerlink" title="匿名嵌套类型"></a>匿名嵌套类型</h2><p><code>struct&#123;&#125;</code>  作为一个匿名字段，内嵌其他结构体。这种情况是怎么样的？</p><p><strong>匿名嵌套方式一</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">struct</span> &#123;</span><br><span class="line">    emptyStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名嵌套方式二</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住一点，空结构体还是空结构体，类型变量本身绝对不分配内存（ size=0 ），所以编译器对以上的 <code>Object</code>，<code>Object1</code> 两种类型的处理和空结构体类型是一致的，分配地址为 <code>runtime.zerobase</code> 地址，变量大小为0，不占任何内存大小。</p><h2 id="内置字段"><a href="#内置字段" class="headerlink" title="内置字段"></a>内置字段</h2><p>内置字段的场景没有什么特殊的，主要是地址和长度的对齐要考虑。还是只需要注意 3 个要点：</p><ul><li>空结构体的类型不占内存大小；</li><li>地址偏移要和自身类型对齐；</li><li>整体类型长度要和最长的字段类型长度对齐；</li></ul><p>我们分 3 种场景讨论这个问题：</p><p><strong>场景一：<code>struct &#123;&#125;</code>  在最前面</strong></p><p>这种场景非常好理解，<code>struct &#123;&#125;</code> 字段类型在最前面，这种类型不占空间，所以自然第二个字段的地址和整个变量的地址一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="comment">// Object1 类型变量占用 1 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">b <span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object2 类型变量占用 8 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object2 <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">n <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1&#123; &#125;</span><br><span class="line">o2 := Object2&#123; &#125;</span><br></pre></td></tr></table></figure><p>内存怎么分配？</p><ul><li><code>&amp;o1</code>  和 <code>&amp;o1.s</code> 是一致的，变量 <code>o1</code>  的内存大小对齐到 1 字节；</li><li><code>&amp;o2</code>  和 <code>&amp;o2.s</code> 是一致的，变量 <code>o2</code>  的内存大小对齐到 8 字节；</li></ul><p>这种分配是满足对齐规则的，编译器也不会对这种 <code>struct &#123;&#125;</code> 字段做任何特殊的字节填充。</p><p><strong>场景二：<code>struct &#123;&#125;</code> 在中间</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object1 类型变量占用 16 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">b  <span class="type">byte</span></span><br><span class="line">s  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">b1 <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>按照对齐规则，变量 <code>o1</code> 占用 16 个字节；</li><li><code>&amp;o1.s</code> 和 <code>&amp;o1.b1</code>  相同；</li></ul><p>编译器不会对 <code>struct &#123; &#125;</code> 做任何字节填充。</p><p><strong>场景三：<code>struct &#123;&#125;</code> 在最后</strong></p><p>这个场景稍微注意下，因为编译器遇到之后会做特殊的字节填充补齐，如下；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">b <span class="type">byte</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object2 <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int64</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object3 <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int16</span></span><br><span class="line">m <span class="type">int16</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object4 <span class="keyword">struct</span> &#123;</span><br><span class="line">n  <span class="type">int16</span></span><br><span class="line">m  <span class="type">int64</span></span><br><span class="line">s  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1 &#123; &#125;</span><br><span class="line">o2 := Object2 &#123; &#125;</span><br><span class="line">o3 := Object3 &#123; &#125;</span><br><span class="line">o4 := Object4 &#123; &#125;</span><br></pre></td></tr></table></figure><p>编译器在遇到这种 <code>struct &#123;&#125;</code>  在<strong>最后一个字段</strong>的场景，会进行特殊填充，<code>struct &#123; &#125;</code> 作为最后一个字段，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变；</p><p>可以现在心里思考下，<code>o1</code>，<code>o2</code>，<code>o3</code>，<code>o4</code>  这四个对象的内存分配分别占多少空间？下面解密：</p><ul><li>变量 <code>o1</code>  大小为 2 字节；</li><li>变量 <code>o2</code>  大小为 16 字节；</li><li>变量 <code>o3</code>  大小为 6 字节；</li><li>变量 <code>o4</code>  大小为 24 字节；</li></ul><p>这种情况，需要先把 <code>struct &#123;&#125;</code>  按照前一个字段的长度分配 padding 内存，然后整个变量按照地址和长度的对齐规则不变。</p><h1 id="空结构体的作用"><a href="#空结构体的作用" class="headerlink" title="空结构体的作用"></a>空结构体的作用</h1><p>因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。</p><h2 id="实现-Set"><a href="#实现-Set" class="headerlink" title="实现 Set"></a>实现 Set</h2><p>Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。</p><p>因此呢，将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Has(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">_, ok := s[key]</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Add(key <span class="type">string</span>) &#123;</span><br><span class="line">s[key] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Delete(key <span class="type">string</span>) &#123;</span><br><span class="line"><span class="built_in">delete</span>(s, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>(Set)</span><br><span class="line">s.Add(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">s.Add(<span class="string">&quot;Sam&quot;</span>)</span><br><span class="line">fmt.Println(s.Has(<span class="string">&quot;Tom&quot;</span>))</span><br><span class="line">fmt.Println(s.Has(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不发送数据的-channel"><a href="#不发送数据的-channel" class="headerlink" title="不发送数据的 channel"></a>不发送数据的 <code>channel</code></h2><p>有时候使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。<code>struct&#123;&#125;</code> 通常作为一个信号来传输，并不关注其中内容。<code>channel</code> 本质的数据结构是一个管理结构加上一个 ringbuffer ，如果 <code>struct&#123;&#125;</code> 作为元素的话，ringbuffer 就是 0 分配的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> worker(ch)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种场景我们思考下，是否一定是非 <code>struct&#123;&#125;</code> 不可？其实不是，而且也不多这几个字节的内存，所以这种情况真的就只是不关心 <code>chan</code> 的元素值而已，所以才用的 <code>struct&#123;&#125;</code>。</p><h2 id="struct-作为-receiver"><a href="#struct-作为-receiver" class="headerlink" title="struct {} 作为 receiver"></a><code>struct &#123;&#125;</code> 作为 receiver</h2><p>receiver 这个是 golang 里 struct 具有的基础特点。空结构体本质上作为结构体也是一样的，可以作为 receiver 来定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyStruct)</span></span> FuncB(n, m <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e emptyStruct)</span></span> FuncA(n, m <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := emptyStruct&#123;&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">m := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a.FuncA(n, m)</span><br><span class="line">a.FuncB(n, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>receiver 这种写法是 golang 支撑面向对象的基础，本质上的实现也是非常简单，常规情况（普通的结构体）可以翻译成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncA</span> <span class="params">(e *emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncB</span> <span class="params">(e  emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器只是把对象的值或地址作为第一个参数传给这个参数而已，就这么简单。</strong> 但是在这里要提一点，空结构体稍微有一点点不一样，空结构体应该翻译成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncA</span> <span class="params">(e *emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncB</span> <span class="params">(n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00000000004525d0 &lt;main.main&gt;:</span><br><span class="line">  4525d0:64 48 8b 0c 25 f8 ff mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  4525d9:48 3b 61 10          cmp    0x10(%rcx),%rsp</span><br><span class="line">  4525dd:76 63                jbe    452642 &lt;main.main+0x72&gt;</span><br><span class="line">  4525df:48 83 ec 30          sub    $0x30,%rsp</span><br><span class="line">  4525e3:48 89 6c 24 28       mov    %rbp,0x28(%rsp)</span><br><span class="line">  4525e8:48 8d 6c 24 28       lea    0x28(%rsp),%rbp</span><br><span class="line">  4525ed:48 c7 44 24 18 01 00 movq   $0x1,0x18(%rsp)</span><br><span class="line">  4525f6:48 c7 44 24 20 02 00 movq   $0x2,0x20(%rsp)</span><br><span class="line">  4525ff:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  452604:48 89 04 24          mov    %rax,(%rsp)// n 变量值压栈（第一个参数）</span><br><span class="line">  452608:48 c7 44 24 08 02 00 movq   $0x2,0x8(%rsp)// m 变量值压栈（第二个参数）</span><br><span class="line">  452611:e8 aa ff ff ff       callq  4525c0 &lt;main.emptyStruct.FuncA&gt;</span><br><span class="line">  452616:48 8d 44 24 18       lea    0x18(%rsp),%rax</span><br><span class="line">  45261b:48 89 04 24          mov    %rax,(%rsp)// $rax 里面是 zerobase 的值，压栈（第一个参数）；</span><br><span class="line">  45261f:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  452624:48 89 44 24 08       mov    %rax,0x8(%rsp)// n 变量值压栈（第二个参数）</span><br><span class="line">  452629:48 8b 44 24 20       mov    0x20(%rsp),%rax</span><br><span class="line">  45262e:48 89 44 24 10       mov    %rax,0x10(%rsp)// m 变量值压栈（第三个参数）</span><br><span class="line">  452633:e8 78 ff ff ff       callq  4525b0 &lt;main.(*emptyStruct).FuncB&gt;</span><br><span class="line">  452638:48 8b 6c 24 28       mov    0x28(%rsp),%rbp</span><br><span class="line">  45263d:48 83 c4 30          add    $0x30,%rsp</span><br><span class="line">  452641:c3                   retq   </span><br><span class="line">  452642:e8 b9 7a ff ff       callq  44a100 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">  452647:eb 87                jmp    4525d0 &lt;main.main&gt;</span><br></pre></td></tr></table></figure><p>通过这段代码证实几个点：</p><ol><li>receiver 其实就是一种语法糖，本质上就是作为第一个参数传入函数；</li><li>receiver 为值的场景，不需要传空结构体做第一个参数，因为空结构体没有值；</li><li>receiver 为一个指针的场景，对象地址作为第一个参数传入函数，函数调用的时候，编译器传入 <code>zerobase</code> 的值（编译期间就可以确认）；</li></ol><p>在二进制编译之后，一般 <code>e.FuncA</code> 的调用，第一个参数是直接压入 <code>&amp;zerobase</code> 到栈里。</p><p>总结几个知识点：</p><ul><li>receiver 本质上是非常简单的一个通用思路，就是把对象值或地址作为第一参数传入函数；</li><li>函数参数压栈方式从前往后（可以调试看下）；</li><li>对象值作为 receiver 的时候，涉及到一次值拷贝；</li><li>golang 对于值做 receiver 的函数定义，会根据现实需要情况可能会生成了两个函数，一个值版本，一个指针版本（思考：什么是“需要情况”？就是有 <code>interface</code> 的场景 ）；</li><li>空结构体在编译期间就能识别出来的场景，编译器会对既定的事实，可以做特殊的代码生成；</li></ul><p>可以这么说，编译期间，关于空结构体的参数基本都能确定，那么代码生成的时候，就可以生成对应的静态代码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习上面空指针的各种使用场景，我们能得出结论，一般只会在以下两种情况会使用到空结构体：</p><ol><li>需要一个占位符，并不关系数据的内容。</li><li>节省空间。</li></ol><p>空结构体就像一些牛马一样，又让人家干活，又不给人家内存地址。是你，是我，是大家。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://geektutu.com/post/hpg-empty-struct.html">https://geektutu.com/post/hpg-empty-struct.html</a></li><li><a href="https://juejin.cn/post/6908733156707287048#heading-0">https://juejin.cn/post/6908733156707287048#heading-0</a></li><li><a href="https://juejin.cn/post/7228977496514560058">https://juejin.cn/post/7228977496514560058</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，正常的 &lt;code&gt;struct&lt;/code&gt; 就是一个普通的内存块，必定是要占用一块内存的，并且结构体的大小是要经过边界，长度是对其的。&lt;/p&gt;
&lt;p&gt;当你需要一个结构体，但是却丝毫不关系里面的内容，声明一个最小的结构体，也需要占用 1 字节，这是就要用</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="学习周报" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>了解MongoDB——你想知道的都在这</title>
    <link href="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/"/>
    <id>http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/</id>
    <published>2024-06-02T12:11:30.000Z</published>
    <updated>2024-06-11T15:54:01.684Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。</p><p>本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。</p><h1 id="什么是-NoSQL？"><a href="#什么是-NoSQL？" class="headerlink" title="什么是 NoSQL？"></a>什么是 NoSQL？</h1><p>在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQL 以外，还了解什么数据库。我回答，不知道。结束后，我机智的舍友问我为什么不回答 NoSQL，我以为这是不知道其他数据库的英文表达（离谱）。</p><p>NoSQL 也被称为 “not only SQL” 或 “non-SQL”，它是一种数据库设计方法，可以在关系数据库中的传统结构之外存储和查询数据。</p><p>虽然 NoSQL 仍然可以存储关系数据库管理系统 (RDBMS) 中的数据，但与 RDBMS 相比，数据存储方式有所不同。决定使用关系数据库还是非关系数据库在很大程度上取决于上下文，并且因用例而异。</p><p>NoSQL 数据库并非采用关系数据库的典型表结构，而是将数据存储在一个数据结构中，例如 JSON 文档。由于这种非关系数据库设计不需要使用架构，因此，它提供快速可扩展性以管理通常为非结构化的大型数据集。</p><p>NoSQL 也是一种分布式数据库类型，这意味着将信息复制并存储在不同的服务器上，这些服务器可能是远程服务器或本地服务器。这确保了数据的可用性和可靠性。如果一些数据脱机，数据库的其他部分可以继续运行。</p><p><strong>特点</strong></p><ol><li><strong>灵活的数据模型</strong>：NoSQL数据库支持多种数据模型，如键值对、文档、列族和图形模型，适应各种应用场景。</li><li><strong>高可扩展性</strong>：通过分布式架构实现水平扩展，可以轻松添加更多的服务器来处理增加的数据量和流量。</li><li><strong>高性能</strong>：NoSQL数据库设计优化了读写操作，能提供高性能的查询速度。</li><li><strong>可用性和可靠性</strong>：通常具备内置的故障转移和数据复制机制，保证数据的高可用性和可靠性。</li></ol><p><strong>类型</strong></p><ol><li><p>键值存储（Key-Value Store）</p><p>：数据以键值对的形式存储，适合简单查询和高速读写操作。</p><ul><li>示例：Redis, DynamoDB</li></ul></li><li><p>文档存储（Document Store）</p><p>：数据以文档的形式存储，每个文档可以有不同的结构，适合存储复杂的嵌套数据。</p><ul><li>示例：MongoDB, CouchDB</li></ul></li><li><p>列族存储（Column-Family Store）</p><p>：数据以列的形式存储，每一列可以独立查询，适合大规模数据分析。</p><ul><li>示例：Cassandra, HBase</li></ul></li><li><p>图形数据库（Graph Database）</p><p>：数据以节点和边的形式存储，适合处理复杂关系和网络图。</p><ul><li>示例：Neo4j, ArangoDB</li></ul></li></ol><h2 id="常见的-NoSQL"><a href="#常见的-NoSQL" class="headerlink" title="常见的 NoSQL"></a>常见的 NoSQL</h2><p>以下是几个常用的NoSQL数据库及其主要特点：</p><ol><li>MongoDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式（BSON）存储数据，文档具有灵活的结构。</li><li>强大的查询和索引功能，支持复杂的查询操作。</li><li>支持水平扩展，通过分片实现高可扩展性。</li><li>提供复制集功能，保证数据的高可用性和自动故障转移。</li></ul></li></ul><ol><li>Cassandra</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>采用分布式架构，无单点故障，提供高可用性和高容错性。</li><li>高写入和读取性能，适用于大规模数据处理。</li><li>支持多数据中心的复制，保证数据的高可用性和一致性。</li><li>灵活的Schema设计，适合时间序列数据和大数据分析。</li></ul></li></ul><ol><li>Redis</li></ol><ul><li><strong>类型</strong>：键值存储（Key-Value Store）</li><li><strong>特点</strong>：<ul><li>数据存储在内存中，提供极高的读写性能，适用于实时应用。</li><li>支持多种数据结构，如字符串、哈希、列表、集合和有序集合。</li><li>提供丰富的操作和事务功能，支持发布/订阅、Lua脚本等。</li><li>具有持久化机制，数据可以持久化到磁盘。</li></ul></li></ul><ol><li>Neo4j</li></ol><ul><li><strong>类型</strong>：图形数据库（Graph Database）</li><li><strong>特点</strong>：<ul><li>以节点和关系（边）的形式存储数据，适合处理复杂关系和网络图。</li><li>提供强大的图形查询语言Cypher，支持高效的图遍历和查询操作。</li><li>广泛应用于社交网络、推荐系统和网络分析等场景。</li><li>提供ACID事务保证，确保数据一致性和可靠性。</li></ul></li></ul><ol><li>CouchDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式存储数据，每个文档可以有不同的结构。</li><li>提供RESTful API接口，便于集成和访问数据。</li><li>支持多主复制，允许在不同节点之间同步数据。</li><li>具备内置的冲突解决机制，适用于分布式环境。</li></ul></li></ul><ol><li>HBase</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>基于Hadoop HDFS构建，适用于处理大规模结构化数据。</li><li>提供强一致性的读写操作，适合需要高可靠性的应用。</li><li>支持随机读写和实时查询，适合大数据分析和实时应用。</li><li>与Hadoop生态系统紧密集成，支持MapReduce等大数据处理框架。</li></ul></li></ul><p>这些NoSQL数据库在不同的应用场景中发挥着重要作用，根据具体需求选择合适的数据库可以显著提升系统的性能和可扩展性。</p><h1 id="MongoDB-出现的原因"><a href="#MongoDB-出现的原因" class="headerlink" title="MongoDB 出现的原因"></a>MongoDB 出现的原因</h1><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。而MongoDB可应对“三高”需求。“三高”需求：</p><p>（1）High performance - 对数据库高并发读写的需求。</p><p>（2）Huge Storage - 对海量数据的高效率存储和访问的需求。</p><p>（3）High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对“三高”需求。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从它的命名也可以看出来，设计者是有一定野心的。MongoDB 的原名一开始<strong>来自于 英文单词”Humongous”, 中文含义是指”庞大”</strong>，即命名者的意图是可以处理大规模的数据。</p><p>在使用 MongoDB 我会有两种感觉：</p><ul><li>第一层感受是”爽”，使用这个文档数据库的特点是几乎不受什么限制，一方面Json文档式的结构更容易理解，而无Schema约束也让DDL管理更加简单，一切都可以很快速的进行。</li><li>第二层感受是”酸爽”，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验”太过于友好”，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。</li></ul><p>所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的RDBMS数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的话，会遇到更多的坑。</p><p>尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-aedbdb7187c091f3b2e091baea945806_720w.webp" alt="img"></p><p>在全部的排名中，MongoDB 长期排在第5位(文档数据库排名第1位)，同时也是最受欢迎的 NoSQL 数据库。</p><p>MongoDB 数据库的一些特性：</p><ul><li>面向文档存储，基于JSON/BSON 可表示灵活的数据结构</li><li>动态 DDL能力，没有强Schema约束，支持快速迭代</li><li>高性能计算，提供基于内存的快速数据查询</li><li>容易扩展，利用数据分片可以支持海量数据存储</li><li>丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。</li><li>跨平台版本、支持多语言SDK..</li></ul><h1 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h1><p>数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。</p><blockquote><p>关于这点，也有人说，MongoDB 是 NoSQL中最像SQL的数据库..</p></blockquote><p>我们来看与MySQL的对比，通过对比来学习其基本模型。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428161048312-2056386348.png" alt="img"></p><ul><li>database 数据库，与SQL的数据库(database)概念相同，一个数据库包含多个集合(表)</li><li>collection 集合，相当于SQL中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是<strong>动态的</strong>，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema的校验。</li><li>document 文档，相当于SQL中的行(row)，一个文档由多个字段(列)组成，并采用<code>bson(json)</code>格式表示。</li><li>field 字段，相当于SQL中的列(column)，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。</li></ul><p>此外，MongoDB中字段的类型是<strong>固定的</strong>、<strong>区分大小写</strong>、并且文档中的字段也是<strong>有序的</strong>。</p><p>另外，SQL 还有一些其他的概念，对应关系如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a4ce8ff9c69d5402f70baa1b050ad0d_720w.webp" alt="img"></p><ul><li>_id 主键，MongoDB 默认使用一个 _id 字段来保证文档的<strong>唯一性</strong>。</li><li>reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。</li><li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。</li><li>index 索引，与SQL 的索引相同。</li><li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li><li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li><li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li></ul><h2 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a><code>BSON</code> 数据类型</h2><p> MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以 <code>BSON（Binary-JSON）</code>文档的格式存储在磁盘上。</p><p><code>BSON（Binary Serialized Document Format）</code>是一种类 <code>json</code> 的一种二进制形式的存储格式，简称<code>Binary JSON</code>。<code>BSON</code>和<code>JSON</code>一样，支持 内嵌的文档对象和数组对象，但是<code>BSON</code>有<code>JSON</code>没有的一些数据类型，如Date和BinData类型。</p><p><code>BSON</code>采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p><code>BSON</code>中，除了基本的JSON类型：string, integer, boolean, double, null, array 和 object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详 细信息。</p><p>BSON数据类型参考列表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428163656218-1316936233.png" alt="img"></p><p> 提示： shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符 号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p><h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><p>面试问题：在进行数据库分表或者将同一个数据库部署到不同的服务器上，如何保证主键不重复。</p><p>当然，方法有很多，不同公司会有自己的处理方式，具体的后续会写文章来分析。我们先看在 MongoDB 中是如何保证主键不重复的。</p><p>在单机时代，大多数应用可以使用数据可自增式 ID 来作为主键。传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。</p><p>为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。</p><p>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-227bd6ae2f8a3c05546f51cfd4a0b7a8_720w.webp" alt="img"></p><p>其中包括：</p><ul><li>4-byte Unix 时间戳</li><li>3-byte 机器 ID</li><li>2-byte 进程 ID</li><li>3-byte 计数器(初始化随机)</li></ul><p>值得一提的是 _id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。<br>当然服务端也会检测写入的文档是否包含 _id 字段，如果没有就生成一个。</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>除了文档模型本身，对于数据的操作命令也是基于JSON/BSON 格式的语法。</p><p>详细的语法操作，可以去看<a href="https://www.mongodb.com/docs/manual/reference/sql-comparison/">官方的文档</a>，下面简单介绍一下基础使用语法。</p><p>比如插入文档的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.book.insert(</span><br><span class="line">&#123;</span><br><span class="line">  title: &quot;My first blog post&quot;,</span><br><span class="line">  published: <span class="keyword">new</span> <span class="type">Date</span>(),</span><br><span class="line">  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],</span><br><span class="line">  type: &quot;Work&quot;,</span><br><span class="line">  author : &quot;James&quot;,</span><br><span class="line">  viewCount: <span class="number">25</span>,</span><br><span class="line">  commentCount: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行文档查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;author : &quot;James&quot;&#125;)</span><br></pre></td></tr></table></figure><p>更新文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.book.update(</span><br><span class="line">   &#123;&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)&#125;,</span><br><span class="line">   &#123;&quot;$inc&quot;: &#123;&quot;viewCount&quot;: <span class="number">3</span>&#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>删除文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.remove(&#123;&quot;_id&quot;:</span><br><span class="line">     ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&quot;author&quot;: &quot;James&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;: <span class="number">1</span>, &quot;title&quot;: <span class="number">1</span>, &quot;author&quot;: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>实现简单的分页查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&#125;)</span><br><span class="line">    .sort(&#123;&quot;viewCount&quot; : <span class="number">-1</span>&#125;)</span><br><span class="line">    .<span class="keyword">skip</span>(<span class="number">10</span>).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。<br>与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。</p><p>那么，一个有趣的问题是 MongoDB 能不能用 SQL进行查询？</p><p>当然是可以！</p><p>但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：</p><ul><li>客户端使用SQL，可以使用 mongobooster、studio3t 这样的工具</li><li>服务端的话，可以看看 presto 之类的一些平台..</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。</p><p>索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。在索引的实现上使用了 B 树，MySQL 则是采用 B+ 树来实现索引的。</p><p>使用 <code>ensureIndexes</code> 可以为集合声明一个普通的索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;author: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>author后面的数字 1 代表升序，如果是降序则是 -1</p></blockquote><p>实现复合式(compound)的索引，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;type: 1, published: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>只有对于复合式索引时，索引键的顺序才变得有意义</p></blockquote><p>如果索引的字段是数组类型，该索引就自动成为数组(multikey)索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;tags: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个</p></blockquote><h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a><strong>索引特性</strong></h2><p>在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：</p><ul><li>unique=true，表示一个唯一性索引</li><li>expireAfterSeconds=3600，表示这是一个TTL索引，并且数据将在1小时后老化</li><li>sparse=true，表示稀疏的索引，仅索引非空(non-null)字段的文档</li><li>partialFilterExpression: { rating: { $gt: 5 }，条件式索引，即满足计算条件的文档才进行索引</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h2><p>除了普通索引之外，MongoDB 支持的类型还包括：</p><ul><li>哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。</li><li>地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。</li><li>文本索引，用于支持快速的全文检索</li><li>模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。</li></ul><h2 id="索引评估、调优"><a href="#索引评估、调优" class="headerlink" title="索引评估、调优"></a><strong>索引评估、调优</strong></h2><p>使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。<br>如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.explain().find( &#123; a : 5 &#125; )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;queryPlanner&quot; : &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;winningPlan&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">      &quot;inputStage&quot; : &#123;</span><br><span class="line">        &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">        &quot;keyPattern&quot; : &#123;</span><br><span class="line">            &quot;a&quot; : 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;indexName&quot; : &quot;a_1&quot;,</span><br><span class="line">        &quot;isMultiKey&quot; : false,</span><br><span class="line">        &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">        &quot;indexBounds&quot; : &#123;&quot;a&quot; : [&quot;[5.0, 5.0]&quot;]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果 winningPlan 中可以看出执行计划是否高效，比如：</p><ul><li>未能命中索引的结果，会显示COLLSCAN</li><li>命中索引的结果，使用IXSCAN</li><li>出现了内存排序，显示为 SORT</li></ul><p>更加详细的内容，请移步到<a href="https://www.mongodb.com/docs/manual/indexes/">官方文档</a>。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>在大数据领域常常提到的4V特征中，Volume(数据量大)是首当其冲被提及的。<br>由于单机垂直扩展能力的局限，<strong>水平扩展</strong>的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。<br>此外，同时为了保证数据的高可用，MongoDB 采用<strong>副本集</strong>的方式来实现数据复制。</p><p>一个典型的MongoDB集群架构会同时采用分片+副本集的方式，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6f849c75bffb439f06e9ceafe6263377_720w.webp" alt="img"></p><p><strong>架构说明</strong></p><ul><li>数据分片（Shards）<br>分片用于存储真正的集群数据，可以是一个单独的 Mongod实例，也可以是一个副本集。 生产环境下Shard一般是一个 Replica Set，以防止该数据片的单点故障。<br>对于分片集合(sharded collection)来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard中。</li><li>配置服务器（Config Servers）<br>保存集群的元数据（metadata），包含各个Shard的路由规则，配置服务器由一个副本集(ReplicaSet)组成。</li><li>查询路由（Query Routers）<br>Mongos是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的Shard。<br>Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。</li></ul><h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><p>基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片(Shard) 则记录在 Config Server(配置服务器)上。<br>Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。</p><p><strong>数据是根据分片策略来进行切分的，而分片策略则由 分片键(ShardKey)+分片算法(ShardStrategy)组成。</strong></p><p>MongoDB 支持两种分片算法：</p><h3 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a9c8b977f026d13650d5fd70818d280_720w.webp" alt="img"></p><p>假设集合根据x字段来分片，x的取值范围为[minKey, maxKey]（x为整型，这里的minKey、maxKey为整型的最小值和最大值），将整个取值范围划分为多个chunk，每个chunk（默认配置为64MB）包含其中一小段的数据：<br>如Chunk1包含x的取值在[minKey, -75)的所有文档，而Chunk2包含x取值在[-75, 25)之间的所有文档…</p><p>范围分片能很好的满足<strong>范围查询</strong>的需求，比如想查询x的值在[-30, 10]之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力，比如使用_id作为 ShardKey，而MongoDB自动生成的id高位是时间戳，是持续递增的。</p><h3 id="哈希分片"><a href="#哈希分片" class="headerlink" title="哈希分片"></a>哈希分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6beb0f8fd6e84d4ffa847d7a579bf1e7_720w.webp" alt="img"></p><p>Hash分片是根据用户的 ShardKey 先计算出hash值（64bit整型），再根据hash值按照<strong>范围分片</strong>的策略将文档分布到不同的 chunk。<br>由于 hash值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。</p><h2 id="如何保证均衡"><a href="#如何保证均衡" class="headerlink" title="如何保证均衡"></a>如何保证均衡</h2><p>既然数据是分布在不同的 chunk 上的，而不同的 chunk 会被分配到不同的分片上，那么就会出现一个问题，如何保证分片上的数据（chunk）是均衡的。</p><p>一般会有以下两种情况：</p><ul><li>全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10个shard，存储1000个chunk，那么每个shard 分别拥有100个chunk。</li><li>非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂(split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk数据的搬迁达到均衡。</li></ul><p>MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点)上，而该节点也同时会控制 Chunk 数据的搬迁流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-ecb42a8acff963eacb2463f56d51465b_720w.webp" alt="img"></p><p>对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-a4afc0f479a98f4d8fa6302159dd5d4b_720w.webp" alt="img"></p><p>MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将<a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/%23sharding-schedule-balancing-window">均衡窗口</a>对齐到业务闲时段。</p><h2 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h2><p>应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-02b6729e1ae7d867e243c30524278a29_720w.webp" alt=""></p><p>当然，连接高可用的功能是由 Driver 实现的。</p><h3 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h3><p>副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个Shard(片)之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。<br>MongoDB 的副本集采取了一主多从的结构，即一个Primary Node + N* Secondary Node的方式，数据从主节点写入，并复制到多个备节点。</p><p>典型的架构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-69646e694e88aafce80498990307df9b_720w.webp" alt="img"></p><p>利用副本集，我们可以实现：：</p><ul><li>数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；</li><li>读写分离，读请求可以分流到备节点，减轻主节点的单点压力。</li></ul><p>请注意，读写分离只能增加集群”读”的能力，对于写负载非常高的情况却无能为力。<br>对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘IO、CPU能力可以取得一定效果。</p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config <span class="operator">=</span> &#123;</span><br><span class="line">    _id : &quot;my_replica_set&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : <span class="number">0</span>, host : &quot;rs1.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">1</span>, host : &quot;rs2.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">2</span>, host : &quot;rs3.example.net:27017&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster()命令就可以看到选举的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.isMaster()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;hosts&quot; : [</span><br><span class="line">    &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;192.168.100.2:27030&quot;,</span><br><span class="line">    &quot;192.168.100.3:27030&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;setName&quot; : &quot;myReplSet&quot;,</span><br><span class="line">    &quot;setVersion&quot; : <span class="number">1</span>,</span><br><span class="line">    &quot;ismaster&quot; : <span class="literal">true</span>,</span><br><span class="line">    &quot;secondary&quot; : <span class="literal">false</span>,</span><br><span class="line">    &quot;primary&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;me&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;electionId&quot; : ObjectId(&quot;7fffffff0000000000000001&quot;),</span><br><span class="line">    &quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 Raft算法的影响，主节点的选举需要满足”大多数”原则，可以参考下表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-099f568819dbb05978634934e3aa585e_720w.webp" alt="img"></p><p>因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如3个，正所谓三人行必有我师..</p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a><strong>心跳</strong></h4><p>在高可用的实现机制中，心跳(heartbeat)是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。<br>副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。<br>利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-81382e5544264faae3d6954584fe9254_720w.webp" alt="img"></p><p>默认情况下，节点会每2秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在10秒内没有收到主节点的响应就会主动发起选举。<br>此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。<br>如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>主节点和备节点的数据是通过日志(oplog)复制来实现的，这很类似于 mysql 的 binlog。<br>在每一个副本集的节点中，都会存在一个名为local.oplog.rs的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条oplog，<br>而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。</p><p>下面，看看一条 oplog 的具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ts&quot; : <span class="type">Timestamp</span>(<span class="number">1446011584</span>, <span class="number">2</span>),</span><br><span class="line">&quot;h&quot; : NumberLong(&quot;1687359108795812092&quot;),</span><br><span class="line">&quot;v&quot; : <span class="number">2</span>,</span><br><span class="line">&quot;op&quot; : &quot;i&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.nosql&quot;,</span><br><span class="line">&quot;o&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;563062c0b085733f34ab4129&quot;), &quot;name&quot; : &quot;mongodb&quot;, &quot;score&quot; : &quot;100&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的一些关键字段有：</p><ul><li>ts 操作的 optime，该字段不仅仅包含了操作的时间戳(timestamp)，还包含一个自增的计数器值。</li><li>h 操作的全局唯一表示</li><li>v oplog 的版本信息</li><li>op 操作类型，比如 i=insert,u=update..</li><li>ns 操作集合，形式为 database.collection</li><li>o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容</li></ul><p>MongoDB 对于 oplog 的设计是比较仔细的，比如：</p><ul><li>oplog 必须保证有序，通过 optime 来保证。</li><li>oplog 必须包含能够进行数据回放的完整信息。</li><li>oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。</li><li>oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。</li></ul><h1 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h1><p>一直以来，”不支持事务” 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡(放弃事务，追求高性能、高可扩展)<br>但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。<br>在4.0 版本之后，MongoDB 开始支持多文档的事务：</p><ul><li>4.0 版本支持副本集范围的多文档事务。</li><li>4.2 版本支持跨分片的多文档事务(基于两阶段提交)。</li></ul><p>在事务的隔离性上，MongoDB 支持快照(snapshot)的隔离级别，可以避免脏读、不可重复读和幻读。<br>尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向系统写入一条数据，应该能够马上读到写入的这个数据。</span><br></pre></td></tr></table></figure><p>在分布式架构的CAP理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-12e5c64d1e1df25b325af95055a7012c_720w.webp" alt="img"></p><p>在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：</p><ul><li>read preference<br>读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点</li><li>write concern<br>写关注，指定写入结果达到什么状态时才返回，可以为无应答(none)、应答(ack)，或者是大多数节点完成了数据复制等等</li><li>read concern<br>读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读(linearizable)等等。</li></ul><p>使用不同的设定将会产生对于C(一致性)、A(可用性)的不同的抉择，比如：</p><ul><li>将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败(可用性降低)</li><li>将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟(出现不一致)</li><li>将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了(节点失效会导致大多数写失败)</li></ul><p>关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动failover等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>行文至此，笔者对 MongoDB 也有了基本的了解，那么在什么样的情况下才需要使用 MongoDB 呢？换句话说就是 MongoDB 的应用场景是什么。</p><p>以下是几个实际的应用案例。</p><ul><li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li><li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。</li><li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li><li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li><li>视频直播，使用 MongoDB 存储用户信息、礼物信息等。</li></ul><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高 对于这样的数据，我们更适合使用MongoDB来实现数据的存储。</p><h2 id="辅助决策"><a href="#辅助决策" class="headerlink" title="辅助决策"></a>辅助决策</h2><p>如果你还在为是否应该使用 MongoDB，不如来做几个选择题来辅助决策</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428154322305-1499789968.png" alt="img"></p><p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择MongoDB绝不会后悔。</p><h1 id="优势和局限性"><a href="#优势和局限性" class="headerlink" title="优势和局限性"></a>优势和局限性</h1><p>MongoDB 为需要可靠数据库的公司提供了众多优势。以下是使用 MongoDB 的一些好处：</p><ul><li>速度：MongoDB比一般的关系数据库快 100 倍。作为一个面向文档的数据库，MongoDB 通过索引使访问文档变得容易。这有助于快速查询响应，从而节省用户宝贵的时间。</li><li>分片：MongoDB 提供的另一个好处是它允许用户存储大量数据。这是通过将数据分发到连接到应用程序的多个服务器来完成的。如果一台服务器无法处理数据的大小，则通过称为自动分片的过程将其共享给另一台服务器。</li><li>灵活的数据库：MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由。</li><li>水平可扩展性：MongoDB 是一个可水平扩展的数据库，这是它的基本优势之一。它允许用户有效地将大量数据分发到多台机器。</li><li>事务可行性：一些 MongoDB 功能包括gridFS 和 Replication。这些功能支持在使用 MongoDB 时提高数据可用性。这确保了应用程序的性能非常高。</li><li>缺少模式：MongoDB 是 NoSQL，这意味着它不需要模式。因此，在使用 MongoDB 时无需概述数据库模式。这减少了数据库处理信息所需的时间。因此，您的架构将由您编写的算法定义。</li></ul><p>尽管 MongoDB 提供了优于其他数据库的显着优势，但它并不完美。它有一些需要改进的限制。以下是 MongoDB 的一些缺点。 </p><ul><li>不支持连接：与支持连接的理性数据库不同，MongoDB 不支持。虽然可以通过手动编码添加连接功能，但执行速度可能会很慢并影响性能。</li><li>高内存使用率：MongoDB 旨在为每个值对存储键名称。它还受到数据冗余的影响，因为它缺少连接功能。这会导致高内存使用率。</li><li>有限数据大小：MongoDB 允许的最大文档大小为16MB。这是一个需要纠正的严峻挑战。</li><li>有限嵌套：MongoDB 提供有限的嵌套访问，因为用户不能执行超过100 级的文档嵌套。</li></ul><h1 id="ChatGPT-怎么看"><a href="#ChatGPT-怎么看" class="headerlink" title="ChatGPT 怎么看"></a>ChatGPT 怎么看</h1><p>问：怎么理解MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由？</p><p>答：MongoDB 作为无模式（schema-less）的文档存储数据库，其设计允许在同一个集合（相当于关系数据库中的表）中的不同文档（相当于关系数据库中的行）具有不同的结构和类型。以下是对这一特性的详细解释：</p><h3 id="1-无模式（Schema-less）特性"><a href="#1-无模式（Schema-less）特性" class="headerlink" title="1. 无模式（Schema-less）特性"></a>1. 无模式（Schema-less）特性</h3><p>在传统的关系数据库中，所有行必须符合预定义的表结构（schema），即每一列的数据类型和属性在创建表时就已经固定下来。这意味着每一行的数据必须遵循相同的格式。</p><p>相比之下，MongoDB 不强制要求文档具有相同的结构。每个文档可以有不同的字段和数据类型。这种灵活性源于 MongoDB 使用 BSON（一种二进制的 JSON 格式）来存储数据。</p><h3 id="2-灵活的数据模型"><a href="#2-灵活的数据模型" class="headerlink" title="2. 灵活的数据模型"></a>2. 灵活的数据模型</h3><ul><li><strong>不同文档的结构可以不同</strong>：在同一个集合中，一个文档可以包含某些字段，而另一个文档可以不包含这些字段，或者包含不同的字段。例如，在一个用户集合中，一个文档可以包含 <code>name</code> 和 <code>email</code> 字段，而另一个文档可以包含 <code>name</code>、<code>email</code> 和 <code>phone</code> 字段。</li><li><strong>字段的数据类型可以不同</strong>：即使是相同字段，在不同文档中也可以具有不同的数据类型。例如，一个文档中的 <code>age</code> 字段可以是整数类型，而在另一个文档中，<code>age</code> 字段可以是字符串类型。</li></ul><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul><li><strong>灵活性</strong>：开发者可以根据需要随时添加或修改文档中的字段，而无需修改整个集合的结构。这使得开发迭代更快，特别是在需求频繁变化的项目中。</li><li><strong>适应性</strong>：能够轻松存储和处理复杂和多变的数据结构，如嵌套文档和数组。适用于需要处理异构数据（heterogeneous data）的应用场景。</li><li><strong>快速开发和原型设计</strong>：无需提前定义和维护模式，能够快速启动项目和进行原型设计。</li></ul><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>考虑一个用户集合，其中的文档结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123-456-7890&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在上述例子中：</p><ul><li>文档1 和 文档2 具有不同的字段，文档2 比文档1 多了 <code>phone</code> 字段。</li><li>文档3 没有 <code>email</code> 字段，但有 <code>age</code> 字段，并且 <code>age</code> 字段的数据类型为整数。</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul><li><strong>内容管理系统（CMS）</strong>：需要存储不同类型的内容，如文章、评论、用户信息等，每种内容的结构可能不同。</li><li><strong>物联网（IoT）</strong>：不同的传感器设备产生的数据格式可能不同，需要灵活存储和处理。</li><li><strong>快速原型设计</strong>：在产品开发初期，需求可能频繁变化，无模式数据库可以快速适应这些变化。</li></ul><h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul><li><strong>数据一致性和验证</strong>：由于没有固定模式，可能会引入不一致的数据，需要在应用层进行数据验证和清理。</li><li><strong>查询优化</strong>：灵活的结构可能会影响查询性能，需要通过索引和查询优化来提高效率。</li></ul><p>总之，MongoDB 的无模式特性为开发者提供了极大的灵活性，允许存储和处理多种类型和结构的数据，适应快速变化的需求和复杂的应用场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通读全文，好像感觉这篇文章在哪看过。对，没错，这就是笔者对几篇文章的缝合。边学习边记录吗，不错的学习模式。</p><p>总之，MongoDB 以其高并发、高扩展性、高可用性和无模式特性取得了不错的成绩。也逐渐变成了找工作必须要会的一项技能。情到深处，不得不搞个一首，“都是内卷惹的祸……”。</p><p>关于 MongoDB 的学习绝不仅于此，后续会记录深入的内容。</p><p>一位同志在第三次考ccf通过后突然顿悟，决定不考研了，乐。猜一下他学 Java 能学多久，刚好我也要学。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/littleatp/p/11675233.html">了解 MongoDB 看这一篇就够了</a></p><p><a href="https://www.cnblogs.com/liaowenhui/p/17362409.html">MongoDB 的简介及应用场景</a></p><p><a href="https://developer.aliyun.com/article/64352">什么场景下该用 MongoDB</a></p><p><a href="https://www.mongodb.com/docs/manual/">MongoDB 官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。&lt;/p&gt;
&lt;p&gt;本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个</summary>
      
    
    
    
    <category term="MongoDB" scheme="http://example.com/categories/MongoDB/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战总结</title>
    <link href="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-01T10:02:00.000Z</published>
    <updated>2024-06-11T15:53:43.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。</p><p>主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。</p><p>从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。</p><p>学习MySQL的索引，就避不开要了解 B+ 树，在 MySQL 里 InnoDB 存储引擎就是采用 B+ 树来组织数据的，这是我们在背八股文时一定要记住的东西。那么在 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？为什么要选择 B+ 树来组织数据呢？下面我们来深入学习一下。</p><h2 id="从数据页的角度看-B-树"><a href="#从数据页的角度看-B-树" class="headerlink" title="从数据页的角度看 B+ 树"></a>从数据页的角度看 B+ 树</h2><p>这次，我们<strong>从数据页的角度看 B+ 树</strong>，看看每个节点长啥样。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f7696506a3c1c94621fcbad10341f1a8.png" alt="图片"></p><h3 id="InnoDB-是如何进行存储数据的？"><a href="#InnoDB-是如何进行存储数据的？" class="headerlink" title="InnoDB 是如何进行存储数据的？"></a>InnoDB 是如何进行存储数据的？</h3><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同，我们最常用的就是 InnoDB 存储引擎。</p><p>记录时按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p><p>因此，InnoDB 的数据时按<strong>「数据页」</strong>为单位来读写的，也就是说，当需要读一条数据的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>InnoDB 数据页的默认大小是 16KB</strong>，数据页包括七个部分，结构如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p><p>这 7 个部分的作用如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向的链表</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/557d17e05ce90f18591c2305871af665.png" alt="图片"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><hr><p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>可以得出，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h3 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h3><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><hr><p>看了这么多关于 B+ 树和数据库索引的内容，我们对其也有了基本的了解，那就来再解决一个问题吧，为什么要用 B+ 树，而不是其他的数据结构，也顺便了解一下其他的树相关的知识。</p><h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的。</p><h3 id="怎样的索引的数据结构是好的？"><a href="#怎样的索引的数据结构是好的？" class="headerlink" title="怎样的索引的数据结构是好的？"></a>怎样的索引的数据结构是好的？</h3><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存在磁盘上的，因为这样及时设备断电了，数据也不会丢失。</p><p>这样就带来了一个新的问题，速度太慢，因为磁盘是一个慢的离谱的存储设备。磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><blockquote><p>索引的数据最好是按顺序排列的，这样才能使用<strong>「二分查找法」</strong>高效定位数据。</p></blockquote><h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p><p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p><p>那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？</p><p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/49cb4df3fb7d4accbc75f6970ff1d0ea.gif" alt="请添加图片描述"></p><p>这样这个数组就变成了一个二叉查找树。</p><p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p><p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p><p>那么既然已经解决了所有问题，是不是就可以直接用二叉查找树来组织索引了。</p><p>不行，因为二叉查找树有一个致命的问题，那就是当新插入的数据全都比已有数据大或者小，那这个二叉查找树就变成了一个链表了，也就失去了现有的优势。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/320c5c2653e74f9e9ebfcd8ca9681905.gif" alt="请添加图片描述"></p><h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p><p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树。</p><p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，由于也被面试官提到过类似的问题，后面会单独写一篇博客来记录。</p><p>现在，平衡二叉树退化成为链表的情况被解决了，但是随着数据的插入，树会变得越来越高，查询次数也就越来越多。</p><p>下面我们来看一下二叉树和三叉树在有相同节点个数的情况下高度的差别。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2d26d30c953cd47c6ab637ad0eba2f99.png" alt="图片"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00fb73de7014a87958f1597345e9ef2f.png" alt="图片"></p><p><strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B 树"></a>B 树</h3><p>对于上一节中提到的问题，一个新的数据结构被提出——B 树，它不在限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，特点就是每个节点最多有 M-1个数据，超过这些要求的话，就会分裂节点。</p><p>这么看来，B 树好像又解决了所有已经出现的问题，还有新的吗，当然。毕竟我们的主角是 B+ 树。</p><p>正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？</p><p>在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p><p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p><h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>好了好了，没想到设计一个索引需要的数据结构能遇到这么多困难，现在我们的救世主——B+ 树他终于来了。</p><p>B+ 树就是对 B 树做了一个升级，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mysql-20240322142950.png" alt="用户1260737：B+树"></p><p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了。</p><p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p><p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p><hr><p>至此，所有出现的问题都得到了解决，当然也并不是在所有的数据库中都使用 B+ 树来存储索引。比如在 MongoDB 中存储索引的数据结构就是 B 树。详细原因还是在后面的博客中记录吧，挖个坑先……</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>腾讯第二次面试时提的问题，我回答的不知道，后来美团面试也问了，我答了几种情况，当时就只是背下来了，也不知道为什么，面试官想要更深入地问，我就又不会了。</p><p>那在本文中就详细解释一下这个问题吧。</p><p>在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。</p><p>但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。</p><p>稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低（之前我甚至以为索引失效是索引直接被删除了，脑子坏了）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9e6a9708a6dbbcc65906d1338d2ae70.png" alt=""></p><h2 id="索引长什么样？"><a href="#索引长什么样？" class="headerlink" title="索引长什么样？"></a>索引长什么样？</h2><p>我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。</p><p>索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。</p><p>MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构。在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p><p>MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。</p><p>虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：</p><ul><li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；</li><li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；</li></ul><p>举个栗子：</p><p>这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00730eac527c21a4034f0f9ba0218aba.png" alt="图片"></p><p>如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f287701eba9bf6f32a2d09b013bb451b.png" alt="图片"></p><p>如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（图中叶子节点之间是双向链表）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ef726d7287b854ea4862f7442d8012ec.png" alt="图片"></p><p>InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p><p>如果将 name 字段设置为普通索引，那么这个二级索引长下图这样（图中叶子节点之间是双向链表）</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7dd91be9fe584d94a4d71572ae7214d0.png" alt="图片"></p><p>在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 字段为主键索引</span><br><span class="line">select * from t_user where id=1;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：</p><ul><li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li><li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li></ul><p>上面这个过程叫做<strong>回表</strong>，如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select * from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做<strong>覆盖索引</strong>。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select id from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><h2 id="什么情况会导致索引失效？"><a href="#什么情况会导致索引失效？" class="headerlink" title="什么情况会导致索引失效？"></a>什么情况会导致索引失效？</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><blockquote><p>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</p></blockquote><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b161c1d88f978e42077f8c14e10972a7.png" alt="图片"></p><p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li><li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li></ul><p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p><h3 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h3><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><blockquote><p>为什么对索引使用函数，就无法走索引了呢？</p></blockquote><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><h3 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h3><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><blockquote><p>为什么对索引进行表达式计算，就无法走索引了呢？</p></blockquote><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><h3 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h3><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>MySQL 的数据类型转换规则是什么？是会将字符串转成数字处理，还是将数字转换成字符串处理。</p><p>《MySQL45讲》里有一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p><ul><li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li><li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li></ul><p>在 MySQL 中，执行的结果如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/25316fd06cadff4434f02391ef0b5c55.png" alt="图片"></p><p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>所以，在索引字段为字符串类型，比较字段为数字类型时，MySQL会对索引使用函数实现隐式类型转换，从而导致索引失效。</p><h3 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul><blockquote><p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？</p><p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>为什么联合索引不遵循最左匹配原则就会失效？</p></blockquote><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><h3 id="WHERE-字句中地-OR"><a href="#WHERE-字句中地-OR" class="headerlink" title="WHERE 字句中地 OR"></a>WHERE 字句中地 OR</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><h2 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h1 id="百万-千万级数据库如何优化？"><a href="#百万-千万级数据库如何优化？" class="headerlink" title="百万/千万级数据库如何优化？"></a>百万/千万级数据库如何优化？</h1><p>百万级、千万级数据处理，个人认为核心关键在于数据存储方案设计，存储方案设计的是否合理，直接影响到数据CRUD操作。总体设计可以考虑一下几个方面进行设计考虑：</p><ul><li>数据存储结构设计</li><li>索引设计</li><li>数据主键设计</li><li>查询方案设计</li></ul><p>由于本人也没有这个实力去真正实操百万千万级别地数据库，所以更到还是纸上谈兵，图个乐就行了。</p><h2 id="百万级"><a href="#百万级" class="headerlink" title="百万级"></a>百万级</h2><h3 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><ul><li>表字段 not null，因为 null 值很难查询优化且占用额外的索引空间，推荐默认数字 0。</li><li>数据状态类型的字段，比如 status, type 等等，尽量不要定义负数，如 -1。因为这样可以加上 UNSIGNED，数值容量就会扩大一倍。</li><li>可以的话用 TINYINT、SMALLINT 等代替 INT，尽量不使用 BIGINT，因为占的空间更小。</li><li>字符串类型的字段会比数字类型占的空间更大，所以尽量用整型代替字符串，很多场景是可以通过编码逻辑来实现用整型代替的。</li><li>字符串类型长度不要随意设置，保证满足业务的前提下尽量小。</li><li>用整型来存 IP。</li><li>单表不要有太多字段，建议在20以内。</li><li>为能预见的字段提前预留，因为数据量越大，修改数据结构越耗时。</li></ul><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul><li>索引，空间换时间的优化策略，基本上根据业务需求设计好索引，足以应付百万级的数据量，养成使用 explain 的习惯，关于 explain 也可以访问：explain 让你的 sql 写的更踏实了解更多。</li><li>一个常识：索引并不是越多越好，索引是会降低数据写入性能的。</li><li>索引字段长度尽量短，这样能够节省大量索引空间；</li><li>取消外键，可交由程序来约束，性能更好。</li><li>复合索引的匹配最左列规则，索引的顺序和查询条件保持一致，尽量去除没必要的单列索引。</li><li>值分布较少的字段（不重复的较少）不适合建索引，比如像性别这种只有两三个值的情况字段建立索引意义不大。</li><li>需要排序的字段建议加上索引，因为索引是会排序的，能提高查询性能。</li><li>字符串字段使用前缀索引，不使用全字段索引，可大幅减小索引空间。</li></ul><h3 id="查询语句优化"><a href="#查询语句优化" class="headerlink" title="查询语句优化"></a>查询语句优化</h3><ul><li>尽量使用短查询替代复杂的内联查询。</li><li>查询不使用 select *，尽量查询带索引的字段，避免回表。</li><li>尽量使用 limit 对查询数量进行限制。</li><li>查询字段尽量落在索引上，尤其是复合索引，更需要注意最左前缀匹配。</li><li>拆分大的 delete / insert 操作，一方面会锁表，影响其他业务操作，还有一方面是 MySQL 对 sql 长度也是有限制的。</li><li>不建议使用 MySQL 的函数，计算等，可先由程序处理，从上面提的一些点会发现，能交由程序处理的尽量不要把压力转至数据库上。因为多数的服务器性能瓶颈都在数据库上。</li><li>查询 count，性能：count(1) = count(*) &gt; count(主键) &gt; count(其他字段)。</li><li>查询操作符能用 between 则不用 in，能用 in 则不用 or。</li><li>避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符，因为这些查询无法使用索引。</li><li>sql 尽量简单，少用 join，不建议两个 join 以上。</li></ul><h2 id="千万级"><a href="#千万级" class="headerlink" title="千万级"></a>千万级</h2><h3 id="数据存储结构设计-1"><a href="#数据存储结构设计-1" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><p>到了这个阶段的数据量，数据本身已经有很大的价值了，数据除了满足常规业务需求外，还会有一些数据分析的需求。而这个时候数据可变动性不高，基本上不会考虑修改原有结构，一般会考虑从分区，分表，分库三方面做优化：<br><strong>分区</strong><br>分区是根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分，是一种水平划分。对应用来说是完全透明的，不影响应用的业务逻辑，即不用修改代码。因此能存更多的数据，查询，删除也支持按分区来操作，从而达到优化的目的。如果有考虑分区，可以提前做准备，避免下列一些限制：</p><ul><li>一个表最多只能有1024个分区（6之后支持8192个分区）。但你实际操作的时候，最好不要一次性打开超过100 个分区，因为打开分区也是有时间损耗的。</li><li>如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。</li><li>分区表中无法使用外键约束。</li><li>NULL值会使分区过滤无效，这样会被放入默认的分区里，请千万不要让分区字段出现NULL。</li><li>所有分区必须使用相同的存储引擎。</li></ul><p><strong>分表</strong><br>分表分水平分表和垂直分表。<br>水平分表即拆分成数据结构相同的各个小表，如拆分成 table1, table2…，从而缓解数据库读写压力。<br>垂直分表即将一些字段分出去形成一个新表，各个表数据结构不相同，可以优化高并发下锁表的情况。<br>可想而知，分表的话，程序的逻辑是需要做修改的，所以，一般是在项目初期时，预见到大数据量的情况，才会考虑分表。后期阶段不建议分表，成本很大。<br><strong>分库</strong><br>分库一般是主从模式，一个数据库服务器主节点复制到一个或多个从节点多个数据库，主库负责写操作，从库负责读操作，从而达到主从分离，高可用，数据备份等优化目的。<br>当然，主从模式也会有一些缺陷，主从同步延迟，binlog 文件太大导致的问题等等，这里不细讲（笔者也学不动了）。<br><strong>其他</strong><br>冷热表隔离。对于历史的数据，查询和使用的人数少的情况，可以移入另一个冷数据库里，只提供查询用，来缓解热表数据量大的情况。</p><h3 id="数据库表主键设计"><a href="#数据库表主键设计" class="headerlink" title="数据库表主键设计"></a><strong>数据库表主键设计</strong></h3><p>数据库主键设计，个人推荐带有时间属性的自增长数字ID。（分布式自增长ID生成算法）<br>雪花算法<br>百度分布式ID算法<br>美团分布式ID算法<br>为什么要使用这些算法呢，这个与MySQL数据存储结构有关</p><p><strong>从业务上来说</strong></p><p>   在设计数据库时不需要费尽心思去考虑设置哪个字段为主键。然后是这些字段只是理论上是唯一的，例如使用图书编号为主键，这个图书编号只是理论上来说是唯一的，但实践中可能会出现重复的情况。所以还是设置一个与业务无关的自增ID作为主键，然后增加一个图书编号的唯一性约束。</p><p><strong>从技术上来说</strong></p><ol><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。</li><li>对InnoDB来说主键索引既存储索引值，又在叶子节点中存储行的数据，也就是说数据文件本身就是按照b+树方式存放数据的。</li><li>如果没有定义主键，则会使用非空的UNIQUE键做主键 ; 如果没有非空的UNIQUE键，则系统生成一个6字节的rowid做主键;聚簇索引中，N行形成一个页（一页通常大小为16K)。如果碰到不规则数据插入时，为了保持B+树的平衡，会造成频繁的页分裂和页旋转，插入速度比较慢。所以聚簇索引的主键值应尽量是连续增长的值，而不是随机值(不要用随机字符串或UUID)。</li><li>故对于InnoDB的主键，尽量用整型，而且是递增的整型。这样在存储/查询上都是非常高效的。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又到了我最爱的总结环节了，就能想写什么就写什么了。本来这篇文章要写四大部份的，还有一个sql注入的问题，之前看的文章就讲了一点例子，我以为就只有那么一点呢，今天仔细一查才发现还有那么多没有看过，下次再写吧。</p><p>昨天为什么破防，因为还是没有找到实习，一直都没有公司跟我约面试，我也不知道是那个环节出现问题了，可能还是因为学的东西太少了吧，所以我决定不找实习了，沉淀三个月，把MongoDO、kafka、docker、k8s还有Linux这些东西学一下。</p><p>之前一直觉得边找边学挺好的，找着找着发现面试太少了，不能从面试里面学到什么东西，又要因为准备面试耽误时间。我还是得练练表达能力，老是紧张也不是个事啊。加油吧，祝我自己秋招顺利，也祝我的朋友们考研成功、秋招顺利。还有两个有实习的，那就祝他们实习顺利吧（呜呜呜……，留下了羡慕的泪水）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/mysql/index/index_interview.html">小林coding 图解MySQL 索引篇</a></p><p><a href="https://javabetter.cn/sidebar/sanfene/mysql.html">MySQL八股文</a></p><p><a href="https://bbs.huaweicloud.com/blogs/222183">数据库优化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。&lt;/p&gt;
&lt;p&gt;主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。&lt;/p&gt;
&lt;p&gt;从头开始总结一下最近一段时</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
