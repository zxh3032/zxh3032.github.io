<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-02T13:43:05.616Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>了解MongoDB——你想知道的都在这</title>
    <link href="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/"/>
    <id>http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/</id>
    <published>2024-06-02T12:11:30.000Z</published>
    <updated>2024-06-02T13:43:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。</p><p>本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。</p><h1 id="什么是-NoSQL？"><a href="#什么是-NoSQL？" class="headerlink" title="什么是 NoSQL？"></a>什么是 NoSQL？</h1><p>在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQL 以外，还了解什么数据库。我回答，不知道。结束后，我机智的舍友问我为什么不回答 NoSQL，我以为这是不知道其他数据库的英文表达（离谱）。</p><p>NoSQL 也被称为 “not only SQL” 或 “non-SQL”，它是一种数据库设计方法，可以在关系数据库中的传统结构之外存储和查询数据。</p><p>虽然 NoSQL 仍然可以存储关系数据库管理系统 (RDBMS) 中的数据，但与 RDBMS 相比，数据存储方式有所不同。决定使用关系数据库还是非关系数据库在很大程度上取决于上下文，并且因用例而异。</p><p>NoSQL 数据库并非采用关系数据库的典型表结构，而是将数据存储在一个数据结构中，例如 JSON 文档。由于这种非关系数据库设计不需要使用架构，因此，它提供快速可扩展性以管理通常为非结构化的大型数据集。</p><p>NoSQL 也是一种分布式数据库类型，这意味着将信息复制并存储在不同的服务器上，这些服务器可能是远程服务器或本地服务器。这确保了数据的可用性和可靠性。如果一些数据脱机，数据库的其他部分可以继续运行。</p><p><strong>特点</strong></p><ol><li><strong>灵活的数据模型</strong>：NoSQL数据库支持多种数据模型，如键值对、文档、列族和图形模型，适应各种应用场景。</li><li><strong>高可扩展性</strong>：通过分布式架构实现水平扩展，可以轻松添加更多的服务器来处理增加的数据量和流量。</li><li><strong>高性能</strong>：NoSQL数据库设计优化了读写操作，能提供高性能的查询速度。</li><li><strong>可用性和可靠性</strong>：通常具备内置的故障转移和数据复制机制，保证数据的高可用性和可靠性。</li></ol><p><strong>类型</strong></p><ol><li><p>键值存储（Key-Value Store）</p><p>：数据以键值对的形式存储，适合简单查询和高速读写操作。</p><ul><li>示例：Redis, DynamoDB</li></ul></li><li><p>文档存储（Document Store）</p><p>：数据以文档的形式存储，每个文档可以有不同的结构，适合存储复杂的嵌套数据。</p><ul><li>示例：MongoDB, CouchDB</li></ul></li><li><p>列族存储（Column-Family Store）</p><p>：数据以列的形式存储，每一列可以独立查询，适合大规模数据分析。</p><ul><li>示例：Cassandra, HBase</li></ul></li><li><p>图形数据库（Graph Database）</p><p>：数据以节点和边的形式存储，适合处理复杂关系和网络图。</p><ul><li>示例：Neo4j, ArangoDB</li></ul></li></ol><h2 id="常见的-NoSQL"><a href="#常见的-NoSQL" class="headerlink" title="常见的 NoSQL"></a>常见的 NoSQL</h2><p>以下是几个常用的NoSQL数据库及其主要特点：</p><ol><li>MongoDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式（BSON）存储数据，文档具有灵活的结构。</li><li>强大的查询和索引功能，支持复杂的查询操作。</li><li>支持水平扩展，通过分片实现高可扩展性。</li><li>提供复制集功能，保证数据的高可用性和自动故障转移。</li></ul></li></ul><ol><li>Cassandra</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>采用分布式架构，无单点故障，提供高可用性和高容错性。</li><li>高写入和读取性能，适用于大规模数据处理。</li><li>支持多数据中心的复制，保证数据的高可用性和一致性。</li><li>灵活的Schema设计，适合时间序列数据和大数据分析。</li></ul></li></ul><ol><li>Redis</li></ol><ul><li><strong>类型</strong>：键值存储（Key-Value Store）</li><li><strong>特点</strong>：<ul><li>数据存储在内存中，提供极高的读写性能，适用于实时应用。</li><li>支持多种数据结构，如字符串、哈希、列表、集合和有序集合。</li><li>提供丰富的操作和事务功能，支持发布/订阅、Lua脚本等。</li><li>具有持久化机制，数据可以持久化到磁盘。</li></ul></li></ul><ol><li>Neo4j</li></ol><ul><li><strong>类型</strong>：图形数据库（Graph Database）</li><li><strong>特点</strong>：<ul><li>以节点和关系（边）的形式存储数据，适合处理复杂关系和网络图。</li><li>提供强大的图形查询语言Cypher，支持高效的图遍历和查询操作。</li><li>广泛应用于社交网络、推荐系统和网络分析等场景。</li><li>提供ACID事务保证，确保数据一致性和可靠性。</li></ul></li></ul><ol><li>CouchDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式存储数据，每个文档可以有不同的结构。</li><li>提供RESTful API接口，便于集成和访问数据。</li><li>支持多主复制，允许在不同节点之间同步数据。</li><li>具备内置的冲突解决机制，适用于分布式环境。</li></ul></li></ul><ol><li>HBase</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>基于Hadoop HDFS构建，适用于处理大规模结构化数据。</li><li>提供强一致性的读写操作，适合需要高可靠性的应用。</li><li>支持随机读写和实时查询，适合大数据分析和实时应用。</li><li>与Hadoop生态系统紧密集成，支持MapReduce等大数据处理框架。</li></ul></li></ul><p>这些NoSQL数据库在不同的应用场景中发挥着重要作用，根据具体需求选择合适的数据库可以显著提升系统的性能和可扩展性。</p><h1 id="MongoDB-出现的原因"><a href="#MongoDB-出现的原因" class="headerlink" title="MongoDB 出现的原因"></a>MongoDB 出现的原因</h1><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。而MongoDB可应对“三高”需求。“三高”需求：</p><p>（1）High performance - 对数据库高并发读写的需求。</p><p>（2）Huge Storage - 对海量数据的高效率存储和访问的需求。</p><p>（3）High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对“三高”需求。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从它的命名也可以看出来，设计者是有一定野心的。MongoDB 的原名一开始<strong>来自于 英文单词”Humongous”, 中文含义是指”庞大”</strong>，即命名者的意图是可以处理大规模的数据。</p><p>在使用 MongoDB 我会有两种感觉：</p><ul><li>第一层感受是”爽”，使用这个文档数据库的特点是几乎不受什么限制，一方面Json文档式的结构更容易理解，而无Schema约束也让DDL管理更加简单，一切都可以很快速的进行。</li><li>第二层感受是”酸爽”，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验”太过于友好”，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。</li></ul><p>所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的RDBMS数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的话，会遇到更多的坑。</p><p>尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-aedbdb7187c091f3b2e091baea945806_720w.webp" alt="img"></p><p>在全部的排名中，MongoDB 长期排在第5位(文档数据库排名第1位)，同时也是最受欢迎的 NoSQL 数据库。</p><p>MongoDB 数据库的一些特性：</p><ul><li>面向文档存储，基于JSON/BSON 可表示灵活的数据结构</li><li>动态 DDL能力，没有强Schema约束，支持快速迭代</li><li>高性能计算，提供基于内存的快速数据查询</li><li>容易扩展，利用数据分片可以支持海量数据存储</li><li>丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。</li><li>跨平台版本、支持多语言SDK..</li></ul><h1 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h1><p>数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。</p><blockquote><p>关于这点，也有人说，MongoDB 是 NoSQL中最像SQL的数据库..</p></blockquote><p>我们来看与MySQL的对比，通过对比来学习其基本模型。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428161048312-2056386348.png" alt="img"></p><ul><li>database 数据库，与SQL的数据库(database)概念相同，一个数据库包含多个集合(表)</li><li>collection 集合，相当于SQL中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是<strong>动态的</strong>，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema的校验。</li><li>document 文档，相当于SQL中的行(row)，一个文档由多个字段(列)组成，并采用<code>bson(json)</code>格式表示。</li><li>field 字段，相当于SQL中的列(column)，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。</li></ul><p>此外，MongoDB中字段的类型是<strong>固定的</strong>、<strong>区分大小写</strong>、并且文档中的字段也是<strong>有序的</strong>。</p><p>另外，SQL 还有一些其他的概念，对应关系如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a4ce8ff9c69d5402f70baa1b050ad0d_720w.webp" alt="img"></p><ul><li>_id 主键，MongoDB 默认使用一个 _id 字段来保证文档的<strong>唯一性</strong>。</li><li>reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。</li><li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。</li><li>index 索引，与SQL 的索引相同。</li><li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li><li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li><li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li></ul><h2 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a><code>BSON</code> 数据类型</h2><p> MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以 <code>BSON（Binary-JSON）</code>文档的格式存储在磁盘上。</p><p><code>BSON（Binary Serialized Document Format）</code>是一种类 <code>json</code> 的一种二进制形式的存储格式，简称<code>Binary JSON</code>。<code>BSON</code>和<code>JSON</code>一样，支持 内嵌的文档对象和数组对象，但是<code>BSON</code>有<code>JSON</code>没有的一些数据类型，如Date和BinData类型。</p><p><code>BSON</code>采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p><code>BSON</code>中，除了基本的JSON类型：string, integer, boolean, double, null, array 和 object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详 细信息。</p><p>BSON数据类型参考列表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428163656218-1316936233.png" alt="img"></p><p> 提示： shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符 号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p><h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><p>面试问题：在进行数据库分表或者将同一个数据库部署到不同的服务器上，如何保证主键不重复。</p><p>当然，方法有很多，不同公司会有自己的处理方式，具体的后续会写文章来分析。我们先看在 MongoDB 中是如何保证主键不重复的。</p><p>在单机时代，大多数应用可以使用数据可自增式 ID 来作为主键。传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。</p><p>为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。</p><p>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-227bd6ae2f8a3c05546f51cfd4a0b7a8_720w.webp" alt="img"></p><p>其中包括：</p><ul><li>4-byte Unix 时间戳</li><li>3-byte 机器 ID</li><li>2-byte 进程 ID</li><li>3-byte 计数器(初始化随机)</li></ul><p>值得一提的是 _id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。<br>当然服务端也会检测写入的文档是否包含 _id 字段，如果没有就生成一个。</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>除了文档模型本身，对于数据的操作命令也是基于JSON/BSON 格式的语法。</p><p>详细的语法操作，可以去看<a href="https://www.mongodb.com/docs/manual/reference/sql-comparison/">官方的文档</a>，下面简单介绍一下基础使用语法。</p><p>比如插入文档的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.book.insert(</span><br><span class="line">&#123;</span><br><span class="line">  title: &quot;My first blog post&quot;,</span><br><span class="line">  published: <span class="keyword">new</span> <span class="type">Date</span>(),</span><br><span class="line">  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],</span><br><span class="line">  type: &quot;Work&quot;,</span><br><span class="line">  author : &quot;James&quot;,</span><br><span class="line">  viewCount: <span class="number">25</span>,</span><br><span class="line">  commentCount: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行文档查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;author : &quot;James&quot;&#125;)</span><br></pre></td></tr></table></figure><p>更新文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.book.update(</span><br><span class="line">   &#123;&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)&#125;,</span><br><span class="line">   &#123;&quot;$inc&quot;: &#123;&quot;viewCount&quot;: <span class="number">3</span>&#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>删除文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.remove(&#123;&quot;_id&quot;:</span><br><span class="line">     ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&quot;author&quot;: &quot;James&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;: <span class="number">1</span>, &quot;title&quot;: <span class="number">1</span>, &quot;author&quot;: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>实现简单的分页查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&#125;)</span><br><span class="line">    .sort(&#123;&quot;viewCount&quot; : <span class="number">-1</span>&#125;)</span><br><span class="line">    .<span class="keyword">skip</span>(<span class="number">10</span>).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。<br>与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。</p><p>那么，一个有趣的问题是 MongoDB 能不能用 SQL进行查询？</p><p>当然是可以！</p><p>但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：</p><ul><li>客户端使用SQL，可以使用 mongobooster、studio3t 这样的工具</li><li>服务端的话，可以看看 presto 之类的一些平台..</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。</p><p>索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。在索引的实现上使用了 B 树，MySQL 则是采用 B+ 树来实现索引的。</p><p>使用 <code>ensureIndexes</code> 可以为集合声明一个普通的索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;author: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>author后面的数字 1 代表升序，如果是降序则是 -1</p></blockquote><p>实现复合式(compound)的索引，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;type: 1, published: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>只有对于复合式索引时，索引键的顺序才变得有意义</p></blockquote><p>如果索引的字段是数组类型，该索引就自动成为数组(multikey)索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;tags: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个</p></blockquote><h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a><strong>索引特性</strong></h2><p>在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：</p><ul><li>unique=true，表示一个唯一性索引</li><li>expireAfterSeconds=3600，表示这是一个TTL索引，并且数据将在1小时后老化</li><li>sparse=true，表示稀疏的索引，仅索引非空(non-null)字段的文档</li><li>partialFilterExpression: { rating: { $gt: 5 }，条件式索引，即满足计算条件的文档才进行索引</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h2><p>除了普通索引之外，MongoDB 支持的类型还包括：</p><ul><li>哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。</li><li>地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。</li><li>文本索引，用于支持快速的全文检索</li><li>模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。</li></ul><h2 id="索引评估、调优"><a href="#索引评估、调优" class="headerlink" title="索引评估、调优"></a><strong>索引评估、调优</strong></h2><p>使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。<br>如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.explain().find( &#123; a : 5 &#125; )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;queryPlanner&quot; : &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;winningPlan&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">      &quot;inputStage&quot; : &#123;</span><br><span class="line">        &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">        &quot;keyPattern&quot; : &#123;</span><br><span class="line">            &quot;a&quot; : 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;indexName&quot; : &quot;a_1&quot;,</span><br><span class="line">        &quot;isMultiKey&quot; : false,</span><br><span class="line">        &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">        &quot;indexBounds&quot; : &#123;&quot;a&quot; : [&quot;[5.0, 5.0]&quot;]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果 winningPlan 中可以看出执行计划是否高效，比如：</p><ul><li>未能命中索引的结果，会显示COLLSCAN</li><li>命中索引的结果，使用IXSCAN</li><li>出现了内存排序，显示为 SORT</li></ul><p>更加详细的内容，请移步到<a href="https://www.mongodb.com/docs/manual/indexes/">官方文档</a>。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>在大数据领域常常提到的4V特征中，Volume(数据量大)是首当其冲被提及的。<br>由于单机垂直扩展能力的局限，<strong>水平扩展</strong>的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。<br>此外，同时为了保证数据的高可用，MongoDB 采用<strong>副本集</strong>的方式来实现数据复制。</p><p>一个典型的MongoDB集群架构会同时采用分片+副本集的方式，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6f849c75bffb439f06e9ceafe6263377_720w.webp" alt="img"></p><p><strong>架构说明</strong></p><ul><li>数据分片（Shards）<br>分片用于存储真正的集群数据，可以是一个单独的 Mongod实例，也可以是一个副本集。 生产环境下Shard一般是一个 Replica Set，以防止该数据片的单点故障。<br>对于分片集合(sharded collection)来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard中。</li><li>配置服务器（Config Servers）<br>保存集群的元数据（metadata），包含各个Shard的路由规则，配置服务器由一个副本集(ReplicaSet)组成。</li><li>查询路由（Query Routers）<br>Mongos是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的Shard。<br>Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。</li></ul><h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><p>基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片(Shard) 则记录在 Config Server(配置服务器)上。<br>Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。</p><p><strong>数据是根据分片策略来进行切分的，而分片策略则由 分片键(ShardKey)+分片算法(ShardStrategy)组成。</strong></p><p>MongoDB 支持两种分片算法：</p><h3 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a9c8b977f026d13650d5fd70818d280_720w.webp" alt="img"></p><p>假设集合根据x字段来分片，x的取值范围为[minKey, maxKey]（x为整型，这里的minKey、maxKey为整型的最小值和最大值），将整个取值范围划分为多个chunk，每个chunk（默认配置为64MB）包含其中一小段的数据：<br>如Chunk1包含x的取值在[minKey, -75)的所有文档，而Chunk2包含x取值在[-75, 25)之间的所有文档…</p><p>范围分片能很好的满足<strong>范围查询</strong>的需求，比如想查询x的值在[-30, 10]之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力，比如使用_id作为 ShardKey，而MongoDB自动生成的id高位是时间戳，是持续递增的。</p><h3 id="哈希分片"><a href="#哈希分片" class="headerlink" title="哈希分片"></a>哈希分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6beb0f8fd6e84d4ffa847d7a579bf1e7_720w.webp" alt="img"></p><p>Hash分片是根据用户的 ShardKey 先计算出hash值（64bit整型），再根据hash值按照<strong>范围分片</strong>的策略将文档分布到不同的 chunk。<br>由于 hash值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。</p><h2 id="如何保证均衡"><a href="#如何保证均衡" class="headerlink" title="如何保证均衡"></a>如何保证均衡</h2><p>既然数据是分布在不同的 chunk 上的，而不同的 chunk 会被分配到不同的分片上，那么就会出现一个问题，如何保证分片上的数据（chunk）是均衡的。</p><p>一般会有以下两种情况：</p><ul><li>全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10个shard，存储1000个chunk，那么每个shard 分别拥有100个chunk。</li><li>非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂(split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk数据的搬迁达到均衡。</li></ul><p>MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点)上，而该节点也同时会控制 Chunk 数据的搬迁流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-ecb42a8acff963eacb2463f56d51465b_720w.webp" alt="img"></p><p>对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-a4afc0f479a98f4d8fa6302159dd5d4b_720w.webp" alt="img"></p><p>MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将<a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/%23sharding-schedule-balancing-window">均衡窗口</a>对齐到业务闲时段。</p><h2 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h2><p>应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-02b6729e1ae7d867e243c30524278a29_720w.webp" alt=""></p><p>当然，连接高可用的功能是由 Driver 实现的。</p><h3 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h3><p>副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个Shard(片)之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。<br>MongoDB 的副本集采取了一主多从的结构，即一个Primary Node + N* Secondary Node的方式，数据从主节点写入，并复制到多个备节点。</p><p>典型的架构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-69646e694e88aafce80498990307df9b_720w.webp" alt="img"></p><p>利用副本集，我们可以实现：：</p><ul><li>数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；</li><li>读写分离，读请求可以分流到备节点，减轻主节点的单点压力。</li></ul><p>请注意，读写分离只能增加集群”读”的能力，对于写负载非常高的情况却无能为力。<br>对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘IO、CPU能力可以取得一定效果。</p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config <span class="operator">=</span> &#123;</span><br><span class="line">    _id : &quot;my_replica_set&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : <span class="number">0</span>, host : &quot;rs1.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">1</span>, host : &quot;rs2.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">2</span>, host : &quot;rs3.example.net:27017&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster()命令就可以看到选举的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.isMaster()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;hosts&quot; : [</span><br><span class="line">    &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;192.168.100.2:27030&quot;,</span><br><span class="line">    &quot;192.168.100.3:27030&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;setName&quot; : &quot;myReplSet&quot;,</span><br><span class="line">    &quot;setVersion&quot; : <span class="number">1</span>,</span><br><span class="line">    &quot;ismaster&quot; : <span class="literal">true</span>,</span><br><span class="line">    &quot;secondary&quot; : <span class="literal">false</span>,</span><br><span class="line">    &quot;primary&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;me&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;electionId&quot; : ObjectId(&quot;7fffffff0000000000000001&quot;),</span><br><span class="line">    &quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 Raft算法的影响，主节点的选举需要满足”大多数”原则，可以参考下表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-099f568819dbb05978634934e3aa585e_720w.webp" alt="img"></p><p>因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如3个，正所谓三人行必有我师..</p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a><strong>心跳</strong></h4><p>在高可用的实现机制中，心跳(heartbeat)是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。<br>副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。<br>利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-81382e5544264faae3d6954584fe9254_720w.webp" alt="img"></p><p>默认情况下，节点会每2秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在10秒内没有收到主节点的响应就会主动发起选举。<br>此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。<br>如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>主节点和备节点的数据是通过日志(oplog)复制来实现的，这很类似于 mysql 的 binlog。<br>在每一个副本集的节点中，都会存在一个名为local.oplog.rs的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条oplog，<br>而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。</p><p>下面，看看一条 oplog 的具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ts&quot; : <span class="type">Timestamp</span>(<span class="number">1446011584</span>, <span class="number">2</span>),</span><br><span class="line">&quot;h&quot; : NumberLong(&quot;1687359108795812092&quot;),</span><br><span class="line">&quot;v&quot; : <span class="number">2</span>,</span><br><span class="line">&quot;op&quot; : &quot;i&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.nosql&quot;,</span><br><span class="line">&quot;o&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;563062c0b085733f34ab4129&quot;), &quot;name&quot; : &quot;mongodb&quot;, &quot;score&quot; : &quot;100&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的一些关键字段有：</p><ul><li>ts 操作的 optime，该字段不仅仅包含了操作的时间戳(timestamp)，还包含一个自增的计数器值。</li><li>h 操作的全局唯一表示</li><li>v oplog 的版本信息</li><li>op 操作类型，比如 i=insert,u=update..</li><li>ns 操作集合，形式为 database.collection</li><li>o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容</li></ul><p>MongoDB 对于 oplog 的设计是比较仔细的，比如：</p><ul><li>oplog 必须保证有序，通过 optime 来保证。</li><li>oplog 必须包含能够进行数据回放的完整信息。</li><li>oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。</li><li>oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。</li></ul><h1 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h1><p>一直以来，”不支持事务” 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡(放弃事务，追求高性能、高可扩展)<br>但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。<br>在4.0 版本之后，MongoDB 开始支持多文档的事务：</p><ul><li>4.0 版本支持副本集范围的多文档事务。</li><li>4.2 版本支持跨分片的多文档事务(基于两阶段提交)。</li></ul><p>在事务的隔离性上，MongoDB 支持快照(snapshot)的隔离级别，可以避免脏读、不可重复读和幻读。<br>尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向系统写入一条数据，应该能够马上读到写入的这个数据。</span><br></pre></td></tr></table></figure><p>在分布式架构的CAP理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-12e5c64d1e1df25b325af95055a7012c_720w.webp" alt="img"></p><p>在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：</p><ul><li>read preference<br>读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点</li><li>write concern<br>写关注，指定写入结果达到什么状态时才返回，可以为无应答(none)、应答(ack)，或者是大多数节点完成了数据复制等等</li><li>read concern<br>读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读(linearizable)等等。</li></ul><p>使用不同的设定将会产生对于C(一致性)、A(可用性)的不同的抉择，比如：</p><ul><li>将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败(可用性降低)</li><li>将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟(出现不一致)</li><li>将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了(节点失效会导致大多数写失败)</li></ul><p>关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动failover等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>行文至此，笔者对 MongoDB 也有了基本的了解，那么在什么样的情况下才需要使用 MongoDB 呢？换句话说就是 MongoDB 的应用场景是什么。</p><p>以下是几个实际的应用案例。</p><ul><li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li><li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。</li><li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li><li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li><li>视频直播，使用 MongoDB 存储用户信息、礼物信息等。</li></ul><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高 对于这样的数据，我们更适合使用MongoDB来实现数据的存储。</p><h2 id="辅助决策"><a href="#辅助决策" class="headerlink" title="辅助决策"></a>辅助决策</h2><p>如果你还在为是否应该使用 MongoDB，不如来做几个选择题来辅助决策</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428154322305-1499789968.png" alt="img"></p><p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择MongoDB绝不会后悔。</p><h1 id="优势和局限性"><a href="#优势和局限性" class="headerlink" title="优势和局限性"></a>优势和局限性</h1><p>MongoDB 为需要可靠数据库的公司提供了众多优势。以下是使用 MongoDB 的一些好处：</p><ul><li>速度：MongoDB比一般的关系数据库快 100 倍。作为一个面向文档的数据库，MongoDB 通过索引使访问文档变得容易。这有助于快速查询响应，从而节省用户宝贵的时间。</li><li>分片：MongoDB 提供的另一个好处是它允许用户存储大量数据。这是通过将数据分发到连接到应用程序的多个服务器来完成的。如果一台服务器无法处理数据的大小，则通过称为自动分片的过程将其共享给另一台服务器。</li><li>灵活的数据库：MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由。</li><li>水平可扩展性：MongoDB 是一个可水平扩展的数据库，这是它的基本优势之一。它允许用户有效地将大量数据分发到多台机器。</li><li>事务可行性：一些 MongoDB 功能包括gridFS 和 Replication。这些功能支持在使用 MongoDB 时提高数据可用性。这确保了应用程序的性能非常高。</li><li>缺少模式：MongoDB 是 NoSQL，这意味着它不需要模式。因此，在使用 MongoDB 时无需概述数据库模式。这减少了数据库处理信息所需的时间。因此，您的架构将由您编写的算法定义。</li></ul><p>尽管 MongoDB 提供了优于其他数据库的显着优势，但它并不完美。它有一些需要改进的限制。以下是 MongoDB 的一些缺点。 </p><ul><li>不支持连接：与支持连接的理性数据库不同，MongoDB 不支持。虽然可以通过手动编码添加连接功能，但执行速度可能会很慢并影响性能。</li><li>高内存使用率：MongoDB 旨在为每个值对存储键名称。它还受到数据冗余的影响，因为它缺少连接功能。这会导致高内存使用率。</li><li>有限数据大小：MongoDB 允许的最大文档大小为16MB。这是一个需要纠正的严峻挑战。</li><li>有限嵌套：MongoDB 提供有限的嵌套访问，因为用户不能执行超过100 级的文档嵌套。</li></ul><h1 id="ChatGPT-怎么看"><a href="#ChatGPT-怎么看" class="headerlink" title="ChatGPT 怎么看"></a>ChatGPT 怎么看</h1><p>问：怎么理解MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由？</p><p>答：MongoDB 作为无模式（schema-less）的文档存储数据库，其设计允许在同一个集合（相当于关系数据库中的表）中的不同文档（相当于关系数据库中的行）具有不同的结构和类型。以下是对这一特性的详细解释：</p><h3 id="1-无模式（Schema-less）特性"><a href="#1-无模式（Schema-less）特性" class="headerlink" title="1. 无模式（Schema-less）特性"></a>1. 无模式（Schema-less）特性</h3><p>在传统的关系数据库中，所有行必须符合预定义的表结构（schema），即每一列的数据类型和属性在创建表时就已经固定下来。这意味着每一行的数据必须遵循相同的格式。</p><p>相比之下，MongoDB 不强制要求文档具有相同的结构。每个文档可以有不同的字段和数据类型。这种灵活性源于 MongoDB 使用 BSON（一种二进制的 JSON 格式）来存储数据。</p><h3 id="2-灵活的数据模型"><a href="#2-灵活的数据模型" class="headerlink" title="2. 灵活的数据模型"></a>2. 灵活的数据模型</h3><ul><li><strong>不同文档的结构可以不同</strong>：在同一个集合中，一个文档可以包含某些字段，而另一个文档可以不包含这些字段，或者包含不同的字段。例如，在一个用户集合中，一个文档可以包含 <code>name</code> 和 <code>email</code> 字段，而另一个文档可以包含 <code>name</code>、<code>email</code> 和 <code>phone</code> 字段。</li><li><strong>字段的数据类型可以不同</strong>：即使是相同字段，在不同文档中也可以具有不同的数据类型。例如，一个文档中的 <code>age</code> 字段可以是整数类型，而在另一个文档中，<code>age</code> 字段可以是字符串类型。</li></ul><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul><li><strong>灵活性</strong>：开发者可以根据需要随时添加或修改文档中的字段，而无需修改整个集合的结构。这使得开发迭代更快，特别是在需求频繁变化的项目中。</li><li><strong>适应性</strong>：能够轻松存储和处理复杂和多变的数据结构，如嵌套文档和数组。适用于需要处理异构数据（heterogeneous data）的应用场景。</li><li><strong>快速开发和原型设计</strong>：无需提前定义和维护模式，能够快速启动项目和进行原型设计。</li></ul><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>考虑一个用户集合，其中的文档结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123-456-7890&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在上述例子中：</p><ul><li>文档1 和 文档2 具有不同的字段，文档2 比文档1 多了 <code>phone</code> 字段。</li><li>文档3 没有 <code>email</code> 字段，但有 <code>age</code> 字段，并且 <code>age</code> 字段的数据类型为整数。</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul><li><strong>内容管理系统（CMS）</strong>：需要存储不同类型的内容，如文章、评论、用户信息等，每种内容的结构可能不同。</li><li><strong>物联网（IoT）</strong>：不同的传感器设备产生的数据格式可能不同，需要灵活存储和处理。</li><li><strong>快速原型设计</strong>：在产品开发初期，需求可能频繁变化，无模式数据库可以快速适应这些变化。</li></ul><h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul><li><strong>数据一致性和验证</strong>：由于没有固定模式，可能会引入不一致的数据，需要在应用层进行数据验证和清理。</li><li><strong>查询优化</strong>：灵活的结构可能会影响查询性能，需要通过索引和查询优化来提高效率。</li></ul><p>总之，MongoDB 的无模式特性为开发者提供了极大的灵活性，允许存储和处理多种类型和结构的数据，适应快速变化的需求和复杂的应用场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通读全文，好像感觉这篇文章在哪看过。对，没错，这就是笔者对几篇文章的缝合。边学习边记录吗，不错的学习模式。</p><p>总之，MongoDB 以其高并发、高扩展性、高可用性和无模式特性取得了不错的成绩。也逐渐变成了找工作必须要会的一项技能。情到深处，不得不搞个一首，“都是内卷惹的祸……”。</p><p>关于 MongoDB 的学习绝不仅于此，后续会记录深入的内容。</p><p>一位同志在第三次考ccf通过后突然顿悟，决定不考研了，乐。猜一下他学 Java 能学多久，刚好我也要学。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/littleatp/p/11675233.html">了解 MongoDB 看这一篇就够了</a></p><p><a href="https://www.cnblogs.com/liaowenhui/p/17362409.html">MongoDB 的简介及应用场景</a></p><p><a href="https://developer.aliyun.com/article/64352">什么场景下该用 MongoDB</a></p><p><a href="https://www.mongodb.com/docs/manual/">MongoDB 官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。&lt;/p&gt;
&lt;p&gt;本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个</summary>
      
    
    
    
    <category term="周报" scheme="http://example.com/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战总结</title>
    <link href="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-01T10:02:00.000Z</published>
    <updated>2024-06-01T15:07:06.789Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。</p><p>主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。</p><p>从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。</p><p>学习MySQL的索引，就避不开要了解 B+ 树，在 MySQL 里 InnoDB 存储引擎就是采用 B+ 树来组织数据的，这是我们在背八股文时一定要记住的东西。那么在 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？为什么要选择 B+ 树来组织数据呢？下面我们来深入学习一下。</p><h2 id="从数据页的角度看-B-树"><a href="#从数据页的角度看-B-树" class="headerlink" title="从数据页的角度看 B+ 树"></a>从数据页的角度看 B+ 树</h2><p>这次，我们<strong>从数据页的角度看 B+ 树</strong>，看看每个节点长啥样。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f7696506a3c1c94621fcbad10341f1a8.png" alt="图片"></p><h3 id="InnoDB-是如何进行存储数据的？"><a href="#InnoDB-是如何进行存储数据的？" class="headerlink" title="InnoDB 是如何进行存储数据的？"></a>InnoDB 是如何进行存储数据的？</h3><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同，我们最常用的就是 InnoDB 存储引擎。</p><p>记录时按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p><p>因此，InnoDB 的数据时按<strong>「数据页」</strong>为单位来读写的，也就是说，当需要读一条数据的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>InnoDB 数据页的默认大小是 16KB</strong>，数据页包括七个部分，结构如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p><p>这 7 个部分的作用如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向的链表</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/557d17e05ce90f18591c2305871af665.png" alt="图片"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><hr><p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>可以得出，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h3 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h3><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><hr><p>看了这么多关于 B+ 树和数据库索引的内容，我们对其也有了基本的了解，那就来再解决一个问题吧，为什么要用 B+ 树，而不是其他的数据结构，也顺便了解一下其他的树相关的知识。</p><h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的。</p><h3 id="怎样的索引的数据结构是好的？"><a href="#怎样的索引的数据结构是好的？" class="headerlink" title="怎样的索引的数据结构是好的？"></a>怎样的索引的数据结构是好的？</h3><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存在磁盘上的，因为这样及时设备断电了，数据也不会丢失。</p><p>这样就带来了一个新的问题，速度太慢，因为磁盘是一个慢的离谱的存储设备。磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><blockquote><p>索引的数据最好是按顺序排列的，这样才能使用<strong>「二分查找法」</strong>高效定位数据。</p></blockquote><h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p><p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p><p>那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？</p><p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/49cb4df3fb7d4accbc75f6970ff1d0ea.gif" alt="请添加图片描述"></p><p>这样这个数组就变成了一个二叉查找树。</p><p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p><p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p><p>那么既然已经解决了所有问题，是不是就可以直接用二叉查找树来组织索引了。</p><p>不行，因为二叉查找树有一个致命的问题，那就是当新插入的数据全都比已有数据大或者小，那这个二叉查找树就变成了一个链表了，也就失去了现有的优势。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/320c5c2653e74f9e9ebfcd8ca9681905.gif" alt="请添加图片描述"></p><h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p><p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树。</p><p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，由于也被面试官提到过类似的问题，后面会单独写一篇博客来记录。</p><p>现在，平衡二叉树退化成为链表的情况被解决了，但是随着数据的插入，树会变得越来越高，查询次数也就越来越多。</p><p>下面我们来看一下二叉树和三叉树在有相同节点个数的情况下高度的差别。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2d26d30c953cd47c6ab637ad0eba2f99.png" alt="图片"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00fb73de7014a87958f1597345e9ef2f.png" alt="图片"></p><p><strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B 树"></a>B 树</h3><p>对于上一节中提到的问题，一个新的数据结构被提出——B 树，它不在限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，特点就是每个节点最多有 M-1个数据，超过这些要求的话，就会分裂节点。</p><p>这么看来，B 树好像又解决了所有已经出现的问题，还有新的吗，当然。毕竟我们的主角是 B+ 树。</p><p>正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？</p><p>在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p><p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p><h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>好了好了，没想到设计一个索引需要的数据结构能遇到这么多困难，现在我们的救世主——B+ 树他终于来了。</p><p>B+ 树就是对 B 树做了一个升级，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mysql-20240322142950.png" alt="用户1260737：B+树"></p><p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了。</p><p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p><p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p><hr><p>至此，所有出现的问题都得到了解决，当然也并不是在所有的数据库中都使用 B+ 树来存储索引。比如在 MongoDB 中存储索引的数据结构就是 B 树。详细原因还是在后面的博客中记录吧，挖个坑先……</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>腾讯第二次面试时提的问题，我回答的不知道，后来美团面试也问了，我答了几种情况，当时就只是背下来了，也不知道为什么，面试官想要更深入地问，我就又不会了。</p><p>那在本文中就详细解释一下这个问题吧。</p><p>在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。</p><p>但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。</p><p>稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低（之前我甚至以为索引失效是索引直接被删除了，脑子坏了）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9e6a9708a6dbbcc65906d1338d2ae70.png" alt=""></p><h2 id="索引长什么样？"><a href="#索引长什么样？" class="headerlink" title="索引长什么样？"></a>索引长什么样？</h2><p>我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。</p><p>索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。</p><p>MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构。在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p><p>MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。</p><p>虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：</p><ul><li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；</li><li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；</li></ul><p>举个栗子：</p><p>这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00730eac527c21a4034f0f9ba0218aba.png" alt="图片"></p><p>如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f287701eba9bf6f32a2d09b013bb451b.png" alt="图片"></p><p>如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（图中叶子节点之间是双向链表）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ef726d7287b854ea4862f7442d8012ec.png" alt="图片"></p><p>InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p><p>如果将 name 字段设置为普通索引，那么这个二级索引长下图这样（图中叶子节点之间是双向链表）</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7dd91be9fe584d94a4d71572ae7214d0.png" alt="图片"></p><p>在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 字段为主键索引</span><br><span class="line">select * from t_user where id=1;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：</p><ul><li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li><li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li></ul><p>上面这个过程叫做<strong>回表</strong>，如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select * from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做<strong>覆盖索引</strong>。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select id from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><h2 id="什么情况会导致索引失效？"><a href="#什么情况会导致索引失效？" class="headerlink" title="什么情况会导致索引失效？"></a>什么情况会导致索引失效？</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><blockquote><p>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</p></blockquote><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b161c1d88f978e42077f8c14e10972a7.png" alt="图片"></p><p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li><li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li></ul><p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p><h3 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h3><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><blockquote><p>为什么对索引使用函数，就无法走索引了呢？</p></blockquote><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><h3 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h3><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><blockquote><p>为什么对索引进行表达式计算，就无法走索引了呢？</p></blockquote><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><h3 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h3><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>MySQL 的数据类型转换规则是什么？是会将字符串转成数字处理，还是将数字转换成字符串处理。</p><p>《MySQL45讲》里有一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p><ul><li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li><li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li></ul><p>在 MySQL 中，执行的结果如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/25316fd06cadff4434f02391ef0b5c55.png" alt="图片"></p><p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>所以，在索引字段为字符串类型，比较字段为数字类型时，MySQL会对索引使用函数实现隐式类型转换，从而导致索引失效。</p><h3 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul><blockquote><p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？</p><p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>为什么联合索引不遵循最左匹配原则就会失效？</p></blockquote><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><h3 id="WHERE-字句中地-OR"><a href="#WHERE-字句中地-OR" class="headerlink" title="WHERE 字句中地 OR"></a>WHERE 字句中地 OR</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><h2 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h1 id="百万-千万级数据库如何优化？"><a href="#百万-千万级数据库如何优化？" class="headerlink" title="百万/千万级数据库如何优化？"></a>百万/千万级数据库如何优化？</h1><p>百万级、千万级数据处理，个人认为核心关键在于数据存储方案设计，存储方案设计的是否合理，直接影响到数据CRUD操作。总体设计可以考虑一下几个方面进行设计考虑：</p><ul><li>数据存储结构设计</li><li>索引设计</li><li>数据主键设计</li><li>查询方案设计</li></ul><p>由于本人也没有这个实力去真正实操百万千万级别地数据库，所以更到还是纸上谈兵，图个乐就行了。</p><h2 id="百万级"><a href="#百万级" class="headerlink" title="百万级"></a>百万级</h2><h3 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><ul><li>表字段 not null，因为 null 值很难查询优化且占用额外的索引空间，推荐默认数字 0。</li><li>数据状态类型的字段，比如 status, type 等等，尽量不要定义负数，如 -1。因为这样可以加上 UNSIGNED，数值容量就会扩大一倍。</li><li>可以的话用 TINYINT、SMALLINT 等代替 INT，尽量不使用 BIGINT，因为占的空间更小。</li><li>字符串类型的字段会比数字类型占的空间更大，所以尽量用整型代替字符串，很多场景是可以通过编码逻辑来实现用整型代替的。</li><li>字符串类型长度不要随意设置，保证满足业务的前提下尽量小。</li><li>用整型来存 IP。</li><li>单表不要有太多字段，建议在20以内。</li><li>为能预见的字段提前预留，因为数据量越大，修改数据结构越耗时。</li></ul><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul><li>索引，空间换时间的优化策略，基本上根据业务需求设计好索引，足以应付百万级的数据量，养成使用 explain 的习惯，关于 explain 也可以访问：explain 让你的 sql 写的更踏实了解更多。</li><li>一个常识：索引并不是越多越好，索引是会降低数据写入性能的。</li><li>索引字段长度尽量短，这样能够节省大量索引空间；</li><li>取消外键，可交由程序来约束，性能更好。</li><li>复合索引的匹配最左列规则，索引的顺序和查询条件保持一致，尽量去除没必要的单列索引。</li><li>值分布较少的字段（不重复的较少）不适合建索引，比如像性别这种只有两三个值的情况字段建立索引意义不大。</li><li>需要排序的字段建议加上索引，因为索引是会排序的，能提高查询性能。</li><li>字符串字段使用前缀索引，不使用全字段索引，可大幅减小索引空间。</li></ul><h3 id="查询语句优化"><a href="#查询语句优化" class="headerlink" title="查询语句优化"></a>查询语句优化</h3><ul><li>尽量使用短查询替代复杂的内联查询。</li><li>查询不使用 select *，尽量查询带索引的字段，避免回表。</li><li>尽量使用 limit 对查询数量进行限制。</li><li>查询字段尽量落在索引上，尤其是复合索引，更需要注意最左前缀匹配。</li><li>拆分大的 delete / insert 操作，一方面会锁表，影响其他业务操作，还有一方面是 MySQL 对 sql 长度也是有限制的。</li><li>不建议使用 MySQL 的函数，计算等，可先由程序处理，从上面提的一些点会发现，能交由程序处理的尽量不要把压力转至数据库上。因为多数的服务器性能瓶颈都在数据库上。</li><li>查询 count，性能：count(1) = count(*) &gt; count(主键) &gt; count(其他字段)。</li><li>查询操作符能用 between 则不用 in，能用 in 则不用 or。</li><li>避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符，因为这些查询无法使用索引。</li><li>sql 尽量简单，少用 join，不建议两个 join 以上。</li></ul><h2 id="千万级"><a href="#千万级" class="headerlink" title="千万级"></a>千万级</h2><h3 id="数据存储结构设计-1"><a href="#数据存储结构设计-1" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><p>到了这个阶段的数据量，数据本身已经有很大的价值了，数据除了满足常规业务需求外，还会有一些数据分析的需求。而这个时候数据可变动性不高，基本上不会考虑修改原有结构，一般会考虑从分区，分表，分库三方面做优化：<br><strong>分区</strong><br>分区是根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分，是一种水平划分。对应用来说是完全透明的，不影响应用的业务逻辑，即不用修改代码。因此能存更多的数据，查询，删除也支持按分区来操作，从而达到优化的目的。如果有考虑分区，可以提前做准备，避免下列一些限制：</p><ul><li>一个表最多只能有1024个分区（6之后支持8192个分区）。但你实际操作的时候，最好不要一次性打开超过100 个分区，因为打开分区也是有时间损耗的。</li><li>如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。</li><li>分区表中无法使用外键约束。</li><li>NULL值会使分区过滤无效，这样会被放入默认的分区里，请千万不要让分区字段出现NULL。</li><li>所有分区必须使用相同的存储引擎。</li></ul><p><strong>分表</strong><br>分表分水平分表和垂直分表。<br>水平分表即拆分成数据结构相同的各个小表，如拆分成 table1, table2…，从而缓解数据库读写压力。<br>垂直分表即将一些字段分出去形成一个新表，各个表数据结构不相同，可以优化高并发下锁表的情况。<br>可想而知，分表的话，程序的逻辑是需要做修改的，所以，一般是在项目初期时，预见到大数据量的情况，才会考虑分表。后期阶段不建议分表，成本很大。<br><strong>分库</strong><br>分库一般是主从模式，一个数据库服务器主节点复制到一个或多个从节点多个数据库，主库负责写操作，从库负责读操作，从而达到主从分离，高可用，数据备份等优化目的。<br>当然，主从模式也会有一些缺陷，主从同步延迟，binlog 文件太大导致的问题等等，这里不细讲（笔者也学不动了）。<br><strong>其他</strong><br>冷热表隔离。对于历史的数据，查询和使用的人数少的情况，可以移入另一个冷数据库里，只提供查询用，来缓解热表数据量大的情况。</p><h3 id="数据库表主键设计"><a href="#数据库表主键设计" class="headerlink" title="数据库表主键设计"></a><strong>数据库表主键设计</strong></h3><p>数据库主键设计，个人推荐带有时间属性的自增长数字ID。（分布式自增长ID生成算法）<br>雪花算法<br>百度分布式ID算法<br>美团分布式ID算法<br>为什么要使用这些算法呢，这个与MySQL数据存储结构有关</p><p><strong>从业务上来说</strong></p><p>   在设计数据库时不需要费尽心思去考虑设置哪个字段为主键。然后是这些字段只是理论上是唯一的，例如使用图书编号为主键，这个图书编号只是理论上来说是唯一的，但实践中可能会出现重复的情况。所以还是设置一个与业务无关的自增ID作为主键，然后增加一个图书编号的唯一性约束。</p><p><strong>从技术上来说</strong></p><ol><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。</li><li>对InnoDB来说主键索引既存储索引值，又在叶子节点中存储行的数据，也就是说数据文件本身就是按照b+树方式存放数据的。</li><li>如果没有定义主键，则会使用非空的UNIQUE键做主键 ; 如果没有非空的UNIQUE键，则系统生成一个6字节的rowid做主键;聚簇索引中，N行形成一个页（一页通常大小为16K)。如果碰到不规则数据插入时，为了保持B+树的平衡，会造成频繁的页分裂和页旋转，插入速度比较慢。所以聚簇索引的主键值应尽量是连续增长的值，而不是随机值(不要用随机字符串或UUID)。</li><li>故对于InnoDB的主键，尽量用整型，而且是递增的整型。这样在存储/查询上都是非常高效的。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又到了我最爱的总结环节了，就能想写什么就写什么了。本来这篇文章要写四大部份的，还有一个sql注入的问题，之前看的文章就讲了一点例子，我以为就只有那么一点呢，今天仔细一查才发现还有那么多没有看过，下次再写吧。</p><p>昨天为什么破防，因为还是没有找到实习，一直都没有公司跟我约面试，我也不知道是那个环节出现问题了，可能还是因为学的东西太少了吧，所以我决定不找实习了，沉淀三个月，把MongoDO、kafka、docker、k8s还有Linux这些东西学一下。</p><p>之前一直觉得边找边学挺好的，找着找着发现面试太少了，不能从面试里面学到什么东西，又要因为准备面试耽误时间。我还是得练练表达能力，老是紧张也不是个事啊。加油吧，祝我自己秋招顺利，也祝我的朋友们考研成功、秋招顺利。还有两个有实习的，那就祝他们实习顺利吧（呜呜呜……，留下了羡慕的泪水）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/mysql/index/index_interview.html">小林coding 图解MySQL 索引篇</a></p><p><a href="https://javabetter.cn/sidebar/sanfene/mysql.html">MySQL八股文</a></p><p><a href="https://bbs.huaweicloud.com/blogs/222183">数据库优化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。&lt;/p&gt;
&lt;p&gt;主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。&lt;/p&gt;
&lt;p&gt;从头开始总结一下最近一段时</summary>
      
    
    
    
    <category term="周报" scheme="http://example.com/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>解锁灵活与高效——Casbin</title>
    <link href="http://example.com/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/"/>
    <id>http://example.com/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/</id>
    <published>2024-05-31T13:52:01.000Z</published>
    <updated>2024-05-31T15:32:35.988Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇博客的标题看起来就很有逼格，不错，就是我们万能的 ChatGPT起的。当然，还是稍微改了一下，它给的实在是太有逼格了，我不太敢用。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240531215653176.png" alt="image-20240531215653176"></p><p>每隔一段时间使用ChatGPT就会给我一种AI已经发展得这么牛逼的感觉，但是每次用它来解决一些实际问题的时候又会让我觉得它是个智障。</p><p>不得不说，ChatGPT在很多方面都已经发展到了可以取代一大部分人的水平了。从它出现之后，我就没有自己动手写过思政方面的任何东西，全是它完成的，属实是有点东西。写点题外话让破防的自己慢慢恢复一下，题外话到此为止。</p><p>本文要记录的是一个访问控制库——Casbin。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Casbin 是一个开源的访问控制框架，用于实现权限管理和访问控制的功能。它提供了一种简单而灵活的访问控制模型，可以用于保护应用程序、服务或其他系统中的资源。Casbin 的设计目标是提供一种通用的访问控制模型，并支持多种编程语言。</p><p>Casbin 的核心概念是访问控制模型和策略。访问控制模型定义了一组规则，用于描述谁可以访问哪些资源以及在什么条件下可以访问。策略是基于模型定义的规则，描述了实际的访问控制规则集合。</p><p>Casbin 支持多种访问控制模型，包括基于角色的访问控制（RBAC）、访问控制列表（ACL）和属性访问控制（ABAC）等。它还提供了灵活的策略管理机制，可以将策略存储在不同的持久化存储中，如文件、数据库或远程服务。</p><p>使用 Casbin，你可以轻松地实现细粒度的权限管理，定义和管理角色、资源和操作之间的访问规则，并在应用程序中进行访问控制的验证。无论是 Web 应用程序、API 服务还是其他类型的系统，Casbin 都可以帮助你实现安全的访问控制机制。</p><h2 id="关键性概念"><a href="#关键性概念" class="headerlink" title="关键性概念"></a>关键性概念</h2><ol><li>模型（Model）：模型定义了访问控制策略的基本结构和规则。它由多个规则组成，每个规则包含多个字段，如”sub”（Subject，主体，表示用户）、”obj”（Object，对象，表示资源）、”act”（Action，动作，表示操作）等。</li><li>策略（Policy）：策略是实际的访问控制规则集合，用于定义谁可以对什么资源执行什么操作。Casbin 支持多种类型的策略，包括基于角色的访问控制（Role-Based Access Control，RBAC）、基于对象的访问控制（Object-Based Access Control，OBAC）等。</li><li>主体（Subject）：主体代表用户或者实体，它通常通过唯一标识符（如用户名、角色等）进行识别。主体在访问控制中被授予特定的权限。</li><li>对象（Object）：对象代表系统中的资源，可以是文件、数据库表、API 端点等。对象具有特定的属性和标识符，用于确定访问控制规则。</li><li>动作（Action）：动作表示主体对对象执行的操作或行为，如读取、写入、删除等。动作定义了主体对资源的权限。</li><li>策略存储（Policy Store）：策略存储用于存储和管理策略规则。Casbin 支持多种策略存储后端，如内存、文件、数据库等。</li></ol><p>通过定义模型、策略和访问请求，Casbin 可以进行访问控制决策，判断是否允许主体执行特定的操作。它提供了灵活的访问控制模型和丰富的策略管理功能，使开发人员能够轻松实现细粒度的权限管理和访问控制策略。</p><h1 id="和JWT有什么关系"><a href="#和JWT有什么关系" class="headerlink" title="和JWT有什么关系"></a>和<code>JWT</code>有什么关系</h1><p>提到鉴权，笔者第一个学习到的是 JWT。之前面试官会问，在你的项目里面是怎么实现鉴权操作的。我会统一回答，使用JWT生成token，然后解析出用户数据，最后在数据库中查找相关信息。其实我也不知道这样的回答是不是正确的，反正那么多场面试到最后都是不了了之，这都不是重点，重点是不要把 casbin 和 JWT 搞混了。</p><p>JWT（JSON Web Token）鉴权和 Casbin 鉴权在权限管理体系中扮演着不同但互补的角色。以下是它们的关系和区别：</p><h3 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h3><p><strong>JWT 鉴权：</strong></p><ul><li><strong>作用：</strong> JWT 主要用于认证（Authentication），即验证用户的身份。它确保请求的发起者是合法用户。</li><li><strong>功能：</strong> JWT 是一种自包含的令牌，通常包含用户ID、用户名、角色等信息，并且通过数字签名进行验证，确保数据的完整性和真实性。</li></ul><p><strong>Casbin 鉴权：</strong></p><ul><li><strong>作用：</strong> Casbin 主要用于授权（Authorization），即确定已认证用户是否有权限执行某个操作。它基于访问控制模型和策略来决定权限。</li><li><strong>功能：</strong> Casbin 通过模型和策略定义权限规则，可以实现复杂的权限管理，如基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>JWT 鉴权：</strong></p><ol><li>用户登录并提供凭据（用户名和密码）。</li><li>服务器验证凭据，如果验证通过，生成 JWT 并返回给用户。</li><li>用户在后续请求中附带 JWT（通常在 HTTP 头部的 Authorization 字段）。</li><li>服务器验证 JWT 的签名和有效期，确定用户身份。</li></ol><p><strong>Casbin 鉴权：</strong></p><ol><li>用户的请求经过 JWT 验证后，服务器获取用户身份信息。</li><li>服务器根据用户身份信息（如用户ID或角色），请求资源和操作。</li><li>使用 Casbin 的 Enforcer 进行权限校验，判断用户是否有权执行该操作。</li><li>根据校验结果，允许或拒绝用户的请求。</li></ol><h3 id="关系和结合"><a href="#关系和结合" class="headerlink" title="关系和结合"></a>关系和结合</h3><ul><li><strong>关系：</strong> JWT 和 Casbin 是互补的。JWT 负责认证，确保请求者的身份；Casbin 负责授权，确保请求者有权限执行特定操作。</li><li><strong>结合：</strong> 在实际应用中，通常会先进行 JWT 验证，确认用户身份后，再使用 Casbin 进行权限检查。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><strong>JWT 验证身份，Casbin 验证权限：</strong> JWT 确认用户是谁，Casbin 确认用户能做什么。</li><li><strong>JWT 是一种令牌，Casbin 是一种访问控制工具：</strong> JWT 是一种令牌机制，用于在无状态的环境中传递用户信息。Casbin 是一个权限管理库，用于根据预定义的策略进行权限判断。</li><li><strong>使用时机不同：</strong> JWT 通常在每次请求的开始进行验证，以确定用户身份。而 Casbin 的权限校验则在身份验证通过后，根据请求的具体资源和操作进行。</li></ul><h3 id="结合实例"><a href="#结合实例" class="headerlink" title="结合实例"></a>结合实例</h3><p>在一个 Web 应用中，结合 JWT 和 Casbin 的典型流程如下：</p><ol><li><p><strong>用户登录：</strong></p><ul><li>用户提交登录信息。</li><li>服务器验证登录信息，生成 JWT 并返回给用户。</li></ul></li><li><p><strong>用户请求资源：</strong></p><ul><li>用户在请求头中附带 JWT 访问资源。</li><li>服务器验证 JWT，确定用户身份。</li></ul></li><li><p><strong>权限校验：</strong></p><ul><li>服务器提取用户身份、请求资源和操作。</li><li>使用 Casbin Enforcer 进行权限检查，判断用户是否有权访问该资源或执行该操作。</li></ul></li><li><p><strong>处理请求：</strong></p><ul><li>如果权限校验通过，处理请求并返回结果。</li><li>如果权限校验不通过，返回 403 Forbidden 响应。</li></ul></li></ol><p>通过这种方式，JWT 和 Casbin 可以无缝结合，实现安全且灵活的认证和授权机制。</p><h1 id="能做什么？又不能做什么？"><a href="#能做什么？又不能做什么？" class="headerlink" title="能做什么？又不能做什么？"></a>能做什么？又不能做什么？</h1><p>我们从上面的回答就能看出，这两个东西其实是结合在一起使用的，在本项目中也是如此。在更加详细地了解其原理之前，我们先来看一下在什么情况下会使用到它。</p><h2 id="Can-Do"><a href="#Can-Do" class="headerlink" title="Can Do"></a>Can Do</h2><ol><li>以典型的 {主体、对象、动作} 形式或您定义的自定义形式形成策略。支持允许和拒绝授权。</li><li>具有访问控制模型 <code>model</code> 和策略 <code>policy</code> 两个核心概念。</li><li>支持 RBAC 中的多层角色继承，不止主体可以有角色，资源也可以具有角色。</li><li>支持内置超级用户，如 <code>root</code> 或 <code>administrator</code>。 超级用户可以在没有明确权限的情况下做任何事情。</li><li>提供多个内置操作符，支持规则匹配。例如，<code>keyMatch</code> 可将资源键 <code>/foo/bar</code> 映射到模式 <code>/foo*</code>。</li></ol><h2 id="Can‘t-do"><a href="#Can‘t-do" class="headerlink" title="Can‘t do"></a>Can‘t do</h2><ol><li>验证（又称用户登录时验证用户名和密码）：Casbin 仅负责权限管理，不负责用户身份验证。身份验证需要通过其他机制（如 JWT、OAuth 等）实现。</li><li>管理用户列表或角色列表：Casbin 不提供用户管理功能，如用户注册、密码管理等。这些功能通常由用户管理系统（如 LDAP、Active Directory）或自定义用户管理模块实现。</li><li>数据加密和解密：Casbin 不处理数据的加密和解密任务。这需要通过其他安全工具和库来实现。</li><li>网络安全：Casbin 不直接处理网络安全问题，如防火墙、防御 DDoS 攻击等。这需要通过网络安全设备和配置来实现。</li><li>审计和日志管理：虽然 Casbin 可以配合其他工具进行权限使用的审计和日志记录，但它自身不具备全面的审计和日志管理功能。</li></ol><p>项目管理用户、角色或密码列表更加方便。用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。 而是存储 RBAC 方案中用户和角色之间的映射关系。</p><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><p>讲了那么对概念，想必对casbin也有了一个大概的了解了。拿就来看一下要怎么使用吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> ( </span><br><span class="line"><span class="string">&quot;github.com/casbin/casbin/v2&quot;</span> </span><br><span class="line"><span class="string">&quot;fmt&quot;</span> </span><br><span class="line">) </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">sub := <span class="string">&quot;lili&quot;</span> </span><br><span class="line">obj := <span class="string">&quot;/posts&quot;</span> </span><br><span class="line">act := <span class="string">&quot;GET&quot;</span> </span><br><span class="line"> </span><br><span class="line"> e,err := casbin.NewEnforcer(<span class="string">&quot;resources/model.conf&quot;</span>,<span class="string">&quot;resources/policy.csv&quot;</span>) </span><br><span class="line"> checkError(err) </span><br><span class="line">ok,err := e.Enforce(sub,obj,act) </span><br><span class="line"> checkError(err) </span><br><span class="line"> <span class="keyword">if</span> ok &#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;通过！&quot;</span>) </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;不通过！&quot;</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 统一错误检查 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span>  &#123; </span><br><span class="line"> <span class="keyword">if</span> err!=<span class="literal">nil</span> &#123; </span><br><span class="line">  <span class="built_in">println</span>(err.Error()) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里面涉及到两个配置文件，分别是 model.conf 和 policy.csv 文件。</p><p>内容如下：</p><p><strong>model.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[request_definition] </span><br><span class="line">r = sub, obj, act </span><br><span class="line"> </span><br><span class="line">[policy_definition] </span><br><span class="line">p = sub, obj, act </span><br><span class="line"> </span><br><span class="line">[role_definition] </span><br><span class="line">g = _, _ </span><br><span class="line"> </span><br><span class="line">[policy_effect] </span><br><span class="line">e = some(where (p.eft == allow)) </span><br><span class="line"> </span><br><span class="line">[matchers] </span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act </span><br></pre></td></tr></table></figure><p><strong>policy.csv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p, member, /posts, GET </span><br><span class="line">p, member, /posts/:id, GET </span><br><span class="line"> </span><br><span class="line">p, admin, /posts, POST </span><br><span class="line">p, admin, /posts/:id, PUT </span><br><span class="line">p, admin, /posts/:id, DELETE </span><br><span class="line"> </span><br><span class="line">g, admin, member </span><br><span class="line">g, super, admin </span><br><span class="line">g, lili, member </span><br></pre></td></tr></table></figure><p>这两个配置文件你现在就暂时先理解为 model.conf 定义了匹配规则，policy.csv 定义了权限组等权限。</p><p>直接运行起来，你会看到控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过！ </span><br></pre></td></tr></table></figure><p>假如此时我们把 act 改成 POST 就不能通过了。</p><hr><p>学习过大概怎么使用后，就要更加深入地学习了。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>casbin 支持多种模型，适用于多种业务场景</p><ol><li><a href="https://en.wikipedia.org/wiki/Access_control_list"><strong>ACL (Access Control List, 访问控制列表)</strong></a></li><li><strong>具有 <a href="https://en.wikipedia.org/wiki/Superuser">超级用户</a> 的 ACL</strong></li><li><strong>ACL without users</strong>: 这对于没有身份验证或用户登录的系统特别有用。</li><li><strong>ACL without resources</strong>: 在某些场景中，目标是一种类型的资源，而不是单个资源。可以使用 “写文章” 和 “读日志” 等权限。这不会控制对特定文章或日志的访问。</li><li><strong><a href="https://en.wikipedia.org/wiki/Role-based_access_control">RBAC (基于角色的访问控制)</a></strong></li><li><strong>RBAC with resource roles</strong>: 用户和资源可以同时拥有角色（或组）。</li><li><strong>RBAC with domains/tenants</strong>: 用户可以为不同的域 / 租户拥有不同的角色集。</li><li><strong><a href="https://en.wikipedia.org/wiki/Attribute-Based_Access_Control">ABAC (Attribute-Based Access Control)</a></strong>: 像 “resource.Owner” 这样的语法糖可以用来获取资源的属性。</li><li><strong><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a></strong>: 支持 “/res/*”、“/res/：id” 等路径，以及 “GET”、“POST”、“PUT”、“DELETE” 等 HTTP 方法。</li><li><strong>Deny-override</strong>: 在允许拒绝覆盖的情况下，允许和拒绝授权都受支持。</li><li><strong>Priority</strong>: 策略规则可以按优先级排列，类似于防火墙规则。</li></ol><p>一般会通过使用场景确定模型，然后在官网实例中查询模型，直接使用。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>casbin 支持通过加载存储的模型、策略、策略子集实现动态调整。</p><h3 id="模型的存储"><a href="#模型的存储" class="headerlink" title="模型的存储"></a>模型的存储</h3><p>与策略不同，模型只能加载，不能保存。我们认为，模型不是动态组件，不应在运行时修改，因此我们没有实现将模型保存到存储中的应用程序接口。</p><p>不过，有一个好消息。我们提供了三种等效的方法来静态或动态加载模型：</p><ul><li>从 <code>.conf</code> 文件中加载 model</li><li>从代码加载 model</li><li>从字符串加载 model</li></ul><h3 id="策略地存储"><a href="#策略地存储" class="headerlink" title="策略地存储"></a>策略地存储</h3><p>在 casbin 中，策略存储作为 <strong>适配器</strong> 来实现</p><ul><li>从 <code>.csv</code> 文件加载</li><li>从后端存储加载实现</li></ul><h3 id="策略子集加载"><a href="#策略子集加载" class="headerlink" title="策略子集加载"></a>策略子集加载</h3><p>一些 adapter 支持过滤策略管理。 这意味着 Casbin 加载的策略是根据给定过滤器存储在数据库中的策略的子集。这样就能在大型多租户环境中高效执行策略，因为在这种环境中，解析整个策略会成为性能瓶颈。</p><p>为了防止意外数据丢失，当策略已经加载， SavePolicy 方法会被禁用。</p><p>要使用支持的 adapter 处理过滤后的策略，只需调用 <code>LoadFilteredPolicy</code> 方法。 过滤器参数的有效格式取决于所用的适配器。 为了防止意外数据丢失，当策略已经加载， <code>SavePolicy</code> 方法会被禁用。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>Casbin 使用配置文件来定义访问控制模型。</p><p>例如使用文件记录模型和策略存储文件，作为两个配置文件：<code>model.conf</code> 和 <code>policy.csv</code>。<code>model.conf</code> 保存访问模型，而 <code>policy.csv</code> 保存具体的用户权限配置。<code>Casbin</code> 的使用非常简单。我们只需创建一个主要结构：<code>enforcer</code>。当构造这个结构的时候，<code>model.conf</code> 和 <code>policy.csv</code> 将会被加载。</p><p>换句话说，<strong>要创建一个 Casbin 执行器，您需要提供一个模型和一个适配器。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, <span class="string">&quot;path/to/policy.csv&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 Casbin 中，执行器（Enforcer）是负责执行访问控制策略的核心组件。它提供了一系列方法，用于判断主体是否被授予对特定资源执行特定操作的权限。</p><p>执行器的主要功能包括：</p><ol><li>加载策略：执行器可以从不同的策略存储（如文件、数据库）中加载访问控制策略。它可以读取和解析策略规则，并将其转换为内部模型进行处理。</li><li>决策判断：执行器可以根据加载的策略和传入的访问请求，进行访问控制决策。它会根据模型中定义的规则和策略，判断主体是否有权限执行特定的操作。</li><li>策略管理：执行器提供了管理策略的方法，可以动态地添加、修改或删除策略规则。这使得开发人员可以根据需要对访问控制策略进行灵活的调整和管理。</li><li>角色管理：执行器支持角色（Role）的管理，包括角色的添加、删除和关联。角色可以用于实现基于角色的访问控制（RBAC）模型。</li></ol><p>通过执行器，开发人员可以轻松地集成 Casbin 的访问控制功能到他们的应用程序中。执行器提供了简单而强大的 API，使开发人员能够方便地进行访问控制决策和策略管理。</p><h3 id="几种执行器"><a href="#几种执行器" class="headerlink" title="几种执行器"></a>几种执行器</h3><ul><li>通用执行器：最基础的执行器，Enforcer 是用户与 Casbin 策略和模型交互的基本结构。</li><li>带缓存的执行器：<code>CachedEnforcer</code> 基于 <code>Enforcer</code>，支持使用 <code>map</code> 将请求的判断结果（是否具有能力）缓存在内存中。它能在指定的过期时间内清除缓存。此外，它还通过读写锁保证线程安全。您可以使用 <code>EnableCache</code> 启用缓存评估结果（默认为启用）。<code>CachedEnforcer</code> 的其他 API 方法与 <code>Enforcer</code> 相同。</li><li>分布式执行器：<code>DistributedEnforcer</code> 支持分布式集群中的多个实例。它为调度器封装了 <code>SyncedEnforcer</code>。官方的分布式执行器无法指定适配器，使用内置的适配器，而且通过 HTTP 接口实现一致性。</li><li>同步执行器：<code>SyncedEnforcer</code> 同步执行器提供并发功能，是线程安全的。</li><li>带缓存的同步执行器：<code>SyncedCachedEnforcer</code> ，同步执行器和带缓存的执行器结合</li></ul><p>如何挑选：</p><ul><li>如果是简单环境，使用通用执行器：<code>casbin.NewEnforcer()</code></li><li>如果需要提高判断结果的并发，则使用带缓存的执行器：<code>casbin.NewCachedEnforcer()</code></li><li>如果是分布式的场景，例如多个服务器集群中，每个集群都需要有 casbin 实例，而且需要有独立的后端存储，则使用分布式执行器：<code>casbin.NewDistributedEnforcer()</code></li><li>如果会频繁变动策略，而且是并发场景，则使用同步执行器：<code>casbin.NewSyncedEnforcer()</code></li><li>如果既要频繁变动策略，也要求判断结果的高并发，则使用带缓存的同步执行器：<code>casbin.NewSyncedCachedEnforcer()</code></li></ul><p>在当下云原生的场景下，部署在 <code>k8s</code> 上，并且后端使用同一个存储，多个实例，推荐使用同步执行器或者带缓存的同步执行器。</p><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>在 Casbin 中，策略存储作为 adapter (Casbin 的中间件) 实现。 Casbin 用户可以使用 adapter 从存储中加载策略规则 (<code>LoadPolicy()</code>) 或者将策略规则保存到其中 (<code>SavePolicy()</code>)。</p><blockquote><ol><li>如果使用显式或隐式 adapter 调用 <code>casbin.NewEnforcer()</code>，策略将自动加载。</li><li>可以调用 <code>e.LoadPolicy()</code> 来从存储中重新加载策略规则。</li><li>如果 adapter 不支持 <code>Auto-Save</code> 特性，则在添加或删除策略时不能将策略规则自动保存回存储器。 你必须手动调用 <code>SavePolicy()</code> 来保存所有的策略规则</li></ol></blockquote><p>当然，以下是使用 Go 语言结合 Casbin 和多种适配器的代码示例：</p><h3 id="使用文件适配器"><a href="#使用文件适配器" class="headerlink" title="使用文件适配器"></a>使用文件适配器</h3><p>文件适配器是 Casbin 的默认适配器，使用本地文件系统存储策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载模型文件和策略文件</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, <span class="string">&quot;path/to/policy.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-MySQL-适配器"><a href="#使用-MySQL-适配器" class="headerlink" title="使用 MySQL 适配器"></a>使用 MySQL 适配器</h3><p>使用 MySQL 数据库存储策略，需要安装 <code>github.com/casbin/mysql-adapter/v2</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/mysql-adapter/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MySQL 适配器</span></span><br><span class="line">    a, err := mysqladapter.NewAdapter(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:1234@tcp(127.0.0.1:3306)/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create MySQL adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-PostgreSQL-适配器"><a href="#使用-PostgreSQL-适配器" class="headerlink" title="使用 PostgreSQL 适配器"></a>使用 PostgreSQL 适配器</h3><p>使用 PostgreSQL 数据库存储策略，需要安装 <code>github.com/casbin/pg-adapter</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/pg-adapter&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 PostgreSQL 适配器</span></span><br><span class="line">    a, err := pgadapter.NewAdapter(<span class="string">&quot;postgresql://user:password@localhost:5432/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create PostgreSQL adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-MongoDB-适配器"><a href="#使用-MongoDB-适配器" class="headerlink" title="使用 MongoDB 适配器"></a>使用 MongoDB 适配器</h3><p>使用 MongoDB 数据库存储策略，需要安装 <code>github.com/casbin/mongodb-adapter/v3</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/mongodb-adapter/v3&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MongoDB 适配器</span></span><br><span class="line">    a, err := mongodbadapter.NewAdapter(<span class="string">&quot;mongodb://localhost:27017/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create MongoDB adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Redis-适配器"><a href="#使用-Redis-适配器" class="headerlink" title="使用 Redis 适配器"></a>使用 Redis 适配器</h3><p>使用 Redis 数据库存储策略，需要安装 <code>github.com/casbin/redis-adapter/v2</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/redis-adapter/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Redis 适配器</span></span><br><span class="line">    a, err := redisadapter.NewAdapter(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create Redis adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义适配器"><a href="#自定义适配器" class="headerlink" title="自定义适配器"></a>自定义适配器</h3><p>如果现有适配器不能满足需求，可以实现自定义适配器。自定义适配器需要实现 <code>casbin.Adapter</code> 接口的以下方法：</p><ul><li><code>LoadPolicy(model model.Model) error</code></li><li><code>SavePolicy(model model.Model) error</code></li><li><code>AddPolicy(sec string, ptype string, rule []string) error</code></li><li><code>RemovePolicy(sec string, ptype string, rule []string) error</code></li><li><code>RemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) error</code></li></ul><p>这是一个自定义适配器的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2/model&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2/persist&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义存储结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> LoadPolicy(model model.Model) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 加载策略到模型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> SavePolicy(model model.Model) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 保存策略到存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> AddPolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, rule []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 添加策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> RemovePolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, rule []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 移除策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> RemoveFilteredPolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, fieldIndex <span class="type">int</span>, fieldValues ...<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 移除符合过滤条件的策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建自定义适配器</span></span><br><span class="line">    a := &amp;CustomAdapter&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这些示例，可以看到如何使用 Casbin 和不同的适配器实现权限管理，具体选择哪种适配器取决于应用的具体需求和环境。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>casbin 支持使用分布式消息系统（如 etcd）来保持多个 Casbin 执行器实例之间的一致性。这样，用户就可以同时使用多个 Casbin 执行器来处理大量权限检查请求。</p><p>与策略存储适配器类似，casbin 在主库中不包含监视器代码。任何对新消息系统的支持都应该作为监视程序来实现。</p><p>关于监视器的完整列表建议去<a href="https://casbin.org/zh/docs/watchers/">casbin官网</a>查看。</p><p>推荐使用 Redis ，内部是通过 redis 的 channel 实现多个实例之间通讯。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>调度程序提供了一种同步策略增量变化的方法。它们应基于 Raft 等一致性算法，以确保所有执行者实例的一致性。通过调度器，用户可以轻松建立分布式集群。</p><p>调度器的方法分为两部分。 第一部分是与 Casbin 结合的方法。这些方法应在 Casbin 内部调用。用户可以使用 Casbin 本身提供的更完整的 API。</p><p>另一部分是调度器自身定义的方法，包括调度器初始化方法和不同算法提供的不同功能，如动态成员资格和配置更改。</p><blockquote><p>我们希望调度器只在运行时确保 Casbin 执行器的一致性。因此，如果策略在初始化时不一致，调度程序将无法正常工作。用户需要在使用调度程序前确保所有实例的状态一致。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dispatcher-architecture.svg" alt="overall architecture"></p><p>调度器的使用场景更合适分布式的环境下。</p><h2 id="角色管理器"><a href="#角色管理器" class="headerlink" title="角色管理器"></a>角色管理器</h2><p>角色管理器用于管理 Casbin 中的 RBAC 角色层次结构（用户角色映射）。 角色管理器可从 Casbin 策略规则或外部来源（如 LDAP、Okta、Auth0、Azure AD 等）检索角色数据。我们支持不同的角色管理器实现。 为了保持轻量级，我们在主库中不包含角色管理器代码（默认角色管理器除外）。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面一共介绍了casbin的五个组件，那么它们之间有什么关系呢？</p><p>在 Casbin 中，执行器（Enforcer）、适配器（Adapter）、监视器（Watcher）、调度器（Dispatcher）和角色管理器（RoleManager）是五个核心组件，它们各自负责不同的功能，但在 Casbin 的权限管理系统中有着密切的联系。</p><ul><li><strong>适配器与执行器：</strong> 适配器为执行器提供加载策略的数据源，执行器在权限判断时依赖适配器加载的策略数据。</li><li><strong>监视器与适配器：</strong> 监视器与适配器协作，适配器加载策略数据后，监视器可以持续监控数据的变化。</li><li><strong>调度器与执行器：</strong> 调度器负责管理执行器的并发访问，确保执行器在多线程环境下的安全运行。</li><li><strong>角色管理器与执行器：</strong> 角色管理器与执行器配合，执行器在权限判断时可能涉及角色信息，需要通过角色管理器查询和验证角色。</li></ul><p>总的来说，执行器是 Casbin 权限判断的核心，适配器用于加载和保存策略数据，监视器用于监控数据的变化，调度器用于管理并发访问，角色管理器用于管理角色信息。这些组件之间紧密联系并协作，共同构建了 Casbin 的权限管理系统。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>嘿，这才是真正的总结，我的博客文章怎么可能有一个那么正经的总结呢。</p><p>上面已经基本把casbin中会使用到的东西讲的很清楚了，在本项目中也是结合着 JWT 来实现的权限控制。基本流程为，先使用 JWT 检查是否正常登录，若正常登录再检查该用户的操作权限，两者相辅相成。</p><p>ok，那么又增加了一个在面试时能讲的内容，但是孩子现在根本就没有面试的机会，该说自己是运气不好呢，还是脑子里根本就没有那么多东西，所以才会一次又一次地被牵着鼻子走。再沉淀沉淀吧，先不急着找实习（其实是找不到）。</p><p>现在觉得要学的东西好像还有很多，一直赶着找实习会让我根本就没法集中去学习，老是速成也会一直忘，还是放慢脚步吧。</p><p>其实在学完 casbin 鉴权之后，这个开源项目里边比较新的东西就差不多结束了，还能继续学的就是一些数据库的操作了，不过我觉得这个大佬好像不是很想使用其他数据库，也基本上都没有什么能学的。不过 MongoDB 还是要学一下的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://casbin.org/zh/docs/category/the-basics">Casbin官方文档</a></p><p><a href="https://www.xiaoyeshiyu.com/post/bda0.html">大佬的博客</a></p><p><a href="https://www.51cto.com/article/687493.html">鉴权的简单使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天这篇博客的标题看起来就很有逼格，不错，就是我们万能的 ChatGPT起的。当然，还是稍微改了一下，它给的实在是太有逼格了，我不太敢用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zxh3032/save-ima</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>管理定时任务--cron</title>
    <link href="http://example.com/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/"/>
    <id>http://example.com/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/</id>
    <published>2024-05-27T09:03:17.000Z</published>
    <updated>2024-05-31T13:32:23.234Z</updated>
    
    <content type="html"><![CDATA[<p><code>corn</code> 是一个用于管理定时任务的库，用 Go 实现 Linux 中 <code>crontab</code> 这个命令的效果。除了 <code>cron</code> 以外，Go语言中还有另一个比较小巧、灵活的定时任务库，可以执行定时的、周期性的任务。但是它功能相对简单些，并且已经不维护了。如果有定时任务需求，还是建议使用<code>cron</code>。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/robfig/cron/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">&quot;@every 1s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;tick every 1 second&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用非常简单，创建<code>cron</code>对象，这个对象用于管理定时任务。</p><p>调用<code>cron</code>对象的<code>AddFunc()</code>方法向管理器中添加定时任务。<code>AddFunc()</code>接受两个参数，参数 1 以字符串形式指定触发时间规则，参数 2 是一个无参的函数，每次触发时调用。<code>@every 1s</code>表示每秒触发一次，<code>@every</code>后加一个时间间隔，表示每隔多长时间触发一次。例如<code>@every 1h</code>表示每小时触发一次，<code>@every 1m2s</code>表示每隔 1 分 2 秒触发一次。<code>time.ParseDuration()</code>支持的格式都可以用在这里。</p><p>调用<code>c.Start()</code>启动定时循环。</p><p>注意一点，因为<code>c.Start()</code>启动一个新的 goroutine 做循环检测，我们在代码最后加了一行<code>time.Sleep(time.Second * 5)</code>防止主 goroutine 退出。</p><p>运行效果，每隔 1s 输出一行字符串：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br></pre></td></tr></table></figure><h1 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h1><p>与Linux 中<code>crontab</code>命令相似，<code>cron</code>库支持用 <strong>5</strong> 个空格分隔的域来表示时间。这 5 个域含义依次为：</p><ul><li><code>Minutes</code>：分钟，取值范围<code>[0-59]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Hours</code>：小时，取值范围<code>[0-23]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Day of month</code>：每月的第几天，取值范围<code>[1-31]</code>，支持特殊字符<code>* / , - ?</code>；</li><li><code>Month</code>：月，取值范围<code>[1-12]</code>或者使用月份名字缩写<code>[JAN-DEC]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Day of week</code>：周历，取值范围<code>[0-6]</code>或名字缩写<code>[JUN-SAT]</code>，支持特殊字符<code>* / , - ?</code>。</li></ul><p>注意，月份和周历名称都是不区分大小写的。</p><p>特殊字符含义如下：</p><ul><li><code>*</code>：使用<code>*</code>的域可以匹配任何值，例如将月份域（第 4 个）设置为<code>*</code>，表示每个月；</li><li><code>/</code>：用来指定范围的<strong>步长</strong>，例如将小时域（第 2 个）设置为<code>3-59/15</code>表示第 3 分钟触发，以后每隔 15 分钟触发一次，因此第 2 次触发为第 18 分钟，第 3 次为 33 分钟。。。直到分钟大于 59；</li><li><code>,</code>：用来列举一些离散的值和多个范围，例如将周历的域（第 5 个）设置为<code>MON,WED,FRI</code>表示周一、三和五；</li><li><code>-</code>：用来表示范围，例如将小时的域（第 1 个）设置为<code>9-17</code>表示上午 9 点到下午 17 点（包括 9 和 17）；</li><li><code>?</code>：只能用在月历和周历的域中，用来代替<code>*</code>，表示每月/周的任意一天。</li></ul><p>了解规则之后，我们可以定义任意时间：</p><ul><li><code>30 * * * *</code>：分钟域为 30，其他域都是<code>*</code>表示任意。每小时的 30 分触发；</li><li><code>30 3-6,20-23 * * *</code>：分钟域为 30，小时域的<code>3-6,20-23</code>表示 3 点到 6 点和 20 点到 23 点。3,4,5,6,20,21,22,23 时的 30 分触发；</li><li><code>0 0 1 1 *</code>：1（第 4 个） 月 1（第 3 个） 号的 0（第 2 个） 时 0（第 1 个） 分触发。</li></ul><h2 id="预定义时间规则"><a href="#预定义时间规则" class="headerlink" title="预定义时间规则"></a>预定义时间规则</h2><p>为了方便使用，<code>cron</code>预定义了一些时间规则：</p><ul><li><code>@yearly</code>：也可以写作<code>@annually</code>，表示每年第一天的 0 点。等价于<code>0 0 1 1 *</code>；</li><li><code>@monthly</code>：表示每月第一天的 0 点。等价于<code>0 0 1 * *</code>；</li><li><code>@weekly</code>：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于<code>0 0 * * 0</code>；</li><li><code>@daily</code>：也可以写作<code>@midnight</code>，表示每天 0 点。等价于<code>0 0 * * *</code>；</li><li><code>@hourly</code>：表示每小时的开始。等价于<code>0 * * * *</code>。</li></ul><h2 id="固定时间间隔"><a href="#固定时间间隔" class="headerlink" title="固定时间间隔"></a>固定时间间隔</h2><p><code>cron</code>支持固定时间间隔，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@every &lt;duration&gt;</span><br></pre></td></tr></table></figure><p>含义为每隔<code>duration</code>触发一次。<code>&lt;duration&gt;</code>会调用<code>time.ParseDuration()</code>函数解析，所以<code>ParseDuration</code>支持的格式都可以。</p><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>默认情况下，所有时间都是基于当前时区的。当然我们也可以指定时区，有 2 两种方式：</p><ul><li>在时间字符串前面添加一个<code>CRON_TZ=</code> + 具体时区，东京时区为<code>Asia/Tokyo</code>，纽约时区为<code>America/New_York</code>；</li><li>创建<code>cron</code>对象时增加一个时区选项<code>cron.WithLocation(location)</code>，<code>location</code>为<code>time.LoadLocation(zone)</code>加载的时区对象，<code>zone</code>为具体的时区格式。或者调用已创建好的<code>cron</code>对象的<code>SetLocation()</code>方法设置时区。</li></ul><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nyc, _ := time.LoadLocation(<span class="string">&quot;America/New_York&quot;</span>)</span><br><span class="line">  c := cron.New(cron.WithLocation(nyc))</span><br><span class="line">  c.AddFunc(<span class="string">&quot;0 6 * * ?&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Every 6 o&#x27;clock at New York&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">&quot;CRON_TZ=Asia/Tokyo 0 6 * * ?&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Every 6 o&#x27;clock at Tokyo&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Job接口"><a href="#Job接口" class="headerlink" title="Job接口"></a><code>Job</code>接口</h1><p>除了直接将无参函数作为回调外，<code>cron</code>还支持<code>Job</code>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">interface</span> &#123;</span><br><span class="line">  Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个实现接口<code>Job</code>的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreetingJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GreetingJob)</span></span> Run() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello &quot;</span>, g.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>cron</code>对象的<code>AddJob()</code>方法将<code>GreetingJob</code>对象添加到定时管理器中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">&quot;@every 1s&quot;</span>, GreetingJob&#123;<span class="string">&quot;dj&quot;</span>&#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br></pre></td></tr></table></figure><hr><p>实际上<code>AddFunc()</code>方法内部也调用了<code>AddJob()</code>方法。首先，<code>cron</code>基于<code>func()</code>类型定义一个新的类型<code>FuncJob</code>并实现<code>Job</code>接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> FuncJob <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncJob)</span></span> Run() &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AddFunc()</code>方法中，将传入的回调转为<code>FuncJob</code>类型，然后调用<code>AddJob()</code>方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cron)</span></span> AddFunc(spec <span class="type">string</span>, cmd <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) (EntryID, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c.AddJob(spec, FuncJob(cmd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><code>cron</code>会创建一个新的 goroutine 来执行触发回调。如果这些回调需要并发访问一些资源、数据，我们需要显式地做同步。</p><h1 id="自定义时间格式"><a href="#自定义时间格式" class="headerlink" title="自定义时间格式"></a>自定义时间格式</h1><p><code>cron</code>支持灵活的时间格式，如果默认的格式不能满足要求，我们可以自己定义时间格式。时间规则字符串需要<code>cron.Parser</code>对象来解析。</p><p>我们先来看看默认的解析器是如何工作的。</p><p>首先定义各个域：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Second         ParseOption = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  SecondOptional                        </span><br><span class="line">  Minute                                </span><br><span class="line">  Hour                                  </span><br><span class="line">  Dom                                   </span><br><span class="line">  Month                                 </span><br><span class="line">  Dow                                   </span><br><span class="line">  DowOptional                           </span><br><span class="line">  Descriptor                            </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了<code>Minute/Hour/Dom(Day of month)/Month/Dow(Day of week)</code>外，还可以支持<code>Second</code>。相对顺序都是固定的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">var</span> places = []ParseOption&#123;</span><br><span class="line">  Second,</span><br><span class="line">  Minute,</span><br><span class="line">  Hour,</span><br><span class="line">  Dom,</span><br><span class="line">  Month,</span><br><span class="line">  Dow,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaults = []<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的时间格式使用 5 个域。</p><p>我们可以调用<code>cron.NewParser()</code>创建自己的<code>Parser</code>对象，以位格式传入使用哪些域，例如下面的<code>Parser</code>使用 6 个域，支持<code>Second</code>（秒）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser := cron.NewParser(</span><br><span class="line">  cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用<code>cron.WithParser(parser)</code>创建一个选项传入构造函数<code>cron.New()</code>，使用时就可以指定秒了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := cron.New(cron.WithParser(parser))</span><br><span class="line">c.AddFunc(<span class="string">&quot;1 * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;every 1 second&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br></pre></td></tr></table></figure><p>这里时间格式必须使用 6 个域，顺序与上面的<code>const</code>定义一致。</p><p>因为上面的时间格式太常见了，<code>cron</code>定义了一个便捷的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithSeconds</span><span class="params">()</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> WithParser(NewParser(</span><br><span class="line">    Second | Minute | Hour | Dom | Month | Dow | Descriptor,</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>Descriptor</code>表示对<code>@every/@hour</code>等的支持。有了<code>WithSeconds()</code>，我们不用手动创建<code>Parser</code>对象了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := cron.New(cron.WithSeconds())</span><br></pre></td></tr></table></figure><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p><code>cron</code>对象创建使用了选项模式，我们前面已经介绍了 3 个选项：</p><ul><li><code>WithLocation</code>：指定时区；</li><li><code>WithParser</code>：使用自定义的解析器；</li><li><code>WithSeconds</code>：让时间格式支持秒，实际上内部调用了<code>WithParser</code>。</li></ul><p><code>cron</code>还提供了另外两种选项：</p><ul><li><code>WithLogger</code>：自定义<code>Logger</code>；</li><li><code>WithChain</code>：Job 包装器。</li></ul><h2 id="WithLogger"><a href="#WithLogger" class="headerlink" title="WithLogger"></a><code>WithLogger</code></h2><p><code>WithLogger</code>可以设置<code>cron</code>内部使用我们自定义的<code>Logger</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New(</span><br><span class="line">    cron.WithLogger(</span><br><span class="line">      cron.VerbosePrintfLogger(log.New(os.Stdout, <span class="string">&quot;cron: &quot;</span>, log.LstdFlags))))</span><br><span class="line">  c.AddFunc(<span class="string">&quot;@every 1s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面调用<code>cron.VerbosPrintfLogger()</code>包装<code>log.Logger</code>，这个<code>logger</code>会详细记录<code>cron</code>内部的调度过程。</p><p>默认的<code>Logger</code>是什么样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultLogger Logger = PrintfLogger(log.New(os.Stdout, <span class="string">&quot;cron: &quot;</span>, log.LstdFlags))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#125;) Logger &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerbosePrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#125;) Logger &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printfLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger  <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) &#125;</span><br><span class="line">  logInfo <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithChain"><a href="#WithChain" class="headerlink" title="WithChain"></a><code>WithChain</code></h2><p>Job 包装器可以在执行实际的<code>Job</code>前后添加一些逻辑：</p><ul><li>捕获<code>panic</code>；</li><li>如果<code>Job</code>上次运行还未结束，推迟本次执行;</li><li>如果<code>Job</code>上次运行还未介绍，跳过本次执行；</li><li>记录每个<code>Job</code>的执行情况。</li></ul><p>我们可以将<code>Chain</code>类比为 Web 处理器的中间件。实际上就是在<code>Job</code>的执行逻辑外在封装一层逻辑。我们的封装逻辑需要写成一个函数，传入一个<code>Job</code>类型，返回封装后的<code>Job</code>。<code>cron</code>为这种函数定义了一个类型<code>JobWrapper</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chain.go</span></span><br><span class="line"><span class="keyword">type</span> JobWrapper <span class="function"><span class="keyword">func</span><span class="params">(Job)</span></span> Job</span><br></pre></td></tr></table></figure><p>然后使用一个<code>Chain</code>对象将这些<code>JobWrapper</code>组合到一起：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chain <span class="keyword">struct</span> &#123;</span><br><span class="line">  wrappers []JobWrapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChain</span><span class="params">(c ...JobWrapper)</span></span> Chain &#123;</span><br><span class="line">  <span class="keyword">return</span> Chain&#123;c&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Chain</code>对象的<code>Then(job)</code>方法应用这些<code>JobWrapper</code>，返回最终的<code>Job</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chain)</span></span> Then(j Job) Job &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> c.wrappers &#123;</span><br><span class="line">    j = c.wrappers[<span class="built_in">len</span>(c.wrappers)-i<span class="number">-1</span>](j)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意应用<code>JobWrapper</code>的顺序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本项目中其实并没有用到这么多与之相关的东西，当然还有更加详细的内容本文并没有记录。</p><p>本文就不放参考资料了，因为整篇博客都是照抄的别人的，原因是我破防了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;corn&lt;/code&gt; 是一个用于管理定时任务的库，用 Go 实现 Linux 中 &lt;code&gt;crontab&lt;/code&gt; 这个命令的效果。除了 &lt;code&gt;cron&lt;/code&gt; 以外，Go语言中还有另一个比较小巧、灵活的定时任务库，可以执行定时的、周期性的</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>高性能日志库——Zap</title>
    <link href="http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/"/>
    <id>http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/</id>
    <published>2024-05-25T09:39:37.000Z</published>
    <updated>2024-05-25T12:23:08.130Z</updated>
    
    <content type="html"><![CDATA[<p>今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>在任何一个投入使用的项目中，都需要一个好的日志系统（关于什么是<a href="https://zxh3032.github.io/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/">日志</a>，可以看之前的总结，更建议看总结中的参考）。在 Go 语言中，我们有很多能够投入使用的日志库，比如<code>log</code>、<code>zap</code>等。对于一个好的日志记录器来说，我们需要它能够实现一下功能：</p><ul><li>能够将事件记录到文件中，而不是应用程序控制台。</li><li>日志切割-能够根据文件大小、时间或间隔等来切割日志文件。</li><li>支持不同的日志级别。例如INFO，DEBUG，ERROR等。</li><li>能够打印基本信息，如调用文件/函数名和行号，日志时间等。</li></ul><h1 id="默认的Go-Logger"><a href="#默认的Go-Logger" class="headerlink" title="默认的Go Logger"></a>默认的Go Logger</h1><p>在学习Uber-go的zap包之前，还是先学习一下Go语言提供的基本日志功能。由于之前写项目的时候在日志系统设计方面并没有很在意，所以根本就没记住什么东西，还是重新学一下吧。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。</p><p>那就来看一段简单的实现代码吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFileLocation, _ := os.OpenFile(<span class="string">&quot;test.log&quot;</span>, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="number">0744</span>)</span><br><span class="line">log.SetOutput(logFileLocation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error fetching url %s : %s&quot;</span>, url, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Status Code for %s : %s&quot;</span>, url, resp.Status)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">SetupLogger()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行上述代码后，会有一个 <code>test.log</code> 文件被创建，文件中的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Error fetching url www.baidu.com <span class="punctuation">:</span> Get <span class="attr">&quot;www.baidu.com&quot;</span><span class="punctuation">:</span> unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Status Code for http<span class="punctuation">:</span><span class="comment">//www.baidu.com : 200 OK</span></span><br></pre></td></tr></table></figure><h2 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>它最大的优点是使用非常简单。我们可以设置任何<code>io.Writer</code>作为日志记录输出并向其发送要写入的日志。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>仅限基本的日志级别<ul><li>只有一个<code>Print</code>选项。不支持<code>INFO</code>/<code>DEBUG</code>等多个级别。</li></ul></li><li>对于错误日志，它有 <code>Fatal</code> 和 <code>Panic</code><ul><li>Fatal日志通过调用<code>os.Exit(1)</code>来结束程序</li><li>Panic日志在写入日志消息之后抛出一个panic</li><li>但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误</li></ul></li><li>缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。</li><li>不提供日志切割的能力。</li></ul><h1 id="Uber-go-Zap"><a href="#Uber-go-Zap" class="headerlink" title="Uber-go Zap"></a>Uber-go Zap</h1><p>由于上面提到的 <code>Logger</code> 库的劣势并不能帮助我们设计一个良好的日志记录器，所以在本项目中选择了另一个功能更丰富等库——<code>Zap</code>。它同时提供了结构化日志记录和 printf 风格的日志记录。</p><p>那这时候就有同学会有疑问了，提供了更多的功能会不会导致在完成设定的任务时变得更慢呢？</p><p>一个优秀的工具就是实现了既要又要，根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好——也比标准库更快。 以下是Zap发布的基准测试信息</p><p>记录一条消息和10个字段:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">862 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">5 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">1250 ns/op</td><td style="text-align:center">+45%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">4021 ns/op</td><td style="text-align:center">+366%</td><td style="text-align:center">76 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">4542 ns/op</td><td style="text-align:center">+427%</td><td style="text-align:center">105 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">26785 ns/op</td><td style="text-align:center">+3007%</td><td style="text-align:center">115 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">29501 ns/op</td><td style="text-align:center">+3322%</td><td style="text-align:center">125 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">29906 ns/op</td><td style="text-align:center">+3369%</td><td style="text-align:center">122 allocs/op</td></tr></tbody></table></div><p>记录一个静态字符串，没有任何上下文或printf风格的模板：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">118 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">191 ns/op</td><td style="text-align:center">+62%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">93 ns/op</td><td style="text-align:center">-21%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">280 ns/op</td><td style="text-align:center">+137%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">standard library</td><td style="text-align:center">499 ns/op</td><td style="text-align:center">+323%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">1990 ns/op</td><td style="text-align:center">+1586%</td><td style="text-align:center">10 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">3129 ns/op</td><td style="text-align:center">+2552%</td><td style="text-align:center">24 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">3887 ns/op</td><td style="text-align:center">+3194%</td><td style="text-align:center">23 allocs/op</td></tr></tbody></table></div><h2 id="Zap的特性"><a href="#Zap的特性" class="headerlink" title="Zap的特性"></a>Zap的特性</h2><ul><li>高性能：zap 对日志输出进行了多项优化以提高它的性能</li><li>日志分级：有 Debug，Info，Warn，Error，DPanic，Panic，Fatal 等</li><li>日志记录结构化：日志内容记录是结构化的，比如 json 格式输出</li><li>自定义格式：用户可以自定义输出的日志格式</li><li>自定义公共字段：用户可以自定义公共字段，大家输出的日志内容就共同拥有了这些字段</li><li>调试：可以打印文件名、函数名、行号、日志时间等，便于调试程序</li><li>自定义调用栈级别：可以根据日志级别输出它的调用栈信息</li><li>Namespace：日志命名空间。定义命名空间后，所有日志内容就在这个命名空间下。命名空间相当于一个文件夹</li><li>支持 hook 操作</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  url := <span class="string">&quot;http://example.org/api&quot;</span></span><br><span class="line">  logger.Info(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">    zap.Int(<span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    zap.Duration(<span class="string">&quot;backoff&quot;</span>, time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  sugar := logger.Sugar()</span><br><span class="line">  sugar.Infow(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span>, url,</span><br><span class="line">    <span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;backoff&quot;</span>, time.Second,</span><br><span class="line">  )</span><br><span class="line">  sugar.Infof(<span class="string">&quot;Failed to fetch URL: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>zap</code>库的使用与其他的日志库非常相似。先创建一个<code>logger</code>，然后调用各个级别的方法记录日志（<code>Debug/Info/Error/Warn</code>）。</p><p><code>zap</code>提供了几个快速创建<code>logger</code>的方法</p><ul><li><code>zap.NewExample()</code></li><li><code>`zap.NewDevelopment()</code></li><li><code>zap.NewProduction()</code></li><li>还有高度定制化的创建方法<code>zap.New()</code>。</li></ul><p>创建前 3 个<code>logger</code>时，<code>zap</code>会使用一些预定义的设置，它们的使用场景也有所不同。<code>Example</code>适合用在测试代码中，<code>Development</code>在开发环境中使用，<code>Production</code>用在生成环境。</p><p><code>zap</code>底层 API 可以设置缓存，所以一般使用<code>defer logger.Sync()</code>将缓存同步到文件中。</p><hr><p>Zap提供了两种类型的日志记录器—<code>Sugared Logger</code>和<code>Logger</code>。</p><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li>通过调用<code>zap.NewProduction()</code>/<code>zap.NewDevelopment()</code>或者<code>zap.Example()</code>创建一个Logger。</li><li>上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。</li><li>通过Logger调用Info/Error等。</li><li>默认情况下日志都会打印到应用程序的console界面。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(</span><br><span class="line"><span class="string">&quot;Error fetching url..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">zap.Error(err))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Success..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;statusCode&quot;</span>, resp.Status),</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url))</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先创建了一个Logger，然后使用Info/ Error等Logger方法记录消息。</p><h3 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h3><p>现在让我们使用Sugared Logger来实现相同的功能。</p><ul><li>大部分的实现基本都相同。</li><li>惟一的区别是，我们通过调用主logger的<code>. Sugar()</code>方法来获取一个<code>SugaredLogger</code>。</li><li>然后使用<code>SugaredLogger</code>以<code>printf</code>格式记录语句</li></ul><p>下面是修改过后使用<code>SugaredLogger</code>代替<code>Logger</code>的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line"><span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么会有两种？"><a href="#为什么会有两种？" class="headerlink" title="为什么会有两种？"></a>为什么会有两种？</h3><p>由于<code>fmt.Printf</code>之类的方法大量使用<code>interface&#123;&#125;</code>和反射，会有不少性能损失，并且增加了内存分配的频次。<code>zap</code>为了提高性能、减少内存分配次数，没有使用反射，而且默认的<code>Logger</code>只支持强类型的、结构化的日志。必须使用<code>zap</code>提供的方法记录字段。<code>zap</code>为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，<code>zap.Type</code>（<code>Type</code>为<code>bool/int/uint/float64/complex64/time.Time/time.Duration/error</code>等）就表示该类型的字段，<code>zap.Typep</code>以<code>p</code>结尾表示该类型指针的字段，<code>zap.Types</code>以<code>s</code>结尾表示该类型切片的字段。如：</p><ul><li><code>zap.Bool(key string, val bool) Field</code>：<code>bool</code>字段</li><li><code>zap.Boolp(key string, val *bool) Field</code>：<code>bool</code>指针字段；</li><li><code>zap.Bools(key string, val []bool) Field</code>：<code>bool</code>切片字段。</li></ul><p>当然也有一些特殊类型的字段：</p><ul><li><code>zap.Any(key string, value interface&#123;&#125;) Field</code>：任意类型的字段；</li><li><code>zap.Binary(key string, val []byte) Field</code>：二进制串的字段。</li></ul><p>当然，每个字段都用方法包一层用起来比较繁琐。<code>zap</code>也提供了便捷的方法<code>SugarLogger</code>，可以使用<code>printf</code>格式符的方式。调用<code>logger.Sugar()</code>即可创建<code>SugaredLogger</code>。<code>SugaredLogger</code>的使用比<code>Logger</code>简单，只是性能比<code>Logger</code>低 50% 左右，可以用在非热点函数中。调用<code>SugarLogger</code>以<code>f</code>结尾的方法与<code>fmt.Printf</code>没什么区别，如例子中的<code>Infof</code>。同时<code>SugarLogger</code>还支持以<code>w</code>结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可。</p><h2 id="记录层级关系"><a href="#记录层级关系" class="headerlink" title="记录层级关系"></a>记录层级关系</h2><p>前面记录的日志都是一层结构，没有嵌套的层级。我们可以使用 <code>zap.Namespace(key string) Field</code> 构建一个<strong>命名空间</strong>，后续的<code>Filed</code>都记录在此命名空间中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  logger.Info(<span class="string">&quot;tracked some metrics&quot;</span>,</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  logger2 := logger.With(</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line">  logger2.Info(<span class="string">&quot;tracked some metrics&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrics&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrices&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面我们演示了两种<code>Namespace</code>的用法，一种是直接作为字段传入<code>Debug/Info</code>等方法，一种是调用<code>With()</code>创建一个新的<code>Logger</code>，新的<code>Logger</code>记录日志时总是带上预设的字段。</p><h2 id="定制Logger"><a href="#定制Logger" class="headerlink" title="定制Logger"></a>定制<code>Logger</code></h2><p>调用<code>NexExample()/NewDevelopment()/NewProduction()</code>这 3 个方法，<code>zap</code>使用默认的配置。我们也可以手动调整，配置结构如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/config.go</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Level AtomicLevel <span class="string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span></span><br><span class="line">  Encoding <span class="type">string</span> <span class="string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span></span><br><span class="line">  EncoderConfig zapcore.EncoderConfig <span class="string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span></span><br><span class="line">  OutputPaths []<span class="type">string</span> <span class="string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span></span><br><span class="line">  ErrorOutputPaths []<span class="type">string</span> <span class="string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span></span><br><span class="line">  InitialFields <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Level</code>：日志级别；</li><li><code>Encoding</code>：输出的日志格式，默认为 JSON；</li><li><code>OutputPaths</code>：可以配置多个输出路径，路径可以是文件路径和<code>stdout</code>（标准输出）；</li><li><code>ErrorOutputPaths</code>：错误输出路径，也可以是多个；</li><li><code>InitialFields</code>：每条日志中都会输出这些值。</li></ul><p>其中<code>EncoderConfig</code>为编码配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/zapcore/encoder.go</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  MessageKey    <span class="type">string</span> <span class="string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span></span><br><span class="line">  LevelKey      <span class="type">string</span> <span class="string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span></span><br><span class="line">  TimeKey       <span class="type">string</span> <span class="string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span></span><br><span class="line">  NameKey       <span class="type">string</span> <span class="string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span></span><br><span class="line">  CallerKey     <span class="type">string</span> <span class="string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span></span><br><span class="line">  StacktraceKey <span class="type">string</span> <span class="string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span></span><br><span class="line">  LineEnding    <span class="type">string</span> <span class="string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span></span><br><span class="line">  EncodeLevel    LevelEncoder    <span class="string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span></span><br><span class="line">  EncodeTime     TimeEncoder     <span class="string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span></span><br><span class="line">  EncodeDuration DurationEncoder <span class="string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span></span><br><span class="line">  EncodeCaller   CallerEncoder   <span class="string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span></span><br><span class="line">  EncodeName NameEncoder <span class="string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>MessageKey</code>：日志中信息的键名，默认为<code>msg</code>；</li><li><code>LevelKey</code>：日志中级别的键名，默认为<code>level</code>；</li><li><code>EncodeLevel</code>：日志中级别的格式，默认为小写，如<code>debug/info</code>。</li></ul><h3 id="将日志写入文件而不是终端"><a href="#将日志写入文件而不是终端" class="headerlink" title="将日志写入文件而不是终端"></a>将日志写入文件而不是终端</h3><p>在实际运行的项目中，将日志写入终端显然不是一个好的想法，即不方便查看，又不能够长时间存储。所以，将日志单独写入到一个文件夹中，是一个非常好的设计。这时，我们就要用到<code>zap.New()</code>方法来定制创建logger。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span></span> *Logger</span><br></pre></td></tr></table></figure><p><code>zapcore.Core</code>需要三个配置——<code>Encoder</code>，<code>WriteSyncer</code>，<code>LogLevel</code>。</p><ol><li><strong>Encoder</strong>：编码器（如何写入日志）。</li><li><strong>WriterSyncer</strong> ：指定日志将写到哪里去。</li><li><strong>Log Level</strong>：哪种级别的日志将被写入。</li></ol><p>在本项目的实际开发中，对以上三个配置都做出了相应的设计。根据日期以及日志的等级实现了相应的日志分割功能，将日志输出的时间格式也进行了更加简洁的设置。</p><h2 id="全局Logger"><a href="#全局Logger" class="headerlink" title="全局Logger"></a>全局<code>Logger</code></h2><p>为了方便使用，<code>zap</code>提供了两个全局的<code>Logger</code>，一个是<code>*zap.Logger</code>，可调用<code>zap.L()</code>获得；另一个是<code>*zap.SugaredLogger</code>，可调用<code>zap.S()</code>获得。需要注意的是，全局的<code>Logger</code>默认并不会记录日志！它是一个无实际效果的<code>Logger</code>。看源码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.uber.org/zap/global.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  _globalMu sync.RWMutex</span><br><span class="line">  _globalL  = NewNop()</span><br><span class="line">  _globalS  = _globalL.Sugar()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以使用<code>ReplaceGlobals(logger *Logger) func()</code>将<code>logger</code>设置为全局的<code>Logger</code>，该函数返回一个无参函数，用于恢复全局<code>Logger</code>设置：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  zap.L().Info(<span class="string">&quot;global Logger before&quot;</span>)</span><br><span class="line">  zap.S().Info(<span class="string">&quot;global SugaredLogger before&quot;</span>)</span><br><span class="line"></span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  zap.ReplaceGlobals(logger)</span><br><span class="line">  zap.L().Info(<span class="string">&quot;global Logger after&quot;</span>)</span><br><span class="line">  zap.S().Info(<span class="string">&quot;global SugaredLogger after&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;global Logger after&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;global SugaredLogger after&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到在调用<code>ReplaceGlobals</code>之前记录的日志并没有输出。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是在本项目中已经使用的有关 <code>Zap</code> 库的内容，更加详细和底层的东西还是去看大佬的博客和实际源码吧，我写的博客也只是为了强化一下记忆。</p><p>呜呜呜……，暑期实习还是没有一点眉目，不知道该怎么办了，真是不想背八股文啊！！！昨天面了边无际的面试，感觉这才应该是面试该有的情况，就不要问那些要靠死记硬背的八股文了，日常工作又能用到多少，谁会在写代码的时候需要考虑三次握手怎么握呀。不过不问八股好像也没什么可问的了。这就是绝大多数本科生的悲哀之处吧，上了四年学，什么都没学到。</p><p>不过边无际的面试面的好像也没有多好，不过这是我三个月以来说过最流畅的自我介绍了，感觉还是得深入的学习一下Redis和Docker的内容了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://darjun.github.io/2020/04/23/godailylib/zap/">Go 每日一库之 Zap</a></p></li><li><p><a href="https://www.liwenzhou.com/posts/Go/zap/">李文周的博客</a></p></li><li><a href="https://www.cnblogs.com/jiujuan/p/17304844.html">更加详细的Zap介绍</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。&lt;/p&gt;
&lt;h1 id=&quot;日志系统&quot;&gt;&lt;a href=&quot;#日志系统&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>命令行解析——flag</title>
    <link href="http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/"/>
    <id>http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/</id>
    <published>2024-05-23T12:18:13.000Z</published>
    <updated>2024-05-23T13:01:07.684Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用<code>Set</code>显示设置的 &gt; 命令行选项 &gt; 环境变量 &gt; 配置文件 &gt; 默认值。</p><p>在实际项目开发中一般不会直接 <code>Set</code> 来设置，因为要使用的配置现象过多。因此，在考虑直接读取配置文件之前，我们要先做一件事，那就是解析命令行，看看有没有相应的键值设置。</p><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><h1 id="如何获取命令行参数？"><a href="#如何获取命令行参数？" class="headerlink" title="如何获取命令行参数？"></a>如何获取命令行参数？</h1><p>如果只是简单的想要获取命令行参数，可以直接使用 <code>os.Args</code> 来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./args_demo a b c d</span><br><span class="line">args[0]=./args_demo</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=b</span><br><span class="line">args[3]=c</span><br><span class="line">args[4]=d</span><br></pre></td></tr></table></figure><p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p><h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p><code>flag</code>用于解析命令行选项。</p><p>命令行选项在实际开发中很常用，特别是在写工具的时候。</p><ul><li>指定配置文件的路径，如<code>redis-server ./redis.conf</code>以当前目录下的配置文件<code>redis.conf</code>启动 Redis 服务器；</li><li>自定义某些参数，如<code>python -m SimpleHTTPServer 8080</code>启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">flag参数</th><th style="text-align:center">有效值</th></tr></thead><tbody><tr><td style="text-align:center">字符串flag</td><td style="text-align:center">合法字符串</td></tr><tr><td style="text-align:center">整数flag</td><td style="text-align:center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td style="text-align:center">浮点数flag</td><td style="text-align:center">合法浮点数</td></tr><tr><td style="text-align:center">bool类型flag</td><td style="text-align:center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td style="text-align:center">时间段flag</td><td style="text-align:center">任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” /“µs”、“ms”、“s”、“m”、“h”。</td></tr></tbody></table></div><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a><code>flag.Type()</code></h3><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age := flag.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married := flag.Bool(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a><code>flag.TypeVar()</code></h3><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a><code>flag.Parse()</code></h3><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>遇到第一个非选项参数（即不是以<code>-</code>和<code>--</code>开头的）或终止符<code>--</code>，解析停止。</p><hr><p>总结一下，使用<code>flag</code>库的一般步骤：</p><ul><li>定义一些全局变量存储选项的值;</li><li>在<code>init</code>方法中使用<code>flag.TypeVar</code>方法定义选项，这里的<code>Type</code>可以为基本类型<code>Int/Uint/Float64/Bool</code>，还可以是时间间隔<code>time.Duration</code>。定义时传入变量的地址、选项名、默认值和帮助信息；</li><li>在<code>main</code>方法中调用<code>flag.Parse</code>从<code>os.Args[1:]</code>中解析选项。因为<code>os.Args[0]</code>为可执行程序路径，会被剔除。</li></ul><p>注意点：</p><p><code>flag.Parse</code>方法必须在所有选项都定义之后调用，且<code>flag.Parse</code>调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为<code>init</code>在所有代码之前执行，将选项定义都放在<code>init</code>中，<code>main</code>函数中执行<code>flag.Parse</code>时所有选项都已经定义了。</p><h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a><code>flag</code>其他函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="定义短选项"><a href="#定义短选项" class="headerlink" title="定义短选项"></a>定义短选项</h3><p><code>flag</code>库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有<strong>相同的默认值</strong>。否则不传该选项时，行为是不确定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    defaultLogLevel = <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">    usage = <span class="string">&quot;set log level value&quot;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;log_type&quot;</span>, defaultLogLevel, usage)</span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;l&quot;</span>, defaultLogLevel, usage + <span class="string">&quot;(shorthand)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;log level:&quot;</span>, logLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>除了使用<code>flag</code>库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interval []time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(*i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> Set(value <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(*i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;interval flag already set&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, dt := <span class="keyword">range</span> strings.Split(value, <span class="string">&quot;,&quot;</span>) &#123;</span><br><span class="line">    duration, err := time.ParseDuration(dt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    *i = <span class="built_in">append</span>(*i, duration)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  intervalFlag interval</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Var(&amp;intervalFlag, <span class="string">&quot;deltaT&quot;</span>, <span class="string">&quot;comma-seperated list of intervals to use between events&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(intervalFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个新类型，这里定义类型<code>interval</code>。</p><p>新类型必须实现<code>flag.Value</code>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="type">string</span></span><br><span class="line">  Set(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>String</code>方法格式化该类型的值，<code>flag.Parse</code>方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的<code>Set</code>方法。 这里将以<code>,</code>分隔的时间间隔解析出来存入一个切片中。</p><p>自定义类型选项的定义必须使用<code>flag.Var</code>方法。</p><h3 id="解析程序中的字符串"><a href="#解析程序中的字符串" class="headerlink" title="解析程序中的字符串"></a>解析程序中的字符串</h3><p>有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用<code>flag.FlagSet</code>结构的相关方法来解析这些选项。</p><p>实际上，我们前面调用的<code>flag</code>库的方法，都会间接调用<code>FlagSet</code>结构的方法。<code>flag</code>库中定义了一个<code>FlagSet</code>类型的全局变量<code>CommandLine</code>专门用于解析命令行选项。 前面调用的<code>flag</code>库的方法只是为了提供便利，它们内部都是调用的<code>CommandLine</code>的相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">var</span> CommandLine = NewFlagSet(os.Args[<span class="number">0</span>], ExitOnError)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  CommandLine.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntVar</span><span class="params">(p *<span class="type">int</span>, name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  CommandLine.Var(newIntValue(value, p), name, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Int(name, value, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NFlag</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.actual) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Arg</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Arg(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NArg</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.args) &#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以自己创建<code>FlagSet</code>类型变量来解析选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := []<span class="type">string</span>&#123;<span class="string">&quot;-intflag&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;-stringflag&quot;</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> intflag <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> boolflag <span class="type">bool</span></span><br><span class="line">  <span class="keyword">var</span> stringflag <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  fs := flag.NewFlagSet(<span class="string">&quot;MyFlagSet&quot;</span>, flag.ContinueOnError)</span><br><span class="line">  fs.IntVar(&amp;intflag, <span class="string">&quot;intflag&quot;</span>, <span class="number">0</span>, <span class="string">&quot;int flag value&quot;</span>)</span><br><span class="line">  fs.BoolVar(&amp;boolflag, <span class="string">&quot;boolflag&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;bool flag value&quot;</span>)</span><br><span class="line">  fs.StringVar(&amp;stringflag, <span class="string">&quot;stringflag&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;string flag value&quot;</span>)</span><br><span class="line"></span><br><span class="line">  fs.Parse(args)</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">&quot;int flag:&quot;</span>, intflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;bool flag:&quot;</span>, boolflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;string flag:&quot;</span>, stringflag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewFlagSet</code>方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：</p><ul><li><code>ContinueOnError</code>：发生错误后继续解析，<code>CommandLine</code>就是使用这个选项；</li><li><code>ExitOnError</code>：出错时调用<code>os.Exit(2)</code>退出程序；</li><li><code>PanicOnError</code>：出错时产生 panic。</li></ul><p>随便看一眼<code>flag</code>库中的相关代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlagSet)</span></span> Parse(arguments []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  f.parsed = <span class="literal">true</span></span><br><span class="line">  f.args = arguments</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    seen, err := f.parseOne()</span><br><span class="line">    <span class="keyword">if</span> seen &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> f.errorHandling &#123;</span><br><span class="line">    <span class="keyword">case</span> ContinueOnError:</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> ExitOnError:</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> PanicOnError:</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与直接使用<code>flag</code>库的方法有一点不同，<code>FlagSet</code>调用<code>Parse</code>方法时需要显示传入字符串切片作为参数。因为<code>flag.Parse</code>在内部调用了<code>CommandLine.Parse(os.Args[1:])</code>。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，本项目的解析配置文件功能已经基本完成了，该功能先是使用 flag 库来解析命令行中的内容，当命令行内容不为空时，则使用输入值来进行配置；若为空，则通过解析原有的配置文件来实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.liwenzhou.com/posts/Go/flag/">李文周的博客</a></li><li><a href="https://darjun.github.io/2020/01/10/godailylib/flag/">Go每日一库之 flag</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用&lt;code&gt;Set&lt;/code&gt;显示设置的 &amp;gt; 命令行选项 &amp;gt; 环境变量 &amp;gt; 配置文件 &amp;gt; 默认值。&lt;/p&gt;
&lt;p&gt;在实际项目开发中一般不会直接 &lt;cod</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go语言配置管理神器——Viper</title>
    <link href="http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/"/>
    <id>http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/</id>
    <published>2024-05-23T11:39:34.000Z</published>
    <updated>2024-05-23T12:24:48.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——<code>Viper</code>。</p><p>在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 <strong>Viper</strong>。关于 Viper，我也已经不是第一次使用了，但之前确实是没有去了解过，所以要从头开始学习。</p><h1 id="Viper-是什么"><a href="#Viper-是什么" class="headerlink" title="Viper 是什么"></a>Viper 是什么</h1><p>XXX是什么？这是我们去学习一个东西想到的第一个问题。那么 Viper是 什么，详细内容如下：</p><p>viper 是一个配置解决方案，拥有丰富的特性：</p><ul><li>支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；</li><li>可以设置监听配置文件的修改，修改时自动加载新的配置；</li><li>从环境变量、命令行选项和<code>io.Reader</code>中读取配置；</li><li>从远程配置系统中读取和监听修改，如 etcd/Consul；</li><li>代码逻辑中显示设置键值。</li></ul><h2 id="为什么选择-Viper-？"><a href="#为什么选择-Viper-？" class="headerlink" title="为什么选择 Viper ？"></a>为什么选择 Viper ？</h2><p>在构建现代应用程序时，你无需担心配置文件格式；你想要专注于构建出色的软件。Viper的出现就是为了在这方面帮助你的。</p><p>Viper能够为你执行下列操作：</p><ol><li>查找、加载和反序列化<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>INI</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件。</li><li>提供一种机制为你的不同配置选项设置默认值。</li><li>提供一种机制来通过命令行参数覆盖指定选项的值。</li><li>提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。</li><li>当用户提供了与默认值相同的命令行或配置文件时，可以很容易地分辨出它们之间的区别。</li></ol><p>Viper会按照下面的优先级。每个项目的优先级都高于它下面的项目:</p><ul><li>显示调用<code>Set</code>设置值</li><li>命令行参数（flag）</li><li>环境变量</li><li>配置文件</li><li>key/value存储</li><li>默认值</li></ul><p><strong>重要：</strong> 目前Viper配置的键（Key）是大小写不敏感的。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>Viper 的使用非常简单，它需要很少的设置。设置文件名（<code>SetConfigName</code>）、配置类型（<code>SetConfigType</code>）、和搜索路径（<code>AddConfigPath</code>），然后调用<code>ReadInConfig</code>。viper 会自动根据类型来读取配置。使用时调用 <code>viper.Get</code> 方法获取键值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  viper.SetDefault(<span class="string">&quot;redis.port&quot;</span>, <span class="number">6381</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;app_name&quot;</span>))</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;log_level&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql ip: &quot;</span>, viper.Get(<span class="string">&quot;mysql.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql port: &quot;</span>, viper.Get(<span class="string">&quot;mysql.port&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql user: &quot;</span>, viper.Get(<span class="string">&quot;mysql.user&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql password: &quot;</span>, viper.Get(<span class="string">&quot;mysql.password&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql database: &quot;</span>, viper.Get(<span class="string">&quot;mysql.database&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis ip: &quot;</span>, viper.Get(<span class="string">&quot;redis.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.Get(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>设置文件名时不要带后缀；</li><li>搜索路径可以设置多个，viper 会根据设置顺序依次查找；</li><li>viper 获取值时使用<code>section.key</code>的形式，即传入嵌套的键名；</li><li>默认值可以调用<code>viper.SetDefault</code>设置。</li></ul><h2 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h2><p>viper 提供了多种形式的读取方法。在上面的例子中，我们看到了<code>Get</code>方法的用法。<code>Get</code>方法返回一个<code>interface&#123;&#125;</code>的值，使用有所不便。</p><p><code>GetType</code>系列方法可以返回指定类型的值。 其中，Type 可以为<code>Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice</code>。 但是请注意，<strong>如果指定的键不存在或类型不正确，<code>GetType</code>方法返回对应类型的零值</strong>。</p><p>如果要判断某个键是否存在，使用<code>IsSet</code>方法。 另外，<code>GetStringMap</code>和<code>GetStringMapString</code>直接以 map 返回某个键下面所有的键值对，前者返回<code>map[string]interface&#123;&#125;</code>，后者返回<code>map[string]string</code>。 <code>AllSettings</code>以<code>map[string]interface&#123;&#125;</code>返回所有设置。</p><h2 id="设置键值"><a href="#设置键值" class="headerlink" title="设置键值"></a>设置键值</h2><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><h3 id="viper-Set"><a href="#viper-Set" class="headerlink" title="viper.Set"></a>viper.Set</h3><p>如果某个键通过<code>viper.Set</code>设置了值，那么这个值的优先级最高。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`viper.Set(&quot;redis.port&quot;, 5381) `</span></span><br></pre></td></tr></table></figure><p>如果将上面这行代码放到程序中，运行程序，输出的<code>redis.port</code>将是 5381。</p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>如果一个键没有通过<code>viper.Set</code>显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在<code>init</code>方法中定义选项，并且调用<code>viper.BindPFlags</code>绑定选项到配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pflag.Int(<span class="string">&quot;redis.port&quot;</span>, <span class="number">8381</span>, <span class="string">&quot;Redis port to connect&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定命令行</span></span><br><span class="line">  viper.BindPFlags(pflag.CommandLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>main</code>方法开头处调用<code>pflag.Parse</code>解析选项。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。</p><p>在<code>init</code>方法中调用<code>AutomaticEnv</code>方法绑定全部环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.AutomaticEnv()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="string">&quot;GOPATH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以单独绑定环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;redis.port&quot;</span>)<span class="comment">//只传入一个参数，这个参数即表示键名，又表示环境变量名。</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;go.path&quot;</span>, <span class="string">&quot;GOPATH&quot;</span>)<span class="comment">//传入两个参数，第一个参数表示键名，第二个参数表示环境变量名。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;go path: &quot;</span>, viper.Get(<span class="string">&quot;go.path&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过<code>viper.SetEnvPrefix</code>方法设置环境变量前缀，这样一来，通过<code>AutomaticEnv</code>和一个参数的<code>BindEnv</code>绑定的环境变量， 在使用<code>Get</code>的时候，viper 会自动加上这个前缀再从环境变量中查找。</p><p>如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名<code>gopath</code>也能读取环境变量<code>GOPATH</code>的值。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果经过前面的途径都没能找到该键，viper 接下来会尝试从配置文件中查找。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>使用 <code>viper.SetDefault()</code> 来设置默认值，以供使用。</p><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><h3 id="从io-Reader中读取"><a href="#从io-Reader中读取" class="headerlink" title="从io.Reader中读取"></a>从<code>io.Reader</code>中读取</h3><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bytes&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  tomlConfig := []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">app_name = &quot;awesome web&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># possible values: DEBUG, INFO, WARNING, ERROR, FATAL</span></span><br><span class="line"><span class="string">log_level = &quot;DEBUG&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[mysql]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 3306</span></span><br><span class="line"><span class="string">user = &quot;dj&quot;</span></span><br><span class="line"><span class="string">password = 123456</span></span><br><span class="line"><span class="string">database = &quot;awesome&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[redis]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 7381</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.GetInt(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unmarshal"><a href="#Unmarshal" class="headerlink" title="Unmarshal"></a><code>Unmarshal</code></h3><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  AppName  <span class="type">string</span></span><br><span class="line">  LogLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  MySQL    MySQLConfig</span><br><span class="line">  Redis    RedisConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP       <span class="type">string</span></span><br><span class="line">  Port     <span class="type">int</span></span><br><span class="line">  User     <span class="type">string</span></span><br><span class="line">  Password <span class="type">string</span></span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP   <span class="type">string</span></span><br><span class="line">  Port <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c Config</span><br><span class="line">  viper.Unmarshal(&amp;c)</span><br><span class="line"></span><br><span class="line">  fmt.Println(c.MySQL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><p>有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！</p><ul><li><code>WriteConfig</code>：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖；</li><li><code>WriteConfigAs</code>：保存配置到指定路径，如果文件存在，则覆盖；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是入股配置文件存在，则不覆盖。</li></ul><h2 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h2><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><p>只需要调用<code>viper.WatchConfig</code>，viper 会自动监听配置修改。如果有修改，重新加载的配置。</p><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Config file:%s Op:%s\n&quot;</span>, e.Name, e.Op)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，在本项目中所用到的有关 Viper 的内容就记录完了。但是viper相关的设计还没结束，还有另外一个很重要的库 flag。那就再下一篇博客中记录吧，一些写太多容易猪脑过载。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://darjun.github.io/2020/01/18/godailylib/viper/">Go每日一库之 viper</a></li><li><a href="https://www.liwenzhou.com/posts/Go/viper/">李文周的博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——&lt;code&gt;Viper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 &lt;strong&gt;Viper&lt;/s</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go-vue-admin学习</title>
    <link href="http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-05-22T14:00:49.000Z</published>
    <updated>2024-05-31T15:48:14.848Z</updated>
    
    <content type="html"><![CDATA[<p>将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。</p><p>这里插一句，道心破了主要是因为在后面的几场面试里总是达不到想要的效果，说话磕磕巴巴，问项目就回答的含糊不清，也不怪面试官给我秒挂，太不自信了，再沉淀一段时间吧，只能寄希望于秋招了。</p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── deploy： 部署相关的文件</span><br><span class="line">├── docs： 项目文档</span><br><span class="line">├── server： 后端代码</span><br><span class="line">└── web： 前端代码</span><br></pre></td></tr></table></figure><p>项目分为两个部分，使用 vue 框架的前端部分和使用 gin 框架的后端部分，前端部分在<code>web</code> 目录下，后端部分在<code>server</code>目录下。由于我对前端的内容不是很了解，所以主要关注 <code>server</code> 后端部分。了解一下目前 github 排名第一的 golang admin 项目是怎么设计的。</p><h1 id="后端结构"><a href="#后端结构" class="headerlink" title="后端结构"></a>后端结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   └── v1: v1 版本的 api，相当于java中的 controller</span><br><span class="line">├── config: 配置类，包括数据库配置，jwt 配置，redis 配置等</span><br><span class="line">├── core</span><br><span class="line">│   └── internal: 服务启动方法</span><br><span class="line">├── docs: swagger 文档</span><br><span class="line">├── global: 全局对象</span><br><span class="line">├── initialize</span><br><span class="line">│   └── internal: 初始化方法，日志，数据库，redis，jwt，定时任务等</span><br><span class="line">├── middleware: 中间件,包括跨域，jwt，casbin，日志，全局异常处理等,使用了 gin.handleFunc 的特性</span><br><span class="line">├── model: 数据库模型，请求参数，响应参数</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── system</span><br><span class="line">├── packfile</span><br><span class="line">├── plugin:</span><br><span class="line">│   ├── email: email 插件，是个完整的小项目，里面结构和外部类似</span><br><span class="line">│   ├── plugin-tool:</span><br><span class="line">│   └── ws</span><br><span class="line">├── resource: 资源文件，包括自动生成代码的模板，页面模板，插件模板等</span><br><span class="line">│   ├── autocode_template: 代码模板，从结构体生成代码</span><br><span class="line">│   ├── page: 前端静态资源</span><br><span class="line">│   └── plug_template: 插件代码模板</span><br><span class="line">├── router:路由代码</span><br><span class="line">│   └── system:</span><br><span class="line">├── service: 业务代码，相当于 java 中的 service</span><br><span class="line">│   └── system</span><br><span class="line">├── source: 数据库的初始数据</span><br><span class="line">│   └── system</span><br><span class="line">└── utils: 公共的工具类</span><br><span class="line">    ├── captcha</span><br><span class="line">    ├── plugin</span><br><span class="line">    ├── timer</span><br><span class="line">    └── upload</span><br></pre></td></tr></table></figure><p>本文是总结篇，提前写是想要有条理一点。下面是代码的主函数，我计划从主函数开始，一行一行地写一遍完整的项目，实在找不到相关的教程，所以学习的过程应该会比较艰辛，希望自己能够坚持下来吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">global.GVA_VP = core.Viper() <span class="comment">// 初始化Viper</span></span><br><span class="line">initialize.OtherInit()</span><br><span class="line">global.GVA_LOG = core.Zap() <span class="comment">// 初始化zap日志库</span></span><br><span class="line">zap.ReplaceGlobals(global.GVA_LOG)</span><br><span class="line">global.GVA_DB = initialize.Gorm() <span class="comment">// gorm连接数据库</span></span><br><span class="line">initialize.Timer()</span><br><span class="line">initialize.DBList()</span><br><span class="line"><span class="keyword">if</span> global.GVA_DB != <span class="literal">nil</span> &#123;</span><br><span class="line">initialize.RegisterTables() <span class="comment">// 初始化表</span></span><br><span class="line"><span class="comment">// 程序结束前关闭数据库链接</span></span><br><span class="line">db, _ := global.GVA_DB.DB()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br><span class="line">core.RunWindowsServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h1><p>Go语言库：</p><ul><li><a href="https://zxh3032.github.io/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/">Viper</a></li><li><a href="https://zxh3032.github.io/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/">Flag</a></li><li><a href="https://zxh3032.github.io/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/">Zap</a></li><li><a href="https://zxh3032.github.io/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/">cron</a></li><li><p><a href="https://zxh3032.github.io/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/">Casbin</a></p></li><li><p><a href="https://zxh3032.github.io/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/">gorm</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。&lt;/p&gt;
&lt;p&gt;这里插一句</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学——语言特性</title>
    <link href="http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</id>
    <published>2024-04-20T15:40:43.000Z</published>
    <updated>2024-04-23T04:11:09.863Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在学过基础的 Go 语言语法后，我们就发现了 Go 和 C++ 最大的不同，那就是 Go 好像不支持面向对象。</p><p>这门编程语言里没有类（class）、继承（extends），难道真的不支持面向对象编程，难道它也知道我没有对象？完了，被监视了（狗头）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/40b80bdfcc42d53f0ab1bfc99fe1132.jpg" alt="40b80bdfcc42d53f0ab1bfc99fe1132"></p><p>你看，找工作给脑子找坏了吧。不必理会上面一段无脑发言，总结为玩原神玩的。那么 Go 到底支不支持面向对象，让我们一步一步地探寻。</p><h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><p>类（class）在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的特性和方法（via @维基百科）。</p><p>继承是面向对象软件技术当中的一个概念，如果一个类别 B “继承自”另一个类别 A，就把这个 B 称为 “A的子类”，而把 A 称为 “B的父类别” 也可以称 “A 是 B 的超类”（via @维基百科）。</p><p>继承有如下两个特性：</p><ul><li>子类具有父类别的各种属性和方法，不需要再次编写相同的代码。</li><li>子类别继承父类时，可以重新定义某些属性，并重写某些方法，使其获得与父类别不同的功能。</li></ul><h2 id="结构和组合"><a href="#结构和组合" class="headerlink" title="结构和组合"></a>结构和组合</h2><p>在 Go 里就比较 ”特别“ 了，因为没有传统的类，也没有继承。</p><p>取而代之的是结构和组合的方式。这也是业内对 Go 是否 OOP 争议最大的地方。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>我们可以在 Go 中通过结构体的方式来组织代码，达到类似类的方式。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>类的声明采取结构体的方式取代后，也可以配套使用 ”组合“ 来达到类似继承的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> man <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span></span> hello1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">man</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> hello2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">p := person&#123;name: name&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := newPerson(<span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">p.hello1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 man 和 person 两个结构体，并将 man 嵌入到 person 中，形成组合。</p><h2 id="Go-是面向对象的语言吗"><a href="#Go-是面向对象的语言吗" class="headerlink" title="Go 是面向对象的语言吗"></a>Go 是面向对象的语言吗</h2><p>“Go 语言是否一门面向对象的语言？”，这是一个日经话题。官方 FAQ 给出的答复是：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/go-faq-objects.png" alt="image"></p><p>是的，也不是。原因是：</p><ul><li>Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。</li><li>Go 中的 “接口 “概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。</li><li>Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、“未装箱的 “整数。它们并不局限于结构（类）。</li><li>Go 由于缺乏类型层次，Go 中的 “对象 “比 C++ 或 Java 等语言更轻巧。</li></ul><h1 id="函数重载和缺省参数"><a href="#函数重载和缺省参数" class="headerlink" title="函数重载和缺省参数"></a>函数重载和缺省参数</h1><p>Go 语言中并不支持函数重载和缺省参数，下面将会介绍这两个是什么。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载（function overloading），也叫方法重载。是某些编程语言（如 C++、C#、Java、Swift、Kotlin 等）具有的一项特性。</p><p>该特性<strong>允许创建多个具有不同实现的同名函数</strong>，对重载函数的调用会运行其适用于调用上下文的具体实现。</p><p>从功能上来讲，就是允许一个函数调用根据上下文执行不同的方法，达到调用同一个函数名，执行不同的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Volume</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;  <span class="comment">// 立方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> s * s * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Volume</span><span class="params">(<span class="type">double</span> r, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 圆柱体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.1415926</span> * r * r * <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Volume</span><span class="params">(<span class="type">long</span> l, <span class="type">int</span> b, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 长方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> l * b * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">2.5</span>, <span class="number">8</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">100l</span>, <span class="number">75</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值，又叫缺省参数。指的是允许程序员设定缺省参数并指定默认值，<strong>当调用该函数并未指定值时，该缺省参数将为缺省值来使用</strong>。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c=<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，函数 <code>my_func</code> 一共有 3 个变量，分别是：a、b、c。变量 c 设置了缺省值，也就是 12。</p><p>其调用方式可以为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在第一种方式中，就会正常的传入所有参数。在第二种方式，由于第三个参数 c 并没有传递，因此会直接使用缺省值 12。</p><p>这就是参数默认值，也叫缺省参数。</p><h2 id="为什么不支持"><a href="#为什么不支持" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>从上述的功能特性介绍来看，似乎非常的不错，能够节省很多功夫。像是 Go 语言的 context 库中的这些方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>要是有函数重载，直接就 WithXXX 就好了，只需要关注传入的参数类型，也不用 “记” 那么多个方法名了。</p><p>有同学说，有参数默认值。那就可以直接设置在上面，作为 “最佳实践” 给到使用函数的人，岂不美哉。那怎么 Go 语言就不支持呢？</p><h3 id="细思"><a href="#细思" class="headerlink" title="细思"></a>细思</h3><p>其实这和设计理念，和对程序的理解有关系。说白了，就是你喜欢 “显式”，还是 “隐喻”。</p><p>函数重载和参数默认值，其实是不好的行为。调用者只看函数名字，可能没法知道，你这个默认值，又或是入参不同，会调用的东西，会产生怎么样的后果？</p><p>你可以观察一下自己的行为。大部分人都会潜意识的追进去看代码，看看会调到哪，缺省值的作用是什么，以确保可控。</p><h3 id="敲定"><a href="#敲定" class="headerlink" title="敲定"></a>敲定</h3><p>这细思的可能，在 Go 语言中是不被允许的。Go 语言的<strong>设计理念就是 “显式大于隐喻”，追求明确，显式</strong>。</p><p>在 Go FAQ 《Why does Go not support overloading of methods and operators?》有相关的解释。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/func-overloading.png" alt="image"></p><p>官方有明确提到两个观点：</p><ul><li>函数重载：拥有各种同名但不同签名的方法有时是很有用的，但在实践中也可能是混乱和脆弱的。</li><li>参数默认值：操作符重载，似乎更像是一种便利，不是绝对的要求。没有它，程序会更简单。</li></ul><p>这就是为什么 Go 语言不支持的原因。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p><strong>Go 里的锁，竟然不支持可重入</strong>？</p><p>如果对已经上锁的普通互斥锁进行 “加锁” 操作，其结果要么失败，要么会阻塞至解锁。</p><p>可重入互斥锁是互斥锁的一种，同一线程对其多次加锁不会产生死锁，又或是导致阻塞。</p><ul><li>在加锁上：如果是可重入互斥锁，当前尝试加锁的线程如果就是持有该锁的线程时，加锁操作就会成功。</li><li>在解锁上：可重入互斥锁一般都会记录被加锁的次数，只有执行相同次数的解锁操作才会真正解锁。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="Go-设计原则"><a href="#Go-设计原则" class="headerlink" title="Go 设计原则"></a>Go 设计原则</h3><p>在工程中使用互斥的根本原因是：为了保护不变量，也可以用于保护内、外部的不变量。</p><p>基于此，Go 在互斥锁设计上会遵守这几个原则。如下：</p><ul><li>在调用 <code>mutex.Lock</code> 方法时，要保证这些变量的不变性保持，不会在后续的过程中被破坏。</li><li>在调用<code>mu.Unlock</code>方法时，要保证：<ul><li>程序不再需要依赖那些不变量。</li><li>如果程序在互斥锁加锁期间破坏了它们，则需要确保已经恢复了它们。</li></ul></li></ul><h3 id="不支持的原因"><a href="#不支持的原因" class="headerlink" title="不支持的原因"></a>不支持的原因</h3><p>讲了 Go 自己的设计原则后，那为什么不支持可重入呢？</p><p>其实 Russ Cox 于 2010 年在《<a href="https://groups.google.com/g/golang-nuts/c/XqW1qcuZgKg/m/Ui3nQkeLV80J">Experimenting with GO</a>》就给出了答复，认为递归（又称：重入）互斥是个坏主意，这个设计并不好。</p><h1 id="并发读写"><a href="#并发读写" class="headerlink" title="并发读写"></a>并发读写</h1><p>来不及惋惜 Redis 三兄弟了，接下来登场的是 Go 语言自己的三兄弟——垃圾回收机制、协程机制和为什么 <code>map</code> 和 <code>slice</code>是非线性的。</p><p>为什么在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？</p><h2 id="非线程安全的例子"><a href="#非线程安全的例子" class="headerlink" title="非线程安全的例子"></a>非线程安全的例子</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>我们使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;随便寻了 %d 个地方&quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一次执行</span><br><span class="line">随便寻了5790个地方</span><br><span class="line">// 第二次执行</span><br><span class="line">随便寻了7370个地方</span><br><span class="line">// 第三次执行</span><br><span class="line">随便寻了6792个地方</span><br></pre></td></tr></table></figure><p>每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式的问题。</p><p>这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>同样针对 map 也如法炮制一下，重复针对类型为 map 的变量进行写入，结果会直接出现报错，并且是 Go 源码调用 <code>throw</code> 方法所导致的致命错误，也就是说 Go 进程会中断。</p><h2 id="如何支持并发读写"><a href="#如何支持并发读写" class="headerlink" title="如何支持并发读写"></a>如何支持并发读写</h2><h3 id="对-map-上锁"><a href="#对-map-上锁" class="headerlink" title="对 map 上锁"></a>对 map 上锁</h3><p>实际上我们仍然会经过有并发 map 的诉求，因为 Go 语言中的 goroutine 实在是太方便了。像是一般写爬虫任务时，基本会用到多个 goroutine，获取到数据后再写入到 map 或者 slice 中去。</p><p>Go 官方在 Go maps in action 中提供了一种简单又便利的方式来实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>这条语句声明了一个变量，它是一个匿名结构（struct）体，包含一个原生和一个嵌入读写锁 <code>sync.RWMutex</code>。</p><h3 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h3><p>虽然有了 Map+Mutex 的极简方案，但是也仍然存在一定问题。那就是在 map 的数据量非常大时，只有一把锁（Mutex）就非常可怕了，一把锁会导致大量的争夺锁，导致各种冲突和性能低下。</p><p>常见的解决方案是分片化，将一个大 map 分成多个区间，各区间使用多个锁，这样子锁的粒度就大大降低了。不过该方案实现起来很复杂，很容易出错。因此 Go 团队到比较为止暂无推荐，而是采取了其他方案。</p><p>该方案就是在 Go1.9 起支持的 <code>sync.Map</code>，其支持并发读写 map，起到一个补充的作用。</p><p>Go 语言的 <code>sync.Map</code> 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex</span><br><span class="line">read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其是专门为 <code>append-only</code> 场景设计的，也就是适合读多写少的场景。这是他的优点之一。</p><p>若出现写多/并发多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。这是他的重大缺点。</p><p>提供了以下常用方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>Delete：删除某一个键的值。</li><li>Load：返回存储在 map 中的键的值，如果没有值，则返回 nil。ok 结果表示是否在 map 中找到了值。</li><li>LoadAndDelete：删除一个键的值，如果有的话返回之前的值。</li><li>LoadOrStore：如果存在的话，则返回键的现有值。否则，它存储并返回给定的值。如果值被加载，加载的结果为 true，如果被存储，则为 false。</li><li>Range：递归调用，对 map 中存在的每个键和值依次调用闭包函数 <code>f</code>。如果 <code>f</code> 返回 false 就停止迭代。</li><li>Store：存储并设置一个键的值。</li></ul><h2 id="为什么不支持-1"><a href="#为什么不支持-1" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>Go Slice 的话，主要还是索引位覆写问题，这个就不需要纠结了，势必是程序逻辑在编写上有明显缺陷，自行改之就好。</p><p>但 Go map 就不大一样了，很多人以为是默认支持的，一个不小心就翻车，这么的常见。那凭什么 Go 官方还不支持，难不成太复杂了，性能太差了，到底是为什么？</p><p>原因如下（via @go faq）：</p><ul><li>典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。</li><li>非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。</li><li>性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。</li></ul><p>汇总来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在学习所谓的 Go 语言哲学时并不会有很多知识上的收获，要去探讨为什么设计师要这么设计某一个功能其实就是在揣测别人的心思，或许并没有什么原因，他只是喜欢。</p><p>那为什么还会有这种 XX 语言哲学的存在呢，我觉得是为了让学习者能够更快地抓住语言特性，也会给未来使用其进行开发带来深远的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……&lt;/p&gt;
&lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言2——反射与unsafe</title>
    <link href="http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/"/>
    <id>http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/</id>
    <published>2024-04-20T15:36:56.000Z</published>
    <updated>2024-04-21T08:37:58.487Z</updated>
    
    <content type="html"><![CDATA[<p>又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在计算机科学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。（来自wikipedia）</p><p>反射是程序审查自身结构的能力，并能对程序做出一定的修改。</p><p>对于人来说，审查自身或过往事情的能力，叫 “反思” 或 “反省”。</p><h2 id="Go-中的反射包：reflect介绍"><a href="#Go-中的反射包：reflect介绍" class="headerlink" title="Go 中的反射包：reflect介绍"></a>Go 中的反射包：reflect介绍</h2><p>同 Java 语言一样，Go 语言也有运行时反射，这为我们提供了一种可以在运行时操作任意类型对象的能力。比如查看一个接口变量的具体类型、看看一个结构体又多少字段、修改某个字段的值等。</p><p>Go语言是静态编译类语言，比如在定义一个变量的时候，已经知道了它是什么类型，那么为什么还需要反射呢？这是因为有些事情只有在运行时才知道。比如你定义了一个函数，它有一个 interface｛｝类型的参数，这也就意味着调用者可以传递任何类型的参数给这个函数。在这种情况下，如果你想知道调用者传递的是什么类型的参数，就需要用到反射。如果你想知道一个结构体有哪些字段和方法，也需要反射。</p><p>Go 中的反射是建立在类型系统之上，它与空接口 interface{} 密切相关。</p><p>每个 interface{} 类型的变量包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</p><blockquote><p>所以 nil != nil </p></blockquote><ul><li>获取 2 种类型信息的方法：</li></ul><blockquote><p><code>reflect.TypeOf()</code> 获取类型信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/type.go;l=39">Type</a> 类型；</p><p><code>reflect.ValueOf()</code> 获取数据信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/value.go;l=39">Value</a> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421145232856.png" alt="image-20240421145232856"></p><ul><li>2 个方法部分源码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> ，经过中间变量 <code>interface&#123;&#125;</code>，把一个普通的变量转换为反射包中类型对象： Type 和 Value 2 个类型，然后再用 reflect 包中的方法对它们进行各种操作。</p><blockquote><p>步骤：Go 变量 -&gt; interface{} -&gt; 反射包的反射类型对象</p></blockquote><p>反射包 reflect 中所有方法基本都是围绕 Type 和 Value 这 2 个类型设计和操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303885-113976386.png" alt="image-20230220180637118"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303895-169946680.png" alt="image-20230220180651792"></p><h2 id="reflect-简单使用"><a href="#reflect-简单使用" class="headerlink" title="reflect 简单使用"></a>reflect 简单使用</h2><p>从上面可以看出 TypeOf() 返回的是一个反射包中的 Type 类型，ValueOf() 返回的是一个反射包中的 Value 类型。</p><h3 id="float-反射实例"><a href="#float-反射实例" class="headerlink" title="float 反射实例"></a>float 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==TypeOf==&quot;</span>) <span class="comment">//TypeOf</span></span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>, t) <span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, t.Kind())<span class="comment">//kind: float64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==ValueOf==&quot;</span>)<span class="comment">//ValueOf</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>, v)<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())<span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind())<span class="comment">//kind: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(v.Interface())<span class="comment">//1.2345</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value is %5.2e\n&quot;</span>, v.Interface())<span class="comment">//value is 1.23e+00</span></span><br><span class="line"></span><br><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)<span class="comment">//1.2345</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;===kind===&quot;</span>)<span class="comment">//=kind=</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v = reflect.ValueOf(m)</span><br><span class="line">    fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind()) <span class="comment">// kind: int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type()) <span class="comment">// type: main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，reflect 包中 <code>reflect.TypeOf()</code> 返回 Type 和 <code>reflect.ValueOf()</code> 返回 Value 类型 都有一个 <code>Kind()</code> 方法，<code>Kind()</code> 返回一个底层的数据类型，如 Unit，Float64，Slice, Int 等。</p><p><strong>reflect.ValueOf() 返回的 Value 类型</strong>：</p><ul><li>它有一个 Type() 方法，返回的是 reflect.Value 的 Type</li><li>它有获取 Value 类型值的方法<ul><li>如果我们知道是 <code>float</code> 类型，所以直接用 <code>Float()</code> 方法。</li><li>如果不知道具体类型呢？由上面例子可知用 <code>Interface()</code> 方法，然后在进行类型断言 <code>v.Interface().(float64)</code> 来判断获取值</li></ul></li></ul><p><strong>v.Kind() 和 v.Type() 区别</strong>：</p><ul><li>在 Go 中，可以用 type 关键字定义自定义类型，<code>Kind()</code> 方法返回底层类型。</li><li>比如还有结构体，指针等类型用 type 定义的，那么 <code>Kind()</code> 方法就可以获取这些类型的底层类型。</li></ul><h3 id="struct-反射实例"><a href="#struct-反射实例" class="headerlink" title="struct 反射实例"></a>struct 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot; id:&quot;1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := student&#123;</span><br><span class="line">Name: <span class="string">&quot;hangmeimei&quot;</span>,</span><br><span class="line">Age:  <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueOfStu := reflect.ValueOf(stu)</span><br><span class="line"><span class="comment">// 获取struct字段数量</span></span><br><span class="line">fmt.Println(<span class="string">&quot;NumFields: &quot;</span>, valueOfStu.NumField()) <span class="comment">//NumFields:  2</span></span><br><span class="line"><span class="comment">// 获取字段 Name 的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name value: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).String(), <span class="string">&quot;, &quot;</span>, valueOfStu.FieldByName(<span class="string">&quot;Name&quot;</span>).String()) <span class="comment">//Name value:  hangmeimei ,  hangmeimei</span></span><br><span class="line"><span class="comment">// 字段类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name type: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).Type()) <span class="comment">//Name type:  string</span></span><br><span class="line"></span><br><span class="line">typeOfStu := reflect.TypeOf(stu)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfStu.NumField(); i++ &#123;</span><br><span class="line"><span class="comment">// 获取字段名</span></span><br><span class="line">name := typeOfStu.Field(i).Name</span><br><span class="line">fmt.Println(<span class="string">&quot;Field Name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tag</span></span><br><span class="line"><span class="keyword">if</span> fieldName, ok := typeOfStu.FieldByName(name); ok &#123;</span><br><span class="line">tag := fieldName.Tag</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;tag-&quot;</span>, tag, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;json:&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), <span class="string">&quot;, id&quot;</span>, tag.Get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//循环输出结果</span></span><br><span class="line">    <span class="comment">//Field Name:  Name</span></span><br><span class="line"><span class="comment">//tag- json:&quot;name&quot; ,  json: name , id</span></span><br><span class="line"><span class="comment">//Field Name:  Age</span></span><br><span class="line">    <span class="comment">//tag- json:&quot;age&quot; id:&quot;1&quot; ,  json: age , id 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 struct 信息的一些方法：</p><ul><li><code>NumField()</code> 获取结构体字段数量</li><li><code>Field(i)</code> 可以通过 i 字段索引来获取结构体字段信息，比如 Field(i).Name 获取字段名</li><li><code>FieldByName(name)</code> 通过 name 获取字段信息</li></ul><h2 id="三大定理"><a href="#三大定理" class="headerlink" title="三大定理"></a>三大定理</h2><p>在 Go 官方博客文章 <a href="https://go.dev/blog/laws-of-reflection">laws-of-reflection</a> 中，叙述了反射的 3 定律：</p><ul><li>第一定律：从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>第二定律：从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>第三定律：要修改反射对象，其值必须可设置；</li></ul><h3 id="第一定律"><a href="#第一定律" class="headerlink" title="第一定律"></a>第一定律</h3><p>反射的第一定律是我们能将 Go 语言的 <code>interface&#123;&#125;</code> 变量转换成反射对象。为什么是从 <code>interface&#123;&#125;</code> 变量到反射对象？</p><blockquote><p>当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://draveness.me/golang/tree/reflect.TypeOf"><code>reflect.TypeOf</code></a>、<a href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface&#123;&#125;</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface&#123;&#125;</code> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151203850.png" alt="image-20240421151203850"></p><h3 id="第二定律"><a href="#第二定律" class="headerlink" title="第二定律"></a>第二定律</h3><p>反射的第二定律是我们可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code>中的 <code>reflect.Value.Interface</code>就能完成这项工作：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151429967.png" alt="image-20240421151429967"></p><p>不过调用 <code>reflect.Value.Interface</code>方法只能获得 <code>interface&#123;&#125;</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p><ul><li>从接口值到反射对象：<ul><li>从基本类型到接口类型的类型转换；</li><li>从接口类型到反射对象的转换；</li></ul></li><li>从反射对象到接口值：<ul><li>反射对象转换成接口类型；</li><li>通过显式类型转换变成原始类型；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151704589.png" alt="image-20240421151704589"></p><h3 id="第三定律"><a href="#第三定律" class="headerlink" title="第三定律"></a>第三定律</h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的。</p><p>看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>这个问题并不是 7.1 不可寻址，而是这个 x 不可设置。</p><p>可设置性是反射值的一个属性，并不是所有的反射值有这个属性。</p><p>Value 的 <code>CanSet</code> 方法可以获取值是否可设置，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>为什么有可设置性？</p><blockquote><p>因为 reflect.ValueOf(x) 这个 x 传递的是一个原数据的副本，上面代码 <code>v.SetFloat(7.1)</code> 如果设置成功，那么更新的是副本值，原始值 x 并没有更新。这就会造成原值和新值的混乱，可设置属性就是避免这个问题。</p></blockquote><p>那怎么办？</p><p>传递的是一个副本，而不是值本身。如果希望能直接修改 x，那么必须把 x 的地址传递给函数，即指向 x 的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet())</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copytype of p:</span> <span class="meta">*float64</span></span><br><span class="line"><span class="attr">settability of p:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>还是 <code>false</code>，为什么？</p><p>反射对象 p 不可设置，它并不是我们要设置的 p，它实际上是 <em>p。为了得到 p 所指向的东西，我们需要调用 Value 的 <code>Elem</code> 方法，通过指针进行简介<em>*寻址</em></em>，然后将结果保存在一个名为 v 的反射 Value 中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyv := p.<span class="built_in">Elem</span>()</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;settability of v:&quot;</span>, v.<span class="built_in">CanSet</span>())</span><br></pre></td></tr></table></figure><p>现在 v 是一个可设置的反射对象，输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后我们可以用 <code>v.SetFloat()</code> 设置值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyv<span class="selector-class">.SetFloat</span>(<span class="number">7.1</span>)</span><br><span class="line">fmt<span class="selector-class">.Println</span>(v.Interface())</span><br><span class="line">fmt<span class="selector-class">.Println</span>(x)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy7.1</span><br><span class="line">7.1</span><br></pre></td></tr></table></figure><blockquote><p>说明：请记住，修改反射值需要值的地址，以便修改他们的真正值。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以根据条件灵活的调用函数。最大一个优点就是灵活。</li></ul><p>比如函数参数的数据类型不确定，这时可以根据反射来判断数据类型，在调用适当的函数。</p><p>还有比如根据某些条件来调用哪个函数。</p><p>需要根据动态需要来调用函数，可以用反射。</p><blockquote><p>使用反射的 2 个典型场景：1、操作数据库的 ORM 框架 ，2、依赖注入</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>用反射编写的代码比较难以阅读和理解</li><li>反射是在运行时才执行，所以编译期间比较难以发现错误</li><li>反射对性能的影响，比一般正常运行代码慢一到两个数量级。</li></ul><h1 id="不安全但高效的-unsafe"><a href="#不安全但高效的-unsafe" class="headerlink" title="不安全但高效的 unsafe"></a>不安全但高效的 unsafe</h1><p>Go的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<strong>强类型的静态语言</strong>。强类型意味着一旦定义了，类型就不能改变；静态意味着在运行前就做了类型检查。同时出于安全考虑，Go语言是不允许两个指针类型进行转换的。</p><p>我们一般使用 <code>*T</code> 作为一个指针类型，表示一个指向类型 <code>T</code> 变量的指针。基于安全考虑，两个不同的指针类型不能相互转换，比如 <em>int 不能转为 </em>float64。</p><p>go官方是不推荐使用unsafe的操作因为它是不安全的，它绕过了golang的内存安全原则，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。但是在很多地方却是很实用。在一些go底层的包中unsafe包被很频繁的使用。</p><h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"><span class="comment">//ArbitraryType仅用于文档目的，实际上并不是unsafe包的一部分,它表示任意Go表达式的类型。</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="comment">//任意类型的指针，类似于C的*void</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"><span class="comment">//确定结构在内存中占用的确切大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的对其值（字节对齐的原因）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>官方中定义了四个描述：</p><ol><li>任何类型的指针都可以被转化为Pointer</li><li>Pointer可以被转化为任何类型的指针</li><li>uintptr可以被转化为Pointer</li><li>Pointer可以被转化为uintptr</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421155246421.png" alt="image-20240421155246421"></p><h2 id="uintptr-指针类型"><a href="#uintptr-指针类型" class="headerlink" title="uintptr 指针类型"></a>uintptr 指针类型</h2><p>uintptr 也是一种指针类型，它足够大，可以表示任何指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">uintptr</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>既然已经有了 <code>unsafe.Pointer</code>，为什么还要设计 <code>uintptr</code> 类型呢？</p><p>通常<code>Pointer</code>不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，<code>Pointer</code> 是不能做这个运算的，那么谁可以呢？这里要靠 <code>uintptr</code> 类型了，只有将 <code>Pointer</code> 类型先转换成 <code>uintptr</code> 类型，做完地址加减法运算后，再转换成 <code>Pointer</code> 类型，通过*操作达到取值、修改值的目的。</p><p><code>uintptr</code> 是 Go 语言的内置类型，是能存储指针的整型， <code>uintptr</code> 的底层类型是int，它和 <code>unsafe.Pointer</code> 可相互转换。</p><p><code>uintptr</code> 和 <code>unsafe.Pointer</code> 的区别就是：</p><ul><li><code>unsafe.Pointer</code> 只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li><li>而<code>uintptr</code>是用于指针运算的，GC 不把 <code>uintptr</code> 当指针，也就是说 <code>uintptr</code> 无法持有对象， <code>uintptr</code> 类型的目标会被回收；</li><li><code>unsafe.Pointer</code> 可以和 普通指针 进行相互转换；</li><li><code>unsafe.Pointer</code> 可以和 <code>uintptr</code> 进行相互转换。</li></ul><h1 id="slice-为何如此高效"><a href="#slice-为何如此高效" class="headerlink" title="slice 为何如此高效"></a>slice 为何如此高效</h1><p><code>slice</code> 是 <code>Go</code> 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 <code>Go</code> 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 <code>Go</code> 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 <code>slice</code> 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在讲 slice的原理之前，我先来介绍一下数组。几乎所有的编程语言里都存在数组，Go也不例外。那么为什么 Go语言除了数组之外又设计了 slice 呢？要想解答这个问题，我们先来了解数组的局限性。</p><p>一个数组由两部分构成：数组的<strong>大小</strong>和数组内的<strong>元素类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组结构伪代码表示</span></span><br><span class="line">array&#123;</span><br><span class="line"><span class="number">1</span>en</span><br><span class="line">    item <span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个数组被声明，它的大小和内部元素就不能改变，你不能随意地向数组添加任意多个元素。这是数组的<strong>第一个限制</strong>。<br>既然数组的大小是固定的，如果需要使用数组存储大量的数据，就需要提前指定一个合适的大小，比如 100000，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a10：= [<span class="number">100000</span>]<span class="type">string</span>｛<span class="string">&quot;随便寻个地方&quot;</span>｝</span><br></pre></td></tr></table></figure><p>这样虽然可以解决问题，但又带来了另外的问题，那就是内存占用。因为在Go语言中，函数间的传参是值传递的，数组作为参数在各个函数之间被传递的时候，同样的内容就会被一遍遍地复制，这就会造成大量的内存浪费，这是数组的<strong>第二个限制</strong>。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>在上面，我们已经了解到了数组的限制，为了解决这些限制，Go 语言创造了 slice，也就是<strong>切片</strong>。</p><p>切片是对数组的抽象和封装，它的底层是一个数组，存储所有的元素，但是它可以动态地添加元素，容量不足时还可以自动扩容，你完全可以把切片理解为动态数组。在Go语言中，除了长度固定的类型需要使用数组外，大多数情况下都是使用切片。</p><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>通过内置的 <code>append</code> 方法，可以向一个切片中追加任意多个元素，这就可以解决数组的第一个限制了。</p><p>当通过 <code>append</code> 追加元素时，如果切片的容量不够，<code>append</code> 函数会自动扩容。</p><p><code>append</code> 自动扩容的原理是新创建一个底层数组，把原来切片内的元素拷贝到新数组中，然后再返回一个指向新数组的切片。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-3708315c909a8a8a327b733597e66938_720w.webp" alt="img"></p><p>底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><p>切片的本质就是 <code>sliceHeader</code>，又因为函数的参数是值传递，所以传递的是 <code>SliceHteader</code>的副本、而不是底层数组的副本。这时候切片的优势就体现出来了，因为 <code>SiceHteader</code> 的副本内存占用非常少，即使是一个非常大的切片（底层数组有很多元素），也顶多占用24字节的内存，这就解决了大数组在传参时内存浪费的问题。</p><blockquote><p>SliceHeader 的三个字段的类型分别是 uintptr、int 和 int，在64位的机器上，这三个字段最多也就是 int64 类型，一个int64 占8字节，三个int64 占24字节肉存。</p></blockquote><h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><p>如果从集合类型的角度考虑，数组、切片和 map 都是集合类型，因为它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是连续的内存操作，通过索引就可以快速地找到元素存储的地址。</p><p>进一步对比，在数组和切片中，切片又更高效，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 <code>SliceHleader</code> 的三个字段就可以了，共用的还是同一个底层数组。</p><p>切片的高效还体现在 <code>for tange</code> 循环中，因为循环得到的临时变量也是个值拷贝，所以在遍历大的数组时，切片的效率更高。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本周所学基础知识就是上面的三大块内容，额，了解 Go 语言的底层设计就会发现其设计的巧妙性，初学数组和切片时认为单独设计这两个明明差不多的东西有点多此一举。看了它的底层逻辑，有了解了其设计哲学才发现好像是有道理的。</p><p>其实可以回答一个面试官很爱问的问题——为什么要学习 Go 这门语言？</p><p>其实这个问题我已经不止一次地在博客中写了，最开始学习的原因是因为舍友说这门语言有着严格的语法和结构要求，所以每个人写出来的代码都没有太大的区别，所以出于规划自己的代码风格以及缩小自己与大佬的差距，我选择学习Go 语言。</p><p>在开始做 Go 语言项目时，发现这个语言要比 C++ 或者 Python 好用很多，简单的语法、高并发等特性吸引着我去继续做项目。</p><p>现在也已经做了不少关于 Go 语言开发的内容，代码量也有几万行了，也开始关注其设计哲学和底层代码，更是被其严谨性所折服。所有设计出来的东西好像都是必须要有的，既不会多出一些无关紧要的设计，也没有什么必不可少的功能。</p><blockquote><p>不过 Go 语言确实不适合用来刷题，不仅仅是在设计输入输出的时候很麻烦，实现一些功能也是不方便。仅代表个人观点。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>反射：<ul><li><a href="https://www.cnblogs.com/jiujuan/p/17142703.html">https://www.cnblogs.com/jiujuan/p/17142703.html</a></li><li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93">https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93</a></li></ul></li><li>unsafe：<ul><li><a href="https://segmentfault.com/a/1190000021625500">https://segmentfault.com/a/1190000021625500</a></li><li><a href="https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html">https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html</a></li><li><a href="https://xie.infoq.cn/article/6513f7a056774b47c63535fae">https://xie.infoq.cn/article/6513f7a056774b47c63535fae</a></li></ul></li><li>slice：<ul><li><a href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html">https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/61121325">https://zhuanlan.zhihu.com/p/61121325</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。&lt;/p&gt;
&lt;h1 id=&quot;反射&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>聊天室</title>
    <link href="http://example.com/2024/04/20/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>http://example.com/2024/04/20/%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2024-04-20T15:33:55.000Z</published>
    <updated>2024-04-25T08:47:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>这次真成全栈工程师了。第三个 Go 语言项目，简单地实现了一个基于 TCP 连接的聊天室。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425124404153.png" alt="image-20240425124404153"></p><p>实现功能也比较简单，用户输入昵称进入聊天室，进入聊天室后会向其他用户广播，用户可以看到聊天室的所有聊天记录和当前在线人数，支持@其他人，支持敏感词检测。</p><p>由于本项目也是基于书籍中的教程进行的开发，所以在此还是大概记录一下完成该项目学到的东西。</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>本项目最重要的组成之一，本项目便是基于 <code>WebSocket</code> 进行开发的。</p><p> <code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，用于在 <code>Web</code> 应用程序中创建实时、双向的通信通道。</p><p>传统的 <code>HTTP</code> 请求通常是一次请求、一次相应，而 <code>WebSocket</code> 则可以建立一个持久连接，允许服务器即时向客户端推送数据，同时也可以接受客户端发送的数据。 <code>WebSocket</code> 相比于传统的轮询或长轮询方式，能够显著减少网络流量和延迟，提高数据传输的效率和速度。它对实时 <code>Web</code> 应用程序和在线游戏的开发非常有用。</p><p> <code>WebSocket</code> 可以在浏览器和服务器之间建立一条<strong>双向通信</strong>的通道，实现服务器主动向浏览器推送消息，而无需浏览器向服务器不断发送请求。其原理是在浏览器和服务器之间建立一个 “套接字”，通过 “握手” 的方式进行数据传输。由于该协议需要浏览器和服务器都支持，因此需要在应用程序中对其进行判断和处理。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-2070.png" alt="WebSocket 是什么"></p><p>WebSocket 是 HTML5 开始推出的基于 TCP 协议的双向通信协议，其优势在于与 HTTP 协议兼容、开销小、通信高效。WebSocket 让客户端和服务器之间建立连接，并通过这个持久连接实时地进行双向数据传输。</p><p>其实 WebSocket 最主要的特点就是建立了一个可持久化的 TCP 连接，这个连接会一直保留，直到客户端或者服务器发起中断请求为止。WebSocket 通过 HTTP/1.1 协议中的 Upgrade 头信息来告诉服务器，希望协议从 HTTP/1.1 升级到 WebSocket 协议。</p><p>WebSocket 建立在 HTTP 协议之上，所有的 WebSocket 请求都会通过普通的 HTTP 协议发送出去，然后在服务器端根据 HTTP 协议识别特定的头信息 Upgrade，服务端也会判断请求信息中 Upgrade 是否存在。 这里面 HTTP 是必不可少的，不然 WebSocket 根本无法建立。特别的，WebSocket 在握手时采用了 Sec-WebSocket-Key 加密处理，并采用 SHA-1 签名。</p><p>一旦建立了 WebSocket 连接，客户端和服务器端就可以互相发送二进制流或 Unicode 字符串。所有的数据都是经过 mask 处理过的，mask 的值是由服务器端随机生成的。在数据进行发送之前，必须先进行 mask 处理，这样可以有效防止数据被第三方恶意篡改。</p><p>最后需要说明一下的是，WebSocket 的通信协议是基于帧（数据包）的。在数据发送时，一个完整的数据包可以分为多个帧进行发送，而每一个帧都包含了数据的一部分，同时还包含了帧头信息。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="WebSocket-和-HTTP"><a href="#WebSocket-和-HTTP" class="headerlink" title="WebSocket 和 HTTP"></a>WebSocket 和 HTTP</h3><p><code>HTTP</code> 是一个无状态的协议，使客户端向服务器请求资源，并从服务器接受响应。客户端使用 HTTP 请求/响应语法，即请求发送到服务器之后，服务器向客户端返回 HTML 文件、图像和其他媒体内容。</p><p>WebSocket 通信协议尝试在较大范围内改进 Web 实时通信和插件技术，并提供<strong>全双工</strong>、<strong>基于事件</strong>的通信而无需采用低效的轮询方式。开发人员可以从 Web 浏览器的 JS 端轻松地创建 WebSocket 连接并发送数据，进而实现应用程序的实时数据传输的实现。</p><p>由于 WebSocket 是面向消息的，因此它更加适用于实时通信，而 HTTP 更适用于请求和服务器-客户端通信的响应。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/blog_05_11_17_01.png" alt="img"></p><h4 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a><strong>区别总结</strong></h4><ul><li><strong>连接方式不同：</strong> HTTP 是一种单向请求-响应协议，每次请求需要重新建立连接，而 WebSocket 是一种双向通信协议，使用长连接实现数据实时推送。</li><li><strong>数据传输方式不同：</strong> HTTP 协议中的数据传输是文本格式的，而 WebSocket 可以传输文本和二进制数据。</li><li><strong>通信类型不同：</strong> HTTP 主要用于客户端和服务器之间的请求和响应，如浏览器请求网页和服务器返回网页的 HTML 文件。WebSocket 可以实现双向通信，常常用于实时通信场景。</li><li><strong>性能方面不同：</strong> 由于 HTTP 的每次请求都需要建立连接和断开连接，而 WebSocket 可以在一次连接上进行多次通信，WebSocket 在性能上比 HTTP 有优势。</li></ul><h3 id="WebSocket-和-TCP"><a href="#WebSocket-和-TCP" class="headerlink" title="WebSocket 和 TCP"></a>WebSocket 和 TCP</h3><p>WebSocket 和 HTTP 都是基于 TCP 协议的应用层协议。</p><ul><li><strong>层次结构：</strong> WebSocket 是应用层协议，而 TCP 是传输层协议。</li><li><strong>协议特点：</strong> TCP 是一种面向连接的协议，使用三次握手建立连接，提供可靠的数据传输。而 WebSocket 是一种无状态的协议，使用 HTTP 协议建立连接，可以进行双向通信，WebSocket 的数据传输比 TCP 更加轻量级。</li><li><strong>数据格式：</strong> TCP 传输的数据需要自定义数据格式，而 WebSocket 可以支持多种数据格式，如 JSON、XML、二进制等。WebSocket 数据格式化可以更好的支持 Web 应用开发。</li></ul><p><strong>连接方式：</strong> TCP 连接的是物理地址和端口号，而 WebSocket 连接的是 URL 地址和端口号。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-2278.png" alt="img"></p><h3 id="WebSocket-和-Socket"><a href="#WebSocket-和-Socket" class="headerlink" title="WebSocket 和 Socket"></a>WebSocket 和 Socket</h3><h4 id="协议不同"><a href="#协议不同" class="headerlink" title="协议不同"></a><strong>协议不同</strong></h4><p>Socket 是基于传输层 TCP 协议的，而 Websocket 是基于 HTTP 协议的。Socket 通信是通过 Socket 套接字来实现的，而 Websocket 通信是通过 HTTP 的握手过程实现的。</p><h4 id="持久化连接"><a href="#持久化连接" class="headerlink" title="持久化连接"></a><strong>持久化连接</strong></h4><p>传统的 Socket 通信是基于短连接的，通信完成后即断开连接。而 Websocket 将 HTTP 协议升级后，实现了长连接，即建立连接后可以持续通信，避免了客户端与服务端频繁连接和断开连接的过程。</p><h4 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a><strong>双向通信</strong></h4><p>传统的 Socket 通信只支持单向通信，即客户端向服务端发送请求，服务端进行响应。而 Websocket 可以实现双向通信，即客户端和服务端都可以发起消息，实时通信效果更佳。</p><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a><strong>效率</strong></h4><p>Socket 通信具有高效性和实时性，因为传输数据时没有 HTTP 协议的头信息，而 Websocket 除了HTTP协议头之外，还需要发送额外的数据，因此通信效率相对较低。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><p>Socket 适用于实时传输数据，例如在线游戏、聊天室等需要快速交换数据的场景。而 Websocket 适用于需要长时间保持连接的场景，例如在线音视频、远程控制等。</p><h1 id="基础代码框架"><a href="#基础代码框架" class="headerlink" title="基础代码框架"></a>基础代码框架</h1><p>在基本了解 <code>WebSocket</code> 之后，尝试去使用 TCP 和 WebSocket 分别来写一个简单的聊天室。具体代码就不在这里赘述了，可以去下面的参考文献中找一下。</p><p>OK，在基本学习了如何使用 WebSocket 来完成一个聊天室的设计之后，我们来正式开启项目的设计。基础框架和流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/chatroom-design.png" alt="image"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── chatroom</span><br><span class="line">│       └── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── logic</span><br><span class="line">│   ├── broadcast.go</span><br><span class="line">│   ├── message.go</span><br><span class="line">│   └── user.go</span><br><span class="line">├── server</span><br><span class="line">│   ├── handle.go</span><br><span class="line">│   ├── home.go</span><br><span class="line">│   └── websocket.go</span><br><span class="line">└── template</span><br><span class="line">    └── home.html</span><br></pre></td></tr></table></figure><p>相关目录说明如下：</p><ul><li>cmd：该目录几乎是 Go 圈约定俗成的，Go 官方以及开源界推荐的方式，用于存放 main.main；</li><li>logic：用于存放项目核心业务逻辑代码，和 service 目录是类似的作用；</li><li>server：存放 server 相关代码，虽然这是 WebSocket 项目，但也可以看成是 Web 项目，因此可以理解成存放类似 controller 的代码；</li><li>template：存放静态模板文件；</li></ul><h2 id="四个类型"><a href="#四个类型" class="headerlink" title="四个类型"></a>四个类型</h2><p>User：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">UID            <span class="type">int</span>           <span class="string">`json:&quot;uid&quot;`</span></span><br><span class="line">NickName       <span class="type">string</span>        <span class="string">`json:&quot;nickname&quot;`</span></span><br><span class="line">EnterAt        time.Time     <span class="string">`json:&quot;enter_at&quot;`</span></span><br><span class="line">Addr           <span class="type">string</span>        <span class="string">`json:&quot;addr&quot;`</span></span><br><span class="line">MessageChannel <span class="keyword">chan</span> *Message <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">Token          <span class="type">string</span>        <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line"></span><br><span class="line">conn *websocket.Conn</span><br><span class="line"></span><br><span class="line">isNew <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>broadcaster：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcaster 广播器</span></span><br><span class="line"><span class="keyword">type</span> broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 所有聊天室用户</span></span><br><span class="line">users <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 channel 统一管理，可以避免外部乱用</span></span><br><span class="line"></span><br><span class="line">enteringChannel <span class="keyword">chan</span> *User</span><br><span class="line">leavingChannel  <span class="keyword">chan</span> *User</span><br><span class="line">messageChannel  <span class="keyword">chan</span> *Message</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该昵称用户是否可进入聊天室（重复与否）：true 能，false 不能</span></span><br><span class="line">checkUserChannel      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">checkUserCanInChannel <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户列表</span></span><br><span class="line">requestUsersChannel <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">usersChannel        <span class="keyword">chan</span> []*User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给用户发送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 哪个用户发送的消息</span></span><br><span class="line">User    *User     <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">Type    <span class="type">int</span>       <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">Content <span class="type">string</span>    <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">MsgTime time.Time <span class="string">`json:&quot;msg_time&quot;`</span></span><br><span class="line"></span><br><span class="line">ClientSendTime time.Time <span class="string">`json:&quot;client_send_time&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息 @ 了谁</span></span><br><span class="line">Ats []<span class="type">string</span> <span class="string">`json:&quot;ats&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>offlineProcessor：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> offlineProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存所有用户最近的 n 条消息</span></span><br><span class="line">recentRing *ring.Ring</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存某个用户离线消息（一样 n 条）</span></span><br><span class="line">userRing <span class="keyword">map</span>[<span class="type">string</span>]*ring.Ring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>本项目的核心流程分为两个部分，一个是前端的设计，另一个是后端的 API 开发。有关前端的部分我想可能还得一段时间才会去学习，所以这一部分就只写后端的内容。</p><h2 id="新用户来了"><a href="#新用户来了" class="headerlink" title="新用户来了"></a>新用户来了</h2><p>由于在第二个项目中已经把注册登录功能实现的很好了，所以在本聊天室中并未设置注册登录功能，为了方便识别用户，我们简单地要求用户输入昵称。</p><p>昵称在建立 WebSocket 连接时，通过 HTTP 协议传递，因此可以通过 http.Request 获取到。虽然没有注册功能，但依然要解决昵称重复的问题。这里必须引出 Broadcaster 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 所有聊天室用户</span></span><br><span class="line">users <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 channel 统一管理，可以避免外部乱用</span></span><br><span class="line"></span><br><span class="line">enteringChannel <span class="keyword">chan</span> *User</span><br><span class="line">leavingChannel  <span class="keyword">chan</span> *User</span><br><span class="line">messageChannel  <span class="keyword">chan</span> *Message</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该昵称用户是否可进入聊天室（重复与否）：true 能，false 不能</span></span><br><span class="line">checkUserChannel      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">checkUserCanInChannel <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Broadcaster.Broadcast() 在一个单独的 goroutine 中运行，按照 Go 语言的原则，应该通过通信来共享内存。因此，我们定义了 5 个 channel，用于和其他 goroutine 进行通信。</p><ul><li>enteringChannel：用户进入聊天室时，通过该 channel 告知 Broadcaster，即将该用户加入 Broadcaster 的 users 中；</li><li>leavingChannel：用户离开聊天室时，通过该 channel 告知 Broadcaster，即将该用户从 Broadcaster 的 users 中删除，同时需要关闭该用户对应的 messageChannel，避免 goroutine 泄露，后文会讲到；</li><li>messageChannel：用户发送的消息，通过该 channel 告知 Broadcaster，之后 Broadcaster 将它发送给 users 中的用户；</li><li>checkUserChannel：用来接收用户昵称，方便 Broadcaster 所在 goroutine 能够无锁判断昵称是否存在；</li><li>checkUserCanInChannel：用来回传该用户昵称是否已经存在；</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/user-exists-goroutine.png" alt="image"></p><p>两个 goroutine 通过两个 channel 进行通讯，因为 conn goroutine（代表用户连接 goroutine）可能很多，通过这种方式，避免了使用锁。</p><p>如果用户已存在，连接会断开；否则创建该用户的实例（新建 <code>User</code> 类型）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := logic.NewUser(conn, nickname, req.RemoteAddr)</span><br></pre></td></tr></table></figure><p>至此，用户算是进入了聊天室，新用户进入，一方面给 TA 发送欢迎的消息，另一方面需要通知聊天室的其他人，有新用户进来了（新建 <code>Message</code> 类型）。</p><p>接下来看看发送消息的过程，发送消息分两情况，它们的处理方式有些差异：</p><ul><li>给单个用户（当前）用户发送消息</li><li>给聊天室其他用户广播消息</li></ul><p>给当前用户发送消息的情况比较简单：conn goroutine 通过用户实例（User）的字段 MessageChannel 将 Message 发送给 write goroutine。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/send-message-single.png" alt="image"></p><p>给聊天室其他用户广播消息自然需要通过 broadcaster goroutine 来实现：conn goroutine 通过 Broadcaster 的 MessageChannel 将 Message 发送出去，broadcaster goroutine 遍历自己维护的聊天室用户列表，通过 User 实例的 MessageChannel 将消息发送给 write goroutine。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/send-message-broadcast.png" alt="image"></p><h2 id="用户走了"><a href="#用户走了" class="headerlink" title="用户走了"></a>用户走了</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 用户离开</span></span><br><span class="line">logic.Broadcaster.UserLeaving(user)</span><br><span class="line">msg = logic.NewNoticeMessage(user.NickName + <span class="string">&quot; 离开了聊天室&quot;</span>)</span><br><span class="line">logic.Broadcaster.Broadcast(msg)</span><br><span class="line">log.Println(<span class="string">&quot;user:&quot;</span>, nickname, <span class="string">&quot;leaves chat&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据读取时的错误执行不同的 Close</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  conn.Close(websocket.StatusNormalClosure, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;read from client error:&quot;</span>, err)</span><br><span class="line">  conn.Close(websocket.StatusTryAgainLater, <span class="string">&quot;Read from client error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了三件事情：</p><ul><li>在 Broadcaster 中注销该用户；</li><li>给聊天室中其他还在线的用户发送通知，告知该用户已离开；</li><li>根据 err 处理不同的 Close 行为。关于 Close 的 Status 可以参考 rfc6455 的 第 7.4 节；</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>Go 不是完全面向对象的语言，只支持部分面向对象的特性。面向对象中的单例模式是一个常见、简单的模式。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该模式规定一个类只允许有一个实例，而且自行实例化并向整个系统提供这个实例。因此单例模式的要点有：</p><ol><li>只有一个实例；</li><li>必须自行创建；</li><li>必须自行向整个系统提供这个实例。</li></ol><p>单例模式主要避免一个全局使用的类频繁地创建与销毁。当你想控制实例的数量，或有时候不允许存在多实例时，单例模式就派上用场了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/singleton.png" alt="image"></p><p>通过该类图我们可以看出，实现一个单例模式有如下要求：</p><ul><li>私有、静态的类实例变量；</li><li>构造函数私有化；</li><li>静态工厂方法，返回此类的唯一实例；</li></ul><p>根据实例化的时机，单例模式一般分成饿汉式和懒汉式。</p><ul><li>饿汉式：在定义 instance 时直接实例化，private static Singleton instance = new Singleton();</li><li>懒汉式：在 getInstance 方法中进行实例化；</li></ul><p>那两者有什么区别或优缺点？</p><ul><li>饿汉式单例类在自己被加载时就将自己实例化。即便加载器是静态的，饿汉式单例类被加载时仍会将自己实例化。单从资源利用率角度讲，这个比懒汉式单例类稍差些。从速度和反应时间角度讲，则比懒汉式单例类稍好些。</li><li>然而，懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器在实例化时必须涉及资源初始化，而资源初始化很有可能耗费时间。这意味着出现多线程同时首次引用此类的几率变得较大。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Instance = <span class="built_in">new</span>(singleton)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> Add() <span class="type">int</span> &#123;</span><br><span class="line">  s.count++</span><br><span class="line">  <span class="keyword">return</span> s.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line">c := singleton.Instance.Add()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  instance *singleton</span><br><span class="line">  mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">  mutex.Lock()</span><br><span class="line">  <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">    instance = <span class="built_in">new</span>(singleton)</span><br><span class="line">  &#125;</span><br><span class="line">  mutex.Unlock()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> Add() <span class="type">int</span> &#123;</span><br><span class="line">  s.count++</span><br><span class="line">  <span class="keyword">return</span> s.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><p>单例模式同时解决了两个问题， 所以违反了<strong>单一职责原则</strong>：</p><ol><li><p><strong>保证一个类只有一个实例</strong>。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p><p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p><p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/singleton-comic-1-zh.png" alt="一个对象的全局访问节点"></p><ol><li><p><strong>为该实例提供一个全局访问节点</strong>。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p><p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p><p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p></li></ol><h1 id="goroutine-泄露"><a href="#goroutine-泄露" class="headerlink" title="goroutine 泄露"></a>goroutine 泄露</h1><p>在 Go 中，goroutine 的创建成本低廉且调度效率高。Go 运行时能很好的支持具有成千上万个 goroutine 的程序运行，数十万个也并不意外。但是，goroutine 在内存占用方面却需要谨慎，内存资源是有限的，因此你不能创建无限的 goroutine。</p><p>每当你在程序中使用 go 关键字启动 goroutine 时，你必须知道该 goroutine 将在何时何地退出。如果你不知道答案，那可能会内存泄漏。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>造成goroutine泄露的几个原因：</p><ul><li><ol><li>从 channel 里读，但是同时没有写入操作</li></ol></li><li><ol><li>向 无缓冲 channel 里写，但是同时没有读操作</li></ol></li><li><ol><li>向已满的 有缓冲 channel 里写，但是同时没有读操作</li></ol></li><li><ol><li>select操作在所有case上都阻塞()</li></ol></li><li><ol><li>goroutine进入死循环，一直结束不了</li></ol></li></ul><p>可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。</p><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><h3 id="生产者消费者场景"><a href="#生产者消费者场景" class="headerlink" title="生产者消费者场景"></a>生产者消费者场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;newRandStream closure exited.&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"><span class="comment">// 死循环：不断向channel中放数据，直到阻塞</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">randStream &lt;- rand.Int()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">randStream := newRandStream()</span><br><span class="line">fmt.Println(<span class="string">&quot;3 random ints:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只消耗3个数据，然后去做其他的事情，此时生产者阻塞，</span></span><br><span class="line"><span class="comment">// 若主goroutine不处理生产者goroutine，则就产生了泄露</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %d\n&quot;</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产协程进入死循环，不断产生数据。消费协程，也就是主协程只消费期中的 3 个值，然后主协程就再也不消费 <code>channel</code> 中的数据，去做其他事情了。此时生产协程放了一个数据到 <code>channel</code> 中，但已经不会有协程消费该数据，所以生产协程阻塞。此时，若没有人再消费 <code>channel</code> 中的数据，生产协程是被泄露的协程</p><p><strong>解决方法：</strong></p><p>总的来说，要解决channel引起的goroutine leak问题，主要是看在channel阻塞goroutine时，该goroutine的阻塞是正常的，还是可能导致协程永远没有机会执行。若可能导致协程永远没有机会执行，则可能会导致协程泄露。 所以，在创建协程时就要考虑到它该如何终止。</p><p>解决一般问题的办法就是，当主线程结束时，告知生产线程，生产线程得到通知后，进行清理工作：或退出，或做一些清理环境的工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;newRandStream closure exited.&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> randStream &lt;- rand.Int():</span><br><span class="line"><span class="keyword">case</span> &lt;-done:  <span class="comment">// 得到通知，结束自己</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">randStream := newRandStream(done)</span><br><span class="line">fmt.Println(<span class="string">&quot;3 random ints:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %d\n&quot;</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知子协程结束自己</span></span><br><span class="line">    <span class="comment">// done &lt;- struct&#123;&#125;&#123;&#125;</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line"><span class="comment">// Simulate ongoing work</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，协程通过一个channel来得到结束的通知，这样它就可以清理现场。防止协程泄露。 通知协程结束的方式，可以是发送一个空的struct，更加简单的方式是直接close channel。如上图所示。</p><h3 id="master-work-场景"><a href="#master-work-场景" class="headerlink" title="master work 场景"></a>master work 场景</h3><p>在该场景下，我们一般是把工作划分成多个子工作，把每个子工作交给每个goroutine来完成。此时若处理不当，也是有可能发生goroutine泄漏的。我们来看一下实际的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function to add an array of numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker_adder</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// writes the sum to the go routines.</span></span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// spin up a goroutine.</span></span><br><span class="line"><span class="keyword">go</span> worker_adder(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c1)</span><br><span class="line"><span class="comment">// spin up a goroutine.</span></span><br><span class="line"><span class="keyword">go</span> worker_adder(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//x, y := &lt;-c1, &lt;-c2 // receive from c1 aND C2</span></span><br><span class="line">x, _:= &lt;-c1</span><br><span class="line"><span class="comment">// 输出从channel获取到的值</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在主协程中，把一个数组分成两个部分，分别交给两个worker协程来计算其值，这两个协程通过channel把结果传回给主协程。 但，在以上代码中，我们只接收了一个channel的数据，导致另一个协程在写channel时阻塞，再也没有执行的机会。 要是我们把这段代码放入一个常驻服务中，看的更加明显：</p><h3 id="http-server-场景"><a href="#http-server-场景" class="headerlink" title="http server 场景"></a>http server 场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数组s中的数字加起来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumInt</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP handler for /sum</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumConcurrent2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sumInt(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c1)</span><br><span class="line"><span class="keyword">go</span> sumInt(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里故意不在c2中读取数据，导致向c2写数据的协程阻塞。</span></span><br><span class="line">x := &lt;-c1</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the response.</span></span><br><span class="line">fmt.Fprintf(w, strconv.Itoa(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">StasticGroutine := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">total := runtime.NumGoroutine()</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> StasticGroutine()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/sum&quot;</span>, sumConcurrent2)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:8001&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行以上程序，并在浏览器中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8001/sum</span><br></pre></td></tr></table></figure><p>并不断刷新浏览器，来不断发送请求，可以看到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>这个输出是我们的http server的协程数量，可以看到：每请求一次，协程数就增加一个，而且不会减少。说明已经发生了协程泄露(goroutine leak)。</p><p><strong>解决方法：</strong></p><p>解决的办法就是不管在任何情况下，都必须要有协程能够读写channel，让协程不会阻塞。 </p><h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMessage</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle `s`</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Minute):</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在标准库 time.After 的文档中有一段说明：</p><blockquote><p>等待持续时间过去，然后在返回的 channel 上发送当前时间。它等效于 NewTimer().C。在计时器触发之前，计时器不会被垃圾收集器回收。</p></blockquote><p>所以，如果还没有到 5 分钟，该函数返回了，计时器就不会被 GC 回收，因此出现了内存泄露。因此大家使用 time.After 时一定要仔细，一般建议不用它，而是使用 time.NewTimer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMessage</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">idleDuration := <span class="number">5</span> * time.Minute</span><br><span class="line">idleDelay := time.NewTimer(idleDuration)</span><br><span class="line">  <span class="comment">// 这句必须的</span></span><br><span class="line"><span class="keyword">defer</span> idleDelay.Stop()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">idleDelay.Reset(idleDuration)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle `s`</span></span><br><span class="line"><span class="keyword">case</span> &lt;-idleDelay.C:</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="敏感词处理"><a href="#敏感词处理" class="headerlink" title="敏感词处理"></a>敏感词处理</h1><p>任何由用户产生内容的公开软件，都必须做好敏感词的处理。作为一个聊天室，当然要处理敏感词。</p><p>其实敏感词（包括广告）检测一直以来都是让人头疼的话题，很多大厂，比如微信、微博、头条等，每天产生大量内容，它们在处理敏感词这块，会投入很多资源。所以，这不是一个简单的问题，本书不可能深入探讨，但尽可能多涉及一些相关内容。</p><p>一般来说，目前敏感词处理有如下方法：</p><ul><li>简单替换或正则替换</li><li>DFA（Deterministic Finite Automaton，确定性有穷自动机算法）</li><li>基于朴素贝叶斯分类算法</li></ul><h2 id="简单替换或正则替换"><a href="#简单替换或正则替换" class="headerlink" title="简单替换或正则替换"></a>简单替换或正则替换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. strings.Replace</span></span><br><span class="line">keywords := []<span class="type">string</span>&#123;<span class="string">&quot;坏蛋&quot;</span>, <span class="string">&quot;坏人&quot;</span>, <span class="string">&quot;发票&quot;</span>, <span class="string">&quot;傻子&quot;</span>, <span class="string">&quot;傻大个&quot;</span>, <span class="string">&quot;傻人&quot;</span>&#125;</span><br><span class="line">content := <span class="string">&quot;不要发票，你就是一个傻子，只会发呆&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, keyword := <span class="keyword">range</span> keywords &#123;</span><br><span class="line">  content = strings.ReplaceAll(content, keyword, <span class="string">&quot;**&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. strings.Replacer</span></span><br><span class="line">replacer := strings.NewReplacer(<span class="string">&quot;坏蛋&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;坏人&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;发票&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻子&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻大个&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻人&quot;</span>, <span class="string">&quot;**&quot;</span>)</span><br><span class="line">fmt.Println(replacer.Replace(<span class="string">&quot;不要发票，你就是一个傻子，只会发呆&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: 不要**，你就是一个**，只会发呆</span></span><br></pre></td></tr></table></figure><p>类似于上面的代码（两种代码类似），我们会使用一个敏感词列表（坏蛋、发票、傻子、傻大个、傻人），来对目标字符串进行检测与替换。比较适合于敏感词列表和待检测目标字符串都比较小的场景，否则性能会有较大影响。（正则替换和这个是类似的）</p><h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>DFA全称为：Deterministic Finite Automaton,即确定有穷自动机。其特征为：有一个有限状态集合和一些从一个状态通向另一个状态的边，每条边上标记有一个符号，其中一个状态是初态，某些状态是终态。但不同于不确定的有限自动机，DFA中不会有从同一状态出发的两条边标志有相同的符号。</p><p>敏感词过滤很适合用DFA算法，用户每次输入都是状态的切换，如果出现敏感词，既是终态，就可以结束判断。</p><p>我们把数组形式的敏感词整理为一个树状结构，准确的说是一个森林。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sensitive-tree.png" alt="image"></p><p>这样查找敏感词就变成了一个查找路径的问题，如果用户输入的内容中包含一个从根节点到叶子节点的完整路径，就说明包含敏感词。</p><p>算法实现逻辑是循环用户输入的字符串，依次查找每个字符是否出现在树的节点上，比如用户输入“你是傻大个”，从第一个字开始判断，“你”不在树的根节点上，进入下一步，“是”也不在根节点上，进入下一步，“傻”出现在了根节点上，这时状态切换，下一步的查找范围变为“傻”的子节点；“大”出现在子节点中，状态再次切换为“大”的子节点；“个”出现在子节点中，并且为叶子节点，所以包含敏感词。</p><h2 id="基于朴素贝叶斯分类算法"><a href="#基于朴素贝叶斯分类算法" class="headerlink" title="基于朴素贝叶斯分类算法"></a>基于朴素贝叶斯分类算法</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。这是一种“半学习”形式的方法，它的准确性依赖于先验概率的准确性。</p><p><strong>敏感词检测步骤：</strong></p><ol><li>分词：对获取的评论进行分词处理，采用的是jieba分词</li><li>去除无意义词：采用的是哈工大的词表，遍历每一条评论，判断是否在无用词表（这里主要包含特殊字符，标点符号，感叹词等）中，从而达到去除无意词的效果</li><li>通过评论建立自己的词库，采用并集处理，达到词库中词的唯一性</li><li>建立向量：将去除无意词后的评论装换成稀疏矩阵，采用的是多项式模型，这里考虑到评论一般都比较短小，相对来说，几乎每一个词都会影响到最终的判断，所以采用多项式模型，而没有采用伯努利模型</li><li>划分训练集和测试集：采用random.shuffle()函数将数据随机排序，然后再通过切片处理划分数据，为了保证每条评论与其对应的标签保持一致，采用zip()函数将评论和标签绑定在一起</li><li>调用sklearn里面内置的贝叶斯算法接口</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里本项目也已经基本完成了，就行文章开始写的那样，这并不是一片详细的教程，只是用来记录一下完成这个项目所学到的东西。</p><p>总的来说，这个项目的教程写的也不是很详细，很多函数的实现还是要自己去完成，但是核心的内容作者都会很详细地解释，而且重要的内容其实都可以搜到。</p><p>现在我知道为什么这个项目是基于 TCP，而不是 UDP 的了。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>WebSocket：</p><ul><li><a href="https://apifox.com/apiskills/what-is-websocket/">https://apifox.com/apiskills/what-is-websocket/</a></li><li><a href="https://apifox.com/apiskills/websocket-socket-tcp-http/">https://apifox.com/apiskills/websocket-socket-tcp-http/</a></li><li><a href="https://xie.infoq.cn/article/1b9128d59e2538604e441bc53">https://xie.infoq.cn/article/1b9128d59e2538604e441bc53</a></li></ul><p>单例模式：</p><ul><li><a href="https://refactoringguru.cn/design-patterns/singleton">https://refactoringguru.cn/design-patterns/singleton</a></li></ul><p>goroutine 泄露：</p><ul><li><a href="https://hoverzheng.github.io/post/technology-blog/go/goroutine-leak%E5%92%8C%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/">https://hoverzheng.github.io/post/technology-blog/go/goroutine-leak%E5%92%8C%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/</a></li><li><a href="https://segmentfault.com/a/1190000040161853">https://segmentfault.com/a/1190000040161853</a></li></ul><p>敏感词检测：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/505941559">https://zhuanlan.zhihu.com/p/505941559</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次真成全栈工程师了。第三个 Go 语言项目，简单地实现了一个基于 TCP 连接的聊天室。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-2024042512</summary>
      
    
    
    
    <category term="聊天室" scheme="http://example.com/categories/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub——日志</title>
    <link href="http://example.com/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-18T14:50:36.000Z</published>
    <updated>2024-04-20T15:32:58.411Z</updated>
    
    <content type="html"><![CDATA[<p>正经人谁写日记啊？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image" alt="img"></p><p>欸欸欸，不好意思，来错片场了（手动狗头）。今天介绍的是项目中必不可少的一部分——日志。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>虽然正经人不写日记，但是正经项目一定要记录日志。总所周知啊，Gohub 就是一个非常正经的项目，虽然还没有到企业级这么高的层次，但是也差不多了。</p><p>在 Gohub 中，我们使用日志来记录整个系统的运行情况，可能但不限于：</p><ul><li>HTTP 请求数据</li><li>数据库 SQL 请求日志</li><li>Panic/Error 错误日志</li><li>请求第三方接口日志（发送短信、发送邮件等）</li><li>……</li></ul><p>好了，是时候掏出祖传的几个问题了，什么是日志？该怎么设置日志？下面将会一一解答。</p><h2 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h2><p>日志系统是一种记录系统活动、事件或消息的工具或机制。在计算机领域，日志系统通常用于记录应用程序、操作系统或者其他软件系统的运行时信息。这些信息可以包括错误、警告、调试信息、用户操作记录等等。</p><p>日志系统的主要目的是帮助开发人员或管理员了解系统的状态和运行情况，以便进行故障排除、性能优化、安全审计等工作。通过分析日志，可以追踪问题的根源，监视系统的健康状况，并且可以在系统发生故障或异常时进行及时的响应和处理。</p><p>日志系统通常具有以下特点：</p><ol><li><strong>可配置性：</strong> 可以根据需求配置日志记录的级别、格式、存储位置等参数。</li><li><strong>实时性：</strong> 能够实时记录系统的运行状态，以便及时发现问题。</li><li><strong>可扩展性：</strong> 能够处理大量的日志数据，并支持水平扩展以应对不断增长的系统负载。</li><li><strong>安全性：</strong> 对日志数据进行安全存储和访问控制，以防止未经授权的访问或篡改。</li><li><strong>分析性：</strong> 提供日志分析工具或接口，帮助用户对日志数据进行搜索、过滤、统计、可视化等操作。</li></ol><p>常见的日志系统包括开源项目如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk、Fluentd等，以及云服务提供商提供的日志管理服务。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>本地开发</strong></p><p>本地开发时，虽然我们可以很方便地使用 Debuger 来调试程序，但是日志将会是我们最廉价】最便捷地作物定位工具。</p><p><strong>线上环境</strong></p><p>日志是程序在生产环境下的健康监控。当程序出错时，或者某块业务逻辑出现问题，我们将依赖日志来知道具体哪一行代码出了问题。</p><p><strong>如何记录？</strong></p><div class="table-container"><table><thead><tr><th>使用环境</th><th>记录的载体</th><th>说明</th></tr></thead><tbody><tr><td>开发环境（local）</td><td>命令行终端</td><td>高亮、打印调用堆栈</td></tr><tr><td>线上环境（production）</td><td>记录到日志文件</td><td>JSON 格式，方便导入专业的日志工具</td></tr></tbody></table></div><p>日志系统在计算机领域有广泛的使用场景，以下是一些常见的应用场景：</p><ol><li><p><strong>故障排查与调试：</strong> 当系统出现错误或异常时，日志可以记录错误信息、异常堆栈跟踪等，帮助开发人员快速定位并修复问题。</p></li><li><p><strong>性能优化：</strong> 通过分析系统的性能日志，可以了解系统各个组件的性能瓶颈，从而进行优化，提升系统整体性能。</p></li><li><p><strong>安全审计与监控：</strong> 日志记录系统的操作、访问权限、安全事件等信息，有助于进行安全审计和监控，及时发现潜在的安全威胁。</p></li><li><p><strong>用户行为分析：</strong> 在网络应用或移动应用中，记录用户的操作行为可以帮助分析用户偏好、行为趋势，从而进行个性化推荐、用户体验优化等工作。</p></li><li><p><strong>合规性需求：</strong> 许多行业或政府监管机构要求企业记录和保留特定类型的数据，日志系统可以满足这些合规性需求，并提供必要的审计跟踪。</p></li><li><p><strong>容灾备份与恢复：</strong> 日志记录系统的备份和恢复功能可以帮助恢复因硬件故障、自然灾害或人为错误导致的数据丢失或损坏。</p></li><li><p><strong>业务分析与决策支持：</strong> 通过分析系统产生的日志数据，可以了解业务运营情况、用户行为趋势等，为业务决策提供数据支持。</p></li><li><p><strong>监控与警报：</strong> 基于日志数据设定监控规则，当系统出现异常或达到预定的阈值时，触发警报并通知相关人员进行处理。</p></li></ol><p>这些场景只是日志系统的一部分应用，实际上日志系统在各个领域都有着重要的作用，帮助保障系统的稳定性、安全性和可靠性。</p><h2 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h2><p>日志系统通常定义了不同的日志等级，用于标识和区分不同类型的日志信息，常见的日志等级包括：</p><div class="table-container"><table><thead><tr><th>日志等级</th><th>说明</th></tr></thead><tbody><tr><td><strong>debug</strong></td><td>信息量大，一般调试时打开。<strong>系统模块详细运行的日志</strong>，例如 HTTP 请求、数据库请求、发送邮件、发送短信</td></tr><tr><td><strong>info</strong></td><td><strong>业务级别的运行日志</strong>，如用户登录、用户退出、订单撤销。</td></tr><tr><td><strong>warn</strong></td><td><strong>感兴趣、需要引起关注的信息。</strong> 例如，调试时候打印调试信息（命令行输出会有高亮）。</td></tr><tr><td><strong>error</strong></td><td><strong>记录错误信息</strong>，用于记录程序发生的错误，这些错误可能导致程序无法正常工作，但不会使程序完全崩溃。Panic 或者 Error。如数据库连接错误、HTTP 端口被占用等。一般生产环境使用的等级。</td></tr></tbody></table></div><p><strong>日志等级规则：</strong></p><ul><li>日志等级在两个地方使用；<ul><li>配置信息（config）中可以配置日志等级；</li><li>代码中调用不同的方法（<code>Debug()</code>、<code>Info()</code>…）记录不同等级的日志。</li></ul></li><li>日志等级具备<strong>过滤信息</strong>的属性；</li><li>配置信息里设置为高等级时，低于这个等级的信息将忽略。如日志等级设为 <strong>warn</strong> ，只有 <code>Warn()</code> 和 <code>Error()</code> 方法记录的日志会有效，<code>Debug()</code> 和 <code>Info()</code> 方法记录的日志会被忽略；</li></ul><h2 id="日志过载"><a href="#日志过载" class="headerlink" title="日志过载"></a>日志过载</h2><p>日志过载是指日志系统产生的日志数量超出了处理能力或存储容量，导致系统无法有效地处理和存储所有的日志信息。这种情况可能会对系统的性能、稳定性和安全性造成负面影响。</p><p>日志过载可能出现在以下几种情况下：</p><ol><li><p><strong>异常情况爆发：</strong> 当系统遭遇大规模的异常或错误时，日志系统可能会产生大量的错误日志，导致日志系统过载。</p></li><li><p><strong>频繁的警告信息：</strong> 如果系统产生大量的警告信息，而这些警告信息又被记录在日志中，就会增加日志系统的负担。</p></li><li><p><strong>日志频率过高：</strong> 如果系统的日志频率过高，比如记录了过多的调试信息或者每个请求都生成了大量的日志记录，就会导致日志系统过载。</p></li><li><p><strong>存储容量不足：</strong> 如果日志系统的存储容量不足以存储所有的日志数据，就会导致部分日志被丢弃或被覆盖，从而丧失了一部分重要的信息。</p></li><li><p><strong>日志记录不当：</strong> 如果日志记录的内容过于冗长或者包含了大量的无关信息，会增加日志系统的负担，导致日志过载。</p></li></ol><p>日志过载可能会导致以下问题：</p><ul><li><strong>性能下降：</strong> 过多的日志记录会占用系统资源，降低系统的性能和响应速度。</li><li><strong>数据丢失：</strong> 如果日志系统无法处理所有的日志数据，部分重要的日志信息可能会被丢弃，导致问题的排查和分析变得困难。</li><li><strong>安全风险：</strong> 日志过载可能会导致系统无法及时记录和响应安全事件，增加系统遭受攻击的风险。</li></ul><p>为了避免日志过载，需要合理配置日志系统的参数，包括日志等级、存储策略、日志格式等，并定期清理和归档历史日志数据，确保日志系统能够有效地处理和存储日志信息。</p><p>记录日志的行为完全掌控在开发者手上。日志等级的错误使用，会导致<strong>日志信息过载</strong>，有违『快速定位问题』的设计初衷。</p><p>所以记录日志时，参与项目的开发者之间需要做好约定，或者说<strong>规范</strong>。</p><ul><li>功能模块的详细运行情况，使用 <code>Debug()</code> 方法，如 HTTP 请求日志、数据库 SQL 日志；</li><li>业务级别的运行日志，使用 <code>Info()</code>，如果信息量太大，例如说一个请求会记录十几条 <code>Info()</code> 日志，要改用 <code>Debug()</code>；</li><li>控制好记录日志的量，切勿滥用，滥用会导致日志信息过载；</li><li>开发调试时，使用 <code>Warn()</code> ，调试完成后记得删除调试信息；</li><li>保持 warn 及以上日志级别的干净；</li><li>线上环境开启 error 等级，接到错误反馈时，再开启 debug 进行调试，调试完成后重新设置为 error 等级，保持线上日志的干净；</li><li>系统运行出错，才能使用 <code>Error()</code> 记录，如数据库连接出错，或出现 500 错误。</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在开发 Go 项目时，我们的项目目录下经常会出现一些文件，例如编译文件、log 文件、编辑器配置文件、系统生成的一些文件，这些文件我们不希望提交到代码仓库中。</p><p>在任何当前工作的 Git 仓库中，每个文件都是这样的：</p><ul><li><strong>追踪的（tracked）</strong>- 这些是 Git 所知道的所有文件或目录。这些是新添加（用 <code>git add</code> 添加）和提交（用 <code>git commit</code> 提交）到主仓库的文件和目录。</li><li><strong>未被追踪的（untracked）</strong> - 这些是在工作目录中创建的，但还没有被暂存（或用 <code>git add</code> 命令添加）的任何新文件或目录。</li><li><strong>被忽略的（ignored）</strong> - 这些是 Git 知道的要全部排除、忽略或在 Git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 Git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。</li></ul><p>所有被忽略的文件都会被保存在一个 <code>.gitignore</code> 文件中。</p><p><code>.gitignore</code> 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。</p><p>在 <code>.gitignore</code> 中，可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。也可以用同样的方法告诉 Git 忽略多个文件或文件夹。</p><h2 id="配置信息的设置"><a href="#配置信息的设置" class="headerlink" title="配置信息的设置"></a>配置信息的设置</h2><p>在项目中，配置信息通常指的是一些参数、选项或设置，这些信息用于指导项目的行为、功能或外部依赖的配置。</p><p>Gohub 中的配置信息，将分为两个层级：</p><ul><li>env</li><li>config</li></ul><h3 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h3><p>一般来讲，项目会运行在多个环境下，例如：</p><ul><li>local —— 本地开发环境（我的机器上、其他开发同事的机器上）</li><li>testing —— 自动化测试环境</li><li>stage —— 接近线上环境的测试环境，方便其他成员访问和测试（编辑人员、产品经理、项目经理）</li><li>production —— 线上生产环境</li></ul><p>不同的环境下，我们将使用不同的配置。例如 local 环境里，发送短信使用的是测试账号，production 环境下，我们将使用验证了公司信息的发信账号。</p><p><code>.env</code> 文件通常用于存储环境变量和敏感配置信息，它的作用包括：</p><ol><li><strong>配置管理：</strong> <code>.env</code> 文件可以用来集中管理项目的配置信息，如数据库连接信息、API 密钥、密码、密钥等。将这些配置信息存储在 <code>.env</code> 文件中有助于统一管理，减少硬编码，提高项目的灵活性和可维护性。</li><li><strong>环境分离：</strong> 使用 <code>.env</code> 文件可以将不同环境（如开发环境、测试环境和生产环境）的配置信息分离开来，避免在代码中硬编码不同环境下的配置，提高代码的可移植性和可重用性。</li><li><strong>安全性：</strong> <code>.env</code> 文件通常位于项目根目录之外，并且可以通过 <code>.gitignore</code> 文件排除在版本控制系统中，从而保护敏感信息不被泄露到公共代码仓库中，提高项目的安全性。</li><li><strong>便捷性：</strong> 通过 <code>.env</code> 文件，可以方便地修改和管理项目的配置信息，无需修改源代码，减少了部署和维护的复杂性。</li><li><strong>跨平台兼容性：</strong> <code>.env</code> 文件的格式通常是简单的键值对格式，易于解析和处理，可以跨多种编程语言和操作系统使用。</li></ol><hr><p>单独的 .env 的设计，是满足一台机器一套环境变量的需求。<strong>多个 .env 文件是满足一台机器上运行多套环境变量的需求</strong>。</p><p>开发时，除了 local 环境变量，很多时候还需要 testing 测试相关的环境变量，testing 的配置有别于 local 。例如测试时，一般需要使用不同的数据库，这样才能不污染我们的开发数据库。</p><p>我们可以利用程序参数，在命令行运行主程序时，传参 <code>--env=testing</code> 的参数，程序接收到这个参数后会读取 <strong>.env.testing</strong> 文件，而不是 <code>.env</code> 文件。</p><p><code>--env</code> 的参数不需要限制值，取到以后直接读取对应的文件即可。以下是几个例子：</p><ul><li><code>--env=testing</code> 读取 <strong>.env.testing</strong> 文件，用以在测试环境使用不同的数据库</li><li><code>--env=production</code> 读取 <strong>.env.production</strong> 文件，用以在本地环境中调试线上的第三方服务配置信息（短信、邮件）</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 是将配置信息存放于 config 目录下，按照单独的逻辑区分单独的配置文件，例如数据库连接信息存放于 config/database.go 文件下。</p><p>config 里加载 .env 里的配置项，且可设置缺省值。</p><p><strong>既然有 .env 文件，为何还要 config 呢？</strong></p><p>config 可以提高配置方案灵活度。在 config 里，我们可以为每个配置项设置默认值。也可以做一些简单的数学运算，或者调用 Go 函数进行默认值的处理。我们甚至可以为配置项设置一个回调函数。</p><p>config 文件是要加入代码版本控制器中的，这些代码是固定的。如果要修改一个 config 配置项，就修改其对应的 .env 文件中的配置项即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文较短，主要记录了在 Gohub 开发设计日志时学到的相关的知识。其实在这个项目中用户使用的功能并没有什么太大的变化，即使增加了一些功能也都只是一种变式，核心并没有发生太大的变化，因此也就没有像之前一样逐个功能地去记录。那为什么还要去做新的项目呢，主要是因为舍友吧两个教程都买了，白嫖完了第一个肯定要继续白嫖第二个了。</p><p>做完第二个项目发现虽然一个叫 Gohub，一个叫 Goblog，两个看起来好像一样，但是实际开发地体验简直就是天上地下。Goblog 入门项目开发，学习怎么搭建 Web 应用；Gohub 才是真正的后端开发，更加专业，也让我学到了更多的东西。后悔啊，为什么上学期开始学 Go 的时候不好好写项目呢，要不然面试的时候也不会被拷打的那么惨了。不过这两个月确实还是学到了不少东西，比前两年半（没有玩梗，非常认真）加一起的都多了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>传统艺能了，每篇文章都像一个模子里刻出来的，不过本文并没有参考什么文章，只参考了教程和 ChatGPT的回答。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正经人谁写日记啊？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image&quot; alt=</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub——注册</title>
    <link href="http://example.com/2024/04/16/Gohub%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/"/>
    <id>http://example.com/2024/04/16/Gohub%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/</id>
    <published>2024-04-16T07:18:28.000Z</published>
    <updated>2024-04-18T15:00:18.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍新项目中第一部分的内容——身份验证接口的设计思路。</p><p>身份验证接口主要包括以下模块：</p><ul><li>注册</li><li>登录</li><li>找回密码</li></ul><p>基本流程为：</p><ol><li>填写手机号或者邮箱</li><li>填写图片验证码中的内容</li><li>填写数字验证码以完成身份验证</li><li>操作完成</li></ol><h1 id="双重验证"><a href="#双重验证" class="headerlink" title="双重验证"></a>双重验证</h1><p>在调用接口时，用户需要完成图片验证码 + 短信验证码，我们在日常使用相关的功能时也是采用这样的双重验证的策略。那我们为什么要用这么繁琐的验证方式呢？在了解为什么之前，我们先来看以下这两种验证码的作用。</p><ul><li>图片验证码 —— 区分机器人和正常用户</li><li>数字验证码——区分用户是否为手机号或邮箱的主人</li></ul><p>采用双重验证，主要还是考虑到开放注册登录接口所带来的安全隐患。在知道了这两种验证码的作用后，我们来看缺少了其中一种会带来什么样的安全隐患。</p><p>黑客容易利用的地方，大致可以分为两部分：</p><ul><li>滥用</li><li>暴力破解</li></ul><h2 id="滥用-轰炸机"><a href="#滥用-轰炸机" class="headerlink" title="滥用(轰炸机)"></a>滥用(轰炸机)</h2><p>删除图片验证，保留短信验证。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>短信验证码轰炸一般基于web方式，主要有两个模块组成：一个前端web网页，提供输入被攻击者手机号码的输入窗口；一个后台攻击页面(如PHP)，利用从各个网站上找到的动态短信URL 和前端输入的被攻击者手机号码，发送HTTP 请求，每次请求给用户发送一个动态短信。原理和实施过程如下：</p><ol><li><p>恶意攻击者在前端中输入被攻击者的手机号；</p></li><li><p>短信炸弹后台服务器，将该手机号与互联网收集的可不需要经过认证即可发送动态短信的URL 进行组合，形成可发送动态短信的URL 请求；</p></li><li>通过后台请求页面，伪造用户的请求发给不同的业务服务器；</li><li>业务服务器收到该请求后，发送动态短信到被攻击用户的手机上。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8ad9cb41-13ad-4bf7-aba9-dbec5c3e6d4c.jpg" alt="img"></p><p>GitHub 上也有一些轰炸机的项目，例如这个 <a href="https://github.com/shellvon/smsBomb/blob/master/config/sms.json">github.com/shellvon/smsBomb/blob/m…</a> ，门槛非常低。</p><p>轰炸机的配置示例：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/CcqRHrK7Fa.png!large" alt="身份验证接口设计"></p><h3 id="如何防治"><a href="#如何防治" class="headerlink" title="如何防治"></a>如何防治</h3><p>短信炸弹形成的原因是因为非授权的动态短信获取，由于在使用动态短信业务前系统并不能建立业务关联。因此，在未建立业务关联的情况下，需要进一步严格限制保证业务使用的安全性。可以采用增加<strong>图形验证码</strong>、<strong>限制单IP请求次数</strong>、<strong>限制用户短信请求间隔</strong>等方式，保护短信通道。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7bca2ddb-f4b1-44e6-b9c7-8d5b5e490a67.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/5b7d30bd-3ed2-4cde-b210-3d1ed5d78ba0.png" alt="img"></p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>用户使用密码登录时，很容易被黑客暴力破解。</p><p>所谓暴力破解，就是针对某个用户名，不断尝试可能出现的密码，直到最终成功登录。</p><p>互联网上有大量的常用密码词典，GitHub 上随便一搜就能找到如 <a href="https://github.com/TheKingOfDuck/fuzzDicts/blob/master/passwordDict/top1000.txt">这个</a> 和 <a href="https://github.com/berzerk0/Probable-Wordlists/blob/master/Real-Passwords/Top207-probable-v2.txt">这个</a> 。也极大的降低了黑客暴力破解的门槛。</p><p>防止暴力破解，是一个系统性工程。用户注册时候，我们会要求密码至少六位数（要求太严格也不好，影响用户体验）。</p><p>另外 API 也会加入限流措施，不会让黑客无止境的尝试，这也是现在主流的防范机制。</p><p>防止暴力破解，一个行之有效的方式，是使用图片验证码。</p><p>图片验证码的设计初衷，是用来区分人和机器的输入：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mNTpWgMD4R.png!large" alt="mNTpWgMD4R.png!large"></p><p>如果一个验证码很容易破解，我们还可以增加其难度：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/uDpbpHfEpb.png!large" alt="uDpbpHfEpb.png!large"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/X1wXrgsdWb.png!large" alt="X1wXrgsdWb.png!large"></p><p>另外，不止用户密码，有时候<strong>短信验证码和邮箱验证码</strong>，也很容易被破解，因为一般情况下我们只会提供六位数的数字。</p><p>六位数，意味着 999999 种可能性。虽然会加入过期时间，例如说 15 分钟内有效，但是如果接口不做限制的话，黑客写个程序，很容易就能在几分钟内尝试完所有的 999999 个可能性。最终短信验证码形同虚设，黑客可以很轻松的通过验证码来重置用户的密码。最终导致用户账号丢失。</p><h1 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h1><p>OK啊，也是好起来了，新项目用到了 Redis，第一次面试也有被面试官问过类似的问题。</p><p>用 Redis 来干吗呢，当然是用来存储图片验证码了，后续也会用 Redis 来完成友情链接的存储。</p><p>提到 Redis，相信找过工作的都知道，只要在简历上写了关于 Redis 的内容，就会触发面试官的被动技能，那就是提问 Redis 三兄弟。那么也来简单看一看关于 Redis 的内容吧。</p><hr><p>Redis 是 <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice 三个单词中加粗字母的组合，是一种基于键值对（key-value）的 NoSQL 数据库。</p><p>但比一般的键值对，Redis 中的 value 支持 string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数估算）、GEO（地理信息定位）等多种数据结构。</p><p>而且因为 Redis 的所有数据都存放在<strong>内存</strong>当中，所以它的<strong>读写性能非常出色</strong>。</p><p>不仅如此，Redis 还可以将内存数据持久化到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据并不会“丢失”。</p><p>除此之外，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 脚本等附加功能，是互联网技术领域中使用最广泛的缓存中间件。</p><h2 id="Redis-有什么用"><a href="#Redis-有什么用" class="headerlink" title="Redis 有什么用"></a>Redis 有什么用</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-b02e44b3-3299-450f-b767-4a862b5ac8ff.png" alt="三分恶面渣逆袭：Redis的作用"></p><ol><li>缓存</li></ol><p>Redis 最常见的用途就是作为缓存，由于所有数据都存储在内存中，所以 Redis 的读写速度非常快，远超基于磁盘存储的数据库。使用 Redis 缓存可以极大地提高应用的响应速度和吞吐量。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png" alt="三分恶面渣逆袭：Redis缓存"></p><ol><li>排行榜/计数器</li></ol><p>Redis 的 ZSet 非常适合用来实现排行榜的功能，同时 Redis 的原子递增操作可以用来实现计数器功能。</p><ol><li>分布式锁</li></ol><p>Redis 可以实现分布式锁，用来控制跨多个进程或服务器的资源访问。</p><p>实例：</p><ul><li>Redis 可以用来存储 Token：用户登录成功之后，使用 Redis 的 hash 存储 Token</li><li>使用 Redis 的 Zset 计数，登录失败超过一定次数，锁定账号</li><li>使用 Redisson 实现分布式环境下的登录、注册等操作</li></ul><h2 id="Redis-中的数据类型"><a href="#Redis-中的数据类型" class="headerlink" title="Redis 中的数据类型"></a>Redis 中的数据类型</h2><p>Redis 有五种基本数据类型，这五种数据类型分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、sorted set（有序集合，也叫 zset）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png" alt="三分恶面渣逆袭：Redis基本数据类型"></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串是最基础的数据类型，key 是一个字符串，不用多说，value 可以是：</p><ul><li>字符串（简单的字符串、复杂的字符串（例如 JSON、XML））</li><li>数字 （整数、浮点数）</li><li>甚至是二进制（图片、音频、视频），但最大不能超过 512MB。</li></ul><p>字符串主要有以下几个典型的使用场景：</p><ul><li>缓存功能</li><li>计数</li><li>共享 Session</li><li>限速</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>键值对集合，key 是字符串，value 是一个 Map 集合，比如说 <code>value = &#123;name: &#39;沉默王二&#39;, age: 18&#125;</code>，name 和 age 属于字段 field，沉默王二 和 18 属于值 value。</p><p>哈希主要有以下两个典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><p>来感受一下，用户字符串类型存储用户信息和用哈希类型存储用户信息的区别：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240315115713.png" alt="img"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 是一个简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表主要有以下两个使用场景：</p><ul><li>消息队列</li><li>文章列表</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>集合是字符串的无序集合，集合中的元素是唯一的，不允许重复。和 Java 集合框架中的 Set 有相似之处。</p><p>集合主要有以下两个使用场景：</p><ul><li>标签（tag）</li><li>共同关注</li></ul><h3 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h3><p>Zset，有序集合，比 set 多了一个排序属性 score（分值）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240315120652.png" alt="img"></p><p>主要应用场景有：</p><ul><li>用户点赞统计</li><li>用户排序</li></ul><h2 id="Redis-三兄弟"><a href="#Redis-三兄弟" class="headerlink" title="Redis 三兄弟"></a>Redis 三兄弟</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询不存在的数据，由于缓存没有命中（因为数据根本就不存在），请求每次都会穿过缓存去查询数据库。如果这种查询非常频繁，就会给数据库造成很大的压力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-029951e6-8b99-4364-a570-010853deb594.png" alt="三分恶面渣逆袭：缓存穿透"></p><p>缓存穿透意味着缓存失去了减轻数据压力的意义。</p><p>缓存穿透可能有两种原因：</p><ul><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ul><p>它主要有两种解决办法：</p><ol><li>缓存空值/默认值</li></ol><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-288af5a2-ae5a-427a-95e9-b4a658b01386.png" alt="三分恶面渣逆袭：缓存空值/默认值"></p><p>缓存空值有两大问题：</p><ul><li><p>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。</p></li></ul><p>例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。</p><p>这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。</p><ol><li>布隆过滤器</li></ol><p>除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。</p><p>布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-0e18ea40-a2e5-4fa6-989e-e771f6e4b0fc.png" alt="布隆过滤器"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-e8a382c9-4379-44ab-b1dc-fb598a228105.png" alt="缓存空对象核布隆过滤器方案对比"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指某一个或少数几个数据被高频访问，当这些数据在缓存中过期的那一刻，大量请求就会直接到达数据库，导致数据库瞬间压力过大。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-86579ee6-9dae-4274-a5cc-af6812f48da4.png" alt="三分恶面渣逆袭：缓存击穿"></p><p>解决⽅案：</p><ol><li>加锁更新，⽐如请求查询 A，发现缓存中没有，对 A 这个 key 加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cf63911a-8501-493e-a375-8b47a9f33358.png" alt="三分恶面渣逆袭：加锁更新"></p><ol><li>将过期时间组合写在 value 中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某一个时间点，由于大量的缓存数据同时过期或缓存服务器突然宕机了，导致所有的请求都落到了数据库上（比如 MySQL），从而对数据库造成巨大压力，甚至导致数据库崩溃的现象。</p><p>总之就是，崩了，崩的非常严重，就叫雪崩了（电影电视里应该看到过，非常夸张）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-1464fe22-c463-4850-8989-b899510cb10e.png" alt="三分恶面渣逆袭：缓存雪崩"></p><p>解决方案：</p><p>第一种：提高缓存可用性</p><ol><li><strong>集群部署</strong>：采用分布式缓存而不是单一缓存服务器，可以降低单点故障的风险。即使某个缓存节点发生故障，其他节点仍然可以提供服务，从而避免对数据库的大量直接访问。</li></ol><p>可以利用 Redis Cluster。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240326220634.png" alt="Rajat Pachauri：Redis Cluster"></p><p>或者第三方集群方案 Codis。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240326220408.png" alt="极客时间：Codis"></p><ol><li><strong>备份缓存</strong>：对于关键数据，除了在主缓存中存储，还可以在备用缓存中保存一份。当主缓存不可用时，可以快速切换到备用缓存，确保系统的稳定性和可用性。</li></ol><p>第二种：过期时间</p><p>对于缓存数据，设置不同的过期时间，避免大量缓存数据同时过期。可以通过在原有过期时间的基础上添加一个随机值来实现，这样可以分散缓存过期时间，减少同一时间对数据库的访问压力。</p><p>第三种：限流和降级</p><p>通过设置合理的系统限流策略，如令牌桶或漏斗算法，来控制访问流量，防止在缓存失效时数据库被打垮。</p><p>此外，系统可以实现降级策略，在缓存雪崩或系统压力过大时，暂时关闭一些非核心服务，确保核心服务的正常运行。</p><hr><p>本项目中对 Redis 的使用并不多，主要是用来存储一些不会经常发生变化的内容，所以更加深层次的内容会在后面继续学习，在这里就不再写了。</p><h1 id="JWT-授权"><a href="#JWT-授权" class="headerlink" title="JWT 授权"></a>JWT 授权</h1><p>互联网服务离不开用户认证。一般流程是下面这样。</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">  <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bg2018072304.jpg" alt="img"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p>写成一行，就是下面的样子。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bg2018072303.jpg" alt="img"></p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，JWT 默认是<strong>不加密</strong>的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 <strong>Header</strong> 里面指定的签名算法（默认是 <strong>HMAC SHA256</strong>），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h3><p>前面提到，<strong>Header</strong> 和 <strong>Payload</strong> 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h2><p>客户端收到服务器返回的 <strong>JWT</strong>，可以储存在 <strong>Cookie</strong> 里面，也可以储存在 <strong>localStorage</strong>。</p><p>此后，客户端每次与服务器通信，都要带上这个 <strong>JWT</strong>。你可以把它放在 <strong>Cookie</strong> 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><hr><p>说了这么多的基础内容，JWT 在本项目中又起到了什么作用呢。使用 JWT 主要用于产生 token，以此来进行授权，未被授权的用户不能执行相关操作，如 A 发布的话题，只有 A 才能对话题进行修改和删除，其他用户只能引用这个话题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录完上面的这三个问题，其实已经解决了我在做这个项目时的一大部分疑问了，因为项目主题其实很类似，这也是为什么后面会使用模板文件进行自动化生成模型、控制器、验证请求、请求授权等这些机制的原因。</p><p>当然，本文中所写到的也都只是相关技术的一些皮毛，后续的深入学习还会进行记录。关于本项目的还会有包括日志、命令行模式、make命令以及关于数据库方面的东西。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li><li><a href="https://javabetter.cn/sidebar/sanfene/redis.html">https://javabetter.cn/sidebar/sanfene/redis.html</a></li><li><a href="https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724">https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍新项目中第一部分的内容——身份验证接口的设计思路。&lt;/p&gt;
&lt;p&gt;身份验证接口主要包括以下模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册&lt;/li&gt;
&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;找回密码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;填写手机号或</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub开发</title>
    <link href="http://example.com/2024/04/15/Gohub%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/04/15/Gohub%E5%BC%80%E5%8F%91/</id>
    <published>2024-04-15T07:41:08.000Z</published>
    <updated>2024-04-18T14:55:42.144Z</updated>
    
    <content type="html"><![CDATA[<p>本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。</p><p>本项目主要设计一下三部分的知识点：</p><ul><li>API 开发</li><li>命令行开发</li><li>构建高效率的程序结构</li></ul><p>主要功能为：</p><ul><li>用户的注册和登录</li><li>安全验证码和图片验证码</li><li>JWT 授权</li><li>用户修改个人信息</li></ul><h1 id="项目统计"><a href="#项目统计" class="headerlink" title="项目统计"></a>项目统计</h1><h2 id="实现路由"><a href="#实现路由" class="headerlink" title="实现路由"></a>实现路由</h2><div class="table-container"><table><thead><tr><th>请求方法</th><th>API 地址</th><th>说明</th></tr></thead><tbody><tr><td>POST</td><td>/api/v1/auth/login/using-phone</td><td>短信 + 手机号登录</td></tr><tr><td>POST</td><td>/api/v1/auth/login/using-password</td><td>手机号、用户名、邮箱 + 密码</td></tr><tr><td>POST</td><td>/api/v1/auth/login/refresh-token</td><td>刷下 Token</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-email</td><td>邮件密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-phone</td><td>短信验证码密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-phone</td><td>使用手机号注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-email</td><td>使用邮箱注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/phone/exist</td><td>手机号是否已注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/email/exist</td><td>email 是否已支持</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/phone</td><td>发送短信验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/email</td><td>发送邮件验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/captcha</td><td>获取图片验证码</td></tr><tr><td>GET</td><td>/api/v1/user</td><td>获取当前用户</td></tr><tr><td>GET</td><td>/api/v1/users</td><td>用户列表</td></tr><tr><td>PUT</td><td>/api/v1/users</td><td>修改个人资料</td></tr><tr><td>PUT</td><td>/api/v1/users/email</td><td>修改邮箱</td></tr><tr><td>PUT</td><td>/api/v1/users/phone</td><td>修改手机号</td></tr><tr><td>PUT</td><td>/api/v1/users/password</td><td>修改密码</td></tr><tr><td>PUT</td><td>/api/v1/users/avatar</td><td>上传头像</td></tr><tr><td>GET</td><td>/api/v1/categories</td><td>分类列表</td></tr><tr><td>POST</td><td>/api/v1/categories</td><td>创建分类</td></tr><tr><td>PUT</td><td>/api/v1/categories/:id</td><td>更新分类</td></tr><tr><td>DELETE</td><td>/api/v1/categories/:id</td><td>删除分类</td></tr><tr><td>GET</td><td>/api/v1/topics</td><td>话题列表</td></tr><tr><td>POST</td><td>/api/v1/topics</td><td>创建话题</td></tr><tr><td>PUT</td><td>/api/v1/topics/:id</td><td>更新话题</td></tr><tr><td>DELETE</td><td>/api/v1/topics/:id</td><td>删除话题</td></tr><tr><td>GET</td><td>/api/v1/topics/:id</td><td>获取话题</td></tr><tr><td>GET</td><td>/api/v1/links</td><td>友情链接列表</td></tr></tbody></table></div><h2 id="第三方依赖"><a href="#第三方依赖" class="headerlink" title="第三方依赖"></a>第三方依赖</h2><p>使用到的开源库：</p><ul><li><a href="https://github.com/gin-gonic/gin">gin</a> —— 路由、路由组、中间件</li><li><a href="https://github.com/gin-contrib/zap">zap</a> —— 高性能日志方案</li><li><a href="https://github.com/go-gorm/gorm">gorm</a> —— ORM 数据操作</li><li><a href="https://github.com/spf13/cobra">cobra</a> —— 命令行结构</li><li><a href="https://github.com/spf13/viper">viper</a> —— 配置信息</li><li><a href="https://github.com/spf13/cast">cast</a> —— 类型转换</li><li><a href="https://github.com/go-redis/redis/v8">redis</a> —— Redis 操作</li><li><a href="https://github.com/golang-jwt/jwt">jwt</a> —— JWT 操作</li><li><a href="https://github.com/mojocn/base64Captcha">base64Captcha</a> —— 图片验证码</li><li><a href="https://github.com/thedevsaddam/govalidator">govalidator</a> —— 请求验证器</li><li><a href="https://github.com/ulule/limiter/v3">limiter</a> —— 限流器</li><li><a href="https://github.com/jordan-wright/email">email</a> —— SMTP 邮件发送</li><li><a href="https://github.com/KenmyZhang/aliyun-communicate">aliyun-communicate</a> —— 发送阿里云短信</li><li><a href="https://github.com/mgutz/ansi">ansi</a> —— 终端高亮输出</li><li><a href="https://github.com/iancoleman/strcase">strcase</a> —— 字符串大小写操作</li><li><a href="https://github.com/gertd/go-pluralize">pluralize</a> —— 英文字符单数复数处理</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/bxcodec/faker">faker</a> —— 假数据填充</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/disintegration/imaging">imaging</a> —— 图片裁切</li></ul><h2 id="自定义的包"><a href="#自定义的包" class="headerlink" title="自定义的包"></a>自定义的包</h2><p>现在来看下我们自建的库：</p><ul><li>app —— 应用对象</li><li>auth —— 用户授权</li><li>cache —— 缓存</li><li>captcha —— 图片验证码</li><li>config —— 配置信息</li><li>console —— 终端</li><li>database —— 数据库操作</li><li>file —— 文件处理</li><li>hash —— 哈希</li><li>helpers —— 辅助方法</li><li>jwt —— JWT 认证</li><li>limiter —— API 限流</li><li>logger —— 日志记录</li><li>mail —— 邮件发送</li><li>migrate —— 数据库迁移</li><li>paginator —— 分页器</li><li>redis —— Redis 数据库操作</li><li>response —— 响应处理</li><li>seed —— 数据填充</li><li>sms —— 发送短信</li><li>str —— 字符串处理</li><li>verifycode —— 数字验证码</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>配置信息（使用 Viper，支持 .env 和 config 目录 ）</li><li>API 版本</li><li>API 错误码</li><li>API 限流<ol><li>支持秒、分钟、小时、天级的请求限制</li><li>支持返回 API 请求量标头（限制数，剩余量、重置时间）</li></ol></li><li>注册登录<ol><li>注册<ol><li>判断手机是否注册</li><li>判断 Email 是否注册</li><li>支持手机 + 短信验证码进行注册</li><li>支持使用邮箱注册账号</li></ol></li><li>登录<ol><li>支持手机 + 短信进行登录</li><li>支持密码登录（手机号、Email、用户名任选）</li><li>支持更加安全的 Token Refresh 机制</li></ol></li><li>找回密码<ol><li>支持使用手机 + 短信验证码找回</li><li>支持使用邮箱 + 邮箱验证码找回</li></ol></li></ol></li><li>JWT 授权</li><li>整个应用使用命令行模式（默认运行 web 服务）</li><li>内置命令行（ cobra，对比 cli 和 cobra）<ol><li>key 命令生成 app key</li><li>make 命令<ul><li>make seeder —— 生成数据填充</li><li>make policy —— 生成授权文件</li><li>make apicontroller —— 生成 Restful API 控制器</li><li>make model —— 生成模型文件</li><li>make request —— 生成请求验证文件</li><li>make factory —— 生成模型工厂文件</li><li>make cmd —— 生成自定义命令文件</li><li>make migration —— 生成数据库迁移文件</li></ul></li><li>seed 数据填充<ul><li>seed 所有数据</li><li>seed 单条数据</li><li>支持使用 faker 填充假数据</li><li>支持模型工厂（ factory ）</li></ul></li><li>migrate 数据库迁移<ol><li>up —— 执行迁移</li><li>rollback (down) —— 回滚上一步执行的迁移</li><li>fresh —— 删除所有表，然后执行所有迁移</li><li>reset —— 回滚所有迁移</li><li>refresh —— 回滚所有迁移，然后再执行所有迁移</li></ol></li><li>cache 缓存处理<ul><li>cache clear —— 清除缓存</li><li>cache forget —— 忘记某个 KEY 对应的缓存</li></ul></li></ol></li><li>分页<ol><li>支持返回上下页链接，方便客户端调用</li></ol></li><li>Cache 缓存包<ol><li>支持 redis 缓存</li><li>使用 interface ，支持使用多驱动</li></ol></li><li>Redis 操作</li><li>安全验证码<ol><li>Email （发送邮箱，使用 Mailhog 进行测试）</li><li>手机验证码（发送手机短信）</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>图片验证码，防机器人滥用<ol><li>支持通过配置信息自定义复杂度</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>日志记录<ol><li>集成 zap 高性能日志库</li><li>支持命令行记录（方便开发时快速定位问题）</li><li>命令行日志高亮</li><li>支持文件记录（多文件和按日期分隔）</li><li>记录 gorm 的 query log</li><li>记录 HTTP 请求 log</li><li>Panic Recovery 中间件</li><li>合理的日志等级（debug, info, error, panic, fatal）</li></ol></li><li>Policy 授权策略结构</li><li>Request 请求验证方案<ol><li>支持 JSON 请求、表单请求、URL Query</li></ol></li><li>API 图片上传</li><li>图片裁切</li><li>数据库支持 mysql 和 sqlite</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于本项目是一个完全只涉及到 API 设计的内容，所以测试功能是否符合预期则是采用了 Postman 这款测试软件，有关 Redis 的可视化则是采用了 Another Redis Desktop Manager。</p><p>考虑到篇幅的问题，项目的知识点总结会分开来写。所以这篇文章是用来提醒我去学习的。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。&lt;/p&gt;
&lt;p&gt;本项目主要设计一下三部分的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 开发&lt;/li&gt;
&lt;li&gt;命令行开发&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>唉……</title>
    <link href="http://example.com/2024/04/14/%E5%94%89%E2%80%A6%E2%80%A6/"/>
    <id>http://example.com/2024/04/14/%E5%94%89%E2%80%A6%E2%80%A6/</id>
    <published>2024-04-14T09:21:21.000Z</published>
    <updated>2024-04-14T09:50:50.924Z</updated>
    
    <content type="html"><![CDATA[<p>文章是越写越慢，质量是越来越差，这周的甚至连标题都想不出来了，离谱。从标题也能看出来，这周应该是不太愉悦的，二面被挂就算了，还被另一个面试官给戏耍了。我懂了，找实习就一个字——摆。</p><h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>清明假期三天，每天都是两三个小时的做题时间，本周倒是没怎么做题。</p><p>原因是觉得刷了一个月的题了，还是在看到题目后几分钟就有思路了，但是不知道代码该怎么写，所以决定先沉淀几天。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>虽然最近几天算法进展不怎么样，项目进展还是不错的。</p><p>上周六开的新项目，其实还是这周才开始，项目内容和之前的项目好像没有什么太大的区别，一个是博客，一个是论坛。但是实际开发就是天差地别了，不仅仅将框架全部换了 <code>gin</code> ，还用上了 <code>redis</code>。是的，就是那个只要出现在简历上就会触发面试官被动的 <code>redis</code> ，当然，以防万一，我非常认真地背了 Redis 三兄弟。</p><p>项目中更加详细地内容还是等到下周专门来写吧，写在周报里好像不是很好记录。</p><h2 id="Go语言设计哲学"><a href="#Go语言设计哲学" class="headerlink" title="Go语言设计哲学"></a>Go语言设计哲学</h2><p>没想到这一块竟然还有后续，因为上一篇有些一些相关的内容，后续也有去了解 Go 和 C++ 的不同，也查了一些资料，感觉很有意思，后续应该会继续写相关的内容。</p><h2 id="找实习的进展"><a href="#找实习的进展" class="headerlink" title="找实习的进展"></a>找实习的进展</h2><p>有什么进展呢，最接近成功的也就是清明假期前的那次了，结果挂在了横向对比上，只能怪一面的时候回答的确实不怎么样。腾讯约了第三次面试，结果是个 KPI 面，一共就二十几分钟，面试官还迟到了，连自我介绍都没让做。</p><p>字节和小米都是简历直接就给挂了，其他的公司也看不上我的简历，只有等月底的华为喽。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，本周学的东西不算很多，因为考试加上心情不是很好，决定开摆一周，也没整理这周学的内容，所以周报也没什么好写的。那为什么还写呢，因为想找一个地方记录并发泄一下。</p><p>下周会把项目全部完成，调整后会继续刷题，那就期待着后续的博客更新吧。完成项目后会继续完善自己的简历，我想这个暑假应该是能找到实习的吧，希望是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章是越写越慢，质量是越来越差，这周的甚至连标题都想不出来了，离谱。从标题也能看出来，这周应该是不太愉悦的，二面被挂就算了，还被另一个面试官给戏耍了。我懂了，找实习就一个字——摆。&lt;/p&gt;
&lt;h1 id=&quot;学习内容&quot;&gt;&lt;a href=&quot;#学习内容&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学</title>
    <link href="http://example.com/2024/04/03/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
    <id>http://example.com/2024/04/03/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</id>
    <published>2024-04-03T13:16:08.000Z</published>
    <updated>2024-04-06T09:05:59.758Z</updated>
    
    <content type="html"><![CDATA[<p>实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。</p><p>在学习一门语言时，有没有考虑过这个语言的语法和格式为什么要这么设计？这个问题一听就是一个好的话题啊，为什么这么设计？为什么在已经有了那么多语言后，还要设计出Go语言？</p><p>那么好，闲话少说，这周的主要内容就改为Go语言的设计哲学。当然，文章内容并不是我原创的，更多的还是网上查到的资料。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Go 编程语言构思于 2007 年底，构思的目的是：为了解决在 Google 开发软件基础设施时遇到的一些问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b73ae4ab1b1ceb693aad4f978f1f2cc.jpg" alt="Go 语言之父"></p><p>图中的三位大佬就是 Go 语言最初的设计者，从左到右依次为：</p><ul><li>Robert Griesemer：参与过 Google V8 JavaScript 引擎和 Java HotSpot 虚拟机的研发。</li><li>Rob Pike：Unix 操作系统早期开发者之一，UTF-8 创始人之一，Go 语言吉祥物设计者是 Rob Pike 的媳妇。</li><li>Ken Thompson：图灵奖得主，Unix 操作系统早期开发者之一，UTF-8 创始人之一，C 语言（前身 B 语言）的设计者。</li></ul><p>那么好，我们来解释第一个问题，为什么这几个大佬要设计 Go 语言。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>曾经在早期的采访中，Google 大佬们反馈感觉 “编程” 太麻烦了，他们很不喜欢 C++，对于现在工作所用的语言和环境感觉比较沮丧，充满着许多不怎么好用的特性。</p><p>具体遭遇到的问题。如下：</p><ul><li>软件复杂：多核处理器、网络系统、大规模计算集群和网络编程模型所带来的问题只能暂时绕开，没法正面解决。</li><li>软件规模：软件规模也发生了变化，今天的服务器程序由数千万行代码组成，由数百甚至数千名程序员进行工作，而且每天都在更新（据闻 Go 就是在等编译的 45 分钟中想出来的）。</li><li>编译耗时：在大型编译集群中，构建时间也延长到了几分钟，甚至几小时。</li></ul><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>为了解决上述的问题，如果在既有语言上进行修改，需要解决很多根本性的问题，因此，他们决定重新设计一个语言。</p><p>这门新语言需要符合以下需求：</p><ul><li>目的：<strong>设计和开发 Go 是为了使在这种环境下能够提高工作效率</strong>。</li><li>设计：在 Go 的设计上，除了比较知名的方面：如内置并发和垃圾收集。还考虑到：严格的依赖性管理，随着系统的发展，软件架构的适应性，以及跨越组件之间边界的健壮性。</li></ul><p>这门新语言就是现在的 Go。</p><h1 id="Go-在-Google"><a href="#Go-在-Google" class="headerlink" title="Go 在 Google"></a>Go 在 Google</h1><p>Google 整体的应用软件很庞大，硬件也很庞大，有数百万行的软件，服务器主要是 C++ 语言，其他部分则是大量的 Java 和 Python。</p><p>数以千计的工程师在代码上工作，在一个由所有软件组成的单一树的 “头 “ 上工作，所以每天都会对该树的所有层次进行重大改变。一个大型的定制设计的分布式构建系统使得这种规模的开发是可行的，但它仍然很大。当然，所有这些软件都在几十亿台机器上运行，这些机器被视为数量不多的独立、联网的计算集群。</p><p>简而言之，Google 的开发规模很大，速度可能是缓慢的，而且往往是笨拙的。但它是有效的。</p><p>Go 项目的目标是：消除 Google 软件开发的缓慢和笨拙，从而使这个过程更富有成效和可扩展。<strong>这门语言是由编写、阅读、调试和维护大型软件系统的人设计的，也是为他们设计的</strong>。</p><p>因此 Go 的目的不是为了研究编程语言的设计，而是为了改善其设计者及其同事的工作环境。</p><h1 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h1><p>Go 的诞生，更多是为了方便程序员进行编程，而不是为了某项科学研究，这就是 Go 语言与其他编程语言的最大的不同。</p><p>当 Go 发布时，有些人声称它缺少被认为是现代语言的必要条件的特定功能或方法。在缺乏这些设施的情况下，Go怎么可能有价值？</p><p>我们的答案是：<strong>Go 所拥有的特性可以解决那些使大规模软件开发变得困难的问题。</strong></p><p>这些问题包括：</p><ul><li>构建速度缓慢。</li><li>不受控制的依赖关系。</li><li>每个程序员使用不同的语言子集。</li><li>对程序的理解不透彻（代码可读性差，文档不全等）。</li><li>工作的重复性。</li><li>更新的成本。</li><li>版本偏移（version skew）。</li><li>编写自动工具的难度。</li><li>跨语言的构建。</li></ul><p>纯粹一门语言的单个功能并不能解决这些问题，我们需要对软件工程有一个更大的看法。因此在 Go 的设计中，我们试图把重点放在这些问题的解决方案上。</p><h1 id="少即是多"><a href="#少即是多" class="headerlink" title="少即是多"></a>少即是多</h1><p>相信对 Go 语言有过了解的人都会经常听到诸如：less is more、少即是多、大道至简、大道不停地至简等黑话。</p><p>那么少即是多这种观点是谁提起的呢，正是 Go 语言之父的 Rob Pike。</p><p>Rob Pike 在多个场合提到过类似 “少即是多” 的观点，该观点广为流传。这种设计理念体现在 Go 语言的语法设计上，它的语法非常简洁，没有复杂的继承和泛型，也没有异常处理，但这并不影响它的功能性和表达力。</p><p>以下内容多为 Rob Pike 在一次演讲时提到的内容，对此感兴趣的可以去阅读一下 Rob Pike 的 <a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">Less is exponentially more</a> 演讲稿。</p><h2 id="Go-特性清单"><a href="#Go-特性清单" class="headerlink" title="Go 特性清单"></a>Go 特性清单</h2><ul><li>规范的语法（无需用于解析的符号表）。</li><li>垃圾收集（唯一）。</li><li>没有头文件。</li><li>明确依赖</li><li>无循环依赖。</li><li>常量只能为数字。</li><li>int 和 int32 是不同的类型。</li><li>字母大小写设定可见性。</li><li>任何类型都可以有方法（没有类）。</li><li>没有子类型继承（没有子类）。</li><li>包级别初始化和定义好的初始化顺序。</li><li>文件编译到一个包中。</li><li>包级别的全局表达与顺序无关。</li><li>没有算术转换（常量做了辅助处理）。</li><li>隐式的接口实现（无需“implements”定义）。</li><li>嵌入（没有向父类的升级）。</li><li>方法如同函数一样进行定义（没有特的别位置要求）。</li><li>方法就是函数。</li><li>接口仅仅包含方法（没有数据）。</li><li>方法仅通过名字匹配（而不是通过类型）。</li><li>没有构造或者析构方法。</li><li>后自增和后自减是语句，而不是表达式。</li><li>没有前自增或前自减。</li><li>赋值不是表达式。</li><li>按照赋值、函数调用定义时的顺序执行（没有“sequence point”）。</li><li>没有指针运算。</li><li>内存总是零值初始化。</li><li>对局部变量取地址合法。</li><li>方法没有“this”。</li><li>分段的堆栈。</li><li>没有静态或其他类型注解。</li><li>没有模板。</li><li>没有异常。</li><li>内建 string、slice、map。</li><li>数组边界检查。</li></ul><p>除了这个简化清单和一些未提及的琐碎内容，我相信，Go 相比 C 或者 C++ 是更加有表达力的。少既是多。</p><h2 id="无法想象没有泛型"><a href="#无法想象没有泛型" class="headerlink" title="无法想象没有泛型"></a>无法想象没有泛型</h2><p>当然明显缺少的是类型层次化。</p><p>在 Go 最初的版本中，有人告诉我他无法想像用一个没有泛型范型的语言来工作。就像之前在某些地方提到过的，我认为这绝对是神奇的评论。</p><p>公平的说，他可能正在用其自己的方式来表达非常喜欢 STL 在 C++ 中为他做的事情。在辩论的前提下，让我们先相信他的观点。</p><p>他说编写像 int 列表或 map string 这样的容器是一个无法忍受的负担。我觉得这是个神奇的观点。</p><p>即便是那些没有泛型范型的语言，我也只会花费很少的时间在这些问题上。</p><h2 id="面向对象的方式"><a href="#面向对象的方式" class="headerlink" title="面向对象的方式"></a>面向对象的方式</h2><p>但是更重要的是，他说类型是放下这些负担的解决途径。类型。不是函数多态，不是语言基础，或者其他协助，仅仅用类型。</p><p>这就是卡住我的细节问题。</p><p>从 C++ 和 Java 转过来 Go 的程序员怀念工作在类型上的编程方式，尤其是继承和子类，以及所有相关的内容。可能对于类型来说，我是门外汉，不过我真得从未发现这个模型十分具有表达力。</p><p>我已故的朋友 Alain Fournier 有一次告诉我说他认为学术的最低级形式就是分类。那么你知道吗？类型层次化就是分类。</p><p>你必须对哪块进哪个盒子作出决策，包括每个类型的父级，不论是 A 继承自 B，还是 B 继承自 A。</p><p>一个可排序的数组是一个排序过的数组还是一个数组表达的排序器？如果你坚信所有问题都是由类型驱动设计的，那么你就必须作出决策。</p><p>我相信这样思考编程是荒谬可笑的。核心不是东西之间的祖宗关系，而是它们可以为你做什么。</p><p>当然，这就是接口进入 Go 的地方。但是它们已经是蓝图的一部分，那是真正的 Go 哲学。</p><p>如果说 C++ 和 Java 是关于类型继承和类型分类的，Go 就是关于组合的。</p><p>Unix pipe 的最终发明人 Doug McIlroy 在 1964 (!) 这样写到：</p><blockquote><p>我们应当像连接花园里的龙头和软管一样，用某种方式一段一段的将消息数据连接起来。这同样是 IO 使用的办法。</p></blockquote><p>这也是 Go 使用的办法。Go 用了这个主意，并且将其向前推进了一大步。这是一个关于组合与连接的语言。</p><p>一个显而易见的例子就是接口为我们提供的组合元件的方式。只要它实现了方法 M，就可以放在合适的地方，而不关心它到底是什么东西。</p><p>另一个重要的例子是并发如何连接独立运行的计算。并且也有一个不同寻常（却非常简单）的类型组合模式：嵌入。</p><p>这就是 Go 特有的组合技术，滋味与 C++ 或 Java 程序完全不同。</p><h2 id="为什么-Go-不被-C-程序员喜欢"><a href="#为什么-Go-不被-C-程序员喜欢" class="headerlink" title="为什么 Go 不被 C++ 程序员喜欢"></a>为什么 Go 不被 C++ 程序员喜欢</h2><p>从上面的内容中，我们不难看出，Go 语言的设计者是十分不喜欢使用C++ 进行编程设计的。当然，在 Go 语言被设计并发布后，程序员没有了更多的选择。但是，相较于 C++ 程序员，其他语言的使用者好像更加喜欢 Go 语言。</p><p><strong>为什么 Go，一个被设计为用于摧毁 C++ 的语言，并为并未获得 C++ 程序员的芳心？</strong></p><p>这是因为 Go 和 C++ 有着完全不同的哲学。</p><p><strong>C++ 是让你的指尖解决所有的问题</strong>：</p><ul><li>C++ 与那些巨大增长的特别编写的手工代码相比，具有更加广泛的抽象，优雅、灵活并且零成本的表达能力。</li></ul><p><strong>Go 的主张更多考虑的是最小化程序员的工作量</strong>：</p><ul><li>Go 不是无所不包的。你无法通过内建获得所有东西。你无法精确控制每个细微的执行。</li><li><strong>你得到的是功能强大，但是容易理解的，容易用来构建一些用于连接组合解决问题的模块</strong>。</li><li>这可能最终不像你使用其他语言编写的解决方案那么快，那么精致，在思想体系上那么明确，但它确实会更加容易编写，容易阅读，容易理解，容易维护，并且更加安全。</li></ul><p>换句话说，当然，有些过于简单：</p><ul><li>Python 和 Ruby 程序员：转到 Go 是因为他们并未放弃太多的表达能力，但是获得了性能，并且与并发共舞。</li><li>C++ 程序员：无法转到 Go 是因为他们经过艰辛的战斗才获得对其语言的精确控制能力，而且也不想放弃任何已经获得的东西。对于他们，软件不仅仅是关于让工作完成，而是关于用一个确定的方式完成。</li></ul><h1 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h1><p>本段则是来自《<a href="https://www.youtube.com/watch?v=YXV7sa4oM4I">The Go Programming Language and Environment</a>》这篇演讲稿。</p><p>出身 Google 的 Go 语言严格意义上来说就是出身于名门望族了，那么十多年过去了，它发展地怎么样了？</p><h2 id="Go-怎么样了"><a href="#Go-怎么样了" class="headerlink" title="Go 怎么样了"></a>Go 怎么样了</h2><p>Rob Pike 表示其实 Go 目前还不能算做主流语言，但是在全世界的影响力和发展都大大的超出了预期。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/958c55da2ff41616a0ae6c88bade062a.png" alt="img"></p><p>像在国内的我们，能够很明显感知到，Go 在近 3~5 年的用户群体不断增大，一些大厂也已经开始转 Go ，甚至有的公司就是全部用 Go 语言来进行工作的。</p><p>Go 并不是那种非常 “有趣” 的语言，在技术上（语言理论、设计）几乎没有什么大进步。当然，这也不是 Go 核心团队的设计目标。</p><p>但就是这么一门语言，他主导了大部分 CNCF 中的项目，例如：K8s、Docker 等，特别牛。<strong>Go 是云基础设施的语言，这是怎么发生的</strong>？</p><h2 id="Go-为什么成功"><a href="#Go-为什么成功" class="headerlink" title="Go 为什么成功"></a>Go 为什么成功</h2><p>Go 从一门无人问津的语言，到现在承担了各云基础设施的核心，变得很重要，也是一种成功实践。</p><p>Rob Pike 认为成功的因素有如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/408cea989ce5e27baff2038e2c99377b.png" alt="img"></p><p>核心观点：<strong>一门编程语言的成功取决于其他很多方面，Go 语言是面向软件开发的，而不仅仅只是编程</strong>。</p><p>为此，Go 就是为了解决软件开发而生，而非只是编程，这是成功的关键因素。</p><h1 id="回答面试官的问题"><a href="#回答面试官的问题" class="headerlink" title="回答面试官的问题"></a>回答面试官的问题</h1><p>在最后<strong>回答一下面试官的问题</strong>，不知道还有没有机会了，就在自己的博客里写一下吧。</p><p>问：一个语言在设计时将其语法结构设计成某种特殊的样子，如 Go 语言中花括号必须要和语句在同一行、Python 中使用缩进来替代花括号，这样的设计有什么原因吗？</p><p>答：无论结构怎么设计，对于机器来说都是没有区别的，无论是花括号还是缩进，能影响的就是有人。那么对于设计者来说，设计语言的一些特性主要还是根据他的思路以及设计哲学。</p><p>Python使用缩进替代花括号的原因有以下几种：</p><ul><li>缩进语法，更加优雅</li><li>缩进语法，更加清晰</li><li>使用缩进，保持一致性，避免造成误读</li><li>使用缩进，代码更紧凑，便于浏览，没有累赘</li><li>使用缩进，已足够令解释器执行，没必要使用多余的符号</li><li>强制缩进，源自古老的 ABC 语言，Guido 是这门语言的设计者之一</li><li>其思想可能出自 Don Knuth(高德纳，著名计算机科学家，经典巨著《计算机程序设计艺术》的作者)，他在 1974 年提出，在当时是很时髦和前卫的思想</li><li>使用缩进，可以终结大括号放在函数名后面还是再换一行的终极争论(据说此话题能令不同派系的程序员大打出手！)</li></ul><p>从 Python 发布至今，关于缩进是不是其设计的败笔就一直被大家讨论，我只能说见仁见智。</p><hr><p>对了，还有一个问题，关于我的博客界面左上角一直显示的加载中的字样，已经修复好了。</p><p>至于是怎么修好的，其实到现在我都不知道是哪里出了问题，也找不到类似的情况和解决方法，就只能把前端的美化“恢复出厂设置”了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们大致了解了 Go 语言的开发背景和开发理念。</p><p>当然本文中的大多数内容都是我看到别人的文章以及 Go 语言之父的演讲稿。</p><p>关于更加细节的开发和设计理念，我还在学习当中，后续会根据学习的情况更新文章，Go语言最为重要的并发还没开始，这个系列就肯定不会结束。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://golang3.eddycjy.com/posts/started-go/">https://golang3.eddycjy.com/posts/started-go/</a></li><li><a href="https://zhuanlan.zhihu.com/p/645695890">https://zhuanlan.zhihu.com/p/645695890</a></li><li><a href="https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f">https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f</a></li><li><a href="https://blog.csdn.net/weixin_39915668/article/details/111451430">https://blog.csdn.net/weixin_39915668/article/details/111451430</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。&lt;/p&gt;
&lt;p&gt;在学习一门语言时，有没有考虑过这个语言的语法和格式为什么</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>操作数据库</title>
    <link href="http://example.com/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2024-03-26T06:34:52.000Z</published>
    <updated>2024-05-31T12:37:07.500Z</updated>
    
    <content type="html"><![CDATA[<p>目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。那么这一节我们就要开始学习如何将数据存入数据库。</p><h1 id="操作-MySQL-数据库"><a href="#操作-MySQL-数据库" class="headerlink" title="操作 MySQL 数据库"></a>操作 MySQL 数据库</h1><p>在本项目中所选用的数据库为<code>MySQL</code>，使用GO操作<code>MySQL</code>等数据库，一般有两种方法：</p><ul><li>一是利用 database/sql 接口，直接在代码里硬编码 sql 语句；</li><li>二是使用 ORM，具体一点是 GORM，以对象关系映射的方式在抽象地操作数据库。</li></ul><h2 id="database-sql"><a href="#database-sql" class="headerlink" title="database/sql"></a>database/sql</h2><p><code>database/sql</code> 包通过提供统一的编程接口，实现了对不同数据库驱动的抽象。</p><h3 id="大致原理"><a href="#大致原理" class="headerlink" title="大致原理"></a>大致原理</h3><ol><li><code>Driver</code> 接口定义：<code>database/sql/driver</code> 包中定义了一个 <code>Driver</code> 接口，该接口用于表示一个数据库驱动。驱动开发者需要实现该接口来提供与特定数据库的交互能力。</li><li><code>Driver</code> 注册：驱动开发者需要在程序初始化阶段，通过调用 <code>database/sql</code> 包提供的 <code>sql.Register()</code> 方法将自己的驱动注册到 <code>database/sql</code> 中。这样，<code>database/sql</code> 就能够识别和使用该驱动。</li><li>数据库连接池管理：<code>database/sql</code> 维护了一个数据库连接池，用于管理数据库连接。当通过 <code>sql.Open()</code> 打开一个数据库连接时，<code>database/sql</code> 会在合适的时机调用注册的驱动来创建一个具体的连接，并将其添加到连接池中。连接池会负责连接的复用、管理和维护工作，并且这是并发安全的。</li><li>统一的编程接口：<code>database/sql</code> 定义了一组统一的编程接口供用户使用，如 <code>Prepare()</code>、<code>Exec()</code> 和 <code>Query()</code> 等方法，用于准备 SQL 语句、执行 SQL 语句和执行查询等操作。这些方法会接收参数并调用底层驱动的相应方法来执行实际的数据库操作。</li><li>接口方法的实现：驱动开发者需要实现 <code>database/sql/driver</code> 中定义的一些接口方法，以此来支持上层 <code>database/sql</code> 包提供的 <code>Prepare()</code>、<code>Exec()</code> 和 <code>Query()</code> 等方法，以提供底层数据库的具体实现。当 <code>database/sql</code> 调用这些方法时，实际上会调用注册的驱动的相应方法来执行具体的数据库操作。</li></ol><p>通过以上的机制，<code>database/sql</code> 包能够实现对不同数据库驱动的统一封装和调用。用户可以使用相同的编程接口来进行数据库操作，无需关心底层驱动的具体细节。这种设计使得代码更具可移植性和灵活性，方便切换和适配不同的数据库。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><code>database/sql</code> 具有如下特点：</p><ul><li>统一的编程接口：<code>database/sql</code> 库提供了一组统一的接口，使得开发人员可以使用相同的方式操作不同的数据库，而不需要学习特定数据库的 API。</li><li>驱动支持：通过导入第三方数据库驱动程序，<code>database/sql</code> 可以与多种常见的关系型数据库系统进行交互，如 MySQL、PostgreSQL、SQLite 等。</li><li>预防 SQL 注入：<code>database/sql</code> 库通过使用预编译语句和参数化查询等技术，有效预防了 SQL 注入攻击。</li><li>支持事务：事务是一个优秀的 SQL 包必备功能。</li></ul><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>与数据库建立连接的代码非常简单，只需调用 <code>sql.Open()</code> 函数即可。它接收两个参数：</p><ul><li>驱动名称</li></ul><p>这里驱动名称为 <code>mysql</code>，<code>database/sql</code> 之所以能够识别这个驱动名称，是因为在匿名导入 <code>github.com/go-sql-driver/mysql</code> 时，这个库内部调用了 <code>sql.Register</code> 将其注册给了 <code>database/sql</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sql.Register(<span class="string">&quot;mysql&quot;</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言中，一个包的 <code>init</code> 方法会在导入时会被自动调用，这里完成了驱动程序的注册。这样在调用 <code>sql.Open()</code> 时才能找到 <code>mysql</code> 驱动。</p><ul><li>DSN</li></ul><p>第二个参数 DSN 全称 <code>Data Source Name</code>，数据库的源名称，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// [用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表</span><br><span class="line">[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</span><br></pre></td></tr></table></figure><p>为了更加直观，我们可以使用 <code>mysql.Config</code> 来创建连接信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据库连接信息</span></span><br><span class="line">config := mysql.Config&#123;</span><br><span class="line">    User:                 <span class="string">&quot;homestead&quot;</span>,</span><br><span class="line">    Passwd:               <span class="string">&quot;secret&quot;</span>,</span><br><span class="line">    Addr:                 <span class="string">&quot;127.0.0.1:3306&quot;</span>,</span><br><span class="line">    Net:                  <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">    DBName:               <span class="string">&quot;goblog&quot;</span>,</span><br><span class="line">    AllowNativePasswords: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sql.Open()</code> 调用后将返回一个 <code>*sql.DB</code> 类型，可以用来操作数据库。</p><p>另外，我们调用 <code>defer db.Close()</code> 来释放数据库连接。其实这一步操作也可以不做，<code>database/sql</code> 底层连接池会帮我们处理。一旦关闭了连接，就不可以再继续使用这个 <code>db</code> 对象了。</p><p><code>*sql.DB</code> 的设计是用来作为长连接使用的，所以不需要频繁的进行 <code>Open</code> 和 <code>Close</code> 操作。如果我们需要连接多个数据库，则可以为每个不同的数据库创建一个 <code>*sql.DB</code> 对象，保持这些对象为 <code>Open</code> 状态，不必频繁使用 <code>Close</code> 来切换连接。</p><p>值得注意的是，其实 <code>sql.Open()</code> 并没有真正建立数据库连接，它只是准备好了一切，以备后续使用，连接将在第一次被使用时延迟建立。</p><p>这样的设计虽然合理，可也有些违反直觉，<code>sql.Open()</code> 甚至不会校验 DSN 参数的合法性。不过我们可以使用 <code>db.Ping()</code> 方法来主动检查连接是否能被正确建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连接池设置"><a href="#连接池设置" class="headerlink" title="连接池设置"></a>连接池设置</h4><p>使用 <code>sql.Open()</code> 并不会建立一个唯一的数据库连接，事实上，<code>database/sql</code> 会维护一个连接池。</p><p>我们可以通过如下方法，控制连接池的一些参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(<span class="number">5</span> * time.Minute)</span><br></pre></td></tr></table></figure><h5 id="SetMaxOpenConns-最大连接数"><a href="#SetMaxOpenConns-最大连接数" class="headerlink" title="SetMaxOpenConns 最大连接数"></a>SetMaxOpenConns 最大连接数</h5><p>设置连接池最大打开数据库连接数，&lt;= 0 表示无限制，默认为 0。</p><ul><li>应该设置多大？<ul><li>实验表明，在高并发的情况下，将值设为大于 10，可以获得比设置为 1 接近六倍的性能提升。而设置为 10 跟设置为 0（也就是无限制），在高并发的情况下，性能差距不明显。</li></ul></li><li>是否越大越好？<ul><li>需要考虑的是不要超出数据库系统设置的最大连接数。另外，还需要注意这个值是整个系统的，如有其他应用程序也在共享这个数据库，这个可以合理地控制小一点。</li></ul></li></ul><h5 id="SetMaxIdleConns-空闲连接数"><a href="#SetMaxIdleConns-空闲连接数" class="headerlink" title="SetMaxIdleConns 空闲连接数"></a>SetMaxIdleConns 空闲连接数</h5><p>设置连接池最大空闲数据库连接数，&lt;= 0 表示不设置空闲连接数，默认为 2。</p><ul><li>应该设置多大？<ul><li>实验表明，在高并发的情况下，将值设为大于 0，可以获得比设置为 0 <strong>超过 20 倍的性能提升</strong>。</li><li>这是因为设置为 0 的情况下，每一个 SQL 连接执行任务以后就销毁掉了，执行新任务时又需要重新建立连接。很明显，重新建立连接是很消耗资源的一个动作。</li><li>设置空闲连接数，当有新任务进来时，直接使用这些随时待命的连接传输数据，以此达到节约资源，提高执行效率的目的。</li></ul></li><li>是不是数值越大越好？<ul><li>首先此值不能大于 <code>SetMaxOpenConns</code> 的值，大于的情况下 mysql 驱动会自动将其纠正。</li><li>其次需要考虑的是，长时间打开大量的数据库连接需要占用系统的内存和 CPU 资源。</li><li>还有一个情况是 MySQL 会有一个 <code>wait_timeout</code> 的设置，连接超过这个时间就会被自动关闭，默认情况下是 8 个小时。当 MySQL 关闭连接时，sql.DB 请求到的就是一个坏的连接，虽然 sql 包里已经做了处理，当请求到坏连接时会自动重连。但是在这种情况下，单次请求相当于建立了两次连接，消耗比设置为 0 还大，得不偿失。</li><li>所以回答上面的问题，不是越大越好，应根据实际情况选择合理的值。</li></ul></li></ul><h5 id="SetConnMaxLifetime-过期时间"><a href="#SetConnMaxLifetime-过期时间" class="headerlink" title="SetConnMaxLifetime 过期时间"></a>SetConnMaxLifetime 过期时间</h5><p>设置连接池里每一个连接的过期时间，过期会自动关闭。理论上来讲，在并发的情况下，此值越小，连接就会越快被关闭，也意味着更多的连接会被创建。</p><ul><li>应该设置多大？<ul><li>设置的值不应该超过 MySQL 的 <code>wait_timeout</code> 设置项（默认情况下是 8 个小时）。</li><li>此值也不宜设置过短，关闭和创建都是极耗系统资源的操作。</li><li>设置此值时，需要特别注意 SetMaxIdleConns 空闲连接数的设置。假如设置了 100 个空闲连接，过期时间设置了 1 分钟，在没有任何应用的 SQL 操作情况下，数据库连接每 1.6 秒就销毁和新建一遍。</li><li>这里的推荐，比较保守的做法是设置五分钟</li></ul></li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><code>sql.DB</code> 提供了 <code>Exec</code> 方法来执行一条 SQL 命令，可以用来<strong>创建</strong>、<strong>更新</strong>、<strong>删除</strong>表数据等。</p><p>语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Exec(<span class="string">`INSERT INTO user(name, email, age, birthday, salary) VALUES(?, ?, ?, ?, ?)`</span>, user.Name, user.Email, user.Age, user.Birthday, user.Salary)</span><br></pre></td></tr></table></figure><p>其中 <code>?</code> 作为参数占位符，不同数据库驱动程序的占位符可能不同，可以参考数据库驱动的文档。</p><p>我们将这 5 个参数顺序传递给 <code>db.Exec</code> 方法，即可完成用户的创建。</p><p><code>db.Exec</code> 方法调用后将返回 <code>sql.Result</code> 保存结果以及一个 <code>error</code> 来标记错误。</p><p><code>sql.Result</code> 是一个接口，它包含两个方法：</p><ul><li><code>LastInsertId() (int64, error)</code>：返回新插入的用户 ID。只用在 <code>INSERT</code> 语句且数据表有自增 ID 时才有返回自增 ID 值，否则返回 0。</li><li><code>RowsAffected() (int64, error)</code>：返回当前操作受影响的行数，我们以此来判断 <code>SQL</code> 语句是否执行成功。</li></ul><p>接口具体实现有数据库驱动程序来完成。</p><p>此外，<code>database/sql</code> 还提供了预处理方法 <code>*sql.DB.Prepare</code> 创建一个准备好的 SQL 语句，在循环中使用预处理，则可以减少与数据库的交互次数。</p><p>比如我们需要创建两个用户，则可以先使用 <code>db.Prepare</code> 创建一个 <code>*sql.Stmt</code> 对象，然后多次调用 <code>*sql.Stmt.Exec</code> 方法来插入数据。</p><p><code>db.Prepare</code> 是预先将一个数据库连接和一个条 SQL 语句绑定并返回 <code>*sql.Stmt</code> 结构体，它代表了这个绑定后的连接对象，是并发安全的。</p><p>通过使用预处理，可以避免在循环中执行多次完整的 SQL 语句，从而显著减少了数据库交互次数，这可以提高应用程序的性能和效率。</p><p>使用预处理，会在 <code>db.Prepare</code> 时从连接池获取一个连接，之后循环执行 <code>stmt.Exec</code>，最终释放连接。</p><p>如果使用 <code>db.Exec</code>，则每次循环时都需要：获取<strong>连接-执行 SQL-释放连接</strong>，这几个步骤，大大增加了与数据库的交互次数。</p><p>不要忘记调用 <code>stmt.Close()</code> 关闭连接，这个方法是密等的，可以多次调用。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在创建数据库并插入相应值后，我们就可以进行查询操作了。</p><p>因为 <code>Exec</code> 方法只会执行 SQL，不会返回结果，所以不适用于查询数据。<code>*sql.DB</code> 提供了 <code>Query</code> 方法执行查询操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>如下获取所有文章的例子：：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * from articles&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>Query()</code> 方法返回一个 <code>sql.Rows</code> 结构体，代表一个查询结果集。</p><blockquote><p>Query 和 Exec 都可以执行 SQL 语句，<strong>那他们的区别是什么呢？</strong></p><p>Exec 只会返回最后插入 ID 和影响行数，而 Query 会返回数据表里的内容（结果集）。</p><p>或者可以这么记：</p><p>Query 中文译为 <strong>查询</strong>，而 Exec 译为 <strong>执行</strong>。想查询数据，使用 Query。想执行命令，使用 Exec。</p></blockquote><ul><li><code>rows.Next()</code> 方法用来判断是否还有下一条结果，可以用于 <code>for</code> 循环，如果存在下一条结果，<code>rows.Next()</code> 将返回 <code>true</code>。</li><li><code>rows.Scan()</code> 方法可以将结果扫描到传递进来的指针对象。<code>rows.Scan()</code> 会将一行记录分别填入指定的变量中，并且会自动根据目标变量的类型处理类型转换的问题，比如数据库中是 <code>varchar</code> 类型，会映射成 Go 中的 <code>string</code>，但如果与之对应的目标变量是 <code>int</code>，那么转换失败就会返回 <code>error</code>。</li></ul><p>如果是读取一行数据，可以使用 <code>QueryRow()</code>，语法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><p>返回的是一个 <code>sql.Row</code> 对象，与其相关的调用有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Row)</span></span> Scan(dest ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure><p><code>sql.Row</code> 没有 <code>Close</code> 方法，当我们调用 <code>Scan()</code> 时就会自动关闭 SQL 连接。所以为了防止忘记关闭而浪费资源，一般需要养成连着调用 <code>Scan()</code> 习惯。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新操作同创建一样可以使用 <code>*sql.DB.Exec</code> 方法来实现，不过这里我们将使用 <code>*sql.DB.ExecContext</code> 方法来实现。</p><p><code>ExecContext</code> 方法与 <code>Exec</code> 方法在使用上没什么两样，只不过第一个参数需要接收一个 <code>context.Context</code>，它允许你控制和取消执行 SQL 语句的操作。使用上下文可以在需要的情况下设置超时时间、处理请求取消等操作。</p><p>三个常用的 SQL 请求方法都有其支持上下文的版本，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><p>支持 Context 上下文的方法传参标准库 context 里的 context.Context 对象实例。</p><p>在一些特殊场景里，我们需要 SQL 请求在执行还未完成时，我们可以取消他们（cancel），或者为请求设置最长执行时间（timeout），就会用到这些方法。</p><p>另外需要知道的是，所有的请求方法底层都是用其上下文版本的方法调用，且传入默认的上下文，例如 <code>Exec()</code> 的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.ExecContext(context.Background(), query, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层调用的是 <code>ExecContext()</code> 方法。<code>context.Background()</code> 是默认的上下文，这是一个空的 <code>context</code> ，我们无法对其进行取消、赋值、设置 deadline 等操作。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>同更新的语句是一样的，只需要把语句稍作更改即可。</p><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>如果没有开启事务，当其中某个语句执行错误，则前面已经执行的 SQL 语句无法回滚。对于一些要求比较严格的业务逻辑来说，如付款、转账等，应该在同一个事务中提交多条 SQL 语句，避免发生执行出错无法回滚事务的情况。</p><p>使用以下可以开启事务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin() (*Tx, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> BeginTx(ctx context.Context, opts *TxOptions) (*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Begin()</code> 和 <code>BeginTx()</code> 方法返回一个 <code>sql.Tx</code> 结构体，他支持以上我们提到过的几种查询方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预编译 Prepare</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Stmt(stmt *Stmt) *Stmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> StmtContext(ctx context.Context, stmt *Stmt) *Stmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> PrepareContext(ctx context.Context, query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>使用这同一个 <code>sql.Tx</code> 对数据库进行操作，就会在同一个事务中提交。</p><p>当使用 <code>sql.Tx</code> 的操作方式操作数据后，需要使用 <code>sql.Tx</code> 的 <code>Commit()</code> 方法提交事务，如果出错，则可以使用 <code>sql.Tx</code> 中的 <code>Rollback()</code> 方法回滚事务，保持数据的一致性，下面是这两个方法的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Commit() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Rollback() <span class="type">error</span></span><br></pre></td></tr></table></figure><p>下面是个简单的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Service)</span></span> DoSomething() (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建事务</span></span><br><span class="line">    tx, err := s.db.Begin()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果请求失败，就回滚所有 SQL 操作，否则提交</span></span><br><span class="line">    <span class="comment">//    defer 会在当前方法的最后执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        err = tx.Commit()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行各种请求</span></span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，所有 SQL 操作都必须使用 <code>tx</code> 来操作，才能支持事务，如果中间使用 <code>db.Exec()</code> 那这条语句是无法回滚的。</p><h2 id="集成-GORM"><a href="#集成-GORM" class="headerlink" title="集成 GORM"></a>集成 GORM</h2><h3 id="什么是-ORM-？"><a href="#什么是-ORM-？" class="headerlink" title="什么是 ORM ？"></a>什么是 ORM ？</h3><p>ORM 全称是：Object Relational Mapping (对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象（结构体），那就对应着一张表，这个对象的实例，就对应着表中的一条记录。</p><h3 id="为什么要使用-GORM？"><a href="#为什么要使用-GORM？" class="headerlink" title="为什么要使用 GORM？"></a>为什么要使用 GORM？</h3><p>本项目使用 GORM 的理由：</p><ol><li>现代化，面对对象</li><li>多数据库支持，为高负载做好准备</li><li>提高项目安全性</li><li>提升开发效率和项目的可维护性</li></ol><p>我们都知道，在正式环境中直接使用 SQL 来查询数据库是很危险的，处理不好就有被注入式攻击的风险。而且组装 SQL 语句也容易出错和减低代码的可维护性。所以需要一个工具来管理数据库语句的组装和操作。</p><p>GORM 是目前比较成熟的 Go 语言数据库管理库，它可以很方便的把 Go 的结构体和数据库表绑定，从而简化获取数据的操作。</p><p>GORM 功能包括下面：</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context，预编译模式，DryRun 模式</li><li>批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><p>以上列表熟悉下即可，后面的项目开发中使用到自然就会记住了，脱离实战记忆没有意义。</p><h3 id="连接数据库-1"><a href="#连接数据库-1" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>与<code>database/sql</code>操作类似，使用<code>gorm.Open()</code>函数即可，该函数同样有两个参数：</p><ul><li>驱动名称</li><li>DSN</li></ul><p><code>*gorm.DB</code> 对象有一个方法 <code>DB()</code> 可以直接获取到 database/sql 包里的 <code>*sql.DB</code> 对象。<strong>GORM 底层也是使用 database/sql 来管理连接池</strong>。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><code>db.Create</code>方法可以新建一条数据，传入的是一个表结构体指针，返回值是一个<code>gorm.DB</code>,即我们的数据库连接。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Create(&amp;ormdemo.UserInfo&#123;</span><br><span class="line">    Name:   <span class="string">&quot;jaylog&quot;</span>,</span><br><span class="line">    Gender: <span class="string">&quot;man&quot;</span>,</span><br><span class="line">    Hobby:  <span class="string">&quot;pingpong&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你想避免<code>ErrRecordNotFound</code>错误，你可以使用<code>Find</code>，比如<code>db.Limit(1).Find(&amp;user)</code>，<code>Find</code>方法可以接受struct和slice的数据。</p><p>对单个对象使用<code>Find</code>而不带limit，<code>db.Find(&amp;user)</code>将会查询整个表并且只返回第一个对象，这是性能不高并且不确定的。</p></blockquote><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p><code>Save</code> 会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br></pre></td></tr></table></figure><p>当使用 <code>Update</code> 更新单列时，需要有一些条件，否则将会引起<code>ErrMissingWhereClause</code> 错误，当使用 <code>Model</code> 方法，并且它有主键值时，主键将会被用于构建条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据条件更新</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User 的 ID 是 `111`</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件和 model 的值进行更新</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><p><code>Updates</code> 方法支持 <code>struct</code> 和 <code>map[string]interface&#123;&#125;</code> 参数。当使用 <code>struct</code> 更新时，默认情况下GORM 只会更新非零值的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 `struct` 更新属性，只会更新非零值的字段</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 `map` 更新属性</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>删除一条记录时，删除对象需要指定主键，否则会触发批量删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><p>GORM 允许通过主键(可以是复合主键)和内联条件来删除对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们已经完成地了解了如何使用两种不同方法来操作数据库。数据库的操作是本项目的重中之重，好好理解这一节的内容对面是有着不小的帮助，因为笔者的第一次面试就是挂在关于数据库的问题上的。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://gorm.io/zh_CN/docs/index.html">GORM</a></li><li><a href="https://xie.infoq.cn/article/6bd776b9af4f1996603ef0948">database/sql</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。那么这一节我们就要开始学习如何将数据存入数据库。&lt;/p&gt;
&lt;h1 id=&quot;操作-MySQL-数据库&quot;&gt;&lt;a href=&quot;#操作-MySQL-数据库&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>路由和中间件</title>
    <link href="http://example.com/2024/03/25/%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2024/03/25/%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2024-03-25T08:07:46.000Z</published>
    <updated>2024-04-06T14:26:04.873Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要用于介绍<code>GoBlog</code>项目中两个最为重要的部分——路由和中间件。这两个部分可以说是本项目的重要组成部分，下面我们会逐个进行学习和分析，并大概介绍其在项目中的作用。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>goblog 需要一款灵活的路由器来搭配 MVC 程序结构，恰巧Go Web 开发有各式各样的路由器可供选择。这个时候可能就有朋友要问了，什么是路由啊，路由有什么用呢？额……其实我在学的时候也有这样的问题，那就慢慢往下看吧。</p><h2 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h2><p>路由，<strong>就是URL地址到业务处理代码的映射</strong>。当用户输入一个<code>URL</code>地址时，服务器改知道要返回什么内容，一个 <code>URL</code> 到一个具体的处理函数之间的映射叫做一条路由。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/6decf088ea6d29afbee3c19acc63c4de.png" alt="img"></p><p>多条路由组成路由表，路由表主要用于路由查找，根据不同的路由表的组织形式，可以有不同的查找方法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e98393a4afcc24a509f1d169d8360fad.png" alt="img"></p><p>给定一个<code>URL</code>，找到对应的处理函数的过程叫做路由查找。路由器就是用来管理路由表并进行路由查找的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0bda1fefe4d9adbf3a91bc13466c85c0.png" alt="img"></p><p>所以，在<code>Web</code>系统中一个路由系统由路由、路由表和路由匹配三部分功能组成。</p><p>路由实现由三种方法，分别是基于映射表、正则表达式以及tries结构的路由实现，下面将会一一介绍。</p><h2 id="基于映射表的路由实现"><a href="#基于映射表的路由实现" class="headerlink" title="基于映射表的路由实现"></a>基于映射表的路由实现</h2><p><code>Go</code>内建标准包<code>bet/http</code>中路由的实现是基于映射表实现的，也是最简单的路由。</p><h3 id="http怎么处理请求"><a href="#http怎么处理请求" class="headerlink" title="http怎么处理请求"></a>http怎么处理请求</h3><p><code>Go</code> 语言中处理 <code>HTTP</code> 请求主要跟两个东西相关：<code>ServeMux</code> 和 <code>Handler</code>。</p><p><code>ServeMux</code> 本质上是一个 <strong>HTTP 请求路由器</strong>（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的<strong>处理器（Handler）</strong>。</p><p>下面来看 <code>HandleFunc</code>函数的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>pattern</code> 是 URI 的规则，例如 <code>/</code> 或者 <code>about</code></li><li><code>handler</code> 是供调用的函数</li></ul><p><code>http.HandleFunc()</code> 函数是对 <code>DefaultServeMux.HandleFunc()</code> 的封装，当 <code>http.ListenAndServe(addr string, handler Handler)</code> 的第二个参数为 <code>nil</code> 时，会使用<code>DefaultServeMux.HandleFunc()</code></p><h3 id="net-http包中路由的实现"><a href="#net-http包中路由的实现" class="headerlink" title="net/http包中路由的实现"></a>net/http包中路由的实现</h3><p>在<code>net/http</code>包中实现路由的机构提是<code>ServeMux</code>，其结构定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line"> mu    sync.RWMutex</span><br><span class="line"> m     <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line"> es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line"> hosts <span class="type">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段很简单，我们重点看m变量，是一个map类型，即key-value结构，就是我们所说的路由表。key就是路由的路径，value是一个<code>muxEntry</code>对象，<code>muxEntry</code>结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line"> h       Handler</span><br><span class="line"> pattern <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pattern</code>是对应的路径，<code>h</code>就是对应的处理函数。当我们进行路由注册时候，实质上就是将路径和<code>HomeHandler</code>对象构建成一个<code>muxEntry</code>对象，然后加入到<code>ServeMux</code>的<code>m</code>中。</p><p>接下来我们再看路<strong>由的查找</strong>，既然路由表是有map实现的，那么路由的查找过程自然就是通过路径从map中查找对应的<code>muxEntry</code>，然后获取对应的<code>handler</code>即可。</p><p>以上就是<code>net/http</code>包中自己路由的实现。非常简单，同时也意味着功能有限。</p><h3 id="http-ServeMux-的局限性"><a href="#http-ServeMux-的局限性" class="headerlink" title="http.ServeMux 的局限性"></a>http.ServeMux 的局限性</h3><p>http.ServeMux 在 goblog 中使用，会遇到以下几个问题：</p><ul><li>不支持 URI 路径参数</li><li>不支持请求方法过滤<ul><li>无法直接从路由上区分 POST 或者 GET 等 HTTP 请求方法，只能手动判断。</li></ul></li><li>不支持路由命名<ul><li>路由命名是一套允许我们快速修改页面里显示 URL 的机制。</li></ul></li></ul><p><strong>优点</strong></p><ul><li>标准库意味着随着 Go 打包安装，无需另行安装</li><li>测试充分</li><li>稳定、兼容性强</li><li>简单，高效</li></ul><p><strong>缺点</strong></p><ul><li>缺少 Web 开发常见的特性</li><li>在复杂的项目中使用，需要你写更多的代码</li></ul><h2 id="基于正则表达式的路由实现"><a href="#基于正则表达式的路由实现" class="headerlink" title="基于正则表达式的路由实现"></a>基于正则表达式的路由实现</h2><p>该包是基于正则表达式实现的路由。该路由支持分组、restful风格路径的定义、绑定路由请求的方法（GET、POST等）、限定路径使用http还是https协议等功能。在本项目中所使用到的路由就是这个。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>通过<code>mux.NewRouter()</code>方法返回了一个<code>Router</code>结构体对象。该结构体对象也实现了<code>ServeHTTP</code>方法，在该方法中<strong>实现了对路由的匹配和转发</strong>。所以覆盖作为<code>http.ListenAndServe</code>的第二个参数，替代了默认的路由分发对象<code>DefaultServeMux</code>。</p><p>在该包中<code>Router</code>的<code>ServeHTTP</code>方法对路由的匹配和分发部分，本质上是和默认的路由分发器DefaultServeMux的实现是一样的。不同的是路由的管理以及匹配上。</p><p>Router 结构体如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d03836d9ccfb7e93bba1e54793c04908.png" alt="img"></p><p>这里我们只列出来核心的字段，省略了一些辅助字段。这里有几个主要的字段：</p><ul><li><strong>Router</strong>中的routes：Route切片类型，角色是路由表，存储所有的路由。</li><li><strong>Route</strong>：一个具体的路由，handler字段存储的是具体的处理函数，同时每个路由的路径是在最后的routeRegexp结构体中的。</li><li><strong>matchers</strong>字段：切片类型，存储了该路由下的所有要匹配的规则。matchers的类型是一个matcher接口，定义了Match方法。其中routeRegexp结构体实现了该方法，所以一个routeRegexp实例就是一个matcher。</li><li><strong>routeRegexp</strong>结构体：该结构体代表了路由中具体的路径的匹配规则。将路由中的路径转换成对应的正则表达式，存储与regexp字段中。</li></ul><p><strong>routeRegexp</strong>结构体中的主要字段分别如下：</p><ul><li><strong>template</strong>：保存的是路由的路径模版。比如<code>r.HandleFunc(&quot;/product/&#123;id:[0-9]+&#125;&quot;, ProductHandler)</code>中，则是<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code></li><li><strong>regexpType</strong>：正则类型，目前支持regexpTypePath、regexpTypeHost、regexpTypePrefix、regexpTypeQuery四种类型。比如<code>r.HandleFunc(&quot;/product/&#123;id:[0-9]+&#125;&quot;, ProductHandler)</code>就是路径匹配regexpTypePath。而<code>r.Host(&quot;www.example.com&quot;)</code>就是域名匹配regexpTypeHost。稍后我们会一一介绍。</li><li><strong>regexp</strong>：是根据路由中的模版路径构造出来的正则表达式。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，最终构造的正则表达式是 <code>^/product/(?P&lt;v0&gt;[0-9]+)$�</code><br>reverse：</li><li><strong>varsN</strong>：是路径模式中花括号{}中的变量个数。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，varsN则等于[]{“id”}。</li><li><strong>varsR</strong>：是路径模式中每个花括号{}对应的正则表达式。以<code>&quot;/product/&#123;id:[0-9]+&#125;&quot;</code>为例，varsR则等于<code>[]&#123;&quot;^[0-9]+$&quot;&#125;</code>。如果路由中是设置<code>r.HandleFunc(&quot;/product/&#123;id&#125;&quot;, ProductHandler)</code>，varsR的元素则是<code>[]&#123;&quot;^[^/]+�&quot;&#125;</code>的正则表达式。</li></ul><p>根据路由表及路由的结构，具体的路由匹配查找基本过程如下：第一步，从 Router.routes 开始依次循环第二步，从每个路由中的 matchers 中循环，看请求的路径是否符合 matchers 中的每一项规则，如果都匹配，则说明找到了该路由，否则继续步骤 1。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4f13aaad7c30f54713ae1a2d6246335a.png" alt="img"></p><h3 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h3><ul><li>匹配特定的域名或子域名</li><li>给路径增加前缀</li><li>限制路由的请求方法（GET、POST等）</li><li>支持路由分组</li><li>支持中间件</li></ul><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p>gorilla/mux 的路由解析采用的是 <strong>精准匹配</strong> 规则，而 net/http 包使用的是 <strong>长度优先匹配</strong> 规则。</p><ul><li><strong>精准匹配</strong> 指路由只会匹配准确指定的规则，这个比较好理解，也是较常见的匹配方式。</li><li><strong>长度优先匹配</strong> 一般用在静态路由上（不支持动态元素如正则和 URL 路径参数），优先匹配字符数较多的规则。</li></ul><p>一般 <strong>长度优先匹配</strong> 规则用在静态内容处理上比较合适，动态内容，例如我们的 goblog 这种动态网站，使用 <strong>精准匹配</strong> 会比较方便。</p><h2 id="基于-tries-结构的路由实现"><a href="#基于-tries-结构的路由实现" class="headerlink" title="基于 tries 结构的路由实现"></a>基于 tries 结构的路由实现</h2><h3 id="gin-框架中的路由"><a href="#gin-框架中的路由" class="headerlink" title="gin 框架中的路由"></a>gin 框架中的路由</h3><p>大名鼎鼎的 gin 框架采用的就是前缀树结构实现的路由。我们先来看一下 gin 框架中路由是如何定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  g := gin.New()</span><br><span class="line">  </span><br><span class="line">  g.POST(<span class="string">&quot;/abc/info&quot;</span>, InfoHandler)</span><br><span class="line">  g.POST(<span class="string">&quot;/abc/info/detail&quot;</span>, InfoHandler)</span><br><span class="line">  g.POST(<span class="string">&quot;/abc/list&quot;</span>, HomeHandler)</span><br><span class="line">  g.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HomeHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.Writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, this is Home page&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InfoHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">  ctx.Writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, this is info&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，首先通过 gin.New()初始化一个 gin 对象 g，然后通过 g.POST 或 g.GET 等方法就可以注册路由。很明显，路由注册过程也限制了请求的方法。</p><p>当然，还有一个方法是允许任何请求方法都能访问该路径的，就是 Any：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.Any(<span class="string">&quot;/&quot;</span>, HomeHandler)</span><br></pre></td></tr></table></figure><p>Any 方法本质上是定义了一组方法名，然后依次调用对应的方法将该路由进行注册，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  anyMethods = []<span class="type">string</span>&#123;</span><br><span class="line">    http.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,</span><br><span class="line">    http.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,</span><br><span class="line">    http.MethodTrace,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any registers a route that matches all the HTTP methods.</span></span><br><span class="line"><span class="comment">// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Any(relativePath <span class="type">string</span>, handlers ...HandlerFunc) IRoutes &#123;</span><br><span class="line">  <span class="keyword">for</span> _, method := <span class="keyword">range</span> anyMethods &#123;</span><br><span class="line">    group.handle(method, relativePath, handlers)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>相比较 map/hash 字典实现的优点：利用字符串公共前缀来减少查询时间，减少无谓的字符串比较。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ad3c820a8c6cbb62704d59796bf40927.png" alt="img"></p><p>上述示例中的<code>g.POST(&quot;/abc/info&quot;, InfoHandler)</code>路由，只会注册到 POST 方法的路由树中。若通过 GET 方法请求该路径，则在搜索的时候，在 GET 方法的路由树中就找不到该路由。这样就起到了通过路由限制请求方法的作用。</p><h4 id="路由树节点的数据结构"><a href="#路由树节点的数据结构" class="headerlink" title="路由树节点的数据结构"></a>路由树节点的数据结构</h4><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b147889ed160783df17d31acea619d57.png" alt="img"></p><p>前缀树中的路由都是基于这个 node 数据结构来进行构建的。其中包含了一个路由中的基本元素：路径 fullPath、对应的处理函数 handlers。其中 handlers 包含了中间件处理函数，因此这里使用一个 handlersChain 表示。</p><p>另外一个关键字段是 children，具有相同路径前缀的子节点通过 children 节点来构成父、子关系。</p><h3 id="路由树的构建"><a href="#路由树的构建" class="headerlink" title="路由树的构建"></a>路由树的构建</h3><p>第一个路由的注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/info&quot;</span>, InfoHandler)</span><br></pre></td></tr></table></figure><p>因为是第一个路由注册，路由树是空的。所以直接构建一个 node 节点，然后将该 node 节点作为 POST 方法路由树的根节点插入即可。如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ab2cd3446fec7cc526bed195a8f7c771.png" alt="img"></p><p>接着注册第二个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/info/detail&quot;</span>, DetailHandler)</span><br></pre></td></tr></table></figure><p>这个路由的特点是和路由”/abc/info”有共同的前缀，所以会将该路由作为第一个路由的子节点放到 children 中。如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/652ef39044e3f6dde0f9740c0e0593fd.png" alt="img"></p><p>这里主要有三个变化：</p><ul><li>一个是根节点的 priority 由 1 变成了 2；</li><li>一个是 children 中多了一个子节点路由；</li><li>最后一个是 indices 字段的值变成了”/“，这个是第一个子节点的 path 字段的第一个字符，用于匹配时索引使用。</li></ul><p>在子节点中，要注意的是 path 的值，因为前缀是”/abc/info”了，所以这里 path 是”/detail”。但 fullPath 依然是注册时完整的路径。</p><p>接下来，再注册第三个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.POST(<span class="string">&quot;/abc/list&quot;</span>, ListHandler)</span><br></pre></td></tr></table></figure><p>这个路由的特点是和前两个路由有共同的前缀”/abc/“，所以首先会将现在的根节点进行拆分，拆分成”/abc/“ 和”info”。而 info 和原来的”/abc/info/detail” 又有共同的前缀 info，所以原来的”/abc/info/detail”就变成了 info 的子节点。而”/abc/list”除去前缀”/abc/“后，剩余”list”子节点，作为”/abc/“的子节点。如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ba55d2e6246676bf96c1175a9d4038ef.png" alt="img"></p><p>那么，按节点组成的路由树就如下所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d4917411671d346791c6ccddf86f9278.png" alt="img"></p><p>这里，首先看根节点的变化：</p><ul><li>handlers 变为 nil。因为该节点不是一个具体的路径，只是一个前缀，所以具体的 handler 下移到了子节点 info 节点。</li><li>path 变为了前缀”/abc/“。</li><li>indices 字段值变为了”il”，其中 i 是第一个子节点中 path 字段的第一个字符，l 是第二个子节点中 path 字段的第一个字符。</li><li>priority 字段变成 3：代表从自身开始及子节点共有 4 个。</li><li>children 字段变成了两个直接子节点。</li><li>fullPath 字段变为了”/abc/“。</li></ul><p>其次，是从原根节点中拆分出一个 info 节点。最后是 detail 节点成为 info 节点的子节点。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件是一种计算机软件，可为操作系统提供的软件应用程序提供服务，以便于各个软件之间的沟通，特别是系统软件和应用软件。广泛用于web应用和面向服务的体系结构等。</p><p>纵观GO语言，中间件应用比较普遍，主要应用：</p><ul><li>记录对服务器发送的请求（request）</li><li>处理服务器响应（response ）</li><li>请求和处理之间做一个权限认证工作</li><li>远程调用</li><li>安全</li><li>等等</li></ul><p><strong>中间件处理程序</strong>是简单的<code>http.Handler</code>，它包装另一个<code>http.Handler</code>做请求的一些预处理和/或后处理。它被称为“中间件”，因为它位于Go Web服务器和实际处理程序之间的中间位置。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1460000018819807" alt="img"></p><h3 id="在gin框架下实现中间件"><a href="#在gin框架下实现中间件" class="headerlink" title="在gin框架下实现中间件"></a>在gin框架下实现中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default() 创建带有默认中间件的路由，默认是包含logger和recovery中间件的</span><br><span class="line">r :=gin.<span class="built_in">new</span>()      创建带有没有中间件的路由</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们就大致了解了路由和中间件。在本项目中，路由和中间件实现了大多数功能，因此深刻地理解这两个概念能够帮助我更好的理解代码。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://xie.infoq.cn/article/0c2d65a7c72147dc457af5007">路由</a></li><li><a href="https://segmentfault.com/a/1190000018819804">中间件</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要用于介绍&lt;code&gt;GoBlog&lt;/code&gt;项目中两个最为重要的部分——路由和中间件。这两个部分可以说是本项目的重要组成部分，下面我们会逐个进行学习和分析，并大概介绍其在项目中的作用。&lt;/p&gt;
&lt;h1 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;he</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>GoBlog，启动！</title>
    <link href="http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/"/>
    <id>http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/</id>
    <published>2024-03-23T12:52:50.000Z</published>
    <updated>2024-03-23T12:38:48.272Z</updated>
    
    <content type="html"><![CDATA[<p>喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直到需要找实习才发现自己简历上能写的东西寥寥无几。说来奇怪，上了几年大学发现自己好像什么都没学到，这应该就是一种清醒的堕落吧。</p><p>我对这个项目的了解就像我对Go语言的了解一样，来自我那个神奇的舍友。他花钱买了教程之后，我就可以蹭一下了，很难想象没有我亲爱的舍友，我的大学生活会变成什么样子。</p><h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p>废话少说，为什么要用Go来开发一个博客系统呢？答案很简单，Go语言本身就非常适用于开发Web应用程序，而且我们在学习的过程中也不难发现好像很多大佬都有自己的博客，那不如把这两个结合一下，这样在设计具体功能的时候也能找到一些可以借鉴的地方。</p><p>开发Web应用要涉及到的知识：</p><ul><li>表单验证</li><li>注册登录</li><li>授权验证</li><li>共享数据库连接</li><li>密码哈希</li><li>路由和中间件</li><li>代码组织（MVC/RESTful）</li><li>打包静态文件和模板文件</li><li>项目部署等</li></ul><p>这些内容会在后面的博客中一一介绍，这个项目并不是一个玩具项目，后续的文章中也会解决一些会在实际生产环境中出现的问题。</p><p>本书源码：<a href="https://github.com/summerblue/goblog">github.com/summerblue/goblog</a></p><p>本项目并不是笔者自己开发的，是跟着社区的教程完成的。</p><h1 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h1><p>作为实战项目，遇到程序报错是很正常的情况，多解决报错能帮助我们学到不少东西。</p><p>在遇到一些很抽象的报错时，不要怀疑机器有问题，99%的概率问题在自己，即使代码都是复制的。</p><p>当然如果实在是找不到，可以利用源码来排除错误。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>Windows11</li><li>Go1.21.1</li><li>编译器Visual studio code</li></ul><h1 id="通过本项目学到了什么"><a href="#通过本项目学到了什么" class="headerlink" title="通过本项目学到了什么"></a>通过本项目学到了什么</h1><ul><li>数据库使用</li><li>模板使用</li><li>基础测试</li><li>项目开发流程</li><li>Go 项目结构选择</li></ul><h1 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240323203506135.png" alt="image-20240323203506135"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的Go Web程序</title>
    <link href="http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-03-22T14:27:49.000Z</published>
    <updated>2024-04-06T14:25:37.038Z</updated>
    
    <content type="html"><![CDATA[<p>在Go中，搭建一个http server简单到令人难以置信。只需要引入net/http包，写几行代码，一个http服务器就可以正常运行并接受访问请求。因此，在正式开启项目开发之前，先来看一段简短的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">&quot;&lt;h1&gt;Hello, 这里是 goblog&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handlerFunc)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这段代码就能够构成一个Web程序，其中最为主要的内容基本上都与一个包有关—— <code>net/http</code>，那就先学习一下有关这个包的内容吧。 </p><h1 id="初识net-http"><a href="#初识net-http" class="headerlink" title="初识net/http"></a>初识net/http</h1><p>在net/http源代码中，我们可以深深体会到Go语言的结构体（以及自定义类型）、接口、方法简单组合的设计哲学。这个包最主要的文件有4个，分别是： <code>client.go</code> <code>server.go</code> <code>request.go</code> <code>response.go</code>。</p><p>这四个文件也分别代表了HTTP中最重要的4个部分，<code>http Request</code> 请求、 <code>http Response</code> 响应、<code>http Client</code>客户端和<code>http Server</code> 服务端，所以我们先从这四个方面来了解<code>net/http</code>包：</p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>http Request</code>请求是由<strong>客户端发出</strong>的消息, 用来使<strong>服务器执行</strong>动作.发出的消息包括起始行, Headers, Body。</p><p>一般使用 <code>http.NewRequest</code>来构造一个<code>http Request</code>请求，可能包括<code>http Headers</code>信息，<code>cookies</code>信息等，然后发给服务端。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><code>http Response</code>响应是由<code>http Server</code>服务端发出的消息，用来响应<code>http Client</code>端发出的<code>http Request</code>请求。发出的消息包括起始行, Headers, Body。</p><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p><code>http Client</code>客户端主要用来发送<code>http Request</code>请求给<code>http Server</code>服务端，比如以<code>Do</code>方法，<code>Get</code>方法以及<code>Post</code>或<code>PostForm</code>方法发送<code>http Request</code>请求。</p><p><code>http.NewRequest</code>可以灵活的对<code>http Request</code>进行配置，然后再使用<code>http.Client</code>的<code>Do</code>方法发送这个<code>http Request</code>请求。</p><ul><li>如果使用<code>Post</code>或者<code>PostForm</code>方法，是不能使用<code>http.NewRequest</code>配置请求的，只有<code>Do</code>方法可以定制<code>http.NewRequest</code>。</li></ul><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><code>http Server</code>服务端用来接收并响应<code>http Client</code>端发出的<code>http Request</code>请求，是<code>net/http</code>包中非常重要和关键的一个功能。我们在Go语言中简单就能搭建<code>HTTP</code>服务器，就是因为它的存在。</p><p>关于以上四部分的详细内容，可以看<a href="https://wizardforcel.gitbooks.io/go42/content/content/42_36_http.html">这篇文章</a>，里面有更加详细的函数解释。</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>大概了解关于<code>net/http</code> 包之后，我们再回头看开篇的那段代码，或许已经能看懂个大概了。</p><h3 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h3><p><code>http.ListenAndServe</code> 用以监听本地 3000 端口以提供服务，标准的 HTTP 端口是 80 端口，如 <code>baidu.com:80</code>，另一个 Web 常用是 HTTPS 的 443 端口，如 <code>baidu.com:443</code>。</p><p>当我们监听本地端口时，可使用 <code>localhost</code> 加上端口号来访问。运行上面的程序，可以通过<a href="http://localhost:3000/">localhost:3000/</a> 进行访问。</p><h3 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h3><p><code>http.HandleFunc</code> 用以指定处理 HTTP 请求的函数，此函数允许我们只写一个 handler，请求会通过参数传递进来，使用者只需与 <code>http.Request</code> 和 <code>http.ResponseWriter</code> 两个对象交互即可。</p><p>在实例代码中，我们利用 <code>fmt.Fprint</code> 将 <code>&lt;h1&gt;Hello, 这里是 goblog&lt;/h1&gt;</code> 子串写入 <code>http.ResponseWriter</code>，即可响应用户请求。</p><h3 id="http-Request"><a href="#http-Request" class="headerlink" title="http.Request"></a>http.Request</h3><p><code>http.Request</code> 是用户的请求信息，一般用 <code>r</code> 作为简写。</p><p>一些常见的操作如：</p><ul><li><code>r.URL.Query()</code> 获取用户参数</li><li>获取客户端信息 <code>r.Header.Get(&quot;User-Agent&quot;)</code></li></ul><h3 id="http-ResponseWriter"><a href="#http-ResponseWriter" class="headerlink" title="http.ResponseWriter"></a>http.ResponseWriter</h3><p><code>http.ResponseWriter</code> 是返回用户的响应，一般用 <code>w</code> 作为简写。</p><p>常见操作如：</p><ul><li>返回 500 状态码 <code>w.WriteHeader(http.StatusInternalServerError)</code></li><li>设置返回标头 <code>w.Header().Set(&quot;name&quot;, &quot;my name is smallsoup&quot;)</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于Web程序我们就完成了简单的了解。我们通过<code>http.ListenAndServe</code>来对本地的端口进行监听，等待用户的操作。使用<code>http.HandleFunc</code>来完成当用户做出指定操作时的动作。<code>handlerFunc</code>函数则是我们自己定义的一系列动作，等待<code>HandleFunc</code>调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go中，搭建一个http server简单到令人难以置信。只需要引入net/http包，写几行代码，一个http服务器就可以正常运行并接受访问请求。因此，在正式开启项目开发之前，先来看一段简短的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
