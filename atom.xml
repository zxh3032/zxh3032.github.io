<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-06T04:48:40.101Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据结构五兄弟：数据江湖的武林盟主</title>
    <link href="http://example.com/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/"/>
    <id>http://example.com/2024/06/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E5%85%84%E5%BC%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B1%9F%E6%B9%96%E7%9A%84%E6%AD%A6%E6%9E%97%E7%9B%9F%E4%B8%BB/</id>
    <published>2024-06-05T12:56:19.000Z</published>
    <updated>2024-06-06T04:48:40.101Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习 Redis 相关的知识，Redis 的五种基础数据结构。虽然在之前的博客中也有提到过这五种数据结构，当时赶着背东西，基本上就是从别人的八股文里抄的，所以还是重新学一下，重新记录加深记忆，正文开始。</p><p>在数据的江湖里，Redis无疑是那位神秘莫测、武功高强的武林盟主。今天，我们要介绍的就是Redis的五个顶级弟子（Redis 到现在已经有 9 种数据结构了），他们各怀绝技，行走江湖无往不利。话不多说，让我们一睹这五兄弟的风采！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我知道现在你已经迫不及待的想要了解这五个大侠了，但是在正式学习这些之前，我们先来了解一下 Redis 武林中的一些“潜规则”。</p><h2 id="Redis的两层数据结构简介"><a href="#Redis的两层数据结构简介" class="headerlink" title="Redis的两层数据结构简介"></a>Redis的两层数据结构简介</h2><p>Redis 为什么会有如此高的性能？这也是一个老生常谈的问题了，其中之一的原因就是它的每种数据结构都是经过专门设计的，并都有一种或多种数据结构来支持，依赖这些灵活的数据结构，来提升读取和写入的性能。</p><p>想要了解Redis的数据结构，可以从两个不同的层面来讨论它：</p><ol><li>第一个层面，是从使用者的角度，这一层面也是Redis暴露给外部的调用接口，比如：<ul><li>string</li><li>list</li><li>hash</li><li>set</li><li>sorted set</li></ul></li><li>第二个层面，是从内部实现的角度，属于更底层的实现，比如：<ul><li>dict</li><li>sds</li><li>ziplist</li><li>quicklist</li><li>skiplist</li><li>intset</li></ul></li></ol><p>本文会先从第一个层面来了解 Redis 的基础操作，再深入学习其底层原理。</p><h2 id="redisObject：两层数据结构的桥梁"><a href="#redisObject：两层数据结构的桥梁" class="headerlink" title="redisObject：两层数据结构的桥梁"></a><code>redisObject</code>：两层数据结构的桥梁</h2><h3 id="什么是redisObject？"><a href="#什么是redisObject？" class="headerlink" title="什么是redisObject？"></a>什么是<code>redisObject</code>？</h3><p>从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系，这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash, set, sorted set等。<br> 而从 Redis 内部实现的角度来看，database 内的这个映射关系是用一个 dict 来维护的。dict 的 key固定用一种数据结构来表达就够了，这就是动态字符串 sds；而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是 robj，全名是<code>redisObject</code>。</p><blockquote><p>举个例子：</p><ul><li><p>如果value是list类型，那么它的内部存储结构是一个quicklist或者是一个ziplist</p></li><li><p>如果value是string类型，那么它的内部存储结构一般情况下是一个sds。但如果string类型的value的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。</p></li></ul><p>所以，一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p></blockquote><h3 id="Redis-的数据结构定义"><a href="#Redis-的数据结构定义" class="headerlink" title="Redis 的数据结构定义"></a>Redis 的数据结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><strong>一个 robj 包含如下 5 个字段</strong></p><ul><li><p>type: 对象的数据类型。占4个bit。可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构</p></li><li><p>encoding: 对象的内部表示方式（也可以称为编码）。占4个 bit。可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。</p></li><li>lru: 做LRU替换算法用，占24个bit。这个不是我们这里讨论的重点，暂时忽略。</li><li>refcount: 引用计数。它允许robj对象在某些情况下被共享。</li><li>ptr: 数据指针。指向真正的数据。比如，一个代表string的 robj，它的 ptr 可能指向一个 sds 结构；一个代表 list 的 robj，它的 ptr 可能指向一个 quicklist。</li></ul><p><strong>encoding字段的说明</strong></p><p>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><blockquote><p>当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p><ul><li><p>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。</p></li><li><p>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。</p></li><li>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。</li></ul><p>当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p><ul><li>OBJ_ENCODING_HT: hash采用一个dict来表示</li><li>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示</li></ul></blockquote><p><strong>10种encoding的取值说明</strong></p><ul><li><p>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。</p></li><li><p>OBJ_ENCODING_INT: 表示成数字。实际用long表示。</p></li><li>OBJ_ENCODING_HT: 表示成dict。</li><li>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。</li><li>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。</li><li>OBJ_ENCODING_ZIPLIST: 表示成ziplist。</li><li>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。</li><li>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。</li><li>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。</li><li>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</li></ul><h3 id="robj-的作用"><a href="#robj-的作用" class="headerlink" title="robj 的作用"></a>robj 的作用</h3><ul><li><code>redisObject</code>就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪些第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist等），则通过不同的encoding来区分。可以说，robj是联结两个层面的数据结构的桥梁。</li><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li><li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/720b2e10a6cc4f009963d0af153a2351.png" alt="img"></p><p>好了，在了解完武林江湖的一些潜规则后，我们就可以正式进入这个江湖了，可以避免露头秒了。</p><h1 id="字符串（String）：一招制敌的快剑手"><a href="#字符串（String）：一招制敌的快剑手" class="headerlink" title="字符串（String）：一招制敌的快剑手"></a>字符串（String）：一招制敌的快剑手</h1><p>首先登场的是字符串，这位老大哥简直是个“快剑手”，动作迅捷、干脆利落。他就像是江湖上的独行侠，擅长简单直接的攻击方式。字符串可以存储任何类型的数据：文本、数字甚至二进制数据，只要你给的，他都能快速接住。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151104537-442214557.png" alt="img"></p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作，下面我们分别来看，后面其他数据结构也都会按照这样的顺序讲解。</p><h3 id="命令行操作方式"><a href="#命令行操作方式" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值</td></tr><tr><td>MSET key1 value1 key2 value2 …</td><td>设置一个或多个指定 key 的值</td></tr><tr><td>MGET key1 key2 …</td><td>获取一个或多个指定 key 的值</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值(整型和浮点型)增一</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值(整型和浮点型)减一</td></tr><tr><td>INCRBY/DECRBY key increment</td><td>将 key 中储存的数字值(整型和浮点型)加/减 increment</td></tr><tr><td>EXISTS key</td><td>判断指定 key 是否存在</td></tr><tr><td>DEL key（通用）</td><td>删除指定的 key</td></tr><tr><td>EXPIRE key seconds（通用）</td><td>给指定 key 设置过期时间</td></tr><tr><td>APPEND key value</td><td>给指定 key 后面追加值 value</td></tr></tbody></table></div><p>更多 Redis String 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=string">Redis 官网</a> 对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）"><a href="#代码操作方式（采用Go-Redis-V8-版本）" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p><strong>常用方法:</strong></p><ul><li>Keys():根据正则获取keys</li><li>Type():获取key对应值得类型</li><li>Del():删除缓存项</li><li>Exists():检测缓存项是否存在</li><li>Expire(),ExpireAt():设置有效期</li><li>TTL(),PTTL():获取有效期</li><li>DBSize():查看当前数据库key的数量</li><li>FlushDB():清空当前数据</li><li>FlushAll():清空所有数据库</li><li>Set():设置键缓存</li><li>SetEX():设置并指定过期时间</li><li>SetNX():设置并指定过期时间,仅当key不存在的时候才设置。</li><li>Get():获取键值</li><li>GetRange():字符串截取</li><li>Incr():增加+1</li><li>IncrBy():按指定步长增加</li><li>Decr():减少-1</li><li>DecrBy():按指定步长减少</li><li>Append():追加</li><li>StrLen():获取长度</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis String Set/Get 示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGetExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.Set 设置 key 如果设置为-1则表示永不过期</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;score&quot;</span>, <span class="number">100</span>, <span class="number">60</span>*time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;set score failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Get 获取已存在的Key其存储的值</span></span><br><span class="line">val1, err := rdb.Get(ctx, <span class="string">&quot;score&quot;</span>).Result() <span class="comment">// 获取其值</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get score failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;val1 -&gt; score ：%v\n&quot;</span>, val1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取一个不存在的值返回redis.Nil 则说明不存在</span></span><br><span class="line">val2, err := rdb.Get(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[ERROR] - Key [name] not exist&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get name failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exists() 方法用于检测某个key是否存在</span></span><br><span class="line">n, _ := rdb.Exists(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name key 存在!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name key 不存在!&quot;</span>)</span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;weiyi&quot;</span>, <span class="number">60</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line">val2, _ = rdb.Get(ctx, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;val2 -&gt; name : &quot;</span>, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.SetNX 当不存在key时将进行设置该可以并设置其过期时间</span></span><br><span class="line">val3, err := rdb.SetNX(ctx, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;weiyigeek&quot;</span>, <span class="number">0</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;set username failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;val3 -&gt; username: %v\n&quot;</span>, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.Keys() 根据正则获取keys, DBSize() 查看当前数据库key的数量.</span></span><br><span class="line">keys, _ := rdb.Keys(ctx, <span class="string">&quot;*&quot;</span>).Result()</span><br><span class="line">num, err := rdb.DBSize(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;All Keys : %v, Keys number : %v \n&quot;</span>, keys, num)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据前缀获取Key</span></span><br><span class="line">  vals, _ := rdb.Keys(ctx, <span class="string">&quot;user*&quot;</span>).Result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.Type() 方法用户获取一个key对应值的类型</span></span><br><span class="line">vType, err := rdb.Type(ctx, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;username key type : %v\n&quot;</span>, vType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.Expire()方法是设置某个时间段(time.Duration)后过期，ExpireAt()方法是在某个时间点(time.Time)过期失效.</span></span><br><span class="line">val4, _ := rdb.Expire(ctx, <span class="string">&quot;name&quot;</span>, time.Minute*<span class="number">2</span>).Result()</span><br><span class="line"><span class="keyword">if</span> val4 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name 过期时间设置成功&quot;</span>, val4)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name 过期时间设置失败&quot;</span>, val4)</span><br><span class="line">&#125;</span><br><span class="line">val5, _ := rdb.ExpireAt(ctx, <span class="string">&quot;username&quot;</span>, time.Now().Add(time.Minute*<span class="number">2</span>)).Result()</span><br><span class="line"><span class="keyword">if</span> val5 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;username 过期时间设置成功&quot;</span>, val5)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;username 过期时间设置失败&quot;</span>, val5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.TTL()与PTTL()方法可以获取某个键的剩余有效期</span></span><br><span class="line">userTTL, _ := rdb.TTL(ctx, <span class="string">&quot;user&quot;</span>).Result() <span class="comment">// 获取其key的过期时间</span></span><br><span class="line">usernameTTL, _ := rdb.PTTL(ctx, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;user TTL : %v, username TTL : %v\n&quot;</span>, userTTL, usernameTTL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.Del():删除缓存项与FlushDB():清空当前数据</span></span><br><span class="line">  <span class="comment">// 当通配符匹配的key的数量不多时，可以使用Keys()得到所有的key在使用Del命令删除。</span></span><br><span class="line">num, err = rdb.Del(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;username&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Del() : &quot;</span>, num)</span><br><span class="line">  <span class="comment">// 如果key的数量非常多的时候，我们可以搭配使用Scan命令和Del命令完成删除。</span></span><br><span class="line">  iter := rdb.Scan(ctx, <span class="number">0</span>, <span class="string">&quot;user*&quot;</span>, <span class="number">0</span>).Iterator()</span><br><span class="line">  <span class="keyword">for</span> iter.Next(ctx) &#123;</span><br><span class="line">    err := rdb.Del(ctx, iter.Val()).Err()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := iter.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.清空当前数据库，因为连接的是索引为0的数据库，所以清空的就是0号数据库</span></span><br><span class="line">flag, err := rdb.FlushDB(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;FlushDB() : &quot;</span>, flag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>redis数据库中字符串与整型操作实践</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringIntExample 数据类型演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringIntExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置字符串类型的key</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetRange ：字符串截取</span></span><br><span class="line"><span class="comment">// 注：即使key不存在，调用GetRange()也不会报错，只是返回的截取结果是空&quot;&quot;,可以使用fmt.Printf(&quot;%q\n&quot;, val)来打印测试</span></span><br><span class="line">val1, _ := rdb.GetRange(ctx, <span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">4</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: hello, value: %v\n&quot;</span>, val1) <span class="comment">//截取到的内容为: ello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append()表示往字符串后面追加元素，返回值是字符串的总长度</span></span><br><span class="line">length1, _ := rdb.Append(ctx, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot; Go Programer&quot;</span>).Result()</span><br><span class="line">val2, _ := rdb.Get(ctx, <span class="string">&quot;hello&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前缓存key的长度为: %v，值: %v \n&quot;</span>, length1, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置整形的key</span></span><br><span class="line">err = rdb.SetNX(ctx, <span class="string">&quot;number&quot;</span>, <span class="number">1</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Incr()、IncrBy()都是操作数字，对数字进行增加的操作</span></span><br><span class="line"><span class="comment">// Decr()、DecrBy()方法是对数字进行减的操作，和Incr正好相反</span></span><br><span class="line"><span class="comment">// incr是执行原子加1操作</span></span><br><span class="line">val3, _ := rdb.Incr(ctx, <span class="string">&quot;number&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Incr -&gt; key当前的值为: %v\n&quot;</span>, val3) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// incrBy是增加指定的数</span></span><br><span class="line">val4, _ := rdb.IncrBy(ctx, <span class="string">&quot;number&quot;</span>, <span class="number">6</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;IncrBy -&gt; key当前的值为: %v\n&quot;</span>, val4) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StrLen 也可以返回缓存key的长度</span></span><br><span class="line">length2, _ := rdb.StrLen(ctx, <span class="string">&quot;number&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;number 值长度: %v\n&quot;</span>, length2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031225.png" alt="字符串总结图.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Redis 3.2 之前 SDS 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031222.png" alt="字符串存储结构图.png"></p><p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* 已使用长度，1 字节存储 */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* 总长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">// 真正存储字符串的数据空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* 已使用长度，2 字节存储 */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* 已使用长度，4 字节存储 */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* 已使用长度，8 字节存储 */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p><p>确切地说，String在Redis中是用一个robj来表示的。</p><p>用来表示String的robj可能编码成3种内部表示：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把 string 存成了 int 型。</p><ul><li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；</li><li>如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li></ul><p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p><p><strong>为什么是 44 字节？</strong></p><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p><p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p><p>在前言部分就已经提到过 <code>redisObject</code> 了，其中的五个字段一共占据了 16 字节。</p><p>SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：SDS <em> TYPE </em> 5、SDS <em> TYPE </em> 8、SDS <em> TYPE </em> 16、SDS <em> TYPE </em> 32、SDS <em> TYPE </em> 64，在这些类型中最小的存储类型为 SDS <em> TYPE </em> ５，但 SDS <em> TYPE </em> ５ 类型会默认转成 SDS <em> TYPE </em> 8，以下源码可以证明，如下图所示：<img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031223.png" alt="SDS-0116-1.png"></p><p><strong>为什么转换？</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-2.png" alt="img"></p><p>可以看出，SDS <em> TYPE </em> 5类型根本就无法使用。</p><p>那我们直接来看 SDS <em> TYPE </em> 8 的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 <code>\0</code> 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031224.png" alt="44字节说明图.png"></p><h2 id="性能优势"><a href="#性能优势" class="headerlink" title="性能优势"></a>性能优势</h2><p>SDS 与 C 语言字符串比较相近，但拥有更过的优势：</p><ul><li>SDS 获取字符串长度时间复杂度 O(1)：因为 SDS 通过 len 字段来存储长度，使用时直接读取就可以；C 语言要想获取字符串长度需要遍历整个字符串，时间复杂度 O(N)。</li><li>SDS 能杜绝缓冲区的溢出：因为当 SDS API 要对 SDS 进行修改时，会先检查 SDS 的空间是否足够，如果不够的话 SDS 会自动扩容，So，不会造成缓冲区溢出。而 C 语言则不具备这个功能。</li><li>SDS 能减少修改字符串时带来的内存重分配次数：<ul><li>空间预分配：当 SDS 扩容时不只是会增加需要的空间大小，还会额外的分配一些未使用的空间。分配的规则是：如果分配后 SDS 的长度小于 1MB，那么会分配等于分配后 SDS 的大小的未使用空间，简单说就是，SDS 动态分配后是 16KB，那么就会多分配 16KB 的未使用空间；如果 小于 1MB，那么久分配 1MB 的未使用空间。</li><li>惰性空间释放： 惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，并不会立即内存重分配来回收多出来的字节，而是用 free 来记录未使用空间。</li></ul></li></ul><h3 id="空间预分配补进一步理解"><a href="#空间预分配补进一步理解" class="headerlink" title="空间预分配补进一步理解"></a>空间预分配补进一步理解</h3><p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf=&#39;Hello World again!\0....................&#39;</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p><p>思考：<strong>这种分配策略会浪费内存资源吗</strong>？</p><p>答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p><h1 id="哈希（Hash）：万花筒般的博学者"><a href="#哈希（Hash）：万花筒般的博学者" class="headerlink" title="哈希（Hash）：万花筒般的博学者"></a>哈希（Hash）：万花筒般的博学者</h1><p>接下来出场的是哈希，哈希就像是一个学识渊博的百科全书，里面装着各种各样的知识点。你问他什么，他都能迅速找到并回答你。哈希非常适合存储对象类型的数据，每个字段都能独立操作，让你在管理数据时游刃有余。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031216.png" alt="哈希表存储结构.png"></p><h2 id="如何使用？-1"><a href="#如何使用？-1" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-1"><a href="#命令行操作方式-1" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置指定哈希表中指定字段的值</td></tr><tr><td>HSETNX key field value</td><td>只有指定字段不存在时设置指定字段的值</td></tr><tr><td>HMSET key field1 value1 field2 value2 …</td><td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td></tr><tr><td>HGET key field</td><td>获取指定哈希表中指定字段的值</td></tr><tr><td>HMGET key field1 field2 …</td><td>获取指定哈希表中一个或者多个指定字段的值</td></tr><tr><td>HGETALL key</td><td>获取指定哈希表中所有的键值对</td></tr><tr><td>HEXISTS key field</td><td>查看指定哈希表中指定的字段是否存在</td></tr><tr><td>HDEL key field1 field2 …</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HLEN key</td><td>获取指定哈希表中字段的数量</td></tr></tbody></table></div><p>更多 Redis Hash 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=hash">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-1"><a href="#代码操作方式（采用Go-Redis-V8-版本）-1" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>HSet():设置</li><li>HMset():批量设置</li><li>HGet():获取某个元素</li><li>HGetAll():获取全部元素</li><li>HDel():删除某个元素</li><li>HExists():判断元素是否存在</li><li>HLen():获取长度</li></ul><p><strong>简单示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// (1) HSet() 设置字段和值</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>&#125;)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;huser&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;key5&quot;</span>: <span class="string">&quot;value5&quot;</span>, <span class="string">&quot;key6&quot;</span>: <span class="string">&quot;value6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) HMset():批量设置</span></span><br><span class="line">rdb.HMSet(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;WeiyiGeek&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">88</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;重庆&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) HGet() 获取某个元素</span></span><br><span class="line">address, _ := rdb.HGet(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="string">&quot;address&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser.address -&gt; &quot;</span>, address)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) HGetAll() 获取全部元素</span></span><br><span class="line">hmuser, _ := rdb.HGetAll(ctx, <span class="string">&quot;hmuser&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser :=&gt; &quot;</span>, hmuser)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) HExists 判断元素是否存在</span></span><br><span class="line">flag, _ := rdb.HExists(ctx, <span class="string">&quot;hmuser&quot;</span>, <span class="string">&quot;address&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;address 是否存在 hmuser 中: &quot;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) HLen() 获取长度</span></span><br><span class="line">length, _ := rdb.HLen(ctx, <span class="string">&quot;hmuser&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;hmuser hash 键长度: &quot;</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (7) HDel() 支持一次删除多个元素</span></span><br><span class="line">count, _ := rdb.HDel(ctx, <span class="string">&quot;huser&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;删除元素的个数: &quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来的三个小节将分别介绍 Redis 的哈希表、哈希表节点、以及字典的实现。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组    </span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值    </span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p></li><li><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p></li><li>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</li></ul><p>下图 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b00db9f0d5b742d777ee65a9de3a0f7a.png" alt="img"></p><h4 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h4><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><ul><li>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</li><li>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</li></ul><p>举个例子， 下图就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/051f340b7b501e61045e94542bf519e0.png" alt="img"></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis 中的字典由 dict.h/dict 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li><li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>下图 展示了一个普通状态下（没有进行 rehash）的字典：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0469efb2d1c938e7ae4650ed62c7f121.png" alt="img"></p><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>字典类型本质上是由数组和链表结构组成的，通常情况下字典类型会使用数组的方式来存储相关的数据，但发生<strong>哈希冲突</strong>时才会使用链表的结构来存储数据。</p><p><strong>Redis 计算索引值的方法是：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>类似 Java 的 HashMap，计算 key 的 hash 值，然后 hash &amp; (len - 1), 而 Redis 的 sizemask 就是 size - 1。</p><p><strong>什么是哈希冲突？发生哈希冲突怎么办？</strong></p><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为<strong>哈希冲突</strong>。</p><p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p><p>键值查询的流程如下：</p><ul><li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li><li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li></ul><p>键值查询流程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031218.png" alt="Redis-HashType-03.png"></p><h2 id="性能优势-1"><a href="#性能优势-1" class="headerlink" title="性能优势"></a>性能优势</h2><p>dict本质上是为了解决算法中的查找问题，是一个基于哈希表的算法，在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，查询的时间复杂度接近<strong>O(1)</strong>。它采用某个哈希函数并通过计算key从而找到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发<strong>重哈希（rehash）</strong>，为了避免扩容时一次性对所有key进行重哈希，Redis采用了一种称为<strong>渐进式重哈希（incremental rehash）</strong>的方法，将重哈希的操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着不断的操作，hash 表中的键值对可能会增多或减少，为了让哈希表的负载因子保持在一个范围内，需要对 hash 表进行扩容或收缩，收缩和扩容的过程就叫 rehash。rehash 过程如下：</p><ol><li>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）(ht 是字典中的 hash 表，上文有介绍)：</li><li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li><li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备</li></ol><p><strong>触发扩容的条件</strong>：</p><p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p><p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p><p><strong>渐进式 rehash</strong></p><p>rehash 时会将 ht[0] 所有的键值对迁移到 ht[1] 中，但这个动作不是一次性的，而是分多次、渐进式地完成。这样的所得原因时：当数据量大的时候一次性迁移会造成服务器在一段时间内定制服务。为了避免发生这样的事就出现了 <strong>渐进式 rehash</strong>。</p><p>主要的执行流程如下：</p><ul><li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li><li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li><li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li></ul><h1 id="列表（List）：风驰电掣的快马"><a href="#列表（List）：风驰电掣的快马" class="headerlink" title="列表（List）：风驰电掣的快马"></a>列表（List）：风驰电掣的快马</h1><p>第三位登场的是列表，这位兄弟简直就是江湖上的快马，擅长在前后两个方向上迅速移动。无论是队列还是栈，列表都能应付自如。最适合需要顺序操作的场景，比如任务队列或者消息队列。</p><p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031229.png" alt="列表类型使用-列表结构图.png"></p><h2 id="如何使用？-2"><a href="#如何使用？-2" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-2"><a href="#命令行操作方式-2" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>LPUSH key value1 value2 ..</td><td>在指定列表的头部（左边）添加一个或多个元素</td></tr><tr><td>RPUSH key value1 value2 …</td><td>在指定列表的尾部（右边）添加一个或多个元素</td></tr><tr><td>LSET key index value</td><td>将指定列表索引 index 位置的值设置为 value</td></tr><tr><td>LPOP key</td><td>移除并获取指定列表的第一个元素(最左边)</td></tr><tr><td>RPOP key</td><td>移除并获取指定列表的最后一个元素(最右边)</td></tr><tr><td>LLEN key</td><td>获取列表元素数量</td></tr><tr><td>LRANGE key start end</td><td>获取列表 start 和 end 之间 的元素</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151156374-72815148.png" alt="img"></p><p>更多 Redis List 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=list">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-2"><a href="#代码操作方式（采用Go-Redis-V8-版本）-2" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p><strong>常用方法:</strong></p><ul><li>LPush():将元素压入链表</li><li>LInsert():在某个位置插入新元素</li><li>LSet():设置某个元素的值</li><li>LLen():获取链表元素个数</li><li>LIndex():获取链表下标对应的元素</li><li>LRange():获取某个选定范围的元素集</li><li>LPop()从链表左侧弹出数据</li><li>LRem():根据值移除元素</li></ul><p><strong>简单示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 插入指定值到list列表中，返回值是当前列表元素的数量</span></span><br><span class="line"><span class="comment">// 使用LPush()方法将数据从左侧压入链表（后进先出）,也可以从右侧压如链表对应的方法是RPush()</span></span><br><span class="line">count, _ := rdb.LPush(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;插入到list集合中元素的数量: &quot;</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LInsert() 在某个位置插入新元素</span></span><br><span class="line"><span class="comment">// 在名为key的缓存项值为2的元素前面插入一个值，值为123 ， 注意只会执行一次</span></span><br><span class="line">_ = rdb.LInsert(ctx, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;before&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">123</span>).Err()</span><br><span class="line"><span class="comment">// 在名为key的缓存项值为2的元素后面插入一个值，值为321</span></span><br><span class="line">_ = rdb.LInsert(ctx, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;after&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">321</span>).Err()</span><br><span class="line"></span><br><span class="line"><span class="comment">// LSet() 设置某个元素的值</span></span><br><span class="line"><span class="comment">//下标是从0开始的</span></span><br><span class="line">val1, _ := rdb.LSet(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>, <span class="number">256</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;是否成功将下标为2的元素值改成256: &quot;</span>, val1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LLen() 获取链表元素个数</span></span><br><span class="line">length, _ := rdb.LLen(ctx, <span class="string">&quot;list&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前链表的长度为: %v\n&quot;</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LIndex() 获取链表下标对应的元素</span></span><br><span class="line">val2, _ := rdb.LIndex(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;下标为2的值为: %v\n&quot;</span>, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表左侧弹出数据</span></span><br><span class="line">val3, _ := rdb.LPop(ctx, <span class="string">&quot;list&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;弹出下标为0的值为: %v\n&quot;</span>, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRem() 根据值移除元素 lrem key count value</span></span><br><span class="line">n, _ := rdb.LRem(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">2</span>, <span class="string">&quot;256&quot;</span>).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;移除了: %v 个\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding list</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p><ol><li><p>Redis3.2之前的底层实现方式：压缩列表ziplist 或者 双向循环链表linkedlist</p><p>当list存储的数据量较少时，会使用ziplist存储数据，也就是同时满足下面两个条件：</p><ul><li>列表中数据个数少于512个</li><li>list中保存的每个元素的长度小于 64 字节</li><li>当不能同时满足上面两个条件的时候，list就通过双向循环链表linkedlist来实现了</li></ul></li><li><p>Redis3.2及之后的底层实现方式：quicklist</p><p>quicklist是一个双向链表，而且是一个基于ziplist的双向链表，quicklist的每个节点都是一个ziplist，结合了双向链表和ziplist的优点。</p></li></ol><h3 id="数据类型-2"><a href="#数据类型-2" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>我们来看下 quicklist 的实现源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistLZF is a 4+N byte struct holding &#x27;sz&#x27; followed by &#x27;compressed&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;sz&#x27; is byte length of &#x27;compressed&#x27; field.</span></span><br><span class="line"><span class="comment"> * &#x27;compressed&#x27; is LZF data with total (compressed) length &#x27;sz&#x27;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span></span><br><span class="line"><span class="comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="type">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bookmarks are padded with realloc at the end of of the quicklist struct.</span></span><br><span class="line"><span class="comment"> * They should only be used for very big lists if thousands of nodes were the</span></span><br><span class="line"><span class="comment"> * excess memory usage is negligible, and there&#x27;s a real need to iterate on them</span></span><br><span class="line"><span class="comment"> * in portions.</span></span><br><span class="line"><span class="comment"> * When not used, they don&#x27;t add any memory overhead, but when used and then</span></span><br><span class="line"><span class="comment"> * deleted, some overhead remains (to avoid resonance).</span></span><br><span class="line"><span class="comment"> * The number of bookmarks used should be kept to minimum since it also adds</span></span><br><span class="line"><span class="comment"> * overhead on node deletion (searching for a bookmark to update). */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistBookmark</span> &#123;</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; quicklistBookmark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: -1 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor.</span></span><br><span class="line"><span class="comment"> * &#x27;bookmakrs are an optional feature that is used by realloc this struct,</span></span><br><span class="line"><span class="comment"> *      so that they don&#x27;t consume memory when not used. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure><p>这里定义了6个结构体:</p><ul><li><code>quicklistNode</code>：宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例。</li><li><code>quicklistLZF</code>：ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例。</li><li><code>quicklistBookmark</code>：在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>：这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间。</li><li><code>quicklistIter</code>是一个迭代器。</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下。</li></ul><p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：        </p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-31230.png" alt="列表类型使用-quicklist结构图.png"></p><p><strong>quicklist更多额外信息：</strong></p><p>下面是有关quicklist的更多额外信息:</p><ul><li><code>quicklist.fill</code>的值影响着每个链表结点中, ziplist的长度. <ol><li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为:</li><li>-1 不超过4kb</li><li>-2 不超过 8kb</li><li>-3 不超过 16kb</li><li>-4 不超过 32kb</li><li>-5 不超过 64kb</li><li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li></ol></li><li><code>quicklist.compress</code>的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF <ol><li>0 表示不压缩, zl字段直接指向ziplist</li><li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>以此类推, 最大值为2^16</li></ol></li><li><code>quicklistNode.encoding</code>字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</li><li><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</li><li><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</li></ul><h4 id="zaplist"><a href="#zaplist" class="headerlink" title="zaplist"></a>zaplist</h4><p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，<strong>ziplist 数据结构</strong>如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-6.png" alt="img"></p><p>其中的字段含义如下：</p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数。</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作。</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到。</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255。</li></ul><p><strong>Entry 结构</strong></p><ul><li><strong>先看下源码中相关介绍</strong></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-7.png" alt="img"></p><p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p><ul><li><code>prevlen</code>：前一个entry的大小，编码方式见下文；</li><li><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</li><li><code>entry-data</code>：真是用于存储entry表示的数据；</li></ul><p><strong>第二种情况</strong>：在entry中存储的是int类型时，<code>encoding</code> 和<code>entry-data</code>会合并在<code>encoding</code>中表示，此时没有<code>entry-data</code>字段；</p><p>redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；</p><p>此时entry结构：<code>&lt;prevlen&gt; &lt;encoding&gt;</code></p><ul><li><strong>prevlen编码</strong></li></ul><p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;      //长度小于254结构</span><br><span class="line">0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;   //长度大于等于254</span><br></pre></td></tr></table></figure><ul><li><strong>encoding编码</strong></li></ul><p>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；</p><p>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><p><strong>存储string时</strong>：</p><p><code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；</p><p><code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；</p><p><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;</p><p><strong>存储int时</strong>：</p><p><code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；</p><p><code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32;</p><p><code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64;</p><p><code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；</p><p><code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；</p><p><code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；</p><p><code>|11111111|</code> 还记得zlend么？</p><ul><li><strong>源码中数据结构支撑</strong></li></ul><p>你可以看到为了操作上的简易实际还增加了几个属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><ul><li><code>prevrawlensize</code>表示 previous_entry_length字段的长度</li><li><code>prevrawlen</code>表示 previous_entry_length字段存储的内容</li><li><code>lensize</code>表示 encoding字段的长度</li><li><code>len</code>表示数据内容长度</li><li><code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和</li><li><code>encoding</code>表示数据类型</li><li><code>p</code>表示当前元素首地址</li></ul><p><strong>看个例子：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis_ziplist_sample.png" alt="Redis Ziplist Sample"></p><p>上图是一份真实的ziplist数据。我们逐项解读一下：</p><ul><li>这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</li><li>头4个字节（0x21000000）是按小端（little endian）模式存储的<code>&lt;zlbytes&gt;</code>字段。因此，这里<code>&lt;zlbytes&gt;</code>的值应该解析成0x00000021，用十进制表示正好就是33。</li><li>接下来4个字节（byte[4..7]）是<code>&lt;zltail&gt;</code>，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</li><li>再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</li><li>接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为”name”。</li><li>接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串”tielei”。</li><li>接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串”age”。</li><li>接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</li><li>最后1个字节（byte[32]）表示<code>&lt;zlend&gt;</code>，是固定的值255（0xFF）。</li></ul><p>总结一下，这个ziplist里存了4个数据项，分别为：</p><ul><li>字符串: “name”</li><li>字符串: “tielei”</li><li>字符串: “age”</li><li>整数: 20</li></ul><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="添加功能源码分析"><a href="#添加功能源码分析" class="headerlink" title="添加功能源码分析"></a>添加功能源码分析</h4><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        <span class="comment">// 在列表头部添加元素</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        <span class="comment">// 在列表尾部添加元素</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 quicklistPushHead 为例，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 在头部节点插入元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p><p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p><p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。 quicklistPushHead 执行流程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031232.png" alt="列表类型使用-插入流程图.png"></p><h4 id="删除功能源码分析"><a href="#删除功能源码分析" class="headerlink" title="删除功能源码分析"></a>删除功能源码分析</h4><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p><h5 id="单一元素删除"><a href="#单一元素删除" class="headerlink" title="单一元素删除"></a>单一元素删除</h5><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> &#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="type">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p><h5 id="区间元素删除"><a href="#区间元素删除" class="headerlink" title="区间元素删除"></a>区间元素删除</h5><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start 表示开始删除的下标，count 表示要删除的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="type">const</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> extent = count; </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// 删除的元素个数大于已有元素</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// 删除指定的元素个数</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// extent 为剩余需要删除的元素个数，</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> del;</span><br><span class="line">        <span class="type">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 删除整个 quicklistNode</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">           <span class="comment">// 删除本节点的所有元素</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除本节点部分元素</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line">        D(<span class="string">&quot;[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), &quot;</span></span><br><span class="line">          <span class="string">&quot;node count: %u&quot;</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余待删除元素的个数</span></span><br><span class="line">        extent -= del;</span><br><span class="line">        <span class="comment">// 下个 quicklistNode</span></span><br><span class="line">        node = next;</span><br><span class="line">        <span class="comment">// 从下个 quicklistNode 起始位置开始删除</span></span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p><p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p><h4 id="更多源码"><a href="#更多源码" class="headerlink" title="更多源码"></a>更多源码</h4><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p><ul><li>quicklistCreate：创建 quicklist；</li><li>quicklistInsertAfter：在某个元素的后面添加数据；</li><li>quicklistInsertBefore：在某个元素的前面添加数据；</li><li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li><li>quicklistReplaceAtIndex：替换某个元素。</li></ul><h2 id="性能优势-2"><a href="#性能优势-2" class="headerlink" title="性能优势"></a>性能优势</h2><p>quicklist有自己的优点， 也有缺点， 对于使用者来说， 其使用体验类似于线性数据结构， list作为最传统的双链表， 结点通过指针持有数据， 指针字段会耗费大量内存。 ziplist解决了耗费内存这个问题。 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配。 quicklist在两者之间做了一个平衡。 并且使用者可以通过自定义<code>quicklist.fill</code>， 根据实际业务情况， 经验主义调参。</p><h3 id="为什么-ziplist-特别省内存"><a href="#为什么-ziplist-特别省内存" class="headerlink" title="为什么 ziplist 特别省内存"></a>为什么 ziplist 特别省内存</h3><p>只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p><p>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</p><p>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</p><p>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</p><hr><p>结合了双向链表和ziplist的优点，quicklist就应运而生了。</p><h1 id="集合（Set）：独步天下的独行侠"><a href="#集合（Set）：独步天下的独行侠" class="headerlink" title="集合（Set）：独步天下的独行侠"></a>集合（Set）：独步天下的独行侠</h1><p>然后，我们的集合大师登场了！集合就像是江湖中的独行侠，天生不爱重复。他擅长处理那些独一无二的数据，无论是要去重还是计算交集并集，集合都能完美胜任。正是他那种独特的个性，让他在数据江湖中独步天下。</p><p>集合类型 (Set) 是一个无序并唯一的键值集合。之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储。</p><p>集合类型和列表类型的区别如下：</p><ul><li>列表可以存储重复元素，集合只能存储非重复元素；</li><li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1695732-20221206151400257-695491959.png" alt="img"></p><h2 id="如何使用？-3"><a href="#如何使用？-3" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-3"><a href="#命令行操作方式-3" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SADD key member1 member2 …</td><td>向指定集合添加一个或多个元素</td></tr><tr><td>SMEMBERS key</td><td>获取指定集合中的所有元素</td></tr><tr><td>SCARD key</td><td>获取指定集合的元素数量</td></tr><tr><td>SISMEMBER key member</td><td>判断指定元素是否在指定集合中</td></tr><tr><td>SINTER key1 key2 …</td><td>获取给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 key2 …</td><td>将给定所有集合的交集存储在 destination 中</td></tr><tr><td>SUNION key1 key2 …</td><td>获取给定所有集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 key2 …</td><td>将给定所有集合的并集存储在 destination 中</td></tr><tr><td>SDIFF key1 key2 …</td><td>获取给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 key2 …</td><td>将给定所有集合的差集存储在 destination 中</td></tr><tr><td>SPOP key count</td><td>随机移除并获取指定集合中一个或多个元素</td></tr><tr><td>SRANDMEMBER key count</td><td>随机获取指定集合中指定数量的元素</td></tr></tbody></table></div><p>更多 Redis Set 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=set">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-3"><a href="#代码操作方式（采用Go-Redis-V8-版本）-3" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>SAdd():添加元素</li><li>SPop():随机获取一个元素</li><li>SRem():删除集合里指定的值</li><li>SSMembers():获取所有成员</li><li>SIsMember():判断元素是否在集合中</li><li>SCard():获取集合元素个数</li><li>SUnion():并集,SDiff():差集,SInter():交集</li></ul><p>Tips：集合数据的特征，元素不能重复保持唯一性, 元素无序不能使用索引(下标)操作</p><p><strong>简单示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 集合元素缓存设置</span></span><br><span class="line">keyname := <span class="string">&quot;Program&quot;</span></span><br><span class="line">mem := []<span class="type">string</span>&#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Delphi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Golang&quot;</span>&#125;</span><br><span class="line"><span class="comment">// //由于Golang已经被添加到Program集合中，所以重复添加时无效的</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> mem &#123;</span><br><span class="line">rdb.SAdd(ctx, keyname, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SCard() 获取集合元素个数</span></span><br><span class="line">total, _ := rdb.SCard(ctx, keyname).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;golang集合成员个数: &quot;</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPop() 随机获取一个元素 （无序性，是随机的）</span></span><br><span class="line">val1, _ := rdb.SPop(ctx, keyname).Result()</span><br><span class="line"><span class="comment">// SPopN()  随机获取多个元素.</span></span><br><span class="line">val2, _ := rdb.SPopN(ctx, keyname, <span class="number">2</span>).Result()</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSMembers() 获取所有成员</span></span><br><span class="line">val3, _ := rdb.SMembers(ctx, keyname).Result()</span><br><span class="line">fmt.Printf(<span class="string">&quot;随机获取一个元素: %v , 随机获取多个元素: %v \n所有成员: %v\n&quot;</span>, val1, val2, val3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIsMember() 判断元素是否在集合中</span></span><br><span class="line">exists, _ := rdb.SIsMember(ctx, keyname, <span class="string">&quot;golang&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;golang 存在 Program 集合中.&quot;</span>) <span class="comment">// 注意:我们存入的是Golang而非golang</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;golang 不存在 Program 集合中.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SUnion():并集, SDiff():差集, SInter():交集</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;setB&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">union, _ := rdb.SUnion(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;并集&quot;</span>, union)</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line">diff, _ := rdb.SDiff(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;差集&quot;</span>, diff)</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">inter, _ := rdb.SInter(ctx, <span class="string">&quot;setA&quot;</span>, <span class="string">&quot;setB&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;交集&quot;</span>, inter)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除集合中指定元素(返回成功)</span></span><br><span class="line">  n, _ := rdb.SRem(ctx, <span class="string">&quot;setB&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;f&quot;</span>).Result()</span><br><span class="line">  fmt.Println(<span class="string">&quot;已成功删除元素的个数: &quot;</span>,n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031226.png" alt="集合Set-hashtable.png"></p><p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储。</p><p>当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储：</p><ol><li>当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。 </li><li>当元素为非整数时，集合将会使用 hashtable 来存储。</li></ol><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>先看源码结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 <strong>encoding 属性</strong>的值：如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。下图是一个包含五个 int16_t 类型整数值的整数集合。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/46856dc6c841acc54dc4a4513eda1007.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-8.png" alt="img"></p><p>可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？</p><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ul><li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ul><p>整数集合<strong>不支持降级操作</strong>， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p><h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 添加元素到集合</span></span><br><span class="line"><span class="comment"> * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 字典类型</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// inset 数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转化为整数类型失败，使用字典类型存储</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未知编码(类型)</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p><h2 id="性能优势-3"><a href="#性能优势-3" class="headerlink" title="性能优势"></a>性能优势</h2><p>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p><p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p><h1 id="有序集合（Sorted-Set）：运筹帷幄的智者"><a href="#有序集合（Sorted-Set）：运筹帷幄的智者" class="headerlink" title="有序集合（Sorted Set）：运筹帷幄的智者"></a>有序集合（Sorted Set）：运筹帷幄的智者</h1><p>最后一位出场的是有序集合，这位兄弟简直是个运筹帷幄的智者。他不仅有集合哥的特质，还多了一项绝技：排序。每个成员都有一个分数，他可以根据分数将成员排序，非常适合排行榜、评分系统等场景。</p><p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p><p>当我们把学生的成绩存储在有序集合中时，它的存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2020-02-28-031227.png" alt="学生存储值.png"></p><h2 id="如何使用？-4"><a href="#如何使用？-4" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="命令行操作方式-4"><a href="#命令行操作方式-4" class="headerlink" title="命令行操作方式"></a>命令行操作方式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>ZADD key score1 member1 score2 member2 …</td><td>向指定有序集合添加一个或多个元素</td></tr><tr><td>ZCARD KEY</td><td>获取指定有序集合的元素数量</td></tr><tr><td>ZSCORE key member</td><td>获取指定有序集合中指定元素的 score 值</td></tr><tr><td>ZINTERSTORE destination numkeys key1 key2 …</td><td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td></tr><tr><td>ZUNIONSTORE destination numkeys key1 key2 …</td><td>求并集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZDIFF destination numkeys key1 key2 …</td><td>求差集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td></tr><tr><td>ZREVRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td></tr><tr><td>ZREVRANK key member</td><td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td></tr></tbody></table></div><p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 <a href="https://redis.io/commands/?group=sorted-set">Redis 官网</a>对应的介绍。</p><h3 id="代码操作方式（采用Go-Redis-V8-版本）-4"><a href="#代码操作方式（采用Go-Redis-V8-版本）-4" class="headerlink" title="代码操作方式（采用Go-Redis V8 版本）"></a>代码操作方式（采用Go-Redis V8 版本）</h3><p>常用方法:</p><ul><li>ZAdd():添加元素</li><li>ZIncrBy():增加元素分值</li><li>ZRange()、ZRevRange():获取根据score排序后的数据段</li><li>ZRangeByScore()、ZRevRangeByScore():获取score过滤后排序的数据段</li><li>ZCard():获取元素个数</li><li>ZCount():获取区间内元素个数</li><li>ZScore():获取元素的score</li><li>ZRank()、ZRevRank():获取某个元素在集合中的排名</li><li>ZRem():删除元素</li><li>ZRemRangeByRank():根据排名来删除</li><li>ZRemRangeByScore():根据分值区间来删除</li></ul><p><strong>简单示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zsetExample</span><span class="params">(rdb *redis.Client, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 有序集合成员与分数设置</span></span><br><span class="line"><span class="comment">// zSet类型需要使用特定的类型值*redis.Z，以便作为排序使用</span></span><br><span class="line">lang := []*redis.Z&#123;</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">90.0</span>, Member: <span class="string">&quot;Golang&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">98.0</span>, Member: <span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">95.0</span>, Member: <span class="string">&quot;Python&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">97.0</span>, Member: <span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">&amp;redis.Z&#123;Score: <span class="number">99.0</span>, Member: <span class="string">&quot;C/C++&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入ZSet类型</span></span><br><span class="line">num, err := rdb.ZAdd(ctx, <span class="string">&quot;language_rank&quot;</span>, lang...).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zadd failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zadd %d succ.\n&quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ZSet中的某一个元素顺序值增加: 把Golang的分数加10</span></span><br><span class="line">newScore, err := rdb.ZIncrBy(ctx, <span class="string">&quot;language_rank&quot;</span>, <span class="number">10.0</span>, <span class="string">&quot;Golang&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zincrby failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Golang&#x27;s score is %f now.\n&quot;</span>, newScore)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据分数排名取出元素:取分数最高的3个</span></span><br><span class="line">ret, err := rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;language_rank&quot;</span>, <span class="number">0</span>, <span class="number">2</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zrevrange failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zsetKey前3名热度的是: %v\n,Top 3 的 Memeber 与 Score 是:\n&quot;</span>, ret)</span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">fmt.Println(z.Member, z.Score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZRangeByScore()、ZRevRangeByScore():获取score过滤后排序的数据段</span></span><br><span class="line"><span class="comment">// 此处表示取95~100分的</span></span><br><span class="line">op := redis.ZRangeBy&#123;</span><br><span class="line">Min: <span class="string">&quot;95&quot;</span>,</span><br><span class="line">Max: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">ret, err = rdb.ZRangeByScoreWithScores(ctx, <span class="string">&quot;language_rank&quot;</span>, &amp;op).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;zrangebyscore failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出全部成员及其score分数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;language_rank 键存储的全部元素:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">fmt.Println(z.Member, z.Score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p><h3 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h4><p>跳跃表（zskiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p><p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p><p> Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。</p><p><strong>跳跃表的实现原理：</strong></p><p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-9.png" alt="img"></p><p>如果我们增加如下两级索引，那么它搜索次数就变成了3次</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/db-redis-ds-x-10.png" alt="img"></p><h3 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>层</p><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p><p>下图分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ，以此类推。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d96fcb014a96af27bcebc26c724919dc.png" alt="img"></p><p>跨度</p><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：两个节点之间的跨度越大， 它们相距得就越远。指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</p><p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子， 下图用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/9ddac8937a38c8bb4a3a7850c1a8a188.png" alt=""></p><p>后退指针</p><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p><p>下图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bbfca4ed488e379585b9ea102757b232.png" alt="img"></p><p>分值和成员</p><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p>举个例子， 在下图所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &lt;= o2 &lt;= o3 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c62c33310c977b13d64a210dadbe0a13.png" alt="img"></p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/964cab7318119286f61ffb60a39d942b.png" alt="img"></p><p>但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如下图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a09e3a9836113e5a9da1ccaeeefb3241.png" alt="img"></p><p>zskiplist 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中节点的数量    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数    </span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</li><li>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</li><li>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</li></ul><h2 id="性能优势-4"><a href="#性能优势-4" class="headerlink" title="性能优势"></a>性能优势</h2><h3 id="为什么是跳跃表？而非红黑树？"><a href="#为什么是跳跃表？而非红黑树？" class="headerlink" title="为什么是跳跃表？而非红黑树？"></a>为什么是跳跃表？而非红黑树？</h3><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p><h3 id="kiplist与平衡树、哈希表的比较"><a href="#kiplist与平衡树、哈希表的比较" class="headerlink" title="kiplist与平衡树、哈希表的比较"></a>kiplist与平衡树、哈希表的比较</h3><p>来源于：<a href="https://www.jianshu.com/p/8ac45fd01548">https://www.jianshu.com/p/8ac45fd01548</a></p><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通过学习上面的内容，我们已经非常了解这五种数据结构的基本使用和内部原理了，那么在实际生产中到底要怎么用，每种数据结构的使用场景是什么，我们来看一下。</p><p>当然！下面是关于Redis五种基础数据结构的应用场景的详细介绍：</p><h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>缓存数据</strong>：字符串是缓存数据的最常用数据结构，比如缓存用户信息、产品详情等。</li><li><strong>计数器</strong>：使用INCR、DECR等命令，可以轻松实现各种计数功能，如网站访问量、点赞数等。</li><li><strong>会话存储</strong>：将用户会话信息存储在字符串中，便于快速读取和更新。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存用户信息</span></span><br><span class="line">SET user:<span class="number">1001</span> <span class="string">&quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数器：增加网站访问量</span></span><br><span class="line">INCR site:views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话存储：设置和获取用户会话</span></span><br><span class="line">SET session:<span class="number">12345</span> <span class="string">&quot;user_id:1001&quot;</span></span><br><span class="line">GET session:<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h2><h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>存储对象</strong>：哈希非常适合存储具有多个字段的对象，如用户信息、商品信息等。</li><li><strong>轻量级的数据存储</strong>：可以存储相对较小的数据，如配置项、状态信息等。</li><li><strong>减少内存消耗</strong>：对于多字段数据，使用哈希可以比字符串节省内存。</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储用户信息</span></span><br><span class="line">HSET user:<span class="number">1001</span> name <span class="string">&quot;John Doe&quot;</span> age <span class="number">30</span> email <span class="string">&quot;john@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的某个字段</span></span><br><span class="line">HGET user:<span class="number">1001</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的所有字段</span></span><br><span class="line">HGETALL user:<span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>任务队列</strong>：列表可以用作任务队列，支持从两端插入和删除元素。</li><li><strong>消息队列</strong>：可以用列表来实现简单的消息队列，保证消息的顺序性。</li><li><strong>日志存储</strong>：将日志条目存储在列表中，便于按时间顺序追加和读取。</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加任务到队列</span></span><br><span class="line">LPUSH task_queue <span class="string">&quot;Task1&quot;</span></span><br><span class="line">RPUSH task_queue <span class="string">&quot;Task2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列获取任务</span></span><br><span class="line">LPOP task_queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储日志条目</span></span><br><span class="line">RPUSH logs <span class="string">&quot;Log entry 1&quot;</span></span><br><span class="line">RPUSH logs <span class="string">&quot;Log entry 2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><h3 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>去重</strong>：集合天生不允许重复元素，非常适合用于去重场景。</li><li><strong>标签管理</strong>：适合存储用户标签、商品标签等。</li><li><strong>社交网络</strong>：可以用来管理好友关系、共同兴趣等。</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储用户标签</span></span><br><span class="line">SADD user:<span class="number">1001</span>:tags <span class="string">&quot;redis&quot;</span> <span class="string">&quot;database&quot;</span> <span class="string">&quot;nosql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在某标签</span></span><br><span class="line">SISMEMBER user:<span class="number">1001</span>:tags <span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有标签</span></span><br><span class="line">SMEMBERS user:<span class="number">1001</span>:tags</span><br></pre></td></tr></table></figure><h2 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h2><h3 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>排行榜</strong>：有序集合非常适合实现排行榜，按分数排序展示前N名用户。</li><li><strong>带权重的数据存储</strong>：适用于需要按权重排序的数据，如评分系统。</li><li><strong>延迟队列</strong>：可以根据分数（时间戳）实现延迟任务队列。</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户到排行榜</span></span><br><span class="line">ZADD leaderboard <span class="number">100</span> <span class="string">&quot;Alice&quot;</span> <span class="number">200</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取排行榜前N名</span></span><br><span class="line">ZRANGE leaderboard <span class="number">0</span> <span class="number">1</span> WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某用户的排名</span></span><br><span class="line">ZRANK leaderboard <span class="string">&quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><p>通过这些应用场景的介绍，相信你对Redis五种基础数据结构的使用有了更深入的了解。每种数据结构都有其独特的优势和适用场景，根据具体需求选择合适的数据结构可以大大提升系统的性能和效率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis数据结构五兄弟，各个身怀绝技，各有千秋。无论是字符串的快剑手、哈希的万花筒、列表的快马、集合的独行侠，还是有序集合的智者，他们都在数据江湖中扮演着不可或缺的角色。希望这篇介绍能让你对Redis的五种基础数据结构有一个更生动形象的了解。让我们一起在Redis的世界中，成为数据江湖的侠客吧！</p><p>哈哈，抽象的标题、抽象的开头和抽象的结尾，笔者实在是懒得去想这些东西要怎么写了，但是又想搞一篇有趣的文章，于是去请教了万能的人工智能 ChatGPt，还可以吧，描述很传神。</p><p>这篇博客真是史诗级的长度，光是看标题就看的眼花缭乱，本来只看了技术摘抄里的文章，觉得好像没有多少内容，还在感慨昨天没学什么东西。结果在搜索更多的资料时发现看的全是概述，重要的内容还没学，于是边学边写，太夸张了，不过还是学到了不少东西的。</p><p>在正式学习 Redis 底层之前，一直觉得 Redis 快就是因为它被存放在内存里，现在发现其实它每一处的设计都有考虑性能和效率。 </p><p>什么？你问为什么今天没有记录什么有趣的东西。</p><p>实在是因为最近一直都在闷着头学东西，也就没怎么去关心实习方面的事，不找实习，连烦恼都消失不见了。</p><p>终于知道为什么大家都讨厌HR了，老小子耍我，说要让技术经理加我的微信跟我面试，结果到现在都没有，骗子不得好死。还好我本来就没有抱希望。</p><p>不过昨天我的好舍友说把我的简历发给他的Leader看了，说不定能帮我找一个实习，不过以我的狗运气，应该不太可能。还是沉下心来学习吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98">Redis数据结构的基本使用和内部原理</a></p><p><a href="https://www.cnblogs.com/xiangningdeguang/p/16955355.html">数据结构的命令行用法</a></p><p><a href="https://www.cnblogs.com/timelesszhuang/p/go-redis.html">数据结构的Go 语言操作</a></p><p><a href="https://blog.csdn.net/a745233700/article/details/113449889">Redis 底层数据结构的概述</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">Redis 底层数据结构的详解</a></p><p><a href="https://xie.infoq.cn/article/78215ce2bb651e7079ea3c80b">Redis 底层数据结构的详解 2</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-dict.html">dict详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-sds.html">SDS详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-robj.html">robj详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-ziplist.html">ziplist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-quicklist.html">quicklist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">skiplist详解</a></p><p><a href="http://zhangtielei.com/posts/blog-redis-intset.html">intset详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天继续学习 Redis 相关的知识，Redis 的五种基础数据结构。虽然在之前的博客中也有提到过这五种数据结构，当时赶着背东西，基本上就是从别人的八股文里抄的，所以还是重新学一下，重新记录加深记忆，正文开始。&lt;/p&gt;
&lt;p&gt;在数据的江湖里，Redis无疑是那位神秘莫测、武</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：让你的数据不再“无疾而终”</title>
    <link href="http://example.com/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/"/>
    <id>http://example.com/2024/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%86%8D%E2%80%9C%E6%97%A0%E7%96%BE%E8%80%8C%E7%BB%88%E2%80%9D/</id>
    <published>2024-06-04T09:21:41.000Z</published>
    <updated>2024-06-04T11:03:27.376Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的出现，大大提高了我们的查询速度，因其将数据存在内存中，我们的查询速度得到了质的提升。也正是因为在内存中，如果服务器突然断电关机，再次开机后我们的数据也就荡然无存了，这会让我们很崩溃。如何解决？那就是 Redis 的持久化。</p><p>今天我要聊的就是 Redis 持久化。没错，就是那个让你的数据在服务器重启后依然坚挺的功能。不知道你有没有这种感觉：当你以为自己写的代码“永垂不朽”时，服务器重启却让一切化为乌有？别担心，Redis 持久化来拯救你！</p><h1 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h1><p>Redis是一个超级快的内存数据库，但问题来了，内存的特点是断电即失，所以Redis默认情况下，你的数据就像美梦一样——一觉醒来全没了。因此，Redis提供了持久化的功能，帮你把数据存储到硬盘上，这样就算是大风吹断电缆，你的数据也不会“风中凌乱”。</p><p>Redis 持久化拥有以下三种方式：</p><ul><li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li><li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li></ul><p>接下来，咱们一个一个聊。</p><h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p>RDB(Redis database)：实现方式是将存在 Redis 内存中的数据写入到 RDB 文件中保存到磁盘上从而实现持久化的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604174014416.png" alt="image-20240604174014416"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16530eac18882d66%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image1"></p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><p>触发rdb持久化的方式有2种，分别是<strong>手动触发</strong>和<strong>自动触发</strong></p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>Redis 中对于手动触发备份数据到 RDB 文件中，提供了两种方式</p><ol><li><p><code>save</code>: 在主线程中执行，不过这种会阻塞 Redis 服务进程；</p></li><li><p><code>bgsave</code>: 主线程会 fork 出一个子进程来负责处理 RDB 文件的创建，不会阻塞主线程的命令操作，这也是 Redis 中 RDB 文件生成的默认配置；</p></li></ol><p>对于 <code>save</code> 和 <code>bgsave</code> 这两种快照方式，服务端是禁止这两种方式同时执行的，防止产生竞争条件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604174933377.png" alt="image-20240604174933377"></p><p>具体流程如下：</p><ul><li>redis客户端执行<code>bgsave</code>命令或者自动触发<code>bgsave</code>命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就<code>fork</code>一个新的子进程进行持久化数据，<code>fork</code>过程是阻塞的，<code>fork</code>操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。</li></ul><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li>执行debug reload命令重新加载redis时也会触发<code>bgsave</code>操作；</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发<code>bgsave</code>操作；</li></ul><h2 id="redis-conf-中配置-RDB"><a href="#redis-conf-中配置-RDB" class="headerlink" title="redis.conf 中配置 RDB"></a>redis.conf 中配置 RDB</h2><p><strong>快照周期</strong>：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。</p><ul><li><strong>Redis中默认的周期新设置</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 周期性执行条件的设置格式为</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line"># 默认的设置为：</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 以下设置方式为关闭RDB快照功能</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照；</li><li>如果300秒内有10条Key信息发生变化，则进行快照；</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整。</li></ul><p>其他相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p><code>dbfilename</code>：RDB文件在磁盘上的名称。</p><p><code>dir</code>：RDB文件的存储路径。默认设置为“./”，也就是Redis服务的主目录。</p><p><code>stop-writes-on-bgsave-error</code>：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no。</p><p><code>rdbcompression</code>：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”。</p><p><code>rdbchecksum</code>：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no。</p><h2 id="快照时发生数据修改"><a href="#快照时发生数据修改" class="headerlink" title="快照时发生数据修改"></a>快照时发生数据修改</h2><ul><li><strong>由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢</strong>？</li></ul><p>RDB中的核心思路是<strong>Copy-on-Write</strong>，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-rdb-cow.png" alt="redis"></p><h2 id="多久做一次快照"><a href="#多久做一次快照" class="headerlink" title="多久做一次快照"></a>多久做一次快照</h2><p>对于快照，如果做的太频繁，可能会出现前一次快照还没有处理完成，后面的快照数据马上就进来了，同时过于频繁的快照也会增加磁盘的压力。</p><p>如果间隔时间过久，服务器在两次快照期间宕机，丢失的数据大小会随着快照间隔时间的增长而增加。</p><p>那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。</p><p>但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的<strong>空间开销问题</strong>。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？且看后文中4.0版本中引入的RDB和AOF的混合方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li><strong>缺点</strong><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p><h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><p>AOF(Append Only File)：通过保存数据库执行的命令来记录数据库的状态。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-aof.png" alt="redis"></p><p>AOF日志对数据库命令的保存顺序是，Redis 先执行命令，把数据写入内存，然后才记录日志。</p><p><strong>为什么采用写后日志？</strong></p><p>Redis 要求高性能，采用写日志有量方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作。</li></ul><h2 id="如何实现-AOF"><a href="#如何实现-AOF" class="headerlink" title="如何实现 AOF"></a>如何实现 AOF</h2><p>AOF 日志记录 Redis 的每个命令，步骤为：命令追加(append)、文件写入(write) 和文件同步(sync)。</p><ul><li><strong>命令追加：</strong>当 AOF 持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将执行的写命令追加到服务器的 <code>aof_buf</code> 缓冲区。</li><li><strong>文件写入和同步：</strong>关于何时将 <code>aof_buf</code> 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-4.jpg" alt="img"></p><p><code>Always</code>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p><p><code>Everysec</code>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p><p><code>No</code>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><hr><p><strong>三种写回策略的优缺点</strong></p><p>上面的三种写回策略体现了一个重要原则：<strong>trade-off</strong>，取舍，指在性能和可靠性保证之间做取舍。</p><p>关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的：</p><blockquote><p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p><p>这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p></blockquote><h2 id="redis-conf-中配置-AOF"><a href="#redis-conf-中配置-AOF" class="headerlink" title="redis.conf 中配置 AOF"></a>redis.conf 中配置 AOF</h2><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>以下是Redis中关于AOF的主要配置信息：</p><p><code>appendonly</code>：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p><p><code>appendfilename</code>：这个参数项很好理解了，就是AOF文件的名字。</p><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。</p><p>什么叫“真正执行”呢？还记得Linux操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中I/O队列的操作效率，应用程序提交的I/O操作请求一般是被放置在linux Page Cache中的，然后再由Linux操作系统中的策略自行决定正在写到磁盘上的时机。而Redis中有一个fsync()函数，可以将Page Cache中待写的数据真正写入到物理设备上，而缺点是频繁调用这个fsync()函数干预操作系统的既定策略，可能导致I/O卡顿的现象频繁 。</p><p>与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为everysec。</p><p><code>no-appendfsync-on-rewrite</code>：always和everysec的设置会使真正的I/O操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的Redis是没法解决的。为了尽量缓解这个情况，Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache（这段时间Redis还在接受客户端的各种写操作命令）。</p><p><code>auto-aof-rewrite-percentage</code>：上文说到在生产环境下，技术人员不可能随时随地使用“BGREWRITEAOF”命令去重写AOF文件。所以更多时候我们需要依靠Redis中对AOF文件的自动重写策略。Redis中对触发自动重写AOF文件的操作提供了两个设置：auto-aof-rewrite-percentage表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。</p><p><code>auto-aof-rewrite-min-size</code>：参考auto-aof-rewrite-percentage选项的介绍，auto-aof-rewrite-min-size设置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage和auto-aof-rewrite-min-size只是用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右。</p><h2 id="AOF-文件重写机制"><a href="#AOF-文件重写机制" class="headerlink" title="AOF 文件重写机制"></a>AOF 文件重写机制</h2><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供<strong>AOF文件重写机制</strong>来对AOF文件进行“瘦身”。</p><p>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-1.jpg" alt="img"></p><p>简单来讲就是多变一，就是把 AOF 中日志根据当前键值的状态，合并成一条操作命令。</p><p>重写之后的文件会保存到新的 AOF 文件中，这时候旧的 AOF 文件和新的 AOF 文件中键值对的状态是一样的。然后新的 AOF 文件会替换掉旧的 AOF 文件，这样 重写操作一直在进行，AOF 文件就不至于变的过大。</p><p><strong>AOF会阻塞吗？</strong></p><p>AOF重写过程是由后台进程<code>bgrewriteaof</code>来完成的。主线程<code>fork</code>出后台的<code>bgrewriteaof</code>子进程，<code>fork</code>会把主线程的内存拷贝一份给<code>bgrewriteaof</code>子进程，这里面就包含了数据库的最新数据。然后，<code>bgrewriteaof</code>子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>所以aof在重写时，在<code>fork</code>进程时是会阻塞住主线程的。</p><p><strong>AOF日志何时会重写？</strong></p><p>有两个配置项控制AOF重写的触发：</p><p><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。</p><p><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p><p><strong>重写日志时，有新数据写入咋整</strong>？</p><p>重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个  aof 日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：<code>bgrewriteaof</code>进程使用的日志文件）</p><p>而在<code>bgrewriteaof</code>子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。</p><p>最后通过修改文件名的方式，保证文件切换的原子性。</p><p>在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604183732936.png" alt="image-20240604183732936"></p><p><strong>为什么AOF重写不复用原AOF日志</strong>？</p><p>两方面原因：</p><ol><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li></ol><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>AOF 优点</strong></p><ul><li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li><li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li><li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li></ul><p><strong>AOF 缺点</strong></p><ul><li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li><li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li><li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li></ul><h1 id="RDB-和-AOF-混合方式"><a href="#RDB-和-AOF-混合方式" class="headerlink" title="RDB 和 AOF 混合方式"></a>RDB 和 AOF 混合方式</h1><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h1 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h1><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-x-aof-5.png" alt="img"></p><ul><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ul><p>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h1 id="过期的键如何持久化"><a href="#过期的键如何持久化" class="headerlink" title="过期的键如何持久化"></a>过期的键如何持久化</h1><p>在生成 RDB 文件的过程中，如果一个键已经过期，那么其不会被保存到 RDB 文件中。在载入 RDB 的时候，要分两种情况：</p><ul><li>如果 Redis 以主服务器的模式运行，那么会对 RDB 中的键进行时间检查，过期的键不会被恢复到 Redis 中。</li><li>如果 Redis 以从服务器的模式运行，那么 RDB 中所有的键都会被载入，忽略时间检查。在从服务器与主服务器进行数据同步的时候，从服务器的数据会先被清空，所以载入过期键不会有问题。</li></ul><p>对于 AOF 来说，如果一个键过期了，那么不会立刻对 AOF 文件造成影响。因为 Redis 使用的是惰性删除和定期删除，只有这个键被删除了，才会往 AOF 文件中追加一条 DEL 命令。在重写 AOF 的过程中，程序会检查数据库中的键，已经过期的键不会被保存到 AOF 文件中。</p><p>在运行过程中，对于主从复制的 Redis，主服务器和从服务器对于过期键的处理也不相同：</p><ul><li>对于主服务器，一个过期的键被删除了后，会向从服务器发送 DEL 命令，通知从服务器删除对应的键；</li><li>从服务器接收到读取一个键的命令时，即使这个键已经过期，也不会删除，而是照常处理这个命令；</li><li>从服务器接收到主服务器的 DEL 命令后，才会删除对应的过期键。</li></ul><p>这样保证了数据的一致性，一个键值对存在于主服务器，也必然存在于从服务器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis 4.0中提出了一个混合使用 AOF 日志和内存快照的方法，如果想要保证数据不丢失，这是一个比较好的选择；</p><p>如果允许分钟级别的数据丢失，可以只使用RDB；</p><p>如果只用AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</p><p>行文至此，我只能说大概了解了 Redis 如何进行持久化，还是有一些地方不是很清楚，后续会去读其他的文章来解开我心中的疑惑。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ybyn/p/14157568.html">https://www.cnblogs.com/ybyn/p/14157568.html</a></li><li><a href="https://boilingfrog.github.io/2022/01/07/redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/#%E5%89%8D%E8%A8%80">https://boilingfrog.github.io/2022/01/07/redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/#%E5%89%8D%E8%A8%80</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html</a></li><li><a href="https://juejin.cn/post/6844903655527677960">https://juejin.cn/post/6844903655527677960</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/03%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94RDB.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/03%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94RDB.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/04%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94AOF.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/04%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94AOF.md</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/05%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/05%20Redis%20%e6%8c%81%e4%b9%85%e5%8c%96%e2%80%94%e2%80%94%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis的出现，大大提高了我们的查询速度，因其将数据存在内存中，我们的查询速度得到了质的提升。也正是因为在内存中，如果服务器突然断电关机，再次开机后我们的数据也就荡然无存了，这会让我们很崩溃。如何解决？那就是 Redis 的持久化。&lt;/p&gt;
&lt;p&gt;今天我要聊的就是 Red</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis执行流程大揭秘：从命令到结果的奇幻之旅</title>
    <link href="http://example.com/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/"/>
    <id>http://example.com/2024/06/04/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E4%BB%8E%E5%91%BD%E4%BB%A4%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/</id>
    <published>2024-06-04T08:10:46.000Z</published>
    <updated>2024-06-04T09:13:31.122Z</updated>
    
    <content type="html"><![CDATA[<p>随着内卷这一情况的不断深化，在数据库方面只学习 MySQL 显然是不够的。那么效率极高的 Redis 就成为了学习首选，以至于现在熟练掌握 Redis 已经成为应届生的必备技能了。</p><p>笔者也是在一个多月前第一次接触到 Redis，期间断断续续地学了一点内容，但并不是深入系统的学习，只是去看了一下几个常见问题的八股文，太浮躁了。既然要直接准备秋招，那就还有大把的时间，所以今天开始系统地学习一下 Redis 相关的内容。</p><p>安装、运行这些最开始的东西就不多赘述了，毕竟操作 Redis 的代码也已经写了不少了。那除了这些以外，还有什么适合当作学习的第一步呢？</p><p>今天的文章将会深入 Redis 到底是如何执行我们输入的命令的。</p><h1 id="Redis-是怎么执行命令的？"><a href="#Redis-是怎么执行命令的？" class="headerlink" title="Redis 是怎么执行命令的？"></a>Redis 是怎么执行命令的？</h1><p>面对这个问题，大部分朋友心中的答案是：客户端发送命令给到服务端，服务端收到执行之后再处理将命令执行结果返回给客户端，简单来说如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9124af423f948eecb328a3ead95259b.png" alt="img"></p><p>显然这样的答案不能帮我们了解 Redis 的工作原理，还是看看更细节的过程吧。</p><h2 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h2><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604162911047.png" alt="image-20240604162911047"></p><h2 id="第一步：连接"><a href="#第一步：连接" class="headerlink" title="第一步：连接"></a>第一步：连接</h2><p>一切的开始，都是从客户端和Redis服务器之间的连接开始的。这就好比你和朋友约好了一起去探险，首先得打个电话确认一下。</p><ol><li><strong>客户端发送连接请求</strong>：客户端就像那个迫不及待的探险者，发出了一条连接请求。</li><li><strong>Redis服务器接受请求</strong>：Redis服务器则像是守门员，确认探险者的身份后，挥舞着双手迎接他们。</li></ol><p>在连接之前，我们先看一下 Redis 服务器的启动，这也是客户端能建立连接的前提。</p><p>Redis服务器启动后，需要经过一些列的初始化及配置的设置，比如状态参数、用户配置、初始化数据结构等，流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0652951979112aa1be062edf1d30223.jpg" alt="0652951979112aa1be062edf1d30223"></p><p>Redis 客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监听接客户端的 socket 连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 开启 Socket 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 【redis.h/redisServer】 中redisServer结构体存储Redis服务器的所有信息，包括但不限于数据库、</p><p>配置参数、命令表、监听端口与地址、客户端列表、若干统计信息、RDB与AOF持久化相关信息、主从复制相关信息、集群相关信息等。</p><p>而客户端连接服务器之前需要创建socket（一套固定的模式），然后根据设定的IP和端口号与服务器进行连接。</p><p>这里有个重要的知识点：在通过网络与redis服务器连接的普通客户端和lua脚本的客户端，服务器都会创建相对应的client 结构，用于记录他们的状态信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端在redisServer结构中的属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 存放普通客户端的列表</span></span><br><span class="line">    <span class="built_in">list</span> *clients;   <span class="comment">/* List of active clients */</span></span><br><span class="line">    <span class="comment">// 存放lua脚本客户端</span></span><br><span class="line">    client *lua_client;    <span class="comment">/* The &quot;fake client&quot; to query Redis from Lua */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Redis客户端其实有三种类型：1：负责执行Lua脚本的伪客户端，2：用来加载aof文件的伪客户端，3：通过网络连接的普通客户端</p></blockquote><p>到这里Redis客户端和服务端就完成连接，接下来继续看到底如何传输执行用户指令的！</p><h2 id="第二步：发送与解析"><a href="#第二步：发送与解析" class="headerlink" title="第二步：发送与解析"></a>第二步：发送与解析</h2><p>当连接建立后，客户端会发送命令给Redis服务器。这时候，就好像你给你的探险伙伴发出了一条魔法指令。</p><ol><li><p><strong>命令发送</strong>：你输入的命令就像是一封魔法信件，通过网络这个传送门，飞向Redis服务器。</p></li><li><p><strong>命令解析</strong>：Redis服务器收到信件后，会认真阅读（解析）你写的内容，确保每个字都理解无误。</p></li></ol><h3 id="客户端发送命令"><a href="#客户端发送命令" class="headerlink" title="客户端发送命令"></a>客户端发送命令</h3><p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于<strong>把服务器端的解析工作交给了每一个客户端</strong>，这样会很大程度的提高 Redis 的运行速度。</p><p>比如我们输入 <code>set xkey xiaoxu</code> 命令会转换成如下格式：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/13e2f2d81c17c4f91bea81ef096adcc1.png" alt="img"></p><p>你问上面的是什么意思，来看下面的解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*3        //参数个数是*开头，3个参数</span><br><span class="line">$3        //参数长度是$开头，命令长度</span><br><span class="line">SET       //命令名称SET</span><br><span class="line">$4        //参数长度是$开头，key长度</span><br><span class="line">xkey      //key的内容</span><br><span class="line">$6        //参数长度是$开头，value长度</span><br><span class="line">xiaoxu      //value内容</span><br><span class="line">参数个数是*开头，参数长度是$开头，每个参数通过\r\n隔开</span><br><span class="line">回复协议格式：</span><br><span class="line">* 状态回复（status reply）的第一个字节是 “+”，如：+ok\r\n</span><br><span class="line">* 错误回复（error reply）的第一个字节是 “-“，如：-ERR unknown command xxx\r\n</span><br></pre></td></tr></table></figure><h3 id="服务端读取命令"><a href="#服务端读取命令" class="headerlink" title="服务端读取命令"></a>服务端读取命令</h3><p>通过连接套接字让客户端的写入变得可读，服务端将读取协议内容，并存储到客户端的缓冲区，这里的缓冲区是client结构的输入缓冲区。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c722ffb11c89aa2bea50a9b31dd1f305.png" alt="img"></p><blockquote><p>每个连接到服务端的客户端，会保存在redisServer结构体中的clients链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 客户端状态的输入缓冲区，保存客户端的命令请求</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="comment">// 下面这两个是解析出来的命令和参数</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 一个是根据argv[0]解析出来的命令，一个是最后一次执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><p>接着会对输入缓冲区中的命令请求进行分析，提取解析出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/6634ecba67597fcf177bed53ec5cee4b.png" alt="img"></p><hr><p>这里插播一个小知识！</p><p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3d48b0f27f7c3338e76b109a7d02a8c7.png" alt="img"></p><h2 id="第三步：命令执行"><a href="#第三步：命令执行" class="headerlink" title="第三步：命令执行"></a>第三步：命令执行</h2><p>解析完命令之后，Redis服务器开始执行命令。这一过程就像是启动了一个巨大的魔法阵，能量开始在其中流动。</p><ol><li><strong>查找命令</strong>：Redis服务器会在它的魔法书（命令表）中找到相应的魔法（命令）来施展。</li><li><strong>执行命令</strong>：服务器根据魔法书中的指示，精准地执行命令。</li></ol><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><p>命令执行器根据客户端状态的<code>argv[0]</code>参数，在命令表中查找参数所指定的命令，本文中的<code>argv[0]</code>参数就是 set ，找到命令后保存到客户端状态的 cmd 属性。</p><blockquote><p><strong>命令表</strong>：其实就是一个字典，字典的键是命令名称，比如”set”、”get”、”del”；而值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2e4dfeda09bd4370c4cb7812d436d50f.png" alt="img"></p><p>SET命令的名字为”set”，实现函数为setCommand；命令的参数个数为-3，表示命令接受三个或以上数量的参数；命令的标识为”wm”，表示SET命令是一个写入命令。</p><p>GET命令的名字为 “get”，实现函数为getCommand函数；命令的参数个数为2，表示命令只接受两个参数；命令的标识为”r”，表示这是一个只读命令。</p><h3 id="执行准备：参数、权限、内存校验"><a href="#执行准备：参数、权限、内存校验" class="headerlink" title="执行准备：参数、权限、内存校验"></a>执行准备：参数、权限、内存校验</h3><p>获得了执行需要的命令、参数后，服务器还需要做一些校验：</p><p>命令校验：检查客户端状态的cmd指针是否指向NULL。</p><p>参数校验：根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确。</p><p>权限校验：检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令。</p><p>内存检测：如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行</p><p>其他校验..</p><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>服务器将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argv属性里面，当服务器执行命令时，只需要一个指向客户端状态的指针作为参数，调用实际执行函数。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2b16c771057fbfe6cb2ca425e7bd1464.png" alt="img"></p><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端</p><h3 id="后续：命令、参数、AOF"><a href="#后续：命令、参数、AOF" class="headerlink" title="后续：命令、参数、AOF"></a><strong>后续：命令、参数、AOF</strong></h3><p>执行完毕后，会有一些后续操作，包括慢日志记录、redisCommand结构属性更新、AOF持久化记录、主从复制命令传播等。</p><h2 id="第四步：返回结果"><a href="#第四步：返回结果" class="headerlink" title="第四步：返回结果"></a>第四步：返回结果</h2><p>命令执行完毕后，Redis服务器会将结果通过网络传送回客户端。这就像是魔法信使带着宝贵的探险成果返回你的身边。</p><ol><li><strong>结果生成</strong>：执行完命令后，Redis服务器生成结果，就像是从宝箱中拿出了宝物。</li><li><strong>结果传送</strong>：通过网络传送门，结果迅速飞回客户端。</li><li><strong>客户端接收</strong>：最终，客户端收到结果，探险圆满成功！</li></ol><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>发送完毕后，回复处理器会清空客户端状态的输出缓冲区，为下一个命令请求做好准备。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604165654029.png" alt="image-20240604165654029"></p><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p><p>比如之前的 set xkey xiaoxu，服务器发送的 “+OK\r\n”，通过协议转换成 “OK\n”</p><hr><p>ok，到这里其实整个发送命令和接收回复的流程就完成了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240604165949466.png" alt="image-20240604165949466"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们知道了一条Redis命令请求从发送到完成的步骤，答题如下：</p><ol><li>Redis客户端发送命令请求到服务器</li><li>服务器读取命令请求，解析命令参数</li><li>命令执行器根据命令参数查找命令的实际实现函数，然后执行，接着回复执行结果给客户端</li></ol><p>服务器的Server结构使用Clients链表来链接多个客户端的状态，包括我们的输入请求和输出结果、解析的命令参数等。</p><p>进入到闲聊部分，最近两天好像并没有什么有意思的事情发生，再决定不找实习之后反倒有几家公司找我要简历，当然还是老样子，要过简历之后就开始已读不回了，有时候想想当一个 HR 好爽啊，可以随时耍求职的人玩。好在我的心态已经放平了。</p><p>你问这么抽象的标题是怎么想出来的。对，就是ChatGPT给的，我觉得很好，优点标题党的意思了，营销号要失业了。</p><p>为了秋招顺利，我还是觉得要学一下 Java 的东西，只凭 Go 还是优点不安心。先把前段时间积压的东西学完，然后学着做一个项目。</p><p>对了，这一段时间的网络奇差无比，这样不好。月初有钱了，又想要冲动消费了，今天去看了苹果的头戴耳机，有点心动了，怎么办，克制一下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/01%20Redis%20%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98/01%20Redis%20%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84.md</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2311065">https://cloud.tencent.com/developer/article/2311065</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着内卷这一情况的不断深化，在数据库方面只学习 MySQL 显然是不够的。那么效率极高的 Redis 就成为了学习首选，以至于现在熟练掌握 Redis 已经成为应届生的必备技能了。&lt;/p&gt;
&lt;p&gt;笔者也是在一个多月前第一次接触到 Redis，期间断断续续地学了一点内容，但并</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>细说空结构体：Go语言中的奇妙用途</title>
    <link href="http://example.com/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/"/>
    <id>http://example.com/2024/06/03/%E7%BB%86%E8%AF%B4%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/</id>
    <published>2024-06-03T08:44:19.000Z</published>
    <updated>2024-06-03T09:50:24.011Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，正常的 <code>struct</code> 就是一个普通的内存块，必定是要占用一块内存的，并且结构体的大小是要经过边界，长度是对其的。</p><p>当你需要一个结构体，但是却丝毫不关系里面的内容，声明一个最小的结构体，也需要占用 1 字节，这是就要用到今天的主角——空结构体了。</p><p>“空结构体”是不占内存的，size 为 0；运行下面的代码可以得出，空结构体是不占用内存的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上来讲，使用空结构体的初衷只有一个：节省内存，但是更多的情况，节省的内存其实很有限，这种情况使用空结构体的考量其实是：<strong>根本不关心结构体变量的值</strong>。</p><h1 id="什么原理"><a href="#什么原理" class="headerlink" title="什么原理"></a>什么原理</h1><h2 id="特殊变量：zerobase"><a href="#特殊变量：zerobase" class="headerlink" title="特殊变量：zerobase"></a>特殊变量：<code>zerobase</code></h2><p>空结构体时没有内存大小的结构体。这句话是没有错，但是更准确的来说，其实是有一个特殊起点的，那就是 <code>zerobase</code> 变量，这是一个  <code>uintptr</code> 全局变量，占用 8 个字节。</p><p>当在任何地方定义无数个 <code>struct &#123;&#125;</code> 类型的变量，编译器都只是把这个 <code>zerobase</code> 变量的地址给出去。换句话说，在 GO 里面，涉及到所有内存 size 为 0 的内存分配，那么就是用的同一个地址 <code>&amp;zerobase</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">c := emptyStruct&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">0x57bb60</span><br><span class="line">0x57bb60</span><br><span class="line">0x57bb60</span><br></pre></td></tr></table></figure><p>无论如何定义空结构体，其变量都是一样的。</p><h2 id="内存特殊管理"><a href="#内存特殊管理" class="headerlink" title="内存特殊管理"></a>内存特殊管理</h2><p>编译器在编译期间，识别到 <code>struct &#123;&#125;</code> 这种特殊类型的内存分配，会统统分配出 <code>runtime.zerobase</code> 的地址出去，这个代码逻辑是在 <code>mallocgc</code> 函数里面：</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 分配 size 为 0 的结构体，把全局变量 zerobase 的地址给出去即可；</span></span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br></pre></td></tr></table></figure><p>golang 使用 <code>mallocgc</code> 分配内存的时候，如果 size 为 0 的时候，统一返回的都是全局变量 <code>zerobase</code> 的地址。</p><p>有这种全局唯一的特殊的地址也方便后面一些逻辑的特殊处理。</p><h1 id="定义的各种姿势"><a href="#定义的各种姿势" class="headerlink" title="定义的各种姿势"></a>定义的各种姿势</h1><h2 id="原生定义"><a href="#原生定义" class="headerlink" title="原生定义"></a>原生定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>struct&#123;&#125;</code> 可以就认为是一种类型，a 变量就是 <code>struct &#123;&#125;</code> 类型的一种变量，地址为 <code>runtime.zerobase</code> ，大小为 0 ，不占内存。</p><h2 id="重定义类型"><a href="#重定义类型" class="headerlink" title="重定义类型"></a>重定义类型</h2><p>golang 使用 <code>type</code>  关键字定义新的类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义出来的 <code>emptyStruct</code>  是新的类型，具有对应的 <code>type</code> 结构，但是性质 <code>struct&#123;&#125;</code> 完全一致，编译器对于 <code>emptryStruct</code> 类型的内存分配，也是直接给 <code>zerobase</code> 地址的。</p><h2 id="匿名嵌套类型"><a href="#匿名嵌套类型" class="headerlink" title="匿名嵌套类型"></a>匿名嵌套类型</h2><p><code>struct&#123;&#125;</code>  作为一个匿名字段，内嵌其他结构体。这种情况是怎么样的？</p><p><strong>匿名嵌套方式一</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">struct</span> &#123;</span><br><span class="line">    emptyStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名嵌套方式二</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住一点，空结构体还是空结构体，类型变量本身绝对不分配内存（ size=0 ），所以编译器对以上的 <code>Object</code>，<code>Object1</code> 两种类型的处理和空结构体类型是一致的，分配地址为 <code>runtime.zerobase</code> 地址，变量大小为0，不占任何内存大小。</p><h2 id="内置字段"><a href="#内置字段" class="headerlink" title="内置字段"></a>内置字段</h2><p>内置字段的场景没有什么特殊的，主要是地址和长度的对齐要考虑。还是只需要注意 3 个要点：</p><ul><li>空结构体的类型不占内存大小；</li><li>地址偏移要和自身类型对齐；</li><li>整体类型长度要和最长的字段类型长度对齐；</li></ul><p>我们分 3 种场景讨论这个问题：</p><p><strong>场景一：<code>struct &#123;&#125;</code>  在最前面</strong></p><p>这种场景非常好理解，<code>struct &#123;&#125;</code> 字段类型在最前面，这种类型不占空间，所以自然第二个字段的地址和整个变量的地址一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="comment">// Object1 类型变量占用 1 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">b <span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object2 类型变量占用 8 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object2 <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line">n <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1&#123; &#125;</span><br><span class="line">o2 := Object2&#123; &#125;</span><br></pre></td></tr></table></figure><p>内存怎么分配？</p><ul><li><code>&amp;o1</code>  和 <code>&amp;o1.s</code> 是一致的，变量 <code>o1</code>  的内存大小对齐到 1 字节；</li><li><code>&amp;o2</code>  和 <code>&amp;o2.s</code> 是一致的，变量 <code>o2</code>  的内存大小对齐到 8 字节；</li></ul><p>这种分配是满足对齐规则的，编译器也不会对这种 <code>struct &#123;&#125;</code> 字段做任何特殊的字节填充。</p><p><strong>场景二：<code>struct &#123;&#125;</code> 在中间</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object1 类型变量占用 16 个字节</span></span><br><span class="line"><span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">b  <span class="type">byte</span></span><br><span class="line">s  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">b1 <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>按照对齐规则，变量 <code>o1</code> 占用 16 个字节；</li><li><code>&amp;o1.s</code> 和 <code>&amp;o1.b1</code>  相同；</li></ul><p>编译器不会对 <code>struct &#123; &#125;</code> 做任何字节填充。</p><p><strong>场景三：<code>struct &#123;&#125;</code> 在最后</strong></p><p>这个场景稍微注意下，因为编译器遇到之后会做特殊的字节填充补齐，如下；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="keyword">type</span> Object1 <span class="keyword">struct</span> &#123;</span><br><span class="line">b <span class="type">byte</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object2 <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int64</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object3 <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int16</span></span><br><span class="line">m <span class="type">int16</span></span><br><span class="line">s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object4 <span class="keyword">struct</span> &#123;</span><br><span class="line">n  <span class="type">int16</span></span><br><span class="line">m  <span class="type">int64</span></span><br><span class="line">s  <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1 := Object1 &#123; &#125;</span><br><span class="line">o2 := Object2 &#123; &#125;</span><br><span class="line">o3 := Object3 &#123; &#125;</span><br><span class="line">o4 := Object4 &#123; &#125;</span><br></pre></td></tr></table></figure><p>编译器在遇到这种 <code>struct &#123;&#125;</code>  在<strong>最后一个字段</strong>的场景，会进行特殊填充，<code>struct &#123; &#125;</code> 作为最后一个字段，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变；</p><p>可以现在心里思考下，<code>o1</code>，<code>o2</code>，<code>o3</code>，<code>o4</code>  这四个对象的内存分配分别占多少空间？下面解密：</p><ul><li>变量 <code>o1</code>  大小为 2 字节；</li><li>变量 <code>o2</code>  大小为 16 字节；</li><li>变量 <code>o3</code>  大小为 6 字节；</li><li>变量 <code>o4</code>  大小为 24 字节；</li></ul><p>这种情况，需要先把 <code>struct &#123;&#125;</code>  按照前一个字段的长度分配 padding 内存，然后整个变量按照地址和长度的对齐规则不变。</p><h1 id="空结构体的作用"><a href="#空结构体的作用" class="headerlink" title="空结构体的作用"></a>空结构体的作用</h1><p>因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。</p><h2 id="实现-Set"><a href="#实现-Set" class="headerlink" title="实现 Set"></a>实现 Set</h2><p>Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。</p><p>因此呢，将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Has(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">_, ok := s[key]</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Add(key <span class="type">string</span>) &#123;</span><br><span class="line">s[key] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Delete(key <span class="type">string</span>) &#123;</span><br><span class="line"><span class="built_in">delete</span>(s, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>(Set)</span><br><span class="line">s.Add(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">s.Add(<span class="string">&quot;Sam&quot;</span>)</span><br><span class="line">fmt.Println(s.Has(<span class="string">&quot;Tom&quot;</span>))</span><br><span class="line">fmt.Println(s.Has(<span class="string">&quot;Jack&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不发送数据的-channel"><a href="#不发送数据的-channel" class="headerlink" title="不发送数据的 channel"></a>不发送数据的 <code>channel</code></h2><p>有时候使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。<code>struct&#123;&#125;</code> 通常作为一个信号来传输，并不关注其中内容。<code>channel</code> 本质的数据结构是一个管理结构加上一个 ringbuffer ，如果 <code>struct&#123;&#125;</code> 作为元素的话，ringbuffer 就是 0 分配的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> worker(ch)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种场景我们思考下，是否一定是非 <code>struct&#123;&#125;</code> 不可？其实不是，而且也不多这几个字节的内存，所以这种情况真的就只是不关心 <code>chan</code> 的元素值而已，所以才用的 <code>struct&#123;&#125;</code>。</p><h2 id="struct-作为-receiver"><a href="#struct-作为-receiver" class="headerlink" title="struct {} 作为 receiver"></a><code>struct &#123;&#125;</code> 作为 receiver</h2><p>receiver 这个是 golang 里 struct 具有的基础特点。空结构体本质上作为结构体也是一样的，可以作为 receiver 来定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyStruct)</span></span> FuncB(n, m <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e emptyStruct)</span></span> FuncA(n, m <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := emptyStruct&#123;&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">m := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a.FuncA(n, m)</span><br><span class="line">a.FuncB(n, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>receiver 这种写法是 golang 支撑面向对象的基础，本质上的实现也是非常简单，常规情况（普通的结构体）可以翻译成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncA</span> <span class="params">(e *emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncB</span> <span class="params">(e  emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器只是把对象的值或地址作为第一个参数传给这个参数而已，就这么简单。</strong> 但是在这里要提一点，空结构体稍微有一点点不一样，空结构体应该翻译成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncA</span> <span class="params">(e *emptyStruct, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncB</span> <span class="params">(n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00000000004525d0 &lt;main.main&gt;:</span><br><span class="line">  4525d0:64 48 8b 0c 25 f8 ff mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  4525d9:48 3b 61 10          cmp    0x10(%rcx),%rsp</span><br><span class="line">  4525dd:76 63                jbe    452642 &lt;main.main+0x72&gt;</span><br><span class="line">  4525df:48 83 ec 30          sub    $0x30,%rsp</span><br><span class="line">  4525e3:48 89 6c 24 28       mov    %rbp,0x28(%rsp)</span><br><span class="line">  4525e8:48 8d 6c 24 28       lea    0x28(%rsp),%rbp</span><br><span class="line">  4525ed:48 c7 44 24 18 01 00 movq   $0x1,0x18(%rsp)</span><br><span class="line">  4525f6:48 c7 44 24 20 02 00 movq   $0x2,0x20(%rsp)</span><br><span class="line">  4525ff:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  452604:48 89 04 24          mov    %rax,(%rsp)// n 变量值压栈（第一个参数）</span><br><span class="line">  452608:48 c7 44 24 08 02 00 movq   $0x2,0x8(%rsp)// m 变量值压栈（第二个参数）</span><br><span class="line">  452611:e8 aa ff ff ff       callq  4525c0 &lt;main.emptyStruct.FuncA&gt;</span><br><span class="line">  452616:48 8d 44 24 18       lea    0x18(%rsp),%rax</span><br><span class="line">  45261b:48 89 04 24          mov    %rax,(%rsp)// $rax 里面是 zerobase 的值，压栈（第一个参数）；</span><br><span class="line">  45261f:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  452624:48 89 44 24 08       mov    %rax,0x8(%rsp)// n 变量值压栈（第二个参数）</span><br><span class="line">  452629:48 8b 44 24 20       mov    0x20(%rsp),%rax</span><br><span class="line">  45262e:48 89 44 24 10       mov    %rax,0x10(%rsp)// m 变量值压栈（第三个参数）</span><br><span class="line">  452633:e8 78 ff ff ff       callq  4525b0 &lt;main.(*emptyStruct).FuncB&gt;</span><br><span class="line">  452638:48 8b 6c 24 28       mov    0x28(%rsp),%rbp</span><br><span class="line">  45263d:48 83 c4 30          add    $0x30,%rsp</span><br><span class="line">  452641:c3                   retq   </span><br><span class="line">  452642:e8 b9 7a ff ff       callq  44a100 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">  452647:eb 87                jmp    4525d0 &lt;main.main&gt;</span><br></pre></td></tr></table></figure><p>通过这段代码证实几个点：</p><ol><li>receiver 其实就是一种语法糖，本质上就是作为第一个参数传入函数；</li><li>receiver 为值的场景，不需要传空结构体做第一个参数，因为空结构体没有值；</li><li>receiver 为一个指针的场景，对象地址作为第一个参数传入函数，函数调用的时候，编译器传入 <code>zerobase</code> 的值（编译期间就可以确认）；</li></ol><p>在二进制编译之后，一般 <code>e.FuncA</code> 的调用，第一个参数是直接压入 <code>&amp;zerobase</code> 到栈里。</p><p>总结几个知识点：</p><ul><li>receiver 本质上是非常简单的一个通用思路，就是把对象值或地址作为第一参数传入函数；</li><li>函数参数压栈方式从前往后（可以调试看下）；</li><li>对象值作为 receiver 的时候，涉及到一次值拷贝；</li><li>golang 对于值做 receiver 的函数定义，会根据现实需要情况可能会生成了两个函数，一个值版本，一个指针版本（思考：什么是“需要情况”？就是有 <code>interface</code> 的场景 ）；</li><li>空结构体在编译期间就能识别出来的场景，编译器会对既定的事实，可以做特殊的代码生成；</li></ul><p>可以这么说，编译期间，关于空结构体的参数基本都能确定，那么代码生成的时候，就可以生成对应的静态代码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习上面空指针的各种使用场景，我们能得出结论，一般只会在以下两种情况会使用到空结构体：</p><ol><li>需要一个占位符，并不关系数据的内容。</li><li>节省空间。</li></ol><p>空结构体就像一些牛马一样，又让人家干活，又不给人家内存地址。是你，是我，是大家。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://geektutu.com/post/hpg-empty-struct.html">https://geektutu.com/post/hpg-empty-struct.html</a></li><li><a href="https://juejin.cn/post/6908733156707287048#heading-0">https://juejin.cn/post/6908733156707287048#heading-0</a></li><li><a href="https://juejin.cn/post/7228977496514560058">https://juejin.cn/post/7228977496514560058</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，正常的 &lt;code&gt;struct&lt;/code&gt; 就是一个普通的内存块，必定是要占用一块内存的，并且结构体的大小是要经过边界，长度是对其的。&lt;/p&gt;
&lt;p&gt;当你需要一个结构体，但是却丝毫不关系里面的内容，声明一个最小的结构体，也需要占用 1 字节，这是就要用</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>了解MongoDB——你想知道的都在这</title>
    <link href="http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/"/>
    <id>http://example.com/2024/06/02/%E4%BA%86%E8%A7%A3MongoDB%E2%80%94%E2%80%94%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99/</id>
    <published>2024-06-02T12:11:30.000Z</published>
    <updated>2024-06-03T08:45:05.897Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。</p><p>本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个科普文就可以了。</p><h1 id="什么是-NoSQL？"><a href="#什么是-NoSQL？" class="headerlink" title="什么是 NoSQL？"></a>什么是 NoSQL？</h1><p>在学习 MongoDB 之前，先来了解一下什么是 NoSQL。之前在面试时被面试官问道，除了 MySQL 以外，还了解什么数据库。我回答，不知道。结束后，我机智的舍友问我为什么不回答 NoSQL，我以为这是不知道其他数据库的英文表达（离谱）。</p><p>NoSQL 也被称为 “not only SQL” 或 “non-SQL”，它是一种数据库设计方法，可以在关系数据库中的传统结构之外存储和查询数据。</p><p>虽然 NoSQL 仍然可以存储关系数据库管理系统 (RDBMS) 中的数据，但与 RDBMS 相比，数据存储方式有所不同。决定使用关系数据库还是非关系数据库在很大程度上取决于上下文，并且因用例而异。</p><p>NoSQL 数据库并非采用关系数据库的典型表结构，而是将数据存储在一个数据结构中，例如 JSON 文档。由于这种非关系数据库设计不需要使用架构，因此，它提供快速可扩展性以管理通常为非结构化的大型数据集。</p><p>NoSQL 也是一种分布式数据库类型，这意味着将信息复制并存储在不同的服务器上，这些服务器可能是远程服务器或本地服务器。这确保了数据的可用性和可靠性。如果一些数据脱机，数据库的其他部分可以继续运行。</p><p><strong>特点</strong></p><ol><li><strong>灵活的数据模型</strong>：NoSQL数据库支持多种数据模型，如键值对、文档、列族和图形模型，适应各种应用场景。</li><li><strong>高可扩展性</strong>：通过分布式架构实现水平扩展，可以轻松添加更多的服务器来处理增加的数据量和流量。</li><li><strong>高性能</strong>：NoSQL数据库设计优化了读写操作，能提供高性能的查询速度。</li><li><strong>可用性和可靠性</strong>：通常具备内置的故障转移和数据复制机制，保证数据的高可用性和可靠性。</li></ol><p><strong>类型</strong></p><ol><li><p>键值存储（Key-Value Store）</p><p>：数据以键值对的形式存储，适合简单查询和高速读写操作。</p><ul><li>示例：Redis, DynamoDB</li></ul></li><li><p>文档存储（Document Store）</p><p>：数据以文档的形式存储，每个文档可以有不同的结构，适合存储复杂的嵌套数据。</p><ul><li>示例：MongoDB, CouchDB</li></ul></li><li><p>列族存储（Column-Family Store）</p><p>：数据以列的形式存储，每一列可以独立查询，适合大规模数据分析。</p><ul><li>示例：Cassandra, HBase</li></ul></li><li><p>图形数据库（Graph Database）</p><p>：数据以节点和边的形式存储，适合处理复杂关系和网络图。</p><ul><li>示例：Neo4j, ArangoDB</li></ul></li></ol><h2 id="常见的-NoSQL"><a href="#常见的-NoSQL" class="headerlink" title="常见的 NoSQL"></a>常见的 NoSQL</h2><p>以下是几个常用的NoSQL数据库及其主要特点：</p><ol><li>MongoDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式（BSON）存储数据，文档具有灵活的结构。</li><li>强大的查询和索引功能，支持复杂的查询操作。</li><li>支持水平扩展，通过分片实现高可扩展性。</li><li>提供复制集功能，保证数据的高可用性和自动故障转移。</li></ul></li></ul><ol><li>Cassandra</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>采用分布式架构，无单点故障，提供高可用性和高容错性。</li><li>高写入和读取性能，适用于大规模数据处理。</li><li>支持多数据中心的复制，保证数据的高可用性和一致性。</li><li>灵活的Schema设计，适合时间序列数据和大数据分析。</li></ul></li></ul><ol><li>Redis</li></ol><ul><li><strong>类型</strong>：键值存储（Key-Value Store）</li><li><strong>特点</strong>：<ul><li>数据存储在内存中，提供极高的读写性能，适用于实时应用。</li><li>支持多种数据结构，如字符串、哈希、列表、集合和有序集合。</li><li>提供丰富的操作和事务功能，支持发布/订阅、Lua脚本等。</li><li>具有持久化机制，数据可以持久化到磁盘。</li></ul></li></ul><ol><li>Neo4j</li></ol><ul><li><strong>类型</strong>：图形数据库（Graph Database）</li><li><strong>特点</strong>：<ul><li>以节点和关系（边）的形式存储数据，适合处理复杂关系和网络图。</li><li>提供强大的图形查询语言Cypher，支持高效的图遍历和查询操作。</li><li>广泛应用于社交网络、推荐系统和网络分析等场景。</li><li>提供ACID事务保证，确保数据一致性和可靠性。</li></ul></li></ul><ol><li>CouchDB</li></ol><ul><li><strong>类型</strong>：文档存储（Document Store）</li><li><strong>特点</strong>：<ul><li>使用JSON格式存储数据，每个文档可以有不同的结构。</li><li>提供RESTful API接口，便于集成和访问数据。</li><li>支持多主复制，允许在不同节点之间同步数据。</li><li>具备内置的冲突解决机制，适用于分布式环境。</li></ul></li></ul><ol><li>HBase</li></ol><ul><li><strong>类型</strong>：列族存储（Column-Family Store）</li><li><strong>特点</strong>：<ul><li>基于Hadoop HDFS构建，适用于处理大规模结构化数据。</li><li>提供强一致性的读写操作，适合需要高可靠性的应用。</li><li>支持随机读写和实时查询，适合大数据分析和实时应用。</li><li>与Hadoop生态系统紧密集成，支持MapReduce等大数据处理框架。</li></ul></li></ul><p>这些NoSQL数据库在不同的应用场景中发挥着重要作用，根据具体需求选择合适的数据库可以显著提升系统的性能和可扩展性。</p><h1 id="MongoDB-出现的原因"><a href="#MongoDB-出现的原因" class="headerlink" title="MongoDB 出现的原因"></a>MongoDB 出现的原因</h1><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。而MongoDB可应对“三高”需求。“三高”需求：</p><p>（1）High performance - 对数据库高并发读写的需求。</p><p>（2）Huge Storage - 对海量数据的高效率存储和访问的需求。</p><p>（3）High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对“三高”需求。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从它的命名也可以看出来，设计者是有一定野心的。MongoDB 的原名一开始<strong>来自于 英文单词”Humongous”, 中文含义是指”庞大”</strong>，即命名者的意图是可以处理大规模的数据。</p><p>在使用 MongoDB 我会有两种感觉：</p><ul><li>第一层感受是”爽”，使用这个文档数据库的特点是几乎不受什么限制，一方面Json文档式的结构更容易理解，而无Schema约束也让DDL管理更加简单，一切都可以很快速的进行。</li><li>第二层感受是”酸爽”，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验”太过于友好”，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。</li></ul><p>所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的RDBMS数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的话，会遇到更多的坑。</p><p>尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-aedbdb7187c091f3b2e091baea945806_720w.webp" alt="img"></p><p>在全部的排名中，MongoDB 长期排在第5位(文档数据库排名第1位)，同时也是最受欢迎的 NoSQL 数据库。</p><p>MongoDB 数据库的一些特性：</p><ul><li>面向文档存储，基于JSON/BSON 可表示灵活的数据结构</li><li>动态 DDL能力，没有强Schema约束，支持快速迭代</li><li>高性能计算，提供基于内存的快速数据查询</li><li>容易扩展，利用数据分片可以支持海量数据存储</li><li>丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。</li><li>跨平台版本、支持多语言SDK..</li></ul><h1 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h1><p>数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。</p><blockquote><p>关于这点，也有人说，MongoDB 是 NoSQL中最像SQL的数据库..</p></blockquote><p>我们来看与MySQL的对比，通过对比来学习其基本模型。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428161048312-2056386348.png" alt="img"></p><ul><li>database 数据库，与SQL的数据库(database)概念相同，一个数据库包含多个集合(表)</li><li>collection 集合，相当于SQL中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是<strong>动态的</strong>，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema的校验。</li><li>document 文档，相当于SQL中的行(row)，一个文档由多个字段(列)组成，并采用<code>bson(json)</code>格式表示。</li><li>field 字段，相当于SQL中的列(column)，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。</li></ul><p>此外，MongoDB中字段的类型是<strong>固定的</strong>、<strong>区分大小写</strong>、并且文档中的字段也是<strong>有序的</strong>。</p><p>另外，SQL 还有一些其他的概念，对应关系如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a4ce8ff9c69d5402f70baa1b050ad0d_720w.webp" alt="img"></p><ul><li>_id 主键，MongoDB 默认使用一个 _id 字段来保证文档的<strong>唯一性</strong>。</li><li>reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。</li><li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。</li><li>index 索引，与SQL 的索引相同。</li><li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li><li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li><li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li></ul><h2 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a><code>BSON</code> 数据类型</h2><p> MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以 <code>BSON（Binary-JSON）</code>文档的格式存储在磁盘上。</p><p><code>BSON（Binary Serialized Document Format）</code>是一种类 <code>json</code> 的一种二进制形式的存储格式，简称<code>Binary JSON</code>。<code>BSON</code>和<code>JSON</code>一样，支持 内嵌的文档对象和数组对象，但是<code>BSON</code>有<code>JSON</code>没有的一些数据类型，如Date和BinData类型。</p><p><code>BSON</code>采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p><code>BSON</code>中，除了基本的JSON类型：string, integer, boolean, double, null, array 和 object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详 细信息。</p><p>BSON数据类型参考列表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428163656218-1316936233.png" alt="img"></p><p> 提示： shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符 号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p><h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><p>面试问题：在进行数据库分表或者将同一个数据库部署到不同的服务器上，如何保证主键不重复。</p><p>当然，方法有很多，不同公司会有自己的处理方式，具体的后续会写文章来分析。我们先看在 MongoDB 中是如何保证主键不重复的。</p><p>在单机时代，大多数应用可以使用数据可自增式 ID 来作为主键。传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。</p><p>为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。</p><p>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-227bd6ae2f8a3c05546f51cfd4a0b7a8_720w.webp" alt="img"></p><p>其中包括：</p><ul><li>4-byte Unix 时间戳</li><li>3-byte 机器 ID</li><li>2-byte 进程 ID</li><li>3-byte 计数器(初始化随机)</li></ul><p>值得一提的是 _id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。<br>当然服务端也会检测写入的文档是否包含 _id 字段，如果没有就生成一个。</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>除了文档模型本身，对于数据的操作命令也是基于JSON/BSON 格式的语法。</p><p>详细的语法操作，可以去看<a href="https://www.mongodb.com/docs/manual/reference/sql-comparison/">官方的文档</a>，下面简单介绍一下基础使用语法。</p><p>比如插入文档的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.book.insert(</span><br><span class="line">&#123;</span><br><span class="line">  title: &quot;My first blog post&quot;,</span><br><span class="line">  published: <span class="keyword">new</span> <span class="type">Date</span>(),</span><br><span class="line">  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],</span><br><span class="line">  type: &quot;Work&quot;,</span><br><span class="line">  author : &quot;James&quot;,</span><br><span class="line">  viewCount: <span class="number">25</span>,</span><br><span class="line">  commentCount: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行文档查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;author : &quot;James&quot;&#125;)</span><br></pre></td></tr></table></figure><p>更新文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.book.update(</span><br><span class="line">   &#123;&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)&#125;,</span><br><span class="line">   &#123;&quot;$inc&quot;: &#123;&quot;viewCount&quot;: <span class="number">3</span>&#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>删除文档的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.remove(&#123;&quot;_id&quot;:</span><br><span class="line">     ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&quot;author&quot;: &quot;James&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;: <span class="number">1</span>, &quot;title&quot;: <span class="number">1</span>, &quot;author&quot;: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>实现简单的分页查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.book.find(&#123;&#125;)</span><br><span class="line">    .sort(&#123;&quot;viewCount&quot; : <span class="number">-1</span>&#125;)</span><br><span class="line">    .<span class="keyword">skip</span>(<span class="number">10</span>).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。<br>与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。</p><p>那么，一个有趣的问题是 MongoDB 能不能用 SQL进行查询？</p><p>当然是可以！</p><p>但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：</p><ul><li>客户端使用SQL，可以使用 mongobooster、studio3t 这样的工具</li><li>服务端的话，可以看看 presto 之类的一些平台..</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。</p><p>索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。在索引的实现上使用了 B 树，MySQL 则是采用 B+ 树来实现索引的。</p><p>使用 <code>ensureIndexes</code> 可以为集合声明一个普通的索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;author: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>author后面的数字 1 代表升序，如果是降序则是 -1</p></blockquote><p>实现复合式(compound)的索引，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;type: 1, published: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>只有对于复合式索引时，索引键的顺序才变得有意义</p></blockquote><p>如果索引的字段是数组类型，该索引就自动成为数组(multikey)索引：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.book.ensureIndex(&#123;tags: 1&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个</p></blockquote><h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a><strong>索引特性</strong></h2><p>在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：</p><ul><li>unique=true，表示一个唯一性索引</li><li>expireAfterSeconds=3600，表示这是一个TTL索引，并且数据将在1小时后老化</li><li>sparse=true，表示稀疏的索引，仅索引非空(non-null)字段的文档</li><li>partialFilterExpression: { rating: { $gt: 5 }，条件式索引，即满足计算条件的文档才进行索引</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h2><p>除了普通索引之外，MongoDB 支持的类型还包括：</p><ul><li>哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。</li><li>地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。</li><li>文本索引，用于支持快速的全文检索</li><li>模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。</li></ul><h2 id="索引评估、调优"><a href="#索引评估、调优" class="headerlink" title="索引评估、调优"></a><strong>索引评估、调优</strong></h2><p>使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。<br>如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.test.explain().find( &#123; a : 5 &#125; )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;queryPlanner&quot; : &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;winningPlan&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">      &quot;inputStage&quot; : &#123;</span><br><span class="line">        &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">        &quot;keyPattern&quot; : &#123;</span><br><span class="line">            &quot;a&quot; : 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;indexName&quot; : &quot;a_1&quot;,</span><br><span class="line">        &quot;isMultiKey&quot; : false,</span><br><span class="line">        &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">        &quot;indexBounds&quot; : &#123;&quot;a&quot; : [&quot;[5.0, 5.0]&quot;]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果 winningPlan 中可以看出执行计划是否高效，比如：</p><ul><li>未能命中索引的结果，会显示COLLSCAN</li><li>命中索引的结果，使用IXSCAN</li><li>出现了内存排序，显示为 SORT</li></ul><p>更加详细的内容，请移步到<a href="https://www.mongodb.com/docs/manual/indexes/">官方文档</a>。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>在大数据领域常常提到的4V特征中，Volume(数据量大)是首当其冲被提及的。<br>由于单机垂直扩展能力的局限，<strong>水平扩展</strong>的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。<br>此外，同时为了保证数据的高可用，MongoDB 采用<strong>副本集</strong>的方式来实现数据复制。</p><p>一个典型的MongoDB集群架构会同时采用分片+副本集的方式，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6f849c75bffb439f06e9ceafe6263377_720w.webp" alt="img"></p><p><strong>架构说明</strong></p><ul><li>数据分片（Shards）<br>分片用于存储真正的集群数据，可以是一个单独的 Mongod实例，也可以是一个副本集。 生产环境下Shard一般是一个 Replica Set，以防止该数据片的单点故障。<br>对于分片集合(sharded collection)来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard中。</li><li>配置服务器（Config Servers）<br>保存集群的元数据（metadata），包含各个Shard的路由规则，配置服务器由一个副本集(ReplicaSet)组成。</li><li>查询路由（Query Routers）<br>Mongos是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的Shard。<br>Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。</li></ul><h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><p>基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片(Shard) 则记录在 Config Server(配置服务器)上。<br>Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。</p><p><strong>数据是根据分片策略来进行切分的，而分片策略则由 分片键(ShardKey)+分片算法(ShardStrategy)组成。</strong></p><p>MongoDB 支持两种分片算法：</p><h3 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-4a9c8b977f026d13650d5fd70818d280_720w.webp" alt="img"></p><p>假设集合根据x字段来分片，x的取值范围为[minKey, maxKey]（x为整型，这里的minKey、maxKey为整型的最小值和最大值），将整个取值范围划分为多个chunk，每个chunk（默认配置为64MB）包含其中一小段的数据：<br>如Chunk1包含x的取值在[minKey, -75)的所有文档，而Chunk2包含x取值在[-75, 25)之间的所有文档…</p><p>范围分片能很好的满足<strong>范围查询</strong>的需求，比如想查询x的值在[-30, 10]之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力，比如使用_id作为 ShardKey，而MongoDB自动生成的id高位是时间戳，是持续递增的。</p><h3 id="哈希分片"><a href="#哈希分片" class="headerlink" title="哈希分片"></a>哈希分片</h3><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-6beb0f8fd6e84d4ffa847d7a579bf1e7_720w.webp" alt="img"></p><p>Hash分片是根据用户的 ShardKey 先计算出hash值（64bit整型），再根据hash值按照<strong>范围分片</strong>的策略将文档分布到不同的 chunk。<br>由于 hash值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。</p><h2 id="如何保证均衡"><a href="#如何保证均衡" class="headerlink" title="如何保证均衡"></a>如何保证均衡</h2><p>既然数据是分布在不同的 chunk 上的，而不同的 chunk 会被分配到不同的分片上，那么就会出现一个问题，如何保证分片上的数据（chunk）是均衡的。</p><p>一般会有以下两种情况：</p><ul><li>全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10个shard，存储1000个chunk，那么每个shard 分别拥有100个chunk。</li><li>非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂(split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk数据的搬迁达到均衡。</li></ul><p>MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点)上，而该节点也同时会控制 Chunk 数据的搬迁流程。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-ecb42a8acff963eacb2463f56d51465b_720w.webp" alt="img"></p><p>对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-a4afc0f479a98f4d8fa6302159dd5d4b_720w.webp" alt="img"></p><p>MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将<a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/%23sharding-schedule-balancing-window">均衡窗口</a>对齐到业务闲时段。</p><h2 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h2><p>应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-02b6729e1ae7d867e243c30524278a29_720w.webp" alt=""></p><p>当然，连接高可用的功能是由 Driver 实现的。</p><h3 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h3><p>副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个Shard(片)之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。<br>MongoDB 的副本集采取了一主多从的结构，即一个Primary Node + N* Secondary Node的方式，数据从主节点写入，并复制到多个备节点。</p><p>典型的架构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-69646e694e88aafce80498990307df9b_720w.webp" alt="img"></p><p>利用副本集，我们可以实现：：</p><ul><li>数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；</li><li>读写分离，读请求可以分流到备节点，减轻主节点的单点压力。</li></ul><p>请注意，读写分离只能增加集群”读”的能力，对于写负载非常高的情况却无能为力。<br>对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘IO、CPU能力可以取得一定效果。</p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config <span class="operator">=</span> &#123;</span><br><span class="line">    _id : &quot;my_replica_set&quot;,</span><br><span class="line">    members : [</span><br><span class="line">        &#123;_id : <span class="number">0</span>, host : &quot;rs1.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">1</span>, host : &quot;rs2.example.net:27017&quot;&#125;,</span><br><span class="line">        &#123;_id : <span class="number">2</span>, host : &quot;rs3.example.net:27017&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster()命令就可以看到选举的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.isMaster()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;hosts&quot; : [</span><br><span class="line">    &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;192.168.100.2:27030&quot;,</span><br><span class="line">    &quot;192.168.100.3:27030&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;setName&quot; : &quot;myReplSet&quot;,</span><br><span class="line">    &quot;setVersion&quot; : <span class="number">1</span>,</span><br><span class="line">    &quot;ismaster&quot; : <span class="literal">true</span>,</span><br><span class="line">    &quot;secondary&quot; : <span class="literal">false</span>,</span><br><span class="line">    &quot;primary&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;me&quot; : &quot;192.168.100.1:27030&quot;,</span><br><span class="line">    &quot;electionId&quot; : ObjectId(&quot;7fffffff0000000000000001&quot;),</span><br><span class="line">    &quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 Raft算法的影响，主节点的选举需要满足”大多数”原则，可以参考下表：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-099f568819dbb05978634934e3aa585e_720w.webp" alt="img"></p><p>因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如3个，正所谓三人行必有我师..</p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a><strong>心跳</strong></h4><p>在高可用的实现机制中，心跳(heartbeat)是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。<br>副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。<br>利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-81382e5544264faae3d6954584fe9254_720w.webp" alt="img"></p><p>默认情况下，节点会每2秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在10秒内没有收到主节点的响应就会主动发起选举。<br>此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。<br>如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>主节点和备节点的数据是通过日志(oplog)复制来实现的，这很类似于 mysql 的 binlog。<br>在每一个副本集的节点中，都会存在一个名为local.oplog.rs的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条oplog，<br>而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。</p><p>下面，看看一条 oplog 的具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ts&quot; : <span class="type">Timestamp</span>(<span class="number">1446011584</span>, <span class="number">2</span>),</span><br><span class="line">&quot;h&quot; : NumberLong(&quot;1687359108795812092&quot;),</span><br><span class="line">&quot;v&quot; : <span class="number">2</span>,</span><br><span class="line">&quot;op&quot; : &quot;i&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.nosql&quot;,</span><br><span class="line">&quot;o&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;563062c0b085733f34ab4129&quot;), &quot;name&quot; : &quot;mongodb&quot;, &quot;score&quot; : &quot;100&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的一些关键字段有：</p><ul><li>ts 操作的 optime，该字段不仅仅包含了操作的时间戳(timestamp)，还包含一个自增的计数器值。</li><li>h 操作的全局唯一表示</li><li>v oplog 的版本信息</li><li>op 操作类型，比如 i=insert,u=update..</li><li>ns 操作集合，形式为 database.collection</li><li>o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容</li></ul><p>MongoDB 对于 oplog 的设计是比较仔细的，比如：</p><ul><li>oplog 必须保证有序，通过 optime 来保证。</li><li>oplog 必须包含能够进行数据回放的完整信息。</li><li>oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。</li><li>oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。</li></ul><h1 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h1><p>一直以来，”不支持事务” 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡(放弃事务，追求高性能、高可扩展)<br>但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。<br>在4.0 版本之后，MongoDB 开始支持多文档的事务：</p><ul><li>4.0 版本支持副本集范围的多文档事务。</li><li>4.2 版本支持跨分片的多文档事务(基于两阶段提交)。</li></ul><p>在事务的隔离性上，MongoDB 支持快照(snapshot)的隔离级别，可以避免脏读、不可重复读和幻读。<br>尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向系统写入一条数据，应该能够马上读到写入的这个数据。</span><br></pre></td></tr></table></figure><p>在分布式架构的CAP理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-12e5c64d1e1df25b325af95055a7012c_720w.webp" alt="img"></p><p>在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：</p><ul><li>read preference<br>读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点</li><li>write concern<br>写关注，指定写入结果达到什么状态时才返回，可以为无应答(none)、应答(ack)，或者是大多数节点完成了数据复制等等</li><li>read concern<br>读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读(linearizable)等等。</li></ul><p>使用不同的设定将会产生对于C(一致性)、A(可用性)的不同的抉择，比如：</p><ul><li>将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败(可用性降低)</li><li>将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟(出现不一致)</li><li>将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了(节点失效会导致大多数写失败)</li></ul><p>关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动failover等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>行文至此，笔者对 MongoDB 也有了基本的了解，那么在什么样的情况下才需要使用 MongoDB 呢？换句话说就是 MongoDB 的应用场景是什么。</p><p>以下是几个实际的应用案例。</p><ul><li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li><li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。</li><li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li><li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li><li>视频直播，使用 MongoDB 存储用户信息、礼物信息等。</li></ul><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高 对于这样的数据，我们更适合使用MongoDB来实现数据的存储。</p><h2 id="辅助决策"><a href="#辅助决策" class="headerlink" title="辅助决策"></a>辅助决策</h2><p>如果你还在为是否应该使用 MongoDB，不如来做几个选择题来辅助决策</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1735743-20230428154322305-1499789968.png" alt="img"></p><p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择MongoDB绝不会后悔。</p><h1 id="优势和局限性"><a href="#优势和局限性" class="headerlink" title="优势和局限性"></a>优势和局限性</h1><p>MongoDB 为需要可靠数据库的公司提供了众多优势。以下是使用 MongoDB 的一些好处：</p><ul><li>速度：MongoDB比一般的关系数据库快 100 倍。作为一个面向文档的数据库，MongoDB 通过索引使访问文档变得容易。这有助于快速查询响应，从而节省用户宝贵的时间。</li><li>分片：MongoDB 提供的另一个好处是它允许用户存储大量数据。这是通过将数据分发到连接到应用程序的多个服务器来完成的。如果一台服务器无法处理数据的大小，则通过称为自动分片的过程将其共享给另一台服务器。</li><li>灵活的数据库：MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由。</li><li>水平可扩展性：MongoDB 是一个可水平扩展的数据库，这是它的基本优势之一。它允许用户有效地将大量数据分发到多台机器。</li><li>事务可行性：一些 MongoDB 功能包括gridFS 和 Replication。这些功能支持在使用 MongoDB 时提高数据可用性。这确保了应用程序的性能非常高。</li><li>缺少模式：MongoDB 是 NoSQL，这意味着它不需要模式。因此，在使用 MongoDB 时无需概述数据库模式。这减少了数据库处理信息所需的时间。因此，您的架构将由您编写的算法定义。</li></ul><p>尽管 MongoDB 提供了优于其他数据库的显着优势，但它并不完美。它有一些需要改进的限制。以下是 MongoDB 的一些缺点。 </p><ul><li>不支持连接：与支持连接的理性数据库不同，MongoDB 不支持。虽然可以通过手动编码添加连接功能，但执行速度可能会很慢并影响性能。</li><li>高内存使用率：MongoDB 旨在为每个值对存储键名称。它还受到数据冗余的影响，因为它缺少连接功能。这会导致高内存使用率。</li><li>有限数据大小：MongoDB 允许的最大文档大小为16MB。这是一个需要纠正的严峻挑战。</li><li>有限嵌套：MongoDB 提供有限的嵌套访问，因为用户不能执行超过100 级的文档嵌套。</li></ul><h1 id="ChatGPT-怎么看"><a href="#ChatGPT-怎么看" class="headerlink" title="ChatGPT 怎么看"></a>ChatGPT 怎么看</h1><p>问：怎么理解MongoDB 允许用户在单独的文档中拥有不同类型的数据，因为它是一个无模式的数据库。这为其用户提供了高度的灵活性和存储任何类型数据的自由？</p><p>答：MongoDB 作为无模式（schema-less）的文档存储数据库，其设计允许在同一个集合（相当于关系数据库中的表）中的不同文档（相当于关系数据库中的行）具有不同的结构和类型。以下是对这一特性的详细解释：</p><h3 id="1-无模式（Schema-less）特性"><a href="#1-无模式（Schema-less）特性" class="headerlink" title="1. 无模式（Schema-less）特性"></a>1. 无模式（Schema-less）特性</h3><p>在传统的关系数据库中，所有行必须符合预定义的表结构（schema），即每一列的数据类型和属性在创建表时就已经固定下来。这意味着每一行的数据必须遵循相同的格式。</p><p>相比之下，MongoDB 不强制要求文档具有相同的结构。每个文档可以有不同的字段和数据类型。这种灵活性源于 MongoDB 使用 BSON（一种二进制的 JSON 格式）来存储数据。</p><h3 id="2-灵活的数据模型"><a href="#2-灵活的数据模型" class="headerlink" title="2. 灵活的数据模型"></a>2. 灵活的数据模型</h3><ul><li><strong>不同文档的结构可以不同</strong>：在同一个集合中，一个文档可以包含某些字段，而另一个文档可以不包含这些字段，或者包含不同的字段。例如，在一个用户集合中，一个文档可以包含 <code>name</code> 和 <code>email</code> 字段，而另一个文档可以包含 <code>name</code>、<code>email</code> 和 <code>phone</code> 字段。</li><li><strong>字段的数据类型可以不同</strong>：即使是相同字段，在不同文档中也可以具有不同的数据类型。例如，一个文档中的 <code>age</code> 字段可以是整数类型，而在另一个文档中，<code>age</code> 字段可以是字符串类型。</li></ul><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul><li><strong>灵活性</strong>：开发者可以根据需要随时添加或修改文档中的字段，而无需修改整个集合的结构。这使得开发迭代更快，特别是在需求频繁变化的项目中。</li><li><strong>适应性</strong>：能够轻松存储和处理复杂和多变的数据结构，如嵌套文档和数组。适用于需要处理异构数据（heterogeneous data）的应用场景。</li><li><strong>快速开发和原型设计</strong>：无需提前定义和维护模式，能够快速启动项目和进行原型设计。</li></ul><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>考虑一个用户集合，其中的文档结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123-456-7890&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在上述例子中：</p><ul><li>文档1 和 文档2 具有不同的字段，文档2 比文档1 多了 <code>phone</code> 字段。</li><li>文档3 没有 <code>email</code> 字段，但有 <code>age</code> 字段，并且 <code>age</code> 字段的数据类型为整数。</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul><li><strong>内容管理系统（CMS）</strong>：需要存储不同类型的内容，如文章、评论、用户信息等，每种内容的结构可能不同。</li><li><strong>物联网（IoT）</strong>：不同的传感器设备产生的数据格式可能不同，需要灵活存储和处理。</li><li><strong>快速原型设计</strong>：在产品开发初期，需求可能频繁变化，无模式数据库可以快速适应这些变化。</li></ul><h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul><li><strong>数据一致性和验证</strong>：由于没有固定模式，可能会引入不一致的数据，需要在应用层进行数据验证和清理。</li><li><strong>查询优化</strong>：灵活的结构可能会影响查询性能，需要通过索引和查询优化来提高效率。</li></ul><p>总之，MongoDB 的无模式特性为开发者提供了极大的灵活性，允许存储和处理多种类型和结构的数据，适应快速变化的需求和复杂的应用场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通读全文，好像感觉这篇文章在哪看过。对，没错，这就是笔者对几篇文章的缝合。边学习边记录吗，不错的学习模式。</p><p>总之，MongoDB 以其高并发、高扩展性、高可用性和无模式特性取得了不错的成绩。也逐渐变成了找工作必须要会的一项技能。情到深处，不得不搞个一首，“都是内卷惹的祸……”。</p><p>关于 MongoDB 的学习绝不仅于此，后续会记录深入的内容。</p><p>一位同志在第三次考ccf通过后突然顿悟，决定不考研了，乐。猜一下他学 Java 能学多久，刚好我也要学。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/littleatp/p/11675233.html">了解 MongoDB 看这一篇就够了</a></p><p><a href="https://www.cnblogs.com/liaowenhui/p/17362409.html">MongoDB 的简介及应用场景</a></p><p><a href="https://developer.aliyun.com/article/64352">什么场景下该用 MongoDB</a></p><p><a href="https://www.mongodb.com/docs/manual/">MongoDB 官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库的学习总算是走出 MySQL 了，开源项目涉及的知识确实非常广，还有几个关系型数据库还在学习，今天就先来学习一下另外一个被广泛应用的 NoSQL——MongoDB。&lt;/p&gt;
&lt;p&gt;本文仅作为笔者在了解 MongoDB 时学到的一些东西，并不会包含很深入的原理解析，当个</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战总结</title>
    <link href="http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/06/01/MySQL%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-01T10:02:00.000Z</published>
    <updated>2024-06-03T08:45:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。</p><p>主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。</p><p>从头开始总结一下最近一段时间学到的一些内容，避免以后在秋招的时候还是不会。</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>有关 B+ 树的问题实在第二次面试的时候被提问到的，当时的回答也是一塌糊涂。</p><p>学习MySQL的索引，就避不开要了解 B+ 树，在 MySQL 里 InnoDB 存储引擎就是采用 B+ 树来组织数据的，这是我们在背八股文时一定要记住的东西。那么在 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？为什么要选择 B+ 树来组织数据呢？下面我们来深入学习一下。</p><h2 id="从数据页的角度看-B-树"><a href="#从数据页的角度看-B-树" class="headerlink" title="从数据页的角度看 B+ 树"></a>从数据页的角度看 B+ 树</h2><p>这次，我们<strong>从数据页的角度看 B+ 树</strong>，看看每个节点长啥样。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f7696506a3c1c94621fcbad10341f1a8.png" alt="图片"></p><h3 id="InnoDB-是如何进行存储数据的？"><a href="#InnoDB-是如何进行存储数据的？" class="headerlink" title="InnoDB 是如何进行存储数据的？"></a>InnoDB 是如何进行存储数据的？</h3><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同，我们最常用的就是 InnoDB 存储引擎。</p><p>记录时按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p><p>因此，InnoDB 的数据时按<strong>「数据页」</strong>为单位来读写的，也就是说，当需要读一条数据的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>InnoDB 数据页的默认大小是 16KB</strong>，数据页包括七个部分，结构如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p><p>这 7 个部分的作用如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向的链表</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/557d17e05ce90f18591c2305871af665.png" alt="图片"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><hr><p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>可以得出，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h3 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h3><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><hr><p>看了这么多关于 B+ 树和数据库索引的内容，我们对其也有了基本的了解，那就来再解决一个问题吧，为什么要用 B+ 树，而不是其他的数据结构，也顺便了解一下其他的树相关的知识。</p><h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的。</p><h3 id="怎样的索引的数据结构是好的？"><a href="#怎样的索引的数据结构是好的？" class="headerlink" title="怎样的索引的数据结构是好的？"></a>怎样的索引的数据结构是好的？</h3><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存在磁盘上的，因为这样及时设备断电了，数据也不会丢失。</p><p>这样就带来了一个新的问题，速度太慢，因为磁盘是一个慢的离谱的存储设备。磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><blockquote><p>索引的数据最好是按顺序排列的，这样才能使用<strong>「二分查找法」</strong>高效定位数据。</p></blockquote><h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p><p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p><p>那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？</p><p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/49cb4df3fb7d4accbc75f6970ff1d0ea.gif" alt="请添加图片描述"></p><p>这样这个数组就变成了一个二叉查找树。</p><p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p><p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p><p>那么既然已经解决了所有问题，是不是就可以直接用二叉查找树来组织索引了。</p><p>不行，因为二叉查找树有一个致命的问题，那就是当新插入的数据全都比已有数据大或者小，那这个二叉查找树就变成了一个链表了，也就失去了现有的优势。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/320c5c2653e74f9e9ebfcd8ca9681905.gif" alt="请添加图片描述"></p><h3 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h3><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p><p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树。</p><p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，由于也被面试官提到过类似的问题，后面会单独写一篇博客来记录。</p><p>现在，平衡二叉树退化成为链表的情况被解决了，但是随着数据的插入，树会变得越来越高，查询次数也就越来越多。</p><p>下面我们来看一下二叉树和三叉树在有相同节点个数的情况下高度的差别。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2d26d30c953cd47c6ab637ad0eba2f99.png" alt="图片"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00fb73de7014a87958f1597345e9ef2f.png" alt="图片"></p><p><strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B 树"></a>B 树</h3><p>对于上一节中提到的问题，一个新的数据结构被提出——B 树，它不在限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，特点就是每个节点最多有 M-1个数据，超过这些要求的话，就会分裂节点。</p><p>这么看来，B 树好像又解决了所有已经出现的问题，还有新的吗，当然。毕竟我们的主角是 B+ 树。</p><p>正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？</p><p>在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p><p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p><h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>好了好了，没想到设计一个索引需要的数据结构能遇到这么多困难，现在我们的救世主——B+ 树他终于来了。</p><p>B+ 树就是对 B 树做了一个升级，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mysql-20240322142950.png" alt="用户1260737：B+树"></p><p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了。</p><p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p><p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p><hr><p>至此，所有出现的问题都得到了解决，当然也并不是在所有的数据库中都使用 B+ 树来存储索引。比如在 MongoDB 中存储索引的数据结构就是 B 树。详细原因还是在后面的博客中记录吧，挖个坑先……</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p>腾讯第二次面试时提的问题，我回答的不知道，后来美团面试也问了，我答了几种情况，当时就只是背下来了，也不知道为什么，面试官想要更深入地问，我就又不会了。</p><p>那在本文中就详细解释一下这个问题吧。</p><p>在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。</p><p>但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。</p><p>稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低（之前我甚至以为索引失效是索引直接被删除了，脑子坏了）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a9e6a9708a6dbbcc65906d1338d2ae70.png" alt=""></p><h2 id="索引长什么样？"><a href="#索引长什么样？" class="headerlink" title="索引长什么样？"></a>索引长什么样？</h2><p>我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。</p><p>索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。</p><p>MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构。在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p><p>MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。</p><p>虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：</p><ul><li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；</li><li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；</li></ul><p>举个栗子：</p><p>这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/00730eac527c21a4034f0f9ba0218aba.png" alt="图片"></p><p>如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f287701eba9bf6f32a2d09b013bb451b.png" alt="图片"></p><p>如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（图中叶子节点之间是双向链表）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ef726d7287b854ea4862f7442d8012ec.png" alt="图片"></p><p>InnoDB 存储引擎根据索引类型不同，分为聚簇索引（上图就是聚簇索引）和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p><p>如果将 name 字段设置为普通索引，那么这个二级索引长下图这样（图中叶子节点之间是双向链表）</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7dd91be9fe584d94a4d71572ae7214d0.png" alt="图片"></p><p>在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 字段为主键索引</span><br><span class="line">select * from t_user where id=1;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：</p><ul><li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li><li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li></ul><p>上面这个过程叫做<strong>回表</strong>，如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select * from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><p>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做<strong>覆盖索引</strong>。如下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 字段为二级索引</span><br><span class="line">select id from t_user where name=&quot;林某&quot;;</span><br></pre></td></tr></table></figure><h2 id="什么情况会导致索引失效？"><a href="#什么情况会导致索引失效？" class="headerlink" title="什么情况会导致索引失效？"></a>什么情况会导致索引失效？</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><blockquote><p>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</p></blockquote><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b161c1d88f978e42077f8c14e10972a7.png" alt="图片"></p><p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li><li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li></ul><p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p><h3 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h3><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><blockquote><p>为什么对索引使用函数，就无法走索引了呢？</p></blockquote><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><h3 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h3><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><blockquote><p>为什么对索引进行表达式计算，就无法走索引了呢？</p></blockquote><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><h3 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h3><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>MySQL 的数据类型转换规则是什么？是会将字符串转成数字处理，还是将数字转换成字符串处理。</p><p>《MySQL45讲》里有一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p><ul><li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li><li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li></ul><p>在 MySQL 中，执行的结果如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/25316fd06cadff4434f02391ef0b5c55.png" alt="图片"></p><p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>所以，在索引字段为字符串类型，比较字段为数字类型时，MySQL会对索引使用函数实现隐式类型转换，从而导致索引失效。</p><h3 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h3><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul><blockquote><p>有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？</p><p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>为什么联合索引不遵循最左匹配原则就会失效？</p></blockquote><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><h3 id="WHERE-字句中地-OR"><a href="#WHERE-字句中地-OR" class="headerlink" title="WHERE 字句中地 OR"></a>WHERE 字句中地 OR</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><h2 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h1 id="百万-千万级数据库如何优化？"><a href="#百万-千万级数据库如何优化？" class="headerlink" title="百万/千万级数据库如何优化？"></a>百万/千万级数据库如何优化？</h1><p>百万级、千万级数据处理，个人认为核心关键在于数据存储方案设计，存储方案设计的是否合理，直接影响到数据CRUD操作。总体设计可以考虑一下几个方面进行设计考虑：</p><ul><li>数据存储结构设计</li><li>索引设计</li><li>数据主键设计</li><li>查询方案设计</li></ul><p>由于本人也没有这个实力去真正实操百万千万级别地数据库，所以更到还是纸上谈兵，图个乐就行了。</p><h2 id="百万级"><a href="#百万级" class="headerlink" title="百万级"></a>百万级</h2><h3 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><ul><li>表字段 not null，因为 null 值很难查询优化且占用额外的索引空间，推荐默认数字 0。</li><li>数据状态类型的字段，比如 status, type 等等，尽量不要定义负数，如 -1。因为这样可以加上 UNSIGNED，数值容量就会扩大一倍。</li><li>可以的话用 TINYINT、SMALLINT 等代替 INT，尽量不使用 BIGINT，因为占的空间更小。</li><li>字符串类型的字段会比数字类型占的空间更大，所以尽量用整型代替字符串，很多场景是可以通过编码逻辑来实现用整型代替的。</li><li>字符串类型长度不要随意设置，保证满足业务的前提下尽量小。</li><li>用整型来存 IP。</li><li>单表不要有太多字段，建议在20以内。</li><li>为能预见的字段提前预留，因为数据量越大，修改数据结构越耗时。</li></ul><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul><li>索引，空间换时间的优化策略，基本上根据业务需求设计好索引，足以应付百万级的数据量，养成使用 explain 的习惯，关于 explain 也可以访问：explain 让你的 sql 写的更踏实了解更多。</li><li>一个常识：索引并不是越多越好，索引是会降低数据写入性能的。</li><li>索引字段长度尽量短，这样能够节省大量索引空间；</li><li>取消外键，可交由程序来约束，性能更好。</li><li>复合索引的匹配最左列规则，索引的顺序和查询条件保持一致，尽量去除没必要的单列索引。</li><li>值分布较少的字段（不重复的较少）不适合建索引，比如像性别这种只有两三个值的情况字段建立索引意义不大。</li><li>需要排序的字段建议加上索引，因为索引是会排序的，能提高查询性能。</li><li>字符串字段使用前缀索引，不使用全字段索引，可大幅减小索引空间。</li></ul><h3 id="查询语句优化"><a href="#查询语句优化" class="headerlink" title="查询语句优化"></a>查询语句优化</h3><ul><li>尽量使用短查询替代复杂的内联查询。</li><li>查询不使用 select *，尽量查询带索引的字段，避免回表。</li><li>尽量使用 limit 对查询数量进行限制。</li><li>查询字段尽量落在索引上，尤其是复合索引，更需要注意最左前缀匹配。</li><li>拆分大的 delete / insert 操作，一方面会锁表，影响其他业务操作，还有一方面是 MySQL 对 sql 长度也是有限制的。</li><li>不建议使用 MySQL 的函数，计算等，可先由程序处理，从上面提的一些点会发现，能交由程序处理的尽量不要把压力转至数据库上。因为多数的服务器性能瓶颈都在数据库上。</li><li>查询 count，性能：count(1) = count(*) &gt; count(主键) &gt; count(其他字段)。</li><li>查询操作符能用 between 则不用 in，能用 in 则不用 or。</li><li>避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符，因为这些查询无法使用索引。</li><li>sql 尽量简单，少用 join，不建议两个 join 以上。</li></ul><h2 id="千万级"><a href="#千万级" class="headerlink" title="千万级"></a>千万级</h2><h3 id="数据存储结构设计-1"><a href="#数据存储结构设计-1" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h3><p>到了这个阶段的数据量，数据本身已经有很大的价值了，数据除了满足常规业务需求外，还会有一些数据分析的需求。而这个时候数据可变动性不高，基本上不会考虑修改原有结构，一般会考虑从分区，分表，分库三方面做优化：<br><strong>分区</strong><br>分区是根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分，是一种水平划分。对应用来说是完全透明的，不影响应用的业务逻辑，即不用修改代码。因此能存更多的数据，查询，删除也支持按分区来操作，从而达到优化的目的。如果有考虑分区，可以提前做准备，避免下列一些限制：</p><ul><li>一个表最多只能有1024个分区（6之后支持8192个分区）。但你实际操作的时候，最好不要一次性打开超过100 个分区，因为打开分区也是有时间损耗的。</li><li>如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。</li><li>分区表中无法使用外键约束。</li><li>NULL值会使分区过滤无效，这样会被放入默认的分区里，请千万不要让分区字段出现NULL。</li><li>所有分区必须使用相同的存储引擎。</li></ul><p><strong>分表</strong><br>分表分水平分表和垂直分表。<br>水平分表即拆分成数据结构相同的各个小表，如拆分成 table1, table2…，从而缓解数据库读写压力。<br>垂直分表即将一些字段分出去形成一个新表，各个表数据结构不相同，可以优化高并发下锁表的情况。<br>可想而知，分表的话，程序的逻辑是需要做修改的，所以，一般是在项目初期时，预见到大数据量的情况，才会考虑分表。后期阶段不建议分表，成本很大。<br><strong>分库</strong><br>分库一般是主从模式，一个数据库服务器主节点复制到一个或多个从节点多个数据库，主库负责写操作，从库负责读操作，从而达到主从分离，高可用，数据备份等优化目的。<br>当然，主从模式也会有一些缺陷，主从同步延迟，binlog 文件太大导致的问题等等，这里不细讲（笔者也学不动了）。<br><strong>其他</strong><br>冷热表隔离。对于历史的数据，查询和使用的人数少的情况，可以移入另一个冷数据库里，只提供查询用，来缓解热表数据量大的情况。</p><h3 id="数据库表主键设计"><a href="#数据库表主键设计" class="headerlink" title="数据库表主键设计"></a><strong>数据库表主键设计</strong></h3><p>数据库主键设计，个人推荐带有时间属性的自增长数字ID。（分布式自增长ID生成算法）<br>雪花算法<br>百度分布式ID算法<br>美团分布式ID算法<br>为什么要使用这些算法呢，这个与MySQL数据存储结构有关</p><p><strong>从业务上来说</strong></p><p>   在设计数据库时不需要费尽心思去考虑设置哪个字段为主键。然后是这些字段只是理论上是唯一的，例如使用图书编号为主键，这个图书编号只是理论上来说是唯一的，但实践中可能会出现重复的情况。所以还是设置一个与业务无关的自增ID作为主键，然后增加一个图书编号的唯一性约束。</p><p><strong>从技术上来说</strong></p><ol><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。</li><li>对InnoDB来说主键索引既存储索引值，又在叶子节点中存储行的数据，也就是说数据文件本身就是按照b+树方式存放数据的。</li><li>如果没有定义主键，则会使用非空的UNIQUE键做主键 ; 如果没有非空的UNIQUE键，则系统生成一个6字节的rowid做主键;聚簇索引中，N行形成一个页（一页通常大小为16K)。如果碰到不规则数据插入时，为了保持B+树的平衡，会造成频繁的页分裂和页旋转，插入速度比较慢。所以聚簇索引的主键值应尽量是连续增长的值，而不是随机值(不要用随机字符串或UUID)。</li><li>故对于InnoDB的主键，尽量用整型，而且是递增的整型。这样在存储/查询上都是非常高效的。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又到了我最爱的总结环节了，就能想写什么就写什么了。本来这篇文章要写四大部份的，还有一个sql注入的问题，之前看的文章就讲了一点例子，我以为就只有那么一点呢，今天仔细一查才发现还有那么多没有看过，下次再写吧。</p><p>昨天为什么破防，因为还是没有找到实习，一直都没有公司跟我约面试，我也不知道是那个环节出现问题了，可能还是因为学的东西太少了吧，所以我决定不找实习了，沉淀三个月，把MongoDO、kafka、docker、k8s还有Linux这些东西学一下。</p><p>之前一直觉得边找边学挺好的，找着找着发现面试太少了，不能从面试里面学到什么东西，又要因为准备面试耽误时间。我还是得练练表达能力，老是紧张也不是个事啊。加油吧，祝我自己秋招顺利，也祝我的朋友们考研成功、秋招顺利。还有两个有实习的，那就祝他们实习顺利吧（呜呜呜……，留下了羡慕的泪水）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/mysql/index/index_interview.html">小林coding 图解MySQL 索引篇</a></p><p><a href="https://javabetter.cn/sidebar/sanfene/mysql.html">MySQL八股文</a></p><p><a href="https://bbs.huaweicloud.com/blogs/222183">数据库优化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文用于记录笔者在学习和使用MySQL时遇到的一些问题以及思考。&lt;/p&gt;
&lt;p&gt;主要分为四个部分，也都是之前在面试的时候被提问过的问题，在写过第一次面试的面经之后就再没有总结过面试的问题了，其实在第二次面试被挂了之后就一直都在摆烂。&lt;/p&gt;
&lt;p&gt;从头开始总结一下最近一段时</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>解锁灵活与高效——Casbin</title>
    <link href="http://example.com/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/"/>
    <id>http://example.com/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/</id>
    <published>2024-05-31T13:52:01.000Z</published>
    <updated>2024-05-31T15:32:35.988Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇博客的标题看起来就很有逼格，不错，就是我们万能的 ChatGPT起的。当然，还是稍微改了一下，它给的实在是太有逼格了，我不太敢用。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240531215653176.png" alt="image-20240531215653176"></p><p>每隔一段时间使用ChatGPT就会给我一种AI已经发展得这么牛逼的感觉，但是每次用它来解决一些实际问题的时候又会让我觉得它是个智障。</p><p>不得不说，ChatGPT在很多方面都已经发展到了可以取代一大部分人的水平了。从它出现之后，我就没有自己动手写过思政方面的任何东西，全是它完成的，属实是有点东西。写点题外话让破防的自己慢慢恢复一下，题外话到此为止。</p><p>本文要记录的是一个访问控制库——Casbin。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Casbin 是一个开源的访问控制框架，用于实现权限管理和访问控制的功能。它提供了一种简单而灵活的访问控制模型，可以用于保护应用程序、服务或其他系统中的资源。Casbin 的设计目标是提供一种通用的访问控制模型，并支持多种编程语言。</p><p>Casbin 的核心概念是访问控制模型和策略。访问控制模型定义了一组规则，用于描述谁可以访问哪些资源以及在什么条件下可以访问。策略是基于模型定义的规则，描述了实际的访问控制规则集合。</p><p>Casbin 支持多种访问控制模型，包括基于角色的访问控制（RBAC）、访问控制列表（ACL）和属性访问控制（ABAC）等。它还提供了灵活的策略管理机制，可以将策略存储在不同的持久化存储中，如文件、数据库或远程服务。</p><p>使用 Casbin，你可以轻松地实现细粒度的权限管理，定义和管理角色、资源和操作之间的访问规则，并在应用程序中进行访问控制的验证。无论是 Web 应用程序、API 服务还是其他类型的系统，Casbin 都可以帮助你实现安全的访问控制机制。</p><h2 id="关键性概念"><a href="#关键性概念" class="headerlink" title="关键性概念"></a>关键性概念</h2><ol><li>模型（Model）：模型定义了访问控制策略的基本结构和规则。它由多个规则组成，每个规则包含多个字段，如”sub”（Subject，主体，表示用户）、”obj”（Object，对象，表示资源）、”act”（Action，动作，表示操作）等。</li><li>策略（Policy）：策略是实际的访问控制规则集合，用于定义谁可以对什么资源执行什么操作。Casbin 支持多种类型的策略，包括基于角色的访问控制（Role-Based Access Control，RBAC）、基于对象的访问控制（Object-Based Access Control，OBAC）等。</li><li>主体（Subject）：主体代表用户或者实体，它通常通过唯一标识符（如用户名、角色等）进行识别。主体在访问控制中被授予特定的权限。</li><li>对象（Object）：对象代表系统中的资源，可以是文件、数据库表、API 端点等。对象具有特定的属性和标识符，用于确定访问控制规则。</li><li>动作（Action）：动作表示主体对对象执行的操作或行为，如读取、写入、删除等。动作定义了主体对资源的权限。</li><li>策略存储（Policy Store）：策略存储用于存储和管理策略规则。Casbin 支持多种策略存储后端，如内存、文件、数据库等。</li></ol><p>通过定义模型、策略和访问请求，Casbin 可以进行访问控制决策，判断是否允许主体执行特定的操作。它提供了灵活的访问控制模型和丰富的策略管理功能，使开发人员能够轻松实现细粒度的权限管理和访问控制策略。</p><h1 id="和JWT有什么关系"><a href="#和JWT有什么关系" class="headerlink" title="和JWT有什么关系"></a>和<code>JWT</code>有什么关系</h1><p>提到鉴权，笔者第一个学习到的是 JWT。之前面试官会问，在你的项目里面是怎么实现鉴权操作的。我会统一回答，使用JWT生成token，然后解析出用户数据，最后在数据库中查找相关信息。其实我也不知道这样的回答是不是正确的，反正那么多场面试到最后都是不了了之，这都不是重点，重点是不要把 casbin 和 JWT 搞混了。</p><p>JWT（JSON Web Token）鉴权和 Casbin 鉴权在权限管理体系中扮演着不同但互补的角色。以下是它们的关系和区别：</p><h3 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h3><p><strong>JWT 鉴权：</strong></p><ul><li><strong>作用：</strong> JWT 主要用于认证（Authentication），即验证用户的身份。它确保请求的发起者是合法用户。</li><li><strong>功能：</strong> JWT 是一种自包含的令牌，通常包含用户ID、用户名、角色等信息，并且通过数字签名进行验证，确保数据的完整性和真实性。</li></ul><p><strong>Casbin 鉴权：</strong></p><ul><li><strong>作用：</strong> Casbin 主要用于授权（Authorization），即确定已认证用户是否有权限执行某个操作。它基于访问控制模型和策略来决定权限。</li><li><strong>功能：</strong> Casbin 通过模型和策略定义权限规则，可以实现复杂的权限管理，如基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>JWT 鉴权：</strong></p><ol><li>用户登录并提供凭据（用户名和密码）。</li><li>服务器验证凭据，如果验证通过，生成 JWT 并返回给用户。</li><li>用户在后续请求中附带 JWT（通常在 HTTP 头部的 Authorization 字段）。</li><li>服务器验证 JWT 的签名和有效期，确定用户身份。</li></ol><p><strong>Casbin 鉴权：</strong></p><ol><li>用户的请求经过 JWT 验证后，服务器获取用户身份信息。</li><li>服务器根据用户身份信息（如用户ID或角色），请求资源和操作。</li><li>使用 Casbin 的 Enforcer 进行权限校验，判断用户是否有权执行该操作。</li><li>根据校验结果，允许或拒绝用户的请求。</li></ol><h3 id="关系和结合"><a href="#关系和结合" class="headerlink" title="关系和结合"></a>关系和结合</h3><ul><li><strong>关系：</strong> JWT 和 Casbin 是互补的。JWT 负责认证，确保请求者的身份；Casbin 负责授权，确保请求者有权限执行特定操作。</li><li><strong>结合：</strong> 在实际应用中，通常会先进行 JWT 验证，确认用户身份后，再使用 Casbin 进行权限检查。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><strong>JWT 验证身份，Casbin 验证权限：</strong> JWT 确认用户是谁，Casbin 确认用户能做什么。</li><li><strong>JWT 是一种令牌，Casbin 是一种访问控制工具：</strong> JWT 是一种令牌机制，用于在无状态的环境中传递用户信息。Casbin 是一个权限管理库，用于根据预定义的策略进行权限判断。</li><li><strong>使用时机不同：</strong> JWT 通常在每次请求的开始进行验证，以确定用户身份。而 Casbin 的权限校验则在身份验证通过后，根据请求的具体资源和操作进行。</li></ul><h3 id="结合实例"><a href="#结合实例" class="headerlink" title="结合实例"></a>结合实例</h3><p>在一个 Web 应用中，结合 JWT 和 Casbin 的典型流程如下：</p><ol><li><p><strong>用户登录：</strong></p><ul><li>用户提交登录信息。</li><li>服务器验证登录信息，生成 JWT 并返回给用户。</li></ul></li><li><p><strong>用户请求资源：</strong></p><ul><li>用户在请求头中附带 JWT 访问资源。</li><li>服务器验证 JWT，确定用户身份。</li></ul></li><li><p><strong>权限校验：</strong></p><ul><li>服务器提取用户身份、请求资源和操作。</li><li>使用 Casbin Enforcer 进行权限检查，判断用户是否有权访问该资源或执行该操作。</li></ul></li><li><p><strong>处理请求：</strong></p><ul><li>如果权限校验通过，处理请求并返回结果。</li><li>如果权限校验不通过，返回 403 Forbidden 响应。</li></ul></li></ol><p>通过这种方式，JWT 和 Casbin 可以无缝结合，实现安全且灵活的认证和授权机制。</p><h1 id="能做什么？又不能做什么？"><a href="#能做什么？又不能做什么？" class="headerlink" title="能做什么？又不能做什么？"></a>能做什么？又不能做什么？</h1><p>我们从上面的回答就能看出，这两个东西其实是结合在一起使用的，在本项目中也是如此。在更加详细地了解其原理之前，我们先来看一下在什么情况下会使用到它。</p><h2 id="Can-Do"><a href="#Can-Do" class="headerlink" title="Can Do"></a>Can Do</h2><ol><li>以典型的 {主体、对象、动作} 形式或您定义的自定义形式形成策略。支持允许和拒绝授权。</li><li>具有访问控制模型 <code>model</code> 和策略 <code>policy</code> 两个核心概念。</li><li>支持 RBAC 中的多层角色继承，不止主体可以有角色，资源也可以具有角色。</li><li>支持内置超级用户，如 <code>root</code> 或 <code>administrator</code>。 超级用户可以在没有明确权限的情况下做任何事情。</li><li>提供多个内置操作符，支持规则匹配。例如，<code>keyMatch</code> 可将资源键 <code>/foo/bar</code> 映射到模式 <code>/foo*</code>。</li></ol><h2 id="Can‘t-do"><a href="#Can‘t-do" class="headerlink" title="Can‘t do"></a>Can‘t do</h2><ol><li>验证（又称用户登录时验证用户名和密码）：Casbin 仅负责权限管理，不负责用户身份验证。身份验证需要通过其他机制（如 JWT、OAuth 等）实现。</li><li>管理用户列表或角色列表：Casbin 不提供用户管理功能，如用户注册、密码管理等。这些功能通常由用户管理系统（如 LDAP、Active Directory）或自定义用户管理模块实现。</li><li>数据加密和解密：Casbin 不处理数据的加密和解密任务。这需要通过其他安全工具和库来实现。</li><li>网络安全：Casbin 不直接处理网络安全问题，如防火墙、防御 DDoS 攻击等。这需要通过网络安全设备和配置来实现。</li><li>审计和日志管理：虽然 Casbin 可以配合其他工具进行权限使用的审计和日志记录，但它自身不具备全面的审计和日志管理功能。</li></ol><p>项目管理用户、角色或密码列表更加方便。用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。 而是存储 RBAC 方案中用户和角色之间的映射关系。</p><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><p>讲了那么对概念，想必对casbin也有了一个大概的了解了。拿就来看一下要怎么使用吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> ( </span><br><span class="line"><span class="string">&quot;github.com/casbin/casbin/v2&quot;</span> </span><br><span class="line"><span class="string">&quot;fmt&quot;</span> </span><br><span class="line">) </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">sub := <span class="string">&quot;lili&quot;</span> </span><br><span class="line">obj := <span class="string">&quot;/posts&quot;</span> </span><br><span class="line">act := <span class="string">&quot;GET&quot;</span> </span><br><span class="line"> </span><br><span class="line"> e,err := casbin.NewEnforcer(<span class="string">&quot;resources/model.conf&quot;</span>,<span class="string">&quot;resources/policy.csv&quot;</span>) </span><br><span class="line"> checkError(err) </span><br><span class="line">ok,err := e.Enforce(sub,obj,act) </span><br><span class="line"> checkError(err) </span><br><span class="line"> <span class="keyword">if</span> ok &#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;通过！&quot;</span>) </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;不通过！&quot;</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 统一错误检查 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span>  &#123; </span><br><span class="line"> <span class="keyword">if</span> err!=<span class="literal">nil</span> &#123; </span><br><span class="line">  <span class="built_in">println</span>(err.Error()) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里面涉及到两个配置文件，分别是 model.conf 和 policy.csv 文件。</p><p>内容如下：</p><p><strong>model.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[request_definition] </span><br><span class="line">r = sub, obj, act </span><br><span class="line"> </span><br><span class="line">[policy_definition] </span><br><span class="line">p = sub, obj, act </span><br><span class="line"> </span><br><span class="line">[role_definition] </span><br><span class="line">g = _, _ </span><br><span class="line"> </span><br><span class="line">[policy_effect] </span><br><span class="line">e = some(where (p.eft == allow)) </span><br><span class="line"> </span><br><span class="line">[matchers] </span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act </span><br></pre></td></tr></table></figure><p><strong>policy.csv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p, member, /posts, GET </span><br><span class="line">p, member, /posts/:id, GET </span><br><span class="line"> </span><br><span class="line">p, admin, /posts, POST </span><br><span class="line">p, admin, /posts/:id, PUT </span><br><span class="line">p, admin, /posts/:id, DELETE </span><br><span class="line"> </span><br><span class="line">g, admin, member </span><br><span class="line">g, super, admin </span><br><span class="line">g, lili, member </span><br></pre></td></tr></table></figure><p>这两个配置文件你现在就暂时先理解为 model.conf 定义了匹配规则，policy.csv 定义了权限组等权限。</p><p>直接运行起来，你会看到控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过！ </span><br></pre></td></tr></table></figure><p>假如此时我们把 act 改成 POST 就不能通过了。</p><hr><p>学习过大概怎么使用后，就要更加深入地学习了。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>casbin 支持多种模型，适用于多种业务场景</p><ol><li><a href="https://en.wikipedia.org/wiki/Access_control_list"><strong>ACL (Access Control List, 访问控制列表)</strong></a></li><li><strong>具有 <a href="https://en.wikipedia.org/wiki/Superuser">超级用户</a> 的 ACL</strong></li><li><strong>ACL without users</strong>: 这对于没有身份验证或用户登录的系统特别有用。</li><li><strong>ACL without resources</strong>: 在某些场景中，目标是一种类型的资源，而不是单个资源。可以使用 “写文章” 和 “读日志” 等权限。这不会控制对特定文章或日志的访问。</li><li><strong><a href="https://en.wikipedia.org/wiki/Role-based_access_control">RBAC (基于角色的访问控制)</a></strong></li><li><strong>RBAC with resource roles</strong>: 用户和资源可以同时拥有角色（或组）。</li><li><strong>RBAC with domains/tenants</strong>: 用户可以为不同的域 / 租户拥有不同的角色集。</li><li><strong><a href="https://en.wikipedia.org/wiki/Attribute-Based_Access_Control">ABAC (Attribute-Based Access Control)</a></strong>: 像 “resource.Owner” 这样的语法糖可以用来获取资源的属性。</li><li><strong><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a></strong>: 支持 “/res/*”、“/res/：id” 等路径，以及 “GET”、“POST”、“PUT”、“DELETE” 等 HTTP 方法。</li><li><strong>Deny-override</strong>: 在允许拒绝覆盖的情况下，允许和拒绝授权都受支持。</li><li><strong>Priority</strong>: 策略规则可以按优先级排列，类似于防火墙规则。</li></ol><p>一般会通过使用场景确定模型，然后在官网实例中查询模型，直接使用。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>casbin 支持通过加载存储的模型、策略、策略子集实现动态调整。</p><h3 id="模型的存储"><a href="#模型的存储" class="headerlink" title="模型的存储"></a>模型的存储</h3><p>与策略不同，模型只能加载，不能保存。我们认为，模型不是动态组件，不应在运行时修改，因此我们没有实现将模型保存到存储中的应用程序接口。</p><p>不过，有一个好消息。我们提供了三种等效的方法来静态或动态加载模型：</p><ul><li>从 <code>.conf</code> 文件中加载 model</li><li>从代码加载 model</li><li>从字符串加载 model</li></ul><h3 id="策略地存储"><a href="#策略地存储" class="headerlink" title="策略地存储"></a>策略地存储</h3><p>在 casbin 中，策略存储作为 <strong>适配器</strong> 来实现</p><ul><li>从 <code>.csv</code> 文件加载</li><li>从后端存储加载实现</li></ul><h3 id="策略子集加载"><a href="#策略子集加载" class="headerlink" title="策略子集加载"></a>策略子集加载</h3><p>一些 adapter 支持过滤策略管理。 这意味着 Casbin 加载的策略是根据给定过滤器存储在数据库中的策略的子集。这样就能在大型多租户环境中高效执行策略，因为在这种环境中，解析整个策略会成为性能瓶颈。</p><p>为了防止意外数据丢失，当策略已经加载， SavePolicy 方法会被禁用。</p><p>要使用支持的 adapter 处理过滤后的策略，只需调用 <code>LoadFilteredPolicy</code> 方法。 过滤器参数的有效格式取决于所用的适配器。 为了防止意外数据丢失，当策略已经加载， <code>SavePolicy</code> 方法会被禁用。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>Casbin 使用配置文件来定义访问控制模型。</p><p>例如使用文件记录模型和策略存储文件，作为两个配置文件：<code>model.conf</code> 和 <code>policy.csv</code>。<code>model.conf</code> 保存访问模型，而 <code>policy.csv</code> 保存具体的用户权限配置。<code>Casbin</code> 的使用非常简单。我们只需创建一个主要结构：<code>enforcer</code>。当构造这个结构的时候，<code>model.conf</code> 和 <code>policy.csv</code> 将会被加载。</p><p>换句话说，<strong>要创建一个 Casbin 执行器，您需要提供一个模型和一个适配器。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, <span class="string">&quot;path/to/policy.csv&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 Casbin 中，执行器（Enforcer）是负责执行访问控制策略的核心组件。它提供了一系列方法，用于判断主体是否被授予对特定资源执行特定操作的权限。</p><p>执行器的主要功能包括：</p><ol><li>加载策略：执行器可以从不同的策略存储（如文件、数据库）中加载访问控制策略。它可以读取和解析策略规则，并将其转换为内部模型进行处理。</li><li>决策判断：执行器可以根据加载的策略和传入的访问请求，进行访问控制决策。它会根据模型中定义的规则和策略，判断主体是否有权限执行特定的操作。</li><li>策略管理：执行器提供了管理策略的方法，可以动态地添加、修改或删除策略规则。这使得开发人员可以根据需要对访问控制策略进行灵活的调整和管理。</li><li>角色管理：执行器支持角色（Role）的管理，包括角色的添加、删除和关联。角色可以用于实现基于角色的访问控制（RBAC）模型。</li></ol><p>通过执行器，开发人员可以轻松地集成 Casbin 的访问控制功能到他们的应用程序中。执行器提供了简单而强大的 API，使开发人员能够方便地进行访问控制决策和策略管理。</p><h3 id="几种执行器"><a href="#几种执行器" class="headerlink" title="几种执行器"></a>几种执行器</h3><ul><li>通用执行器：最基础的执行器，Enforcer 是用户与 Casbin 策略和模型交互的基本结构。</li><li>带缓存的执行器：<code>CachedEnforcer</code> 基于 <code>Enforcer</code>，支持使用 <code>map</code> 将请求的判断结果（是否具有能力）缓存在内存中。它能在指定的过期时间内清除缓存。此外，它还通过读写锁保证线程安全。您可以使用 <code>EnableCache</code> 启用缓存评估结果（默认为启用）。<code>CachedEnforcer</code> 的其他 API 方法与 <code>Enforcer</code> 相同。</li><li>分布式执行器：<code>DistributedEnforcer</code> 支持分布式集群中的多个实例。它为调度器封装了 <code>SyncedEnforcer</code>。官方的分布式执行器无法指定适配器，使用内置的适配器，而且通过 HTTP 接口实现一致性。</li><li>同步执行器：<code>SyncedEnforcer</code> 同步执行器提供并发功能，是线程安全的。</li><li>带缓存的同步执行器：<code>SyncedCachedEnforcer</code> ，同步执行器和带缓存的执行器结合</li></ul><p>如何挑选：</p><ul><li>如果是简单环境，使用通用执行器：<code>casbin.NewEnforcer()</code></li><li>如果需要提高判断结果的并发，则使用带缓存的执行器：<code>casbin.NewCachedEnforcer()</code></li><li>如果是分布式的场景，例如多个服务器集群中，每个集群都需要有 casbin 实例，而且需要有独立的后端存储，则使用分布式执行器：<code>casbin.NewDistributedEnforcer()</code></li><li>如果会频繁变动策略，而且是并发场景，则使用同步执行器：<code>casbin.NewSyncedEnforcer()</code></li><li>如果既要频繁变动策略，也要求判断结果的高并发，则使用带缓存的同步执行器：<code>casbin.NewSyncedCachedEnforcer()</code></li></ul><p>在当下云原生的场景下，部署在 <code>k8s</code> 上，并且后端使用同一个存储，多个实例，推荐使用同步执行器或者带缓存的同步执行器。</p><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>在 Casbin 中，策略存储作为 adapter (Casbin 的中间件) 实现。 Casbin 用户可以使用 adapter 从存储中加载策略规则 (<code>LoadPolicy()</code>) 或者将策略规则保存到其中 (<code>SavePolicy()</code>)。</p><blockquote><ol><li>如果使用显式或隐式 adapter 调用 <code>casbin.NewEnforcer()</code>，策略将自动加载。</li><li>可以调用 <code>e.LoadPolicy()</code> 来从存储中重新加载策略规则。</li><li>如果 adapter 不支持 <code>Auto-Save</code> 特性，则在添加或删除策略时不能将策略规则自动保存回存储器。 你必须手动调用 <code>SavePolicy()</code> 来保存所有的策略规则</li></ol></blockquote><p>当然，以下是使用 Go 语言结合 Casbin 和多种适配器的代码示例：</p><h3 id="使用文件适配器"><a href="#使用文件适配器" class="headerlink" title="使用文件适配器"></a>使用文件适配器</h3><p>文件适配器是 Casbin 的默认适配器，使用本地文件系统存储策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载模型文件和策略文件</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, <span class="string">&quot;path/to/policy.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-MySQL-适配器"><a href="#使用-MySQL-适配器" class="headerlink" title="使用 MySQL 适配器"></a>使用 MySQL 适配器</h3><p>使用 MySQL 数据库存储策略，需要安装 <code>github.com/casbin/mysql-adapter/v2</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/mysql-adapter/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MySQL 适配器</span></span><br><span class="line">    a, err := mysqladapter.NewAdapter(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:1234@tcp(127.0.0.1:3306)/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create MySQL adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-PostgreSQL-适配器"><a href="#使用-PostgreSQL-适配器" class="headerlink" title="使用 PostgreSQL 适配器"></a>使用 PostgreSQL 适配器</h3><p>使用 PostgreSQL 数据库存储策略，需要安装 <code>github.com/casbin/pg-adapter</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/pg-adapter&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 PostgreSQL 适配器</span></span><br><span class="line">    a, err := pgadapter.NewAdapter(<span class="string">&quot;postgresql://user:password@localhost:5432/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create PostgreSQL adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-MongoDB-适配器"><a href="#使用-MongoDB-适配器" class="headerlink" title="使用 MongoDB 适配器"></a>使用 MongoDB 适配器</h3><p>使用 MongoDB 数据库存储策略，需要安装 <code>github.com/casbin/mongodb-adapter/v3</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/mongodb-adapter/v3&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MongoDB 适配器</span></span><br><span class="line">    a, err := mongodbadapter.NewAdapter(<span class="string">&quot;mongodb://localhost:27017/casbin&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create MongoDB adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Redis-适配器"><a href="#使用-Redis-适配器" class="headerlink" title="使用 Redis 适配器"></a>使用 Redis 适配器</h3><p>使用 Redis 数据库存储策略，需要安装 <code>github.com/casbin/redis-adapter/v2</code> 适配器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/redis-adapter/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Redis 适配器</span></span><br><span class="line">    a, err := redisadapter.NewAdapter(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create Redis adapter: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义适配器"><a href="#自定义适配器" class="headerlink" title="自定义适配器"></a>自定义适配器</h3><p>如果现有适配器不能满足需求，可以实现自定义适配器。自定义适配器需要实现 <code>casbin.Adapter</code> 接口的以下方法：</p><ul><li><code>LoadPolicy(model model.Model) error</code></li><li><code>SavePolicy(model model.Model) error</code></li><li><code>AddPolicy(sec string, ptype string, rule []string) error</code></li><li><code>RemovePolicy(sec string, ptype string, rule []string) error</code></li><li><code>RemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) error</code></li></ul><p>这是一个自定义适配器的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2/model&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin/v2/persist&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义存储结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> LoadPolicy(model model.Model) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 加载策略到模型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> SavePolicy(model model.Model) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 保存策略到存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> AddPolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, rule []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 添加策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> RemovePolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, rule []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 移除策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *CustomAdapter)</span></span> RemoveFilteredPolicy(sec <span class="type">string</span>, ptype <span class="type">string</span>, fieldIndex <span class="type">int</span>, fieldValues ...<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 移除符合过滤条件的策略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建自定义适配器</span></span><br><span class="line">    a := &amp;CustomAdapter&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型文件和策略</span></span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;path/to/model.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create enforcer: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> ok, _ := e.Enforce(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;read&quot;</span>); ok &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access granted&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这些示例，可以看到如何使用 Casbin 和不同的适配器实现权限管理，具体选择哪种适配器取决于应用的具体需求和环境。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>casbin 支持使用分布式消息系统（如 etcd）来保持多个 Casbin 执行器实例之间的一致性。这样，用户就可以同时使用多个 Casbin 执行器来处理大量权限检查请求。</p><p>与策略存储适配器类似，casbin 在主库中不包含监视器代码。任何对新消息系统的支持都应该作为监视程序来实现。</p><p>关于监视器的完整列表建议去<a href="https://casbin.org/zh/docs/watchers/">casbin官网</a>查看。</p><p>推荐使用 Redis ，内部是通过 redis 的 channel 实现多个实例之间通讯。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>调度程序提供了一种同步策略增量变化的方法。它们应基于 Raft 等一致性算法，以确保所有执行者实例的一致性。通过调度器，用户可以轻松建立分布式集群。</p><p>调度器的方法分为两部分。 第一部分是与 Casbin 结合的方法。这些方法应在 Casbin 内部调用。用户可以使用 Casbin 本身提供的更完整的 API。</p><p>另一部分是调度器自身定义的方法，包括调度器初始化方法和不同算法提供的不同功能，如动态成员资格和配置更改。</p><blockquote><p>我们希望调度器只在运行时确保 Casbin 执行器的一致性。因此，如果策略在初始化时不一致，调度程序将无法正常工作。用户需要在使用调度程序前确保所有实例的状态一致。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dispatcher-architecture.svg" alt="overall architecture"></p><p>调度器的使用场景更合适分布式的环境下。</p><h2 id="角色管理器"><a href="#角色管理器" class="headerlink" title="角色管理器"></a>角色管理器</h2><p>角色管理器用于管理 Casbin 中的 RBAC 角色层次结构（用户角色映射）。 角色管理器可从 Casbin 策略规则或外部来源（如 LDAP、Okta、Auth0、Azure AD 等）检索角色数据。我们支持不同的角色管理器实现。 为了保持轻量级，我们在主库中不包含角色管理器代码（默认角色管理器除外）。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面一共介绍了casbin的五个组件，那么它们之间有什么关系呢？</p><p>在 Casbin 中，执行器（Enforcer）、适配器（Adapter）、监视器（Watcher）、调度器（Dispatcher）和角色管理器（RoleManager）是五个核心组件，它们各自负责不同的功能，但在 Casbin 的权限管理系统中有着密切的联系。</p><ul><li><strong>适配器与执行器：</strong> 适配器为执行器提供加载策略的数据源，执行器在权限判断时依赖适配器加载的策略数据。</li><li><strong>监视器与适配器：</strong> 监视器与适配器协作，适配器加载策略数据后，监视器可以持续监控数据的变化。</li><li><strong>调度器与执行器：</strong> 调度器负责管理执行器的并发访问，确保执行器在多线程环境下的安全运行。</li><li><strong>角色管理器与执行器：</strong> 角色管理器与执行器配合，执行器在权限判断时可能涉及角色信息，需要通过角色管理器查询和验证角色。</li></ul><p>总的来说，执行器是 Casbin 权限判断的核心，适配器用于加载和保存策略数据，监视器用于监控数据的变化，调度器用于管理并发访问，角色管理器用于管理角色信息。这些组件之间紧密联系并协作，共同构建了 Casbin 的权限管理系统。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>嘿，这才是真正的总结，我的博客文章怎么可能有一个那么正经的总结呢。</p><p>上面已经基本把casbin中会使用到的东西讲的很清楚了，在本项目中也是结合着 JWT 来实现的权限控制。基本流程为，先使用 JWT 检查是否正常登录，若正常登录再检查该用户的操作权限，两者相辅相成。</p><p>ok，那么又增加了一个在面试时能讲的内容，但是孩子现在根本就没有面试的机会，该说自己是运气不好呢，还是脑子里根本就没有那么多东西，所以才会一次又一次地被牵着鼻子走。再沉淀沉淀吧，先不急着找实习（其实是找不到）。</p><p>现在觉得要学的东西好像还有很多，一直赶着找实习会让我根本就没法集中去学习，老是速成也会一直忘，还是放慢脚步吧。</p><p>其实在学完 casbin 鉴权之后，这个开源项目里边比较新的东西就差不多结束了，还能继续学的就是一些数据库的操作了，不过我觉得这个大佬好像不是很想使用其他数据库，也基本上都没有什么能学的。不过 MongoDB 还是要学一下的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://casbin.org/zh/docs/category/the-basics">Casbin官方文档</a></p><p><a href="https://www.xiaoyeshiyu.com/post/bda0.html">大佬的博客</a></p><p><a href="https://www.51cto.com/article/687493.html">鉴权的简单使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天这篇博客的标题看起来就很有逼格，不错，就是我们万能的 ChatGPT起的。当然，还是稍微改了一下，它给的实在是太有逼格了，我不太敢用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zxh3032/save-ima</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>管理定时任务--cron</title>
    <link href="http://example.com/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/"/>
    <id>http://example.com/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/</id>
    <published>2024-05-27T09:03:17.000Z</published>
    <updated>2024-05-31T13:32:23.234Z</updated>
    
    <content type="html"><![CDATA[<p><code>corn</code> 是一个用于管理定时任务的库，用 Go 实现 Linux 中 <code>crontab</code> 这个命令的效果。除了 <code>cron</code> 以外，Go语言中还有另一个比较小巧、灵活的定时任务库，可以执行定时的、周期性的任务。但是它功能相对简单些，并且已经不维护了。如果有定时任务需求，还是建议使用<code>cron</code>。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/robfig/cron/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">&quot;@every 1s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;tick every 1 second&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用非常简单，创建<code>cron</code>对象，这个对象用于管理定时任务。</p><p>调用<code>cron</code>对象的<code>AddFunc()</code>方法向管理器中添加定时任务。<code>AddFunc()</code>接受两个参数，参数 1 以字符串形式指定触发时间规则，参数 2 是一个无参的函数，每次触发时调用。<code>@every 1s</code>表示每秒触发一次，<code>@every</code>后加一个时间间隔，表示每隔多长时间触发一次。例如<code>@every 1h</code>表示每小时触发一次，<code>@every 1m2s</code>表示每隔 1 分 2 秒触发一次。<code>time.ParseDuration()</code>支持的格式都可以用在这里。</p><p>调用<code>c.Start()</code>启动定时循环。</p><p>注意一点，因为<code>c.Start()</code>启动一个新的 goroutine 做循环检测，我们在代码最后加了一行<code>time.Sleep(time.Second * 5)</code>防止主 goroutine 退出。</p><p>运行效果，每隔 1s 输出一行字符串：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br></pre></td></tr></table></figure><h1 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h1><p>与Linux 中<code>crontab</code>命令相似，<code>cron</code>库支持用 <strong>5</strong> 个空格分隔的域来表示时间。这 5 个域含义依次为：</p><ul><li><code>Minutes</code>：分钟，取值范围<code>[0-59]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Hours</code>：小时，取值范围<code>[0-23]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Day of month</code>：每月的第几天，取值范围<code>[1-31]</code>，支持特殊字符<code>* / , - ?</code>；</li><li><code>Month</code>：月，取值范围<code>[1-12]</code>或者使用月份名字缩写<code>[JAN-DEC]</code>，支持特殊字符<code>* / , -</code>；</li><li><code>Day of week</code>：周历，取值范围<code>[0-6]</code>或名字缩写<code>[JUN-SAT]</code>，支持特殊字符<code>* / , - ?</code>。</li></ul><p>注意，月份和周历名称都是不区分大小写的。</p><p>特殊字符含义如下：</p><ul><li><code>*</code>：使用<code>*</code>的域可以匹配任何值，例如将月份域（第 4 个）设置为<code>*</code>，表示每个月；</li><li><code>/</code>：用来指定范围的<strong>步长</strong>，例如将小时域（第 2 个）设置为<code>3-59/15</code>表示第 3 分钟触发，以后每隔 15 分钟触发一次，因此第 2 次触发为第 18 分钟，第 3 次为 33 分钟。。。直到分钟大于 59；</li><li><code>,</code>：用来列举一些离散的值和多个范围，例如将周历的域（第 5 个）设置为<code>MON,WED,FRI</code>表示周一、三和五；</li><li><code>-</code>：用来表示范围，例如将小时的域（第 1 个）设置为<code>9-17</code>表示上午 9 点到下午 17 点（包括 9 和 17）；</li><li><code>?</code>：只能用在月历和周历的域中，用来代替<code>*</code>，表示每月/周的任意一天。</li></ul><p>了解规则之后，我们可以定义任意时间：</p><ul><li><code>30 * * * *</code>：分钟域为 30，其他域都是<code>*</code>表示任意。每小时的 30 分触发；</li><li><code>30 3-6,20-23 * * *</code>：分钟域为 30，小时域的<code>3-6,20-23</code>表示 3 点到 6 点和 20 点到 23 点。3,4,5,6,20,21,22,23 时的 30 分触发；</li><li><code>0 0 1 1 *</code>：1（第 4 个） 月 1（第 3 个） 号的 0（第 2 个） 时 0（第 1 个） 分触发。</li></ul><h2 id="预定义时间规则"><a href="#预定义时间规则" class="headerlink" title="预定义时间规则"></a>预定义时间规则</h2><p>为了方便使用，<code>cron</code>预定义了一些时间规则：</p><ul><li><code>@yearly</code>：也可以写作<code>@annually</code>，表示每年第一天的 0 点。等价于<code>0 0 1 1 *</code>；</li><li><code>@monthly</code>：表示每月第一天的 0 点。等价于<code>0 0 1 * *</code>；</li><li><code>@weekly</code>：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于<code>0 0 * * 0</code>；</li><li><code>@daily</code>：也可以写作<code>@midnight</code>，表示每天 0 点。等价于<code>0 0 * * *</code>；</li><li><code>@hourly</code>：表示每小时的开始。等价于<code>0 * * * *</code>。</li></ul><h2 id="固定时间间隔"><a href="#固定时间间隔" class="headerlink" title="固定时间间隔"></a>固定时间间隔</h2><p><code>cron</code>支持固定时间间隔，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@every &lt;duration&gt;</span><br></pre></td></tr></table></figure><p>含义为每隔<code>duration</code>触发一次。<code>&lt;duration&gt;</code>会调用<code>time.ParseDuration()</code>函数解析，所以<code>ParseDuration</code>支持的格式都可以。</p><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>默认情况下，所有时间都是基于当前时区的。当然我们也可以指定时区，有 2 两种方式：</p><ul><li>在时间字符串前面添加一个<code>CRON_TZ=</code> + 具体时区，东京时区为<code>Asia/Tokyo</code>，纽约时区为<code>America/New_York</code>；</li><li>创建<code>cron</code>对象时增加一个时区选项<code>cron.WithLocation(location)</code>，<code>location</code>为<code>time.LoadLocation(zone)</code>加载的时区对象，<code>zone</code>为具体的时区格式。或者调用已创建好的<code>cron</code>对象的<code>SetLocation()</code>方法设置时区。</li></ul><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nyc, _ := time.LoadLocation(<span class="string">&quot;America/New_York&quot;</span>)</span><br><span class="line">  c := cron.New(cron.WithLocation(nyc))</span><br><span class="line">  c.AddFunc(<span class="string">&quot;0 6 * * ?&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Every 6 o&#x27;clock at New York&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">&quot;CRON_TZ=Asia/Tokyo 0 6 * * ?&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Every 6 o&#x27;clock at Tokyo&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Job接口"><a href="#Job接口" class="headerlink" title="Job接口"></a><code>Job</code>接口</h1><p>除了直接将无参函数作为回调外，<code>cron</code>还支持<code>Job</code>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">interface</span> &#123;</span><br><span class="line">  Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个实现接口<code>Job</code>的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreetingJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GreetingJob)</span></span> Run() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello &quot;</span>, g.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>cron</code>对象的<code>AddJob()</code>方法将<code>GreetingJob</code>对象添加到定时管理器中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">&quot;@every 1s&quot;</span>, GreetingJob&#123;<span class="string">&quot;dj&quot;</span>&#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br></pre></td></tr></table></figure><hr><p>实际上<code>AddFunc()</code>方法内部也调用了<code>AddJob()</code>方法。首先，<code>cron</code>基于<code>func()</code>类型定义一个新的类型<code>FuncJob</code>并实现<code>Job</code>接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> FuncJob <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncJob)</span></span> Run() &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AddFunc()</code>方法中，将传入的回调转为<code>FuncJob</code>类型，然后调用<code>AddJob()</code>方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cron)</span></span> AddFunc(spec <span class="type">string</span>, cmd <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) (EntryID, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c.AddJob(spec, FuncJob(cmd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><code>cron</code>会创建一个新的 goroutine 来执行触发回调。如果这些回调需要并发访问一些资源、数据，我们需要显式地做同步。</p><h1 id="自定义时间格式"><a href="#自定义时间格式" class="headerlink" title="自定义时间格式"></a>自定义时间格式</h1><p><code>cron</code>支持灵活的时间格式，如果默认的格式不能满足要求，我们可以自己定义时间格式。时间规则字符串需要<code>cron.Parser</code>对象来解析。</p><p>我们先来看看默认的解析器是如何工作的。</p><p>首先定义各个域：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Second         ParseOption = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  SecondOptional                        </span><br><span class="line">  Minute                                </span><br><span class="line">  Hour                                  </span><br><span class="line">  Dom                                   </span><br><span class="line">  Month                                 </span><br><span class="line">  Dow                                   </span><br><span class="line">  DowOptional                           </span><br><span class="line">  Descriptor                            </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了<code>Minute/Hour/Dom(Day of month)/Month/Dow(Day of week)</code>外，还可以支持<code>Second</code>。相对顺序都是固定的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">var</span> places = []ParseOption&#123;</span><br><span class="line">  Second,</span><br><span class="line">  Minute,</span><br><span class="line">  Hour,</span><br><span class="line">  Dom,</span><br><span class="line">  Month,</span><br><span class="line">  Dow,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaults = []<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;*&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的时间格式使用 5 个域。</p><p>我们可以调用<code>cron.NewParser()</code>创建自己的<code>Parser</code>对象，以位格式传入使用哪些域，例如下面的<code>Parser</code>使用 6 个域，支持<code>Second</code>（秒）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser := cron.NewParser(</span><br><span class="line">  cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用<code>cron.WithParser(parser)</code>创建一个选项传入构造函数<code>cron.New()</code>，使用时就可以指定秒了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := cron.New(cron.WithParser(parser))</span><br><span class="line">c.AddFunc(<span class="string">&quot;1 * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;every 1 second&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br></pre></td></tr></table></figure><p>这里时间格式必须使用 6 个域，顺序与上面的<code>const</code>定义一致。</p><p>因为上面的时间格式太常见了，<code>cron</code>定义了一个便捷的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithSeconds</span><span class="params">()</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> WithParser(NewParser(</span><br><span class="line">    Second | Minute | Hour | Dom | Month | Dow | Descriptor,</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>Descriptor</code>表示对<code>@every/@hour</code>等的支持。有了<code>WithSeconds()</code>，我们不用手动创建<code>Parser</code>对象了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := cron.New(cron.WithSeconds())</span><br></pre></td></tr></table></figure><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p><code>cron</code>对象创建使用了选项模式，我们前面已经介绍了 3 个选项：</p><ul><li><code>WithLocation</code>：指定时区；</li><li><code>WithParser</code>：使用自定义的解析器；</li><li><code>WithSeconds</code>：让时间格式支持秒，实际上内部调用了<code>WithParser</code>。</li></ul><p><code>cron</code>还提供了另外两种选项：</p><ul><li><code>WithLogger</code>：自定义<code>Logger</code>；</li><li><code>WithChain</code>：Job 包装器。</li></ul><h2 id="WithLogger"><a href="#WithLogger" class="headerlink" title="WithLogger"></a><code>WithLogger</code></h2><p><code>WithLogger</code>可以设置<code>cron</code>内部使用我们自定义的<code>Logger</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New(</span><br><span class="line">    cron.WithLogger(</span><br><span class="line">      cron.VerbosePrintfLogger(log.New(os.Stdout, <span class="string">&quot;cron: &quot;</span>, log.LstdFlags))))</span><br><span class="line">  c.AddFunc(<span class="string">&quot;@every 1s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面调用<code>cron.VerbosPrintfLogger()</code>包装<code>log.Logger</code>，这个<code>logger</code>会详细记录<code>cron</code>内部的调度过程。</p><p>默认的<code>Logger</code>是什么样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultLogger Logger = PrintfLogger(log.New(os.Stdout, <span class="string">&quot;cron: &quot;</span>, log.LstdFlags))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#125;) Logger &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerbosePrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#125;) Logger &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printfLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger  <span class="keyword">interface</span>&#123; Printf(<span class="type">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) &#125;</span><br><span class="line">  logInfo <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithChain"><a href="#WithChain" class="headerlink" title="WithChain"></a><code>WithChain</code></h2><p>Job 包装器可以在执行实际的<code>Job</code>前后添加一些逻辑：</p><ul><li>捕获<code>panic</code>；</li><li>如果<code>Job</code>上次运行还未结束，推迟本次执行;</li><li>如果<code>Job</code>上次运行还未介绍，跳过本次执行；</li><li>记录每个<code>Job</code>的执行情况。</li></ul><p>我们可以将<code>Chain</code>类比为 Web 处理器的中间件。实际上就是在<code>Job</code>的执行逻辑外在封装一层逻辑。我们的封装逻辑需要写成一个函数，传入一个<code>Job</code>类型，返回封装后的<code>Job</code>。<code>cron</code>为这种函数定义了一个类型<code>JobWrapper</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chain.go</span></span><br><span class="line"><span class="keyword">type</span> JobWrapper <span class="function"><span class="keyword">func</span><span class="params">(Job)</span></span> Job</span><br></pre></td></tr></table></figure><p>然后使用一个<code>Chain</code>对象将这些<code>JobWrapper</code>组合到一起：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chain <span class="keyword">struct</span> &#123;</span><br><span class="line">  wrappers []JobWrapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChain</span><span class="params">(c ...JobWrapper)</span></span> Chain &#123;</span><br><span class="line">  <span class="keyword">return</span> Chain&#123;c&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Chain</code>对象的<code>Then(job)</code>方法应用这些<code>JobWrapper</code>，返回最终的<code>Job</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chain)</span></span> Then(j Job) Job &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> c.wrappers &#123;</span><br><span class="line">    j = c.wrappers[<span class="built_in">len</span>(c.wrappers)-i<span class="number">-1</span>](j)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意应用<code>JobWrapper</code>的顺序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本项目中其实并没有用到这么多与之相关的东西，当然还有更加详细的内容本文并没有记录。</p><p>本文就不放参考资料了，因为整篇博客都是照抄的别人的，原因是我破防了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;corn&lt;/code&gt; 是一个用于管理定时任务的库，用 Go 实现 Linux 中 &lt;code&gt;crontab&lt;/code&gt; 这个命令的效果。除了 &lt;code&gt;cron&lt;/code&gt; 以外，Go语言中还有另一个比较小巧、灵活的定时任务库，可以执行定时的、周期性的</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>高性能日志库——Zap</title>
    <link href="http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/"/>
    <id>http://example.com/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/</id>
    <published>2024-05-25T09:39:37.000Z</published>
    <updated>2024-05-25T12:23:08.130Z</updated>
    
    <content type="html"><![CDATA[<p>今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>在任何一个投入使用的项目中，都需要一个好的日志系统（关于什么是<a href="https://zxh3032.github.io/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/">日志</a>，可以看之前的总结，更建议看总结中的参考）。在 Go 语言中，我们有很多能够投入使用的日志库，比如<code>log</code>、<code>zap</code>等。对于一个好的日志记录器来说，我们需要它能够实现一下功能：</p><ul><li>能够将事件记录到文件中，而不是应用程序控制台。</li><li>日志切割-能够根据文件大小、时间或间隔等来切割日志文件。</li><li>支持不同的日志级别。例如INFO，DEBUG，ERROR等。</li><li>能够打印基本信息，如调用文件/函数名和行号，日志时间等。</li></ul><h1 id="默认的Go-Logger"><a href="#默认的Go-Logger" class="headerlink" title="默认的Go Logger"></a>默认的Go Logger</h1><p>在学习Uber-go的zap包之前，还是先学习一下Go语言提供的基本日志功能。由于之前写项目的时候在日志系统设计方面并没有很在意，所以根本就没记住什么东西，还是重新学一下吧。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。</p><p>那就来看一段简单的实现代码吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFileLocation, _ := os.OpenFile(<span class="string">&quot;test.log&quot;</span>, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="number">0744</span>)</span><br><span class="line">log.SetOutput(logFileLocation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用日志记录器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error fetching url %s : %s&quot;</span>, url, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Status Code for %s : %s&quot;</span>, url, resp.Status)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">SetupLogger()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行上述代码后，会有一个 <code>test.log</code> 文件被创建，文件中的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Error fetching url www.baidu.com <span class="punctuation">:</span> Get <span class="attr">&quot;www.baidu.com&quot;</span><span class="punctuation">:</span> unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">05</span>/<span class="number">25</span> <span class="number">18</span><span class="punctuation">:</span><span class="number">03</span><span class="punctuation">:</span><span class="number">00</span> Status Code for http<span class="punctuation">:</span><span class="comment">//www.baidu.com : 200 OK</span></span><br></pre></td></tr></table></figure><h2 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>它最大的优点是使用非常简单。我们可以设置任何<code>io.Writer</code>作为日志记录输出并向其发送要写入的日志。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>仅限基本的日志级别<ul><li>只有一个<code>Print</code>选项。不支持<code>INFO</code>/<code>DEBUG</code>等多个级别。</li></ul></li><li>对于错误日志，它有 <code>Fatal</code> 和 <code>Panic</code><ul><li>Fatal日志通过调用<code>os.Exit(1)</code>来结束程序</li><li>Panic日志在写入日志消息之后抛出一个panic</li><li>但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误</li></ul></li><li>缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。</li><li>不提供日志切割的能力。</li></ul><h1 id="Uber-go-Zap"><a href="#Uber-go-Zap" class="headerlink" title="Uber-go Zap"></a>Uber-go Zap</h1><p>由于上面提到的 <code>Logger</code> 库的劣势并不能帮助我们设计一个良好的日志记录器，所以在本项目中选择了另一个功能更丰富等库——<code>Zap</code>。它同时提供了结构化日志记录和 printf 风格的日志记录。</p><p>那这时候就有同学会有疑问了，提供了更多的功能会不会导致在完成设定的任务时变得更慢呢？</p><p>一个优秀的工具就是实现了既要又要，根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好——也比标准库更快。 以下是Zap发布的基准测试信息</p><p>记录一条消息和10个字段:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">862 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">5 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">1250 ns/op</td><td style="text-align:center">+45%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">4021 ns/op</td><td style="text-align:center">+366%</td><td style="text-align:center">76 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">4542 ns/op</td><td style="text-align:center">+427%</td><td style="text-align:center">105 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">26785 ns/op</td><td style="text-align:center">+3007%</td><td style="text-align:center">115 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">29501 ns/op</td><td style="text-align:center">+3322%</td><td style="text-align:center">125 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">29906 ns/op</td><td style="text-align:center">+3369%</td><td style="text-align:center">122 allocs/op</td></tr></tbody></table></div><p>记录一个静态字符串，没有任何上下文或printf风格的模板：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Time</th><th style="text-align:center">Time % to zap</th><th style="text-align:center">Objects Allocated</th></tr></thead><tbody><tr><td style="text-align:center">⚡️ zap</td><td style="text-align:center">118 ns/op</td><td style="text-align:center">+0%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">⚡️ zap (sugared)</td><td style="text-align:center">191 ns/op</td><td style="text-align:center">+62%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">zerolog</td><td style="text-align:center">93 ns/op</td><td style="text-align:center">-21%</td><td style="text-align:center">0 allocs/op</td></tr><tr><td style="text-align:center">go-kit</td><td style="text-align:center">280 ns/op</td><td style="text-align:center">+137%</td><td style="text-align:center">11 allocs/op</td></tr><tr><td style="text-align:center">standard library</td><td style="text-align:center">499 ns/op</td><td style="text-align:center">+323%</td><td style="text-align:center">2 allocs/op</td></tr><tr><td style="text-align:center">apex/log</td><td style="text-align:center">1990 ns/op</td><td style="text-align:center">+1586%</td><td style="text-align:center">10 allocs/op</td></tr><tr><td style="text-align:center">logrus</td><td style="text-align:center">3129 ns/op</td><td style="text-align:center">+2552%</td><td style="text-align:center">24 allocs/op</td></tr><tr><td style="text-align:center">log15</td><td style="text-align:center">3887 ns/op</td><td style="text-align:center">+3194%</td><td style="text-align:center">23 allocs/op</td></tr></tbody></table></div><h2 id="Zap的特性"><a href="#Zap的特性" class="headerlink" title="Zap的特性"></a>Zap的特性</h2><ul><li>高性能：zap 对日志输出进行了多项优化以提高它的性能</li><li>日志分级：有 Debug，Info，Warn，Error，DPanic，Panic，Fatal 等</li><li>日志记录结构化：日志内容记录是结构化的，比如 json 格式输出</li><li>自定义格式：用户可以自定义输出的日志格式</li><li>自定义公共字段：用户可以自定义公共字段，大家输出的日志内容就共同拥有了这些字段</li><li>调试：可以打印文件名、函数名、行号、日志时间等，便于调试程序</li><li>自定义调用栈级别：可以根据日志级别输出它的调用栈信息</li><li>Namespace：日志命名空间。定义命名空间后，所有日志内容就在这个命名空间下。命名空间相当于一个文件夹</li><li>支持 hook 操作</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  url := <span class="string">&quot;http://example.org/api&quot;</span></span><br><span class="line">  logger.Info(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">    zap.Int(<span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    zap.Duration(<span class="string">&quot;backoff&quot;</span>, time.Second),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  sugar := logger.Sugar()</span><br><span class="line">  sugar.Infow(<span class="string">&quot;failed to fetch URL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span>, url,</span><br><span class="line">    <span class="string">&quot;attempt&quot;</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;backoff&quot;</span>, time.Second,</span><br><span class="line">  )</span><br><span class="line">  sugar.Infof(<span class="string">&quot;Failed to fetch URL: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>zap</code>库的使用与其他的日志库非常相似。先创建一个<code>logger</code>，然后调用各个级别的方法记录日志（<code>Debug/Info/Error/Warn</code>）。</p><p><code>zap</code>提供了几个快速创建<code>logger</code>的方法</p><ul><li><code>zap.NewExample()</code></li><li><code>`zap.NewDevelopment()</code></li><li><code>zap.NewProduction()</code></li><li>还有高度定制化的创建方法<code>zap.New()</code>。</li></ul><p>创建前 3 个<code>logger</code>时，<code>zap</code>会使用一些预定义的设置，它们的使用场景也有所不同。<code>Example</code>适合用在测试代码中，<code>Development</code>在开发环境中使用，<code>Production</code>用在生成环境。</p><p><code>zap</code>底层 API 可以设置缓存，所以一般使用<code>defer logger.Sync()</code>将缓存同步到文件中。</p><hr><p>Zap提供了两种类型的日志记录器—<code>Sugared Logger</code>和<code>Logger</code>。</p><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li>通过调用<code>zap.NewProduction()</code>/<code>zap.NewDevelopment()</code>或者<code>zap.Example()</code>创建一个Logger。</li><li>上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。</li><li>通过Logger调用Info/Error等。</li><li>默认情况下日志都会打印到应用程序的console界面。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(</span><br><span class="line"><span class="string">&quot;Error fetching url..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">zap.Error(err))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Success..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;statusCode&quot;</span>, resp.Status),</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url))</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先创建了一个Logger，然后使用Info/ Error等Logger方法记录消息。</p><h3 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h3><p>现在让我们使用Sugared Logger来实现相同的功能。</p><ul><li>大部分的实现基本都相同。</li><li>惟一的区别是，我们通过调用主logger的<code>. Sugar()</code>方法来获取一个<code>SugaredLogger</code>。</li><li>然后使用<code>SugaredLogger</code>以<code>printf</code>格式记录语句</li></ul><p>下面是修改过后使用<code>SugaredLogger</code>代替<code>Logger</code>的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line"><span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么会有两种？"><a href="#为什么会有两种？" class="headerlink" title="为什么会有两种？"></a>为什么会有两种？</h3><p>由于<code>fmt.Printf</code>之类的方法大量使用<code>interface&#123;&#125;</code>和反射，会有不少性能损失，并且增加了内存分配的频次。<code>zap</code>为了提高性能、减少内存分配次数，没有使用反射，而且默认的<code>Logger</code>只支持强类型的、结构化的日志。必须使用<code>zap</code>提供的方法记录字段。<code>zap</code>为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，<code>zap.Type</code>（<code>Type</code>为<code>bool/int/uint/float64/complex64/time.Time/time.Duration/error</code>等）就表示该类型的字段，<code>zap.Typep</code>以<code>p</code>结尾表示该类型指针的字段，<code>zap.Types</code>以<code>s</code>结尾表示该类型切片的字段。如：</p><ul><li><code>zap.Bool(key string, val bool) Field</code>：<code>bool</code>字段</li><li><code>zap.Boolp(key string, val *bool) Field</code>：<code>bool</code>指针字段；</li><li><code>zap.Bools(key string, val []bool) Field</code>：<code>bool</code>切片字段。</li></ul><p>当然也有一些特殊类型的字段：</p><ul><li><code>zap.Any(key string, value interface&#123;&#125;) Field</code>：任意类型的字段；</li><li><code>zap.Binary(key string, val []byte) Field</code>：二进制串的字段。</li></ul><p>当然，每个字段都用方法包一层用起来比较繁琐。<code>zap</code>也提供了便捷的方法<code>SugarLogger</code>，可以使用<code>printf</code>格式符的方式。调用<code>logger.Sugar()</code>即可创建<code>SugaredLogger</code>。<code>SugaredLogger</code>的使用比<code>Logger</code>简单，只是性能比<code>Logger</code>低 50% 左右，可以用在非热点函数中。调用<code>SugarLogger</code>以<code>f</code>结尾的方法与<code>fmt.Printf</code>没什么区别，如例子中的<code>Infof</code>。同时<code>SugarLogger</code>还支持以<code>w</code>结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可。</p><h2 id="记录层级关系"><a href="#记录层级关系" class="headerlink" title="记录层级关系"></a>记录层级关系</h2><p>前面记录的日志都是一层结构，没有嵌套的层级。我们可以使用 <code>zap.Namespace(key string) Field</code> 构建一个<strong>命名空间</strong>，后续的<code>Filed</code>都记录在此命名空间中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  logger.Info(<span class="string">&quot;tracked some metrics&quot;</span>,</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  logger2 := logger.With(</span><br><span class="line">    zap.Namespace(<span class="string">&quot;metrics&quot;</span>),</span><br><span class="line">    zap.Int(<span class="string">&quot;counter&quot;</span>, <span class="number">1</span>),</span><br><span class="line">  )</span><br><span class="line">  logger2.Info(<span class="string">&quot;tracked some metrics&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrics&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrices&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面我们演示了两种<code>Namespace</code>的用法，一种是直接作为字段传入<code>Debug/Info</code>等方法，一种是调用<code>With()</code>创建一个新的<code>Logger</code>，新的<code>Logger</code>记录日志时总是带上预设的字段。</p><h2 id="定制Logger"><a href="#定制Logger" class="headerlink" title="定制Logger"></a>定制<code>Logger</code></h2><p>调用<code>NexExample()/NewDevelopment()/NewProduction()</code>这 3 个方法，<code>zap</code>使用默认的配置。我们也可以手动调整，配置结构如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/config.go</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Level AtomicLevel <span class="string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span></span><br><span class="line">  Encoding <span class="type">string</span> <span class="string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span></span><br><span class="line">  EncoderConfig zapcore.EncoderConfig <span class="string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span></span><br><span class="line">  OutputPaths []<span class="type">string</span> <span class="string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span></span><br><span class="line">  ErrorOutputPaths []<span class="type">string</span> <span class="string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span></span><br><span class="line">  InitialFields <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Level</code>：日志级别；</li><li><code>Encoding</code>：输出的日志格式，默认为 JSON；</li><li><code>OutputPaths</code>：可以配置多个输出路径，路径可以是文件路径和<code>stdout</code>（标准输出）；</li><li><code>ErrorOutputPaths</code>：错误输出路径，也可以是多个；</li><li><code>InitialFields</code>：每条日志中都会输出这些值。</li></ul><p>其中<code>EncoderConfig</code>为编码配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/go.uber.org/zap/zapcore/encoder.go</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  MessageKey    <span class="type">string</span> <span class="string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span></span><br><span class="line">  LevelKey      <span class="type">string</span> <span class="string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span></span><br><span class="line">  TimeKey       <span class="type">string</span> <span class="string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span></span><br><span class="line">  NameKey       <span class="type">string</span> <span class="string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span></span><br><span class="line">  CallerKey     <span class="type">string</span> <span class="string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span></span><br><span class="line">  StacktraceKey <span class="type">string</span> <span class="string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span></span><br><span class="line">  LineEnding    <span class="type">string</span> <span class="string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span></span><br><span class="line">  EncodeLevel    LevelEncoder    <span class="string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span></span><br><span class="line">  EncodeTime     TimeEncoder     <span class="string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span></span><br><span class="line">  EncodeDuration DurationEncoder <span class="string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span></span><br><span class="line">  EncodeCaller   CallerEncoder   <span class="string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span></span><br><span class="line">  EncodeName NameEncoder <span class="string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>MessageKey</code>：日志中信息的键名，默认为<code>msg</code>；</li><li><code>LevelKey</code>：日志中级别的键名，默认为<code>level</code>；</li><li><code>EncodeLevel</code>：日志中级别的格式，默认为小写，如<code>debug/info</code>。</li></ul><h3 id="将日志写入文件而不是终端"><a href="#将日志写入文件而不是终端" class="headerlink" title="将日志写入文件而不是终端"></a>将日志写入文件而不是终端</h3><p>在实际运行的项目中，将日志写入终端显然不是一个好的想法，即不方便查看，又不能够长时间存储。所以，将日志单独写入到一个文件夹中，是一个非常好的设计。这时，我们就要用到<code>zap.New()</code>方法来定制创建logger。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span></span> *Logger</span><br></pre></td></tr></table></figure><p><code>zapcore.Core</code>需要三个配置——<code>Encoder</code>，<code>WriteSyncer</code>，<code>LogLevel</code>。</p><ol><li><strong>Encoder</strong>：编码器（如何写入日志）。</li><li><strong>WriterSyncer</strong> ：指定日志将写到哪里去。</li><li><strong>Log Level</strong>：哪种级别的日志将被写入。</li></ol><p>在本项目的实际开发中，对以上三个配置都做出了相应的设计。根据日期以及日志的等级实现了相应的日志分割功能，将日志输出的时间格式也进行了更加简洁的设置。</p><h2 id="全局Logger"><a href="#全局Logger" class="headerlink" title="全局Logger"></a>全局<code>Logger</code></h2><p>为了方便使用，<code>zap</code>提供了两个全局的<code>Logger</code>，一个是<code>*zap.Logger</code>，可调用<code>zap.L()</code>获得；另一个是<code>*zap.SugaredLogger</code>，可调用<code>zap.S()</code>获得。需要注意的是，全局的<code>Logger</code>默认并不会记录日志！它是一个无实际效果的<code>Logger</code>。看源码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.uber.org/zap/global.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  _globalMu sync.RWMutex</span><br><span class="line">  _globalL  = NewNop()</span><br><span class="line">  _globalS  = _globalL.Sugar()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以使用<code>ReplaceGlobals(logger *Logger) func()</code>将<code>logger</code>设置为全局的<code>Logger</code>，该函数返回一个无参函数，用于恢复全局<code>Logger</code>设置：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  zap.L().Info(<span class="string">&quot;global Logger before&quot;</span>)</span><br><span class="line">  zap.S().Info(<span class="string">&quot;global SugaredLogger before&quot;</span>)</span><br><span class="line"></span><br><span class="line">  logger := zap.NewExample()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  zap.ReplaceGlobals(logger)</span><br><span class="line">  zap.L().Info(<span class="string">&quot;global Logger after&quot;</span>)</span><br><span class="line">  zap.S().Info(<span class="string">&quot;global SugaredLogger after&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;global Logger after&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;global SugaredLogger after&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到在调用<code>ReplaceGlobals</code>之前记录的日志并没有输出。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是在本项目中已经使用的有关 <code>Zap</code> 库的内容，更加详细和底层的东西还是去看大佬的博客和实际源码吧，我写的博客也只是为了强化一下记忆。</p><p>呜呜呜……，暑期实习还是没有一点眉目，不知道该怎么办了，真是不想背八股文啊！！！昨天面了边无际的面试，感觉这才应该是面试该有的情况，就不要问那些要靠死记硬背的八股文了，日常工作又能用到多少，谁会在写代码的时候需要考虑三次握手怎么握呀。不过不问八股好像也没什么可问的了。这就是绝大多数本科生的悲哀之处吧，上了四年学，什么都没学到。</p><p>不过边无际的面试面的好像也没有多好，不过这是我三个月以来说过最流畅的自我介绍了，感觉还是得深入的学习一下Redis和Docker的内容了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://darjun.github.io/2020/04/23/godailylib/zap/">Go 每日一库之 Zap</a></p></li><li><p><a href="https://www.liwenzhou.com/posts/Go/zap/">李文周的博客</a></p></li><li><a href="https://www.cnblogs.com/jiujuan/p/17304844.html">更加详细的Zap介绍</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天把项目中的日志部分完成了，内容还是比较多的，所以从写代码到看各种函数花了十几个小时。那就还是老样子，先总结一下最重要的部分——Zap库的基本使用方法。&lt;/p&gt;
&lt;h1 id=&quot;日志系统&quot;&gt;&lt;a href=&quot;#日志系统&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>命令行解析——flag</title>
    <link href="http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/"/>
    <id>http://example.com/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/</id>
    <published>2024-05-23T12:18:13.000Z</published>
    <updated>2024-05-23T13:01:07.684Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用<code>Set</code>显示设置的 &gt; 命令行选项 &gt; 环境变量 &gt; 配置文件 &gt; 默认值。</p><p>在实际项目开发中一般不会直接 <code>Set</code> 来设置，因为要使用的配置现象过多。因此，在考虑直接读取配置文件之前，我们要先做一件事，那就是解析命令行，看看有没有相应的键值设置。</p><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><h1 id="如何获取命令行参数？"><a href="#如何获取命令行参数？" class="headerlink" title="如何获取命令行参数？"></a>如何获取命令行参数？</h1><p>如果只是简单的想要获取命令行参数，可以直接使用 <code>os.Args</code> 来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./args_demo a b c d</span><br><span class="line">args[0]=./args_demo</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=b</span><br><span class="line">args[3]=c</span><br><span class="line">args[4]=d</span><br></pre></td></tr></table></figure><p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p><h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p><code>flag</code>用于解析命令行选项。</p><p>命令行选项在实际开发中很常用，特别是在写工具的时候。</p><ul><li>指定配置文件的路径，如<code>redis-server ./redis.conf</code>以当前目录下的配置文件<code>redis.conf</code>启动 Redis 服务器；</li><li>自定义某些参数，如<code>python -m SimpleHTTPServer 8080</code>启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">flag参数</th><th style="text-align:center">有效值</th></tr></thead><tbody><tr><td style="text-align:center">字符串flag</td><td style="text-align:center">合法字符串</td></tr><tr><td style="text-align:center">整数flag</td><td style="text-align:center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td style="text-align:center">浮点数flag</td><td style="text-align:center">合法浮点数</td></tr><tr><td style="text-align:center">bool类型flag</td><td style="text-align:center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td style="text-align:center">时间段flag</td><td style="text-align:center">任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” /“µs”、“ms”、“s”、“m”、“h”。</td></tr></tbody></table></div><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a><code>flag.Type()</code></h3><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age := flag.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married := flag.Bool(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a><code>flag.TypeVar()</code></h3><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a><code>flag.Parse()</code></h3><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>遇到第一个非选项参数（即不是以<code>-</code>和<code>--</code>开头的）或终止符<code>--</code>，解析停止。</p><hr><p>总结一下，使用<code>flag</code>库的一般步骤：</p><ul><li>定义一些全局变量存储选项的值;</li><li>在<code>init</code>方法中使用<code>flag.TypeVar</code>方法定义选项，这里的<code>Type</code>可以为基本类型<code>Int/Uint/Float64/Bool</code>，还可以是时间间隔<code>time.Duration</code>。定义时传入变量的地址、选项名、默认值和帮助信息；</li><li>在<code>main</code>方法中调用<code>flag.Parse</code>从<code>os.Args[1:]</code>中解析选项。因为<code>os.Args[0]</code>为可执行程序路径，会被剔除。</li></ul><p>注意点：</p><p><code>flag.Parse</code>方法必须在所有选项都定义之后调用，且<code>flag.Parse</code>调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为<code>init</code>在所有代码之前执行，将选项定义都放在<code>init</code>中，<code>main</code>函数中执行<code>flag.Parse</code>时所有选项都已经定义了。</p><h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a><code>flag</code>其他函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="定义短选项"><a href="#定义短选项" class="headerlink" title="定义短选项"></a>定义短选项</h3><p><code>flag</code>库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有<strong>相同的默认值</strong>。否则不传该选项时，行为是不确定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    defaultLogLevel = <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">    usage = <span class="string">&quot;set log level value&quot;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;log_type&quot;</span>, defaultLogLevel, usage)</span><br><span class="line">  flag.StringVar(&amp;logLevel, <span class="string">&quot;l&quot;</span>, defaultLogLevel, usage + <span class="string">&quot;(shorthand)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;log level:&quot;</span>, logLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>除了使用<code>flag</code>库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interval []time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(*i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *interval)</span></span> Set(value <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(*i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;interval flag already set&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, dt := <span class="keyword">range</span> strings.Split(value, <span class="string">&quot;,&quot;</span>) &#123;</span><br><span class="line">    duration, err := time.ParseDuration(dt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    *i = <span class="built_in">append</span>(*i, duration)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  intervalFlag interval</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Var(&amp;intervalFlag, <span class="string">&quot;deltaT&quot;</span>, <span class="string">&quot;comma-seperated list of intervals to use between events&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line"></span><br><span class="line">  fmt.Println(intervalFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个新类型，这里定义类型<code>interval</code>。</p><p>新类型必须实现<code>flag.Value</code>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="type">string</span></span><br><span class="line">  Set(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>String</code>方法格式化该类型的值，<code>flag.Parse</code>方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的<code>Set</code>方法。 这里将以<code>,</code>分隔的时间间隔解析出来存入一个切片中。</p><p>自定义类型选项的定义必须使用<code>flag.Var</code>方法。</p><h3 id="解析程序中的字符串"><a href="#解析程序中的字符串" class="headerlink" title="解析程序中的字符串"></a>解析程序中的字符串</h3><p>有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用<code>flag.FlagSet</code>结构的相关方法来解析这些选项。</p><p>实际上，我们前面调用的<code>flag</code>库的方法，都会间接调用<code>FlagSet</code>结构的方法。<code>flag</code>库中定义了一个<code>FlagSet</code>类型的全局变量<code>CommandLine</code>专门用于解析命令行选项。 前面调用的<code>flag</code>库的方法只是为了提供便利，它们内部都是调用的<code>CommandLine</code>的相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="keyword">var</span> CommandLine = NewFlagSet(os.Args[<span class="number">0</span>], ExitOnError)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  CommandLine.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntVar</span><span class="params">(p *<span class="type">int</span>, name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  CommandLine.Var(newIntValue(value, p), name, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(name <span class="type">string</span>, value <span class="type">int</span>, usage <span class="type">string</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Int(name, value, usage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NFlag</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.actual) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Arg</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CommandLine.Arg(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NArg</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(CommandLine.args) &#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以自己创建<code>FlagSet</code>类型变量来解析选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;flag&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := []<span class="type">string</span>&#123;<span class="string">&quot;-intflag&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;-stringflag&quot;</span>, <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> intflag <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> boolflag <span class="type">bool</span></span><br><span class="line">  <span class="keyword">var</span> stringflag <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  fs := flag.NewFlagSet(<span class="string">&quot;MyFlagSet&quot;</span>, flag.ContinueOnError)</span><br><span class="line">  fs.IntVar(&amp;intflag, <span class="string">&quot;intflag&quot;</span>, <span class="number">0</span>, <span class="string">&quot;int flag value&quot;</span>)</span><br><span class="line">  fs.BoolVar(&amp;boolflag, <span class="string">&quot;boolflag&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;bool flag value&quot;</span>)</span><br><span class="line">  fs.StringVar(&amp;stringflag, <span class="string">&quot;stringflag&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;string flag value&quot;</span>)</span><br><span class="line"></span><br><span class="line">  fs.Parse(args)</span><br><span class="line">  </span><br><span class="line">  fmt.Println(<span class="string">&quot;int flag:&quot;</span>, intflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;bool flag:&quot;</span>, boolflag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;string flag:&quot;</span>, stringflag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewFlagSet</code>方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：</p><ul><li><code>ContinueOnError</code>：发生错误后继续解析，<code>CommandLine</code>就是使用这个选项；</li><li><code>ExitOnError</code>：出错时调用<code>os.Exit(2)</code>退出程序；</li><li><code>PanicOnError</code>：出错时产生 panic。</li></ul><p>随便看一眼<code>flag</code>库中的相关代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/flag/flag.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlagSet)</span></span> Parse(arguments []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">  f.parsed = <span class="literal">true</span></span><br><span class="line">  f.args = arguments</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    seen, err := f.parseOne()</span><br><span class="line">    <span class="keyword">if</span> seen &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> f.errorHandling &#123;</span><br><span class="line">    <span class="keyword">case</span> ContinueOnError:</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> ExitOnError:</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> PanicOnError:</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与直接使用<code>flag</code>库的方法有一点不同，<code>FlagSet</code>调用<code>Parse</code>方法时需要显示传入字符串切片作为参数。因为<code>flag.Parse</code>在内部调用了<code>CommandLine.Parse(os.Args[1:])</code>。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，本项目的解析配置文件功能已经基本完成了，该功能先是使用 flag 库来解析命令行中的内容，当命令行内容不为空时，则使用输入值来进行配置；若为空，则通过解析原有的配置文件来实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.liwenzhou.com/posts/Go/flag/">李文周的博客</a></li><li><a href="https://darjun.github.io/2020/01/10/godailylib/flag/">Go每日一库之 flag</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在介绍 Viper 库的那一篇文章中我们有提到过 viper 在设置键值时的优先级，依次是 调用&lt;code&gt;Set&lt;/code&gt;显示设置的 &amp;gt; 命令行选项 &amp;gt; 环境变量 &amp;gt; 配置文件 &amp;gt; 默认值。&lt;/p&gt;
&lt;p&gt;在实际项目开发中一般不会直接 &lt;cod</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go语言配置管理神器——Viper</title>
    <link href="http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/"/>
    <id>http://example.com/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/</id>
    <published>2024-05-23T11:39:34.000Z</published>
    <updated>2024-05-23T12:24:48.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——<code>Viper</code>。</p><p>在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 <strong>Viper</strong>。关于 Viper，我也已经不是第一次使用了，但之前确实是没有去了解过，所以要从头开始学习。</p><h1 id="Viper-是什么"><a href="#Viper-是什么" class="headerlink" title="Viper 是什么"></a>Viper 是什么</h1><p>XXX是什么？这是我们去学习一个东西想到的第一个问题。那么 Viper是 什么，详细内容如下：</p><p>viper 是一个配置解决方案，拥有丰富的特性：</p><ul><li>支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；</li><li>可以设置监听配置文件的修改，修改时自动加载新的配置；</li><li>从环境变量、命令行选项和<code>io.Reader</code>中读取配置；</li><li>从远程配置系统中读取和监听修改，如 etcd/Consul；</li><li>代码逻辑中显示设置键值。</li></ul><h2 id="为什么选择-Viper-？"><a href="#为什么选择-Viper-？" class="headerlink" title="为什么选择 Viper ？"></a>为什么选择 Viper ？</h2><p>在构建现代应用程序时，你无需担心配置文件格式；你想要专注于构建出色的软件。Viper的出现就是为了在这方面帮助你的。</p><p>Viper能够为你执行下列操作：</p><ol><li>查找、加载和反序列化<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>INI</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件。</li><li>提供一种机制为你的不同配置选项设置默认值。</li><li>提供一种机制来通过命令行参数覆盖指定选项的值。</li><li>提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。</li><li>当用户提供了与默认值相同的命令行或配置文件时，可以很容易地分辨出它们之间的区别。</li></ol><p>Viper会按照下面的优先级。每个项目的优先级都高于它下面的项目:</p><ul><li>显示调用<code>Set</code>设置值</li><li>命令行参数（flag）</li><li>环境变量</li><li>配置文件</li><li>key/value存储</li><li>默认值</li></ul><p><strong>重要：</strong> 目前Viper配置的键（Key）是大小写不敏感的。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>Viper 的使用非常简单，它需要很少的设置。设置文件名（<code>SetConfigName</code>）、配置类型（<code>SetConfigType</code>）、和搜索路径（<code>AddConfigPath</code>），然后调用<code>ReadInConfig</code>。viper 会自动根据类型来读取配置。使用时调用 <code>viper.Get</code> 方法获取键值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  viper.SetDefault(<span class="string">&quot;redis.port&quot;</span>, <span class="number">6381</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;app_name&quot;</span>))</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">&quot;log_level&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql ip: &quot;</span>, viper.Get(<span class="string">&quot;mysql.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql port: &quot;</span>, viper.Get(<span class="string">&quot;mysql.port&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql user: &quot;</span>, viper.Get(<span class="string">&quot;mysql.user&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql password: &quot;</span>, viper.Get(<span class="string">&quot;mysql.password&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;mysql database: &quot;</span>, viper.Get(<span class="string">&quot;mysql.database&quot;</span>))</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis ip: &quot;</span>, viper.Get(<span class="string">&quot;redis.ip&quot;</span>))</span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.Get(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>设置文件名时不要带后缀；</li><li>搜索路径可以设置多个，viper 会根据设置顺序依次查找；</li><li>viper 获取值时使用<code>section.key</code>的形式，即传入嵌套的键名；</li><li>默认值可以调用<code>viper.SetDefault</code>设置。</li></ul><h2 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h2><p>viper 提供了多种形式的读取方法。在上面的例子中，我们看到了<code>Get</code>方法的用法。<code>Get</code>方法返回一个<code>interface&#123;&#125;</code>的值，使用有所不便。</p><p><code>GetType</code>系列方法可以返回指定类型的值。 其中，Type 可以为<code>Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice</code>。 但是请注意，<strong>如果指定的键不存在或类型不正确，<code>GetType</code>方法返回对应类型的零值</strong>。</p><p>如果要判断某个键是否存在，使用<code>IsSet</code>方法。 另外，<code>GetStringMap</code>和<code>GetStringMapString</code>直接以 map 返回某个键下面所有的键值对，前者返回<code>map[string]interface&#123;&#125;</code>，后者返回<code>map[string]string</code>。 <code>AllSettings</code>以<code>map[string]interface&#123;&#125;</code>返回所有设置。</p><h2 id="设置键值"><a href="#设置键值" class="headerlink" title="设置键值"></a>设置键值</h2><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><h3 id="viper-Set"><a href="#viper-Set" class="headerlink" title="viper.Set"></a>viper.Set</h3><p>如果某个键通过<code>viper.Set</code>设置了值，那么这个值的优先级最高。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`viper.Set(&quot;redis.port&quot;, 5381) `</span></span><br></pre></td></tr></table></figure><p>如果将上面这行代码放到程序中，运行程序，输出的<code>redis.port</code>将是 5381。</p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>如果一个键没有通过<code>viper.Set</code>显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在<code>init</code>方法中定义选项，并且调用<code>viper.BindPFlags</code>绑定选项到配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pflag.Int(<span class="string">&quot;redis.port&quot;</span>, <span class="number">8381</span>, <span class="string">&quot;Redis port to connect&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定命令行</span></span><br><span class="line">  viper.BindPFlags(pflag.CommandLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>main</code>方法开头处调用<code>pflag.Parse</code>解析选项。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。</p><p>在<code>init</code>方法中调用<code>AutomaticEnv</code>方法绑定全部环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.AutomaticEnv()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="string">&quot;GOPATH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以单独绑定环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 绑定环境变量</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;redis.port&quot;</span>)<span class="comment">//只传入一个参数，这个参数即表示键名，又表示环境变量名。</span></span><br><span class="line">  viper.BindEnv(<span class="string">&quot;go.path&quot;</span>, <span class="string">&quot;GOPATH&quot;</span>)<span class="comment">//传入两个参数，第一个参数表示键名，第二个参数表示环境变量名。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;go path: &quot;</span>, viper.Get(<span class="string">&quot;go.path&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过<code>viper.SetEnvPrefix</code>方法设置环境变量前缀，这样一来，通过<code>AutomaticEnv</code>和一个参数的<code>BindEnv</code>绑定的环境变量， 在使用<code>Get</code>的时候，viper 会自动加上这个前缀再从环境变量中查找。</p><p>如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名<code>gopath</code>也能读取环境变量<code>GOPATH</code>的值。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果经过前面的途径都没能找到该键，viper 接下来会尝试从配置文件中查找。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>使用 <code>viper.SetDefault()</code> 来设置默认值，以供使用。</p><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><h3 id="从io-Reader中读取"><a href="#从io-Reader中读取" class="headerlink" title="从io.Reader中读取"></a>从<code>io.Reader</code>中读取</h3><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bytes&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  tomlConfig := []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">app_name = &quot;awesome web&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># possible values: DEBUG, INFO, WARNING, ERROR, FATAL</span></span><br><span class="line"><span class="string">log_level = &quot;DEBUG&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[mysql]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 3306</span></span><br><span class="line"><span class="string">user = &quot;dj&quot;</span></span><br><span class="line"><span class="string">password = 123456</span></span><br><span class="line"><span class="string">database = &quot;awesome&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[redis]</span></span><br><span class="line"><span class="string">ip = &quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="string">port = 7381</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;redis port: &quot;</span>, viper.GetInt(<span class="string">&quot;redis.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unmarshal"><a href="#Unmarshal" class="headerlink" title="Unmarshal"></a><code>Unmarshal</code></h3><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  AppName  <span class="type">string</span></span><br><span class="line">  LogLevel <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  MySQL    MySQLConfig</span><br><span class="line">  Redis    RedisConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP       <span class="type">string</span></span><br><span class="line">  Port     <span class="type">int</span></span><br><span class="line">  User     <span class="type">string</span></span><br><span class="line">  Password <span class="type">string</span></span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">  IP   <span class="type">string</span></span><br><span class="line">  Port <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viper.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line">  viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">  viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  err := viper.ReadInConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;read config failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c Config</span><br><span class="line">  viper.Unmarshal(&amp;c)</span><br><span class="line"></span><br><span class="line">  fmt.Println(c.MySQL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><p>有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！</p><ul><li><code>WriteConfig</code>：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖；</li><li><code>WriteConfigAs</code>：保存配置到指定路径，如果文件存在，则覆盖；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是入股配置文件存在，则不覆盖。</li></ul><h2 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h2><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><p>只需要调用<code>viper.WatchConfig</code>，viper 会自动监听配置修改。如果有修改，重新加载的配置。</p><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Config file:%s Op:%s\n&quot;</span>, e.Name, e.Op)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，在本项目中所用到的有关 Viper 的内容就记录完了。但是viper相关的设计还没结束，还有另外一个很重要的库 flag。那就再下一篇博客中记录吧，一些写太多容易猪脑过载。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://darjun.github.io/2020/01/18/godailylib/viper/">Go每日一库之 viper</a></li><li><a href="https://www.liwenzhou.com/posts/Go/viper/">李文周的博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来记录一下在 go-vue-admin 项目中学习到的第一个东西——&lt;code&gt;Viper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在第一篇文章中，我们已经基本了解了这个项目中后端部分的基本框架以及主函数的内容。从主函数开始，第一条代码便是初始化 &lt;strong&gt;Viper&lt;/s</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="Go语言库" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go-vue-admin学习</title>
    <link href="http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/05/22/go-vue-admin%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-05-22T14:00:49.000Z</published>
    <updated>2024-05-31T15:48:14.848Z</updated>
    
    <content type="html"><![CDATA[<p>将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。</p><p>这里插一句，道心破了主要是因为在后面的几场面试里总是达不到想要的效果，说话磕磕巴巴，问项目就回答的含糊不清，也不怪面试官给我秒挂，太不自信了，再沉淀一段时间吧，只能寄希望于秋招了。</p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── deploy： 部署相关的文件</span><br><span class="line">├── docs： 项目文档</span><br><span class="line">├── server： 后端代码</span><br><span class="line">└── web： 前端代码</span><br></pre></td></tr></table></figure><p>项目分为两个部分，使用 vue 框架的前端部分和使用 gin 框架的后端部分，前端部分在<code>web</code> 目录下，后端部分在<code>server</code>目录下。由于我对前端的内容不是很了解，所以主要关注 <code>server</code> 后端部分。了解一下目前 github 排名第一的 golang admin 项目是怎么设计的。</p><h1 id="后端结构"><a href="#后端结构" class="headerlink" title="后端结构"></a>后端结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   └── v1: v1 版本的 api，相当于java中的 controller</span><br><span class="line">├── config: 配置类，包括数据库配置，jwt 配置，redis 配置等</span><br><span class="line">├── core</span><br><span class="line">│   └── internal: 服务启动方法</span><br><span class="line">├── docs: swagger 文档</span><br><span class="line">├── global: 全局对象</span><br><span class="line">├── initialize</span><br><span class="line">│   └── internal: 初始化方法，日志，数据库，redis，jwt，定时任务等</span><br><span class="line">├── middleware: 中间件,包括跨域，jwt，casbin，日志，全局异常处理等,使用了 gin.handleFunc 的特性</span><br><span class="line">├── model: 数据库模型，请求参数，响应参数</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── system</span><br><span class="line">├── packfile</span><br><span class="line">├── plugin:</span><br><span class="line">│   ├── email: email 插件，是个完整的小项目，里面结构和外部类似</span><br><span class="line">│   ├── plugin-tool:</span><br><span class="line">│   └── ws</span><br><span class="line">├── resource: 资源文件，包括自动生成代码的模板，页面模板，插件模板等</span><br><span class="line">│   ├── autocode_template: 代码模板，从结构体生成代码</span><br><span class="line">│   ├── page: 前端静态资源</span><br><span class="line">│   └── plug_template: 插件代码模板</span><br><span class="line">├── router:路由代码</span><br><span class="line">│   └── system:</span><br><span class="line">├── service: 业务代码，相当于 java 中的 service</span><br><span class="line">│   └── system</span><br><span class="line">├── source: 数据库的初始数据</span><br><span class="line">│   └── system</span><br><span class="line">└── utils: 公共的工具类</span><br><span class="line">    ├── captcha</span><br><span class="line">    ├── plugin</span><br><span class="line">    ├── timer</span><br><span class="line">    └── upload</span><br></pre></td></tr></table></figure><p>本文是总结篇，提前写是想要有条理一点。下面是代码的主函数，我计划从主函数开始，一行一行地写一遍完整的项目，实在找不到相关的教程，所以学习的过程应该会比较艰辛，希望自己能够坚持下来吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">global.GVA_VP = core.Viper() <span class="comment">// 初始化Viper</span></span><br><span class="line">initialize.OtherInit()</span><br><span class="line">global.GVA_LOG = core.Zap() <span class="comment">// 初始化zap日志库</span></span><br><span class="line">zap.ReplaceGlobals(global.GVA_LOG)</span><br><span class="line">global.GVA_DB = initialize.Gorm() <span class="comment">// gorm连接数据库</span></span><br><span class="line">initialize.Timer()</span><br><span class="line">initialize.DBList()</span><br><span class="line"><span class="keyword">if</span> global.GVA_DB != <span class="literal">nil</span> &#123;</span><br><span class="line">initialize.RegisterTables() <span class="comment">// 初始化表</span></span><br><span class="line"><span class="comment">// 程序结束前关闭数据库链接</span></span><br><span class="line">db, _ := global.GVA_DB.DB()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br><span class="line">core.RunWindowsServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h1><p>Go语言库：</p><ul><li><a href="https://zxh3032.github.io/2024/05/23/Go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Viper/">Viper</a></li><li><a href="https://zxh3032.github.io/2024/05/23/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94flag/">Flag</a></li><li><a href="https://zxh3032.github.io/2024/05/25/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97%E5%BA%93%E2%80%94%E2%80%94Zap/">Zap</a></li><li><a href="https://zxh3032.github.io/2024/05/27/%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron/">cron</a></li><li><p><a href="https://zxh3032.github.io/2024/05/31/%E8%A7%A3%E9%94%81%E7%81%B5%E6%B4%BB%E4%B8%8E%E9%AB%98%E6%95%88%E2%80%94%E2%80%94Casbin/">Casbin</a></p></li><li><p><a href="https://zxh3032.github.io/2024/03/26/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/">gorm</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将近一个月没有更新博客了，主要还是因为道心破了，实在是没有什么动力学习了。二十多天里，试着考了几天研，也试着工作考研两手抓。考虑了很久，还是觉得要提升代码能力，找了一个新的开源项目，不像之前一样每天跟着教程写了，试着能不能自己把别人的代码看懂吃透。&lt;/p&gt;
&lt;p&gt;这里插一句</summary>
      
    
    
    
    <category term="gin-vue-admin" scheme="http://example.com/categories/gin-vue-admin/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学——语言特性</title>
    <link href="http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2024/04/20/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</id>
    <published>2024-04-20T15:40:43.000Z</published>
    <updated>2024-04-23T04:11:09.863Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在学过基础的 Go 语言语法后，我们就发现了 Go 和 C++ 最大的不同，那就是 Go 好像不支持面向对象。</p><p>这门编程语言里没有类（class）、继承（extends），难道真的不支持面向对象编程，难道它也知道我没有对象？完了，被监视了（狗头）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/40b80bdfcc42d53f0ab1bfc99fe1132.jpg" alt="40b80bdfcc42d53f0ab1bfc99fe1132"></p><p>你看，找工作给脑子找坏了吧。不必理会上面一段无脑发言，总结为玩原神玩的。那么 Go 到底支不支持面向对象，让我们一步一步地探寻。</p><h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><p>类（class）在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的特性和方法（via @维基百科）。</p><p>继承是面向对象软件技术当中的一个概念，如果一个类别 B “继承自”另一个类别 A，就把这个 B 称为 “A的子类”，而把 A 称为 “B的父类别” 也可以称 “A 是 B 的超类”（via @维基百科）。</p><p>继承有如下两个特性：</p><ul><li>子类具有父类别的各种属性和方法，不需要再次编写相同的代码。</li><li>子类别继承父类时，可以重新定义某些属性，并重写某些方法，使其获得与父类别不同的功能。</li></ul><h2 id="结构和组合"><a href="#结构和组合" class="headerlink" title="结构和组合"></a>结构和组合</h2><p>在 Go 里就比较 ”特别“ 了，因为没有传统的类，也没有继承。</p><p>取而代之的是结构和组合的方式。这也是业内对 Go 是否 OOP 争议最大的地方。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>我们可以在 Go 中通过结构体的方式来组织代码，达到类似类的方式。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>类的声明采取结构体的方式取代后，也可以配套使用 ”组合“ 来达到类似继承的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> man <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span></span> hello1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">man</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> hello2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">p := person&#123;name: name&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := newPerson(<span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">p.hello1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 man 和 person 两个结构体，并将 man 嵌入到 person 中，形成组合。</p><h2 id="Go-是面向对象的语言吗"><a href="#Go-是面向对象的语言吗" class="headerlink" title="Go 是面向对象的语言吗"></a>Go 是面向对象的语言吗</h2><p>“Go 语言是否一门面向对象的语言？”，这是一个日经话题。官方 FAQ 给出的答复是：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/go-faq-objects.png" alt="image"></p><p>是的，也不是。原因是：</p><ul><li>Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。</li><li>Go 中的 “接口 “概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。</li><li>Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、“未装箱的 “整数。它们并不局限于结构（类）。</li><li>Go 由于缺乏类型层次，Go 中的 “对象 “比 C++ 或 Java 等语言更轻巧。</li></ul><h1 id="函数重载和缺省参数"><a href="#函数重载和缺省参数" class="headerlink" title="函数重载和缺省参数"></a>函数重载和缺省参数</h1><p>Go 语言中并不支持函数重载和缺省参数，下面将会介绍这两个是什么。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载（function overloading），也叫方法重载。是某些编程语言（如 C++、C#、Java、Swift、Kotlin 等）具有的一项特性。</p><p>该特性<strong>允许创建多个具有不同实现的同名函数</strong>，对重载函数的调用会运行其适用于调用上下文的具体实现。</p><p>从功能上来讲，就是允许一个函数调用根据上下文执行不同的方法，达到调用同一个函数名，执行不同的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Volume</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;  <span class="comment">// 立方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> s * s * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Volume</span><span class="params">(<span class="type">double</span> r, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 圆柱体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.1415926</span> * r * r * <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Volume</span><span class="params">(<span class="type">long</span> l, <span class="type">int</span> b, <span class="type">int</span> h)</span> </span>&#123;  <span class="comment">// 长方体的体积。</span></span><br><span class="line">  <span class="keyword">return</span> l * b * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">2.5</span>, <span class="number">8</span>);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Volume</span>(<span class="number">100l</span>, <span class="number">75</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>参数默认值，又叫缺省参数。指的是允许程序员设定缺省参数并指定默认值，<strong>当调用该函数并未指定值时，该缺省参数将为缺省值来使用</strong>。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c=<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，函数 <code>my_func</code> 一共有 3 个变量，分别是：a、b、c。变量 c 设置了缺省值，也就是 12。</p><p>其调用方式可以为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二种调用方式</span></span><br><span class="line">result = <span class="built_in">my_func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在第一种方式中，就会正常的传入所有参数。在第二种方式，由于第三个参数 c 并没有传递，因此会直接使用缺省值 12。</p><p>这就是参数默认值，也叫缺省参数。</p><h2 id="为什么不支持"><a href="#为什么不支持" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>从上述的功能特性介绍来看，似乎非常的不错，能够节省很多功夫。像是 Go 语言的 context 库中的这些方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>要是有函数重载，直接就 WithXXX 就好了，只需要关注传入的参数类型，也不用 “记” 那么多个方法名了。</p><p>有同学说，有参数默认值。那就可以直接设置在上面，作为 “最佳实践” 给到使用函数的人，岂不美哉。那怎么 Go 语言就不支持呢？</p><h3 id="细思"><a href="#细思" class="headerlink" title="细思"></a>细思</h3><p>其实这和设计理念，和对程序的理解有关系。说白了，就是你喜欢 “显式”，还是 “隐喻”。</p><p>函数重载和参数默认值，其实是不好的行为。调用者只看函数名字，可能没法知道，你这个默认值，又或是入参不同，会调用的东西，会产生怎么样的后果？</p><p>你可以观察一下自己的行为。大部分人都会潜意识的追进去看代码，看看会调到哪，缺省值的作用是什么，以确保可控。</p><h3 id="敲定"><a href="#敲定" class="headerlink" title="敲定"></a>敲定</h3><p>这细思的可能，在 Go 语言中是不被允许的。Go 语言的<strong>设计理念就是 “显式大于隐喻”，追求明确，显式</strong>。</p><p>在 Go FAQ 《Why does Go not support overloading of methods and operators?》有相关的解释。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/func-overloading.png" alt="image"></p><p>官方有明确提到两个观点：</p><ul><li>函数重载：拥有各种同名但不同签名的方法有时是很有用的，但在实践中也可能是混乱和脆弱的。</li><li>参数默认值：操作符重载，似乎更像是一种便利，不是绝对的要求。没有它，程序会更简单。</li></ul><p>这就是为什么 Go 语言不支持的原因。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p><strong>Go 里的锁，竟然不支持可重入</strong>？</p><p>如果对已经上锁的普通互斥锁进行 “加锁” 操作，其结果要么失败，要么会阻塞至解锁。</p><p>可重入互斥锁是互斥锁的一种，同一线程对其多次加锁不会产生死锁，又或是导致阻塞。</p><ul><li>在加锁上：如果是可重入互斥锁，当前尝试加锁的线程如果就是持有该锁的线程时，加锁操作就会成功。</li><li>在解锁上：可重入互斥锁一般都会记录被加锁的次数，只有执行相同次数的解锁操作才会真正解锁。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="Go-设计原则"><a href="#Go-设计原则" class="headerlink" title="Go 设计原则"></a>Go 设计原则</h3><p>在工程中使用互斥的根本原因是：为了保护不变量，也可以用于保护内、外部的不变量。</p><p>基于此，Go 在互斥锁设计上会遵守这几个原则。如下：</p><ul><li>在调用 <code>mutex.Lock</code> 方法时，要保证这些变量的不变性保持，不会在后续的过程中被破坏。</li><li>在调用<code>mu.Unlock</code>方法时，要保证：<ul><li>程序不再需要依赖那些不变量。</li><li>如果程序在互斥锁加锁期间破坏了它们，则需要确保已经恢复了它们。</li></ul></li></ul><h3 id="不支持的原因"><a href="#不支持的原因" class="headerlink" title="不支持的原因"></a>不支持的原因</h3><p>讲了 Go 自己的设计原则后，那为什么不支持可重入呢？</p><p>其实 Russ Cox 于 2010 年在《<a href="https://groups.google.com/g/golang-nuts/c/XqW1qcuZgKg/m/Ui3nQkeLV80J">Experimenting with GO</a>》就给出了答复，认为递归（又称：重入）互斥是个坏主意，这个设计并不好。</p><h1 id="并发读写"><a href="#并发读写" class="headerlink" title="并发读写"></a>并发读写</h1><p>来不及惋惜 Redis 三兄弟了，接下来登场的是 Go 语言自己的三兄弟——垃圾回收机制、协程机制和为什么 <code>map</code> 和 <code>slice</code>是非线性的。</p><p>为什么在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？</p><h2 id="非线程安全的例子"><a href="#非线程安全的例子" class="headerlink" title="非线程安全的例子"></a>非线程安全的例子</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>我们使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;随便寻个地方&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;随便寻了 %d 个地方&quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一次执行</span><br><span class="line">随便寻了5790个地方</span><br><span class="line">// 第二次执行</span><br><span class="line">随便寻了7370个地方</span><br><span class="line">// 第三次执行</span><br><span class="line">随便寻了6792个地方</span><br></pre></td></tr></table></figure><p>每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式的问题。</p><p>这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>同样针对 map 也如法炮制一下，重复针对类型为 map 的变量进行写入，结果会直接出现报错，并且是 Go 源码调用 <code>throw</code> 方法所导致的致命错误，也就是说 Go 进程会中断。</p><h2 id="如何支持并发读写"><a href="#如何支持并发读写" class="headerlink" title="如何支持并发读写"></a>如何支持并发读写</h2><h3 id="对-map-上锁"><a href="#对-map-上锁" class="headerlink" title="对 map 上锁"></a>对 map 上锁</h3><p>实际上我们仍然会经过有并发 map 的诉求，因为 Go 语言中的 goroutine 实在是太方便了。像是一般写爬虫任务时，基本会用到多个 goroutine，获取到数据后再写入到 map 或者 slice 中去。</p><p>Go 官方在 Go maps in action 中提供了一种简单又便利的方式来实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br></pre></td></tr></table></figure><p>这条语句声明了一个变量，它是一个匿名结构（struct）体，包含一个原生和一个嵌入读写锁 <code>sync.RWMutex</code>。</p><h3 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h3><p>虽然有了 Map+Mutex 的极简方案，但是也仍然存在一定问题。那就是在 map 的数据量非常大时，只有一把锁（Mutex）就非常可怕了，一把锁会导致大量的争夺锁，导致各种冲突和性能低下。</p><p>常见的解决方案是分片化，将一个大 map 分成多个区间，各区间使用多个锁，这样子锁的粒度就大大降低了。不过该方案实现起来很复杂，很容易出错。因此 Go 团队到比较为止暂无推荐，而是采取了其他方案。</p><p>该方案就是在 Go1.9 起支持的 <code>sync.Map</code>，其支持并发读写 map，起到一个补充的作用。</p><p>Go 语言的 <code>sync.Map</code> 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex</span><br><span class="line">read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其是专门为 <code>append-only</code> 场景设计的，也就是适合读多写少的场景。这是他的优点之一。</p><p>若出现写多/并发多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。这是他的重大缺点。</p><p>提供了以下常用方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>Delete：删除某一个键的值。</li><li>Load：返回存储在 map 中的键的值，如果没有值，则返回 nil。ok 结果表示是否在 map 中找到了值。</li><li>LoadAndDelete：删除一个键的值，如果有的话返回之前的值。</li><li>LoadOrStore：如果存在的话，则返回键的现有值。否则，它存储并返回给定的值。如果值被加载，加载的结果为 true，如果被存储，则为 false。</li><li>Range：递归调用，对 map 中存在的每个键和值依次调用闭包函数 <code>f</code>。如果 <code>f</code> 返回 false 就停止迭代。</li><li>Store：存储并设置一个键的值。</li></ul><h2 id="为什么不支持-1"><a href="#为什么不支持-1" class="headerlink" title="为什么不支持"></a>为什么不支持</h2><p>Go Slice 的话，主要还是索引位覆写问题，这个就不需要纠结了，势必是程序逻辑在编写上有明显缺陷，自行改之就好。</p><p>但 Go map 就不大一样了，很多人以为是默认支持的，一个不小心就翻车，这么的常见。那凭什么 Go 官方还不支持，难不成太复杂了，性能太差了，到底是为什么？</p><p>原因如下（via @go faq）：</p><ul><li>典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。</li><li>非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。</li><li>性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。</li></ul><p>汇总来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在学习所谓的 Go 语言哲学时并不会有很多知识上的收获，要去探讨为什么设计师要这么设计某一个功能其实就是在揣测别人的心思，或许并没有什么原因，他只是喜欢。</p><p>那为什么还会有这种 XX 语言哲学的存在呢，我觉得是为了让学习者能够更快地抓住语言特性，也会给未来使用其进行开发带来深远的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言设计哲学第二弹，这不禁勾起了我的伤心往事，当时跟腾讯的面试官聊的多好啊，结果还是被挂了，呜呜呜……&lt;/p&gt;
&lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言2——反射与unsafe</title>
    <link href="http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/"/>
    <id>http://example.com/2024/04/20/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%802%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8Eunsafe/</id>
    <published>2024-04-20T15:36:56.000Z</published>
    <updated>2024-04-21T08:37:58.487Z</updated>
    
    <content type="html"><![CDATA[<p>又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在计算机科学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。（来自wikipedia）</p><p>反射是程序审查自身结构的能力，并能对程序做出一定的修改。</p><p>对于人来说，审查自身或过往事情的能力，叫 “反思” 或 “反省”。</p><h2 id="Go-中的反射包：reflect介绍"><a href="#Go-中的反射包：reflect介绍" class="headerlink" title="Go 中的反射包：reflect介绍"></a>Go 中的反射包：reflect介绍</h2><p>同 Java 语言一样，Go 语言也有运行时反射，这为我们提供了一种可以在运行时操作任意类型对象的能力。比如查看一个接口变量的具体类型、看看一个结构体又多少字段、修改某个字段的值等。</p><p>Go语言是静态编译类语言，比如在定义一个变量的时候，已经知道了它是什么类型，那么为什么还需要反射呢？这是因为有些事情只有在运行时才知道。比如你定义了一个函数，它有一个 interface｛｝类型的参数，这也就意味着调用者可以传递任何类型的参数给这个函数。在这种情况下，如果你想知道调用者传递的是什么类型的参数，就需要用到反射。如果你想知道一个结构体有哪些字段和方法，也需要反射。</p><p>Go 中的反射是建立在类型系统之上，它与空接口 interface{} 密切相关。</p><p>每个 interface{} 类型的变量包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</p><blockquote><p>所以 nil != nil </p></blockquote><ul><li>获取 2 种类型信息的方法：</li></ul><blockquote><p><code>reflect.TypeOf()</code> 获取类型信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/type.go;l=39">Type</a> 类型；</p><p><code>reflect.ValueOf()</code> 获取数据信息，返回 <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.8:src/reflect/value.go;l=39">Value</a> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421145232856.png" alt="image-20240421145232856"></p><ul><li>2 个方法部分源码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span></span><br><span class="line"><span class="comment">// 参数类型 interface&#123;&#125; 可以表示任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> ，经过中间变量 <code>interface&#123;&#125;</code>，把一个普通的变量转换为反射包中类型对象： Type 和 Value 2 个类型，然后再用 reflect 包中的方法对它们进行各种操作。</p><blockquote><p>步骤：Go 变量 -&gt; interface{} -&gt; 反射包的反射类型对象</p></blockquote><p>反射包 reflect 中所有方法基本都是围绕 Type 和 Value 这 2 个类型设计和操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303885-113976386.png" alt="image-20230220180637118"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/650581-20230221220303895-169946680.png" alt="image-20230220180651792"></p><h2 id="reflect-简单使用"><a href="#reflect-简单使用" class="headerlink" title="reflect 简单使用"></a>reflect 简单使用</h2><p>从上面可以看出 TypeOf() 返回的是一个反射包中的 Type 类型，ValueOf() 返回的是一个反射包中的 Value 类型。</p><h3 id="float-反射实例"><a href="#float-反射实例" class="headerlink" title="float 反射实例"></a>float 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==TypeOf==&quot;</span>) <span class="comment">//TypeOf</span></span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type: &quot;</span>, t) <span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, t.Kind())<span class="comment">//kind: float64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;==ValueOf==&quot;</span>)<span class="comment">//ValueOf</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;value: &quot;</span>, v)<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())<span class="comment">//type: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind())<span class="comment">//kind: float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())<span class="comment">//value: 1.2345</span></span><br><span class="line">fmt.Println(v.Interface())<span class="comment">//1.2345</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value is %5.2e\n&quot;</span>, v.Interface())<span class="comment">//value is 1.23e+00</span></span><br><span class="line"></span><br><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)<span class="comment">//1.2345</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;===kind===&quot;</span>)<span class="comment">//=kind=</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v = reflect.ValueOf(m)</span><br><span class="line">    fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind()) <span class="comment">// kind: int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type()) <span class="comment">// type: main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，reflect 包中 <code>reflect.TypeOf()</code> 返回 Type 和 <code>reflect.ValueOf()</code> 返回 Value 类型 都有一个 <code>Kind()</code> 方法，<code>Kind()</code> 返回一个底层的数据类型，如 Unit，Float64，Slice, Int 等。</p><p><strong>reflect.ValueOf() 返回的 Value 类型</strong>：</p><ul><li>它有一个 Type() 方法，返回的是 reflect.Value 的 Type</li><li>它有获取 Value 类型值的方法<ul><li>如果我们知道是 <code>float</code> 类型，所以直接用 <code>Float()</code> 方法。</li><li>如果不知道具体类型呢？由上面例子可知用 <code>Interface()</code> 方法，然后在进行类型断言 <code>v.Interface().(float64)</code> 来判断获取值</li></ul></li></ul><p><strong>v.Kind() 和 v.Type() 区别</strong>：</p><ul><li>在 Go 中，可以用 type 关键字定义自定义类型，<code>Kind()</code> 方法返回底层类型。</li><li>比如还有结构体，指针等类型用 type 定义的，那么 <code>Kind()</code> 方法就可以获取这些类型的底层类型。</li></ul><h3 id="struct-反射实例"><a href="#struct-反射实例" class="headerlink" title="struct 反射实例"></a>struct 反射实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot; id:&quot;1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := student&#123;</span><br><span class="line">Name: <span class="string">&quot;hangmeimei&quot;</span>,</span><br><span class="line">Age:  <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueOfStu := reflect.ValueOf(stu)</span><br><span class="line"><span class="comment">// 获取struct字段数量</span></span><br><span class="line">fmt.Println(<span class="string">&quot;NumFields: &quot;</span>, valueOfStu.NumField()) <span class="comment">//NumFields:  2</span></span><br><span class="line"><span class="comment">// 获取字段 Name 的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name value: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).String(), <span class="string">&quot;, &quot;</span>, valueOfStu.FieldByName(<span class="string">&quot;Name&quot;</span>).String()) <span class="comment">//Name value:  hangmeimei ,  hangmeimei</span></span><br><span class="line"><span class="comment">// 字段类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name type: &quot;</span>, valueOfStu.Field(<span class="number">0</span>).Type()) <span class="comment">//Name type:  string</span></span><br><span class="line"></span><br><span class="line">typeOfStu := reflect.TypeOf(stu)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfStu.NumField(); i++ &#123;</span><br><span class="line"><span class="comment">// 获取字段名</span></span><br><span class="line">name := typeOfStu.Field(i).Name</span><br><span class="line">fmt.Println(<span class="string">&quot;Field Name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tag</span></span><br><span class="line"><span class="keyword">if</span> fieldName, ok := typeOfStu.FieldByName(name); ok &#123;</span><br><span class="line">tag := fieldName.Tag</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;tag-&quot;</span>, tag, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;json:&quot;</span>, tag.Get(<span class="string">&quot;json&quot;</span>), <span class="string">&quot;, id&quot;</span>, tag.Get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//循环输出结果</span></span><br><span class="line">    <span class="comment">//Field Name:  Name</span></span><br><span class="line"><span class="comment">//tag- json:&quot;name&quot; ,  json: name , id</span></span><br><span class="line"><span class="comment">//Field Name:  Age</span></span><br><span class="line">    <span class="comment">//tag- json:&quot;age&quot; id:&quot;1&quot; ,  json: age , id 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 struct 信息的一些方法：</p><ul><li><code>NumField()</code> 获取结构体字段数量</li><li><code>Field(i)</code> 可以通过 i 字段索引来获取结构体字段信息，比如 Field(i).Name 获取字段名</li><li><code>FieldByName(name)</code> 通过 name 获取字段信息</li></ul><h2 id="三大定理"><a href="#三大定理" class="headerlink" title="三大定理"></a>三大定理</h2><p>在 Go 官方博客文章 <a href="https://go.dev/blog/laws-of-reflection">laws-of-reflection</a> 中，叙述了反射的 3 定律：</p><ul><li>第一定律：从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>第二定律：从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>第三定律：要修改反射对象，其值必须可设置；</li></ul><h3 id="第一定律"><a href="#第一定律" class="headerlink" title="第一定律"></a>第一定律</h3><p>反射的第一定律是我们能将 Go 语言的 <code>interface&#123;&#125;</code> 变量转换成反射对象。为什么是从 <code>interface&#123;&#125;</code> 变量到反射对象？</p><blockquote><p>当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://draveness.me/golang/tree/reflect.TypeOf"><code>reflect.TypeOf</code></a>、<a href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface&#123;&#125;</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface&#123;&#125;</code> 类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151203850.png" alt="image-20240421151203850"></p><h3 id="第二定律"><a href="#第二定律" class="headerlink" title="第二定律"></a>第二定律</h3><p>反射的第二定律是我们可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code>中的 <code>reflect.Value.Interface</code>就能完成这项工作：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151429967.png" alt="image-20240421151429967"></p><p>不过调用 <code>reflect.Value.Interface</code>方法只能获得 <code>interface&#123;&#125;</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p><ul><li>从接口值到反射对象：<ul><li>从基本类型到接口类型的类型转换；</li><li>从接口类型到反射对象的转换；</li></ul></li><li>从反射对象到接口值：<ul><li>反射对象转换成接口类型；</li><li>通过显式类型转换变成原始类型；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421151704589.png" alt="image-20240421151704589"></p><h3 id="第三定律"><a href="#第三定律" class="headerlink" title="第三定律"></a>第三定律</h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的。</p><p>看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>这个问题并不是 7.1 不可寻址，而是这个 x 不可设置。</p><p>可设置性是反射值的一个属性，并不是所有的反射值有这个属性。</p><p>Value 的 <code>CanSet</code> 方法可以获取值是否可设置，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>为什么有可设置性？</p><blockquote><p>因为 reflect.ValueOf(x) 这个 x 传递的是一个原数据的副本，上面代码 <code>v.SetFloat(7.1)</code> 如果设置成功，那么更新的是副本值，原始值 x 并没有更新。这就会造成原值和新值的混乱，可设置属性就是避免这个问题。</p></blockquote><p>那怎么办？</p><p>传递的是一个副本，而不是值本身。如果希望能直接修改 x，那么必须把 x 的地址传递给函数，即指向 x 的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyvar x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet())</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copytype of p:</span> <span class="meta">*float64</span></span><br><span class="line"><span class="attr">settability of p:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>还是 <code>false</code>，为什么？</p><p>反射对象 p 不可设置，它并不是我们要设置的 p，它实际上是 <em>p。为了得到 p 所指向的东西，我们需要调用 Value 的 <code>Elem</code> 方法，通过指针进行简介<em>*寻址</em></em>，然后将结果保存在一个名为 v 的反射 Value 中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyv := p.<span class="built_in">Elem</span>()</span><br><span class="line">fmt.<span class="built_in">Println</span>(<span class="string">&quot;settability of v:&quot;</span>, v.<span class="built_in">CanSet</span>())</span><br></pre></td></tr></table></figure><p>现在 v 是一个可设置的反射对象，输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Copysettability of v:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后我们可以用 <code>v.SetFloat()</code> 设置值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyv<span class="selector-class">.SetFloat</span>(<span class="number">7.1</span>)</span><br><span class="line">fmt<span class="selector-class">.Println</span>(v.Interface())</span><br><span class="line">fmt<span class="selector-class">.Println</span>(x)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy7.1</span><br><span class="line">7.1</span><br></pre></td></tr></table></figure><blockquote><p>说明：请记住，修改反射值需要值的地址，以便修改他们的真正值。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以根据条件灵活的调用函数。最大一个优点就是灵活。</li></ul><p>比如函数参数的数据类型不确定，这时可以根据反射来判断数据类型，在调用适当的函数。</p><p>还有比如根据某些条件来调用哪个函数。</p><p>需要根据动态需要来调用函数，可以用反射。</p><blockquote><p>使用反射的 2 个典型场景：1、操作数据库的 ORM 框架 ，2、依赖注入</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>用反射编写的代码比较难以阅读和理解</li><li>反射是在运行时才执行，所以编译期间比较难以发现错误</li><li>反射对性能的影响，比一般正常运行代码慢一到两个数量级。</li></ul><h1 id="不安全但高效的-unsafe"><a href="#不安全但高效的-unsafe" class="headerlink" title="不安全但高效的 unsafe"></a>不安全但高效的 unsafe</h1><p>Go的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<strong>强类型的静态语言</strong>。强类型意味着一旦定义了，类型就不能改变；静态意味着在运行前就做了类型检查。同时出于安全考虑，Go语言是不允许两个指针类型进行转换的。</p><p>我们一般使用 <code>*T</code> 作为一个指针类型，表示一个指向类型 <code>T</code> 变量的指针。基于安全考虑，两个不同的指针类型不能相互转换，比如 <em>int 不能转为 </em>float64。</p><p>go官方是不推荐使用unsafe的操作因为它是不安全的，它绕过了golang的内存安全原则，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。但是在很多地方却是很实用。在一些go底层的包中unsafe包被很频繁的使用。</p><h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"><span class="comment">//ArbitraryType仅用于文档目的，实际上并不是unsafe包的一部分,它表示任意Go表达式的类型。</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="comment">//任意类型的指针，类似于C的*void</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"><span class="comment">//确定结构在内存中占用的确切大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//返回结构体中某个field的对其值（字节对齐的原因）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>官方中定义了四个描述：</p><ol><li>任何类型的指针都可以被转化为Pointer</li><li>Pointer可以被转化为任何类型的指针</li><li>uintptr可以被转化为Pointer</li><li>Pointer可以被转化为uintptr</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240421155246421.png" alt="image-20240421155246421"></p><h2 id="uintptr-指针类型"><a href="#uintptr-指针类型" class="headerlink" title="uintptr 指针类型"></a>uintptr 指针类型</h2><p>uintptr 也是一种指针类型，它足够大，可以表示任何指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">uintptr</span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure><p>既然已经有了 <code>unsafe.Pointer</code>，为什么还要设计 <code>uintptr</code> 类型呢？</p><p>通常<code>Pointer</code>不能参与指针运算，比如你要在某个指针地址上加上一个偏移量，<code>Pointer</code> 是不能做这个运算的，那么谁可以呢？这里要靠 <code>uintptr</code> 类型了，只有将 <code>Pointer</code> 类型先转换成 <code>uintptr</code> 类型，做完地址加减法运算后，再转换成 <code>Pointer</code> 类型，通过*操作达到取值、修改值的目的。</p><p><code>uintptr</code> 是 Go 语言的内置类型，是能存储指针的整型， <code>uintptr</code> 的底层类型是int，它和 <code>unsafe.Pointer</code> 可相互转换。</p><p><code>uintptr</code> 和 <code>unsafe.Pointer</code> 的区别就是：</p><ul><li><code>unsafe.Pointer</code> 只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li><li>而<code>uintptr</code>是用于指针运算的，GC 不把 <code>uintptr</code> 当指针，也就是说 <code>uintptr</code> 无法持有对象， <code>uintptr</code> 类型的目标会被回收；</li><li><code>unsafe.Pointer</code> 可以和 普通指针 进行相互转换；</li><li><code>unsafe.Pointer</code> 可以和 <code>uintptr</code> 进行相互转换。</li></ul><h1 id="slice-为何如此高效"><a href="#slice-为何如此高效" class="headerlink" title="slice 为何如此高效"></a>slice 为何如此高效</h1><p><code>slice</code> 是 <code>Go</code> 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 <code>Go</code> 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 <code>Go</code> 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 <code>slice</code> 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在讲 slice的原理之前，我先来介绍一下数组。几乎所有的编程语言里都存在数组，Go也不例外。那么为什么 Go语言除了数组之外又设计了 slice 呢？要想解答这个问题，我们先来了解数组的局限性。</p><p>一个数组由两部分构成：数组的<strong>大小</strong>和数组内的<strong>元素类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组结构伪代码表示</span></span><br><span class="line">array&#123;</span><br><span class="line"><span class="number">1</span>en</span><br><span class="line">    item <span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个数组被声明，它的大小和内部元素就不能改变，你不能随意地向数组添加任意多个元素。这是数组的<strong>第一个限制</strong>。<br>既然数组的大小是固定的，如果需要使用数组存储大量的数据，就需要提前指定一个合适的大小，比如 100000，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a10：= [<span class="number">100000</span>]<span class="type">string</span>｛<span class="string">&quot;随便寻个地方&quot;</span>｝</span><br></pre></td></tr></table></figure><p>这样虽然可以解决问题，但又带来了另外的问题，那就是内存占用。因为在Go语言中，函数间的传参是值传递的，数组作为参数在各个函数之间被传递的时候，同样的内容就会被一遍遍地复制，这就会造成大量的内存浪费，这是数组的<strong>第二个限制</strong>。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>在上面，我们已经了解到了数组的限制，为了解决这些限制，Go 语言创造了 slice，也就是<strong>切片</strong>。</p><p>切片是对数组的抽象和封装，它的底层是一个数组，存储所有的元素，但是它可以动态地添加元素，容量不足时还可以自动扩容，你完全可以把切片理解为动态数组。在Go语言中，除了长度固定的类型需要使用数组外，大多数情况下都是使用切片。</p><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>通过内置的 <code>append</code> 方法，可以向一个切片中追加任意多个元素，这就可以解决数组的第一个限制了。</p><p>当通过 <code>append</code> 追加元素时，如果切片的容量不够，<code>append</code> 函数会自动扩容。</p><p><code>append</code> 自动扩容的原理是新创建一个底层数组，把原来切片内的元素拷贝到新数组中，然后再返回一个指向新数组的切片。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/v2-3708315c909a8a8a327b733597e66938_720w.webp" alt="img"></p><p>底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><p>切片的本质就是 <code>sliceHeader</code>，又因为函数的参数是值传递，所以传递的是 <code>SliceHteader</code>的副本、而不是底层数组的副本。这时候切片的优势就体现出来了，因为 <code>SiceHteader</code> 的副本内存占用非常少，即使是一个非常大的切片（底层数组有很多元素），也顶多占用24字节的内存，这就解决了大数组在传参时内存浪费的问题。</p><blockquote><p>SliceHeader 的三个字段的类型分别是 uintptr、int 和 int，在64位的机器上，这三个字段最多也就是 int64 类型，一个int64 占8字节，三个int64 占24字节肉存。</p></blockquote><h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><p>如果从集合类型的角度考虑，数组、切片和 map 都是集合类型，因为它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是连续的内存操作，通过索引就可以快速地找到元素存储的地址。</p><p>进一步对比，在数组和切片中，切片又更高效，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 <code>SliceHleader</code> 的三个字段就可以了，共用的还是同一个底层数组。</p><p>切片的高效还体现在 <code>for tange</code> 循环中，因为循环得到的临时变量也是个值拷贝，所以在遍历大的数组时，切片的效率更高。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本周所学基础知识就是上面的三大块内容，额，了解 Go 语言的底层设计就会发现其设计的巧妙性，初学数组和切片时认为单独设计这两个明明差不多的东西有点多此一举。看了它的底层逻辑，有了解了其设计哲学才发现好像是有道理的。</p><p>其实可以回答一个面试官很爱问的问题——为什么要学习 Go 这门语言？</p><p>其实这个问题我已经不止一次地在博客中写了，最开始学习的原因是因为舍友说这门语言有着严格的语法和结构要求，所以每个人写出来的代码都没有太大的区别，所以出于规划自己的代码风格以及缩小自己与大佬的差距，我选择学习Go 语言。</p><p>在开始做 Go 语言项目时，发现这个语言要比 C++ 或者 Python 好用很多，简单的语法、高并发等特性吸引着我去继续做项目。</p><p>现在也已经做了不少关于 Go 语言开发的内容，代码量也有几万行了，也开始关注其设计哲学和底层代码，更是被其严谨性所折服。所有设计出来的东西好像都是必须要有的，既不会多出一些无关紧要的设计，也没有什么必不可少的功能。</p><blockquote><p>不过 Go 语言确实不适合用来刷题，不仅仅是在设计输入输出的时候很麻烦，实现一些功能也是不方便。仅代表个人观点。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>反射：<ul><li><a href="https://www.cnblogs.com/jiujuan/p/17142703.html">https://www.cnblogs.com/jiujuan/p/17142703.html</a></li><li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93">https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#436-%E5%B0%8F%E7%BB%93</a></li></ul></li><li>unsafe：<ul><li><a href="https://segmentfault.com/a/1190000021625500">https://segmentfault.com/a/1190000021625500</a></li><li><a href="https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html">https://wizardforcel.gitbooks.io/go42/content/content/42_28_unsafe.html</a></li><li><a href="https://xie.infoq.cn/article/6513f7a056774b47c63535fae">https://xie.infoq.cn/article/6513f7a056774b47c63535fae</a></li></ul></li><li>slice：<ul><li><a href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html">https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/61121325">https://zhuanlan.zhihu.com/p/61121325</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到了一周一次的总结篇了，本周学到的知识可以用海量来表示了，毕竟这也是近一个月以来既没有考试也没有面试的一周，所以就一直在做项目、改简历。当然，较大模块的内容还是会在整理之后单独来记录。以后的事以后再聊，还是先来看看本周都学了什么吧。&lt;/p&gt;
&lt;h1 id=&quot;反射&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>聊天室</title>
    <link href="http://example.com/2024/04/20/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>http://example.com/2024/04/20/%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2024-04-20T15:33:55.000Z</published>
    <updated>2024-04-25T08:47:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>这次真成全栈工程师了。第三个 Go 语言项目，简单地实现了一个基于 TCP 连接的聊天室。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425124404153.png" alt="image-20240425124404153"></p><p>实现功能也比较简单，用户输入昵称进入聊天室，进入聊天室后会向其他用户广播，用户可以看到聊天室的所有聊天记录和当前在线人数，支持@其他人，支持敏感词检测。</p><p>由于本项目也是基于书籍中的教程进行的开发，所以在此还是大概记录一下完成该项目学到的东西。</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>本项目最重要的组成之一，本项目便是基于 <code>WebSocket</code> 进行开发的。</p><p> <code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，用于在 <code>Web</code> 应用程序中创建实时、双向的通信通道。</p><p>传统的 <code>HTTP</code> 请求通常是一次请求、一次相应，而 <code>WebSocket</code> 则可以建立一个持久连接，允许服务器即时向客户端推送数据，同时也可以接受客户端发送的数据。 <code>WebSocket</code> 相比于传统的轮询或长轮询方式，能够显著减少网络流量和延迟，提高数据传输的效率和速度。它对实时 <code>Web</code> 应用程序和在线游戏的开发非常有用。</p><p> <code>WebSocket</code> 可以在浏览器和服务器之间建立一条<strong>双向通信</strong>的通道，实现服务器主动向浏览器推送消息，而无需浏览器向服务器不断发送请求。其原理是在浏览器和服务器之间建立一个 “套接字”，通过 “握手” 的方式进行数据传输。由于该协议需要浏览器和服务器都支持，因此需要在应用程序中对其进行判断和处理。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-2070.png" alt="WebSocket 是什么"></p><p>WebSocket 是 HTML5 开始推出的基于 TCP 协议的双向通信协议，其优势在于与 HTTP 协议兼容、开销小、通信高效。WebSocket 让客户端和服务器之间建立连接，并通过这个持久连接实时地进行双向数据传输。</p><p>其实 WebSocket 最主要的特点就是建立了一个可持久化的 TCP 连接，这个连接会一直保留，直到客户端或者服务器发起中断请求为止。WebSocket 通过 HTTP/1.1 协议中的 Upgrade 头信息来告诉服务器，希望协议从 HTTP/1.1 升级到 WebSocket 协议。</p><p>WebSocket 建立在 HTTP 协议之上，所有的 WebSocket 请求都会通过普通的 HTTP 协议发送出去，然后在服务器端根据 HTTP 协议识别特定的头信息 Upgrade，服务端也会判断请求信息中 Upgrade 是否存在。 这里面 HTTP 是必不可少的，不然 WebSocket 根本无法建立。特别的，WebSocket 在握手时采用了 Sec-WebSocket-Key 加密处理，并采用 SHA-1 签名。</p><p>一旦建立了 WebSocket 连接，客户端和服务器端就可以互相发送二进制流或 Unicode 字符串。所有的数据都是经过 mask 处理过的，mask 的值是由服务器端随机生成的。在数据进行发送之前，必须先进行 mask 处理，这样可以有效防止数据被第三方恶意篡改。</p><p>最后需要说明一下的是，WebSocket 的通信协议是基于帧（数据包）的。在数据发送时，一个完整的数据包可以分为多个帧进行发送，而每一个帧都包含了数据的一部分，同时还包含了帧头信息。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="WebSocket-和-HTTP"><a href="#WebSocket-和-HTTP" class="headerlink" title="WebSocket 和 HTTP"></a>WebSocket 和 HTTP</h3><p><code>HTTP</code> 是一个无状态的协议，使客户端向服务器请求资源，并从服务器接受响应。客户端使用 HTTP 请求/响应语法，即请求发送到服务器之后，服务器向客户端返回 HTML 文件、图像和其他媒体内容。</p><p>WebSocket 通信协议尝试在较大范围内改进 Web 实时通信和插件技术，并提供<strong>全双工</strong>、<strong>基于事件</strong>的通信而无需采用低效的轮询方式。开发人员可以从 Web 浏览器的 JS 端轻松地创建 WebSocket 连接并发送数据，进而实现应用程序的实时数据传输的实现。</p><p>由于 WebSocket 是面向消息的，因此它更加适用于实时通信，而 HTTP 更适用于请求和服务器-客户端通信的响应。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/blog_05_11_17_01.png" alt="img"></p><h4 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a><strong>区别总结</strong></h4><ul><li><strong>连接方式不同：</strong> HTTP 是一种单向请求-响应协议，每次请求需要重新建立连接，而 WebSocket 是一种双向通信协议，使用长连接实现数据实时推送。</li><li><strong>数据传输方式不同：</strong> HTTP 协议中的数据传输是文本格式的，而 WebSocket 可以传输文本和二进制数据。</li><li><strong>通信类型不同：</strong> HTTP 主要用于客户端和服务器之间的请求和响应，如浏览器请求网页和服务器返回网页的 HTML 文件。WebSocket 可以实现双向通信，常常用于实时通信场景。</li><li><strong>性能方面不同：</strong> 由于 HTTP 的每次请求都需要建立连接和断开连接，而 WebSocket 可以在一次连接上进行多次通信，WebSocket 在性能上比 HTTP 有优势。</li></ul><h3 id="WebSocket-和-TCP"><a href="#WebSocket-和-TCP" class="headerlink" title="WebSocket 和 TCP"></a>WebSocket 和 TCP</h3><p>WebSocket 和 HTTP 都是基于 TCP 协议的应用层协议。</p><ul><li><strong>层次结构：</strong> WebSocket 是应用层协议，而 TCP 是传输层协议。</li><li><strong>协议特点：</strong> TCP 是一种面向连接的协议，使用三次握手建立连接，提供可靠的数据传输。而 WebSocket 是一种无状态的协议，使用 HTTP 协议建立连接，可以进行双向通信，WebSocket 的数据传输比 TCP 更加轻量级。</li><li><strong>数据格式：</strong> TCP 传输的数据需要自定义数据格式，而 WebSocket 可以支持多种数据格式，如 JSON、XML、二进制等。WebSocket 数据格式化可以更好的支持 Web 应用开发。</li></ul><p><strong>连接方式：</strong> TCP 连接的是物理地址和端口号，而 WebSocket 连接的是 URL 地址和端口号。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-2278.png" alt="img"></p><h3 id="WebSocket-和-Socket"><a href="#WebSocket-和-Socket" class="headerlink" title="WebSocket 和 Socket"></a>WebSocket 和 Socket</h3><h4 id="协议不同"><a href="#协议不同" class="headerlink" title="协议不同"></a><strong>协议不同</strong></h4><p>Socket 是基于传输层 TCP 协议的，而 Websocket 是基于 HTTP 协议的。Socket 通信是通过 Socket 套接字来实现的，而 Websocket 通信是通过 HTTP 的握手过程实现的。</p><h4 id="持久化连接"><a href="#持久化连接" class="headerlink" title="持久化连接"></a><strong>持久化连接</strong></h4><p>传统的 Socket 通信是基于短连接的，通信完成后即断开连接。而 Websocket 将 HTTP 协议升级后，实现了长连接，即建立连接后可以持续通信，避免了客户端与服务端频繁连接和断开连接的过程。</p><h4 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a><strong>双向通信</strong></h4><p>传统的 Socket 通信只支持单向通信，即客户端向服务端发送请求，服务端进行响应。而 Websocket 可以实现双向通信，即客户端和服务端都可以发起消息，实时通信效果更佳。</p><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a><strong>效率</strong></h4><p>Socket 通信具有高效性和实时性，因为传输数据时没有 HTTP 协议的头信息，而 Websocket 除了HTTP协议头之外，还需要发送额外的数据，因此通信效率相对较低。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><p>Socket 适用于实时传输数据，例如在线游戏、聊天室等需要快速交换数据的场景。而 Websocket 适用于需要长时间保持连接的场景，例如在线音视频、远程控制等。</p><h1 id="基础代码框架"><a href="#基础代码框架" class="headerlink" title="基础代码框架"></a>基础代码框架</h1><p>在基本了解 <code>WebSocket</code> 之后，尝试去使用 TCP 和 WebSocket 分别来写一个简单的聊天室。具体代码就不在这里赘述了，可以去下面的参考文献中找一下。</p><p>OK，在基本学习了如何使用 WebSocket 来完成一个聊天室的设计之后，我们来正式开启项目的设计。基础框架和流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/chatroom-design.png" alt="image"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── chatroom</span><br><span class="line">│       └── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── logic</span><br><span class="line">│   ├── broadcast.go</span><br><span class="line">│   ├── message.go</span><br><span class="line">│   └── user.go</span><br><span class="line">├── server</span><br><span class="line">│   ├── handle.go</span><br><span class="line">│   ├── home.go</span><br><span class="line">│   └── websocket.go</span><br><span class="line">└── template</span><br><span class="line">    └── home.html</span><br></pre></td></tr></table></figure><p>相关目录说明如下：</p><ul><li>cmd：该目录几乎是 Go 圈约定俗成的，Go 官方以及开源界推荐的方式，用于存放 main.main；</li><li>logic：用于存放项目核心业务逻辑代码，和 service 目录是类似的作用；</li><li>server：存放 server 相关代码，虽然这是 WebSocket 项目，但也可以看成是 Web 项目，因此可以理解成存放类似 controller 的代码；</li><li>template：存放静态模板文件；</li></ul><h2 id="四个类型"><a href="#四个类型" class="headerlink" title="四个类型"></a>四个类型</h2><p>User：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">UID            <span class="type">int</span>           <span class="string">`json:&quot;uid&quot;`</span></span><br><span class="line">NickName       <span class="type">string</span>        <span class="string">`json:&quot;nickname&quot;`</span></span><br><span class="line">EnterAt        time.Time     <span class="string">`json:&quot;enter_at&quot;`</span></span><br><span class="line">Addr           <span class="type">string</span>        <span class="string">`json:&quot;addr&quot;`</span></span><br><span class="line">MessageChannel <span class="keyword">chan</span> *Message <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">Token          <span class="type">string</span>        <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line"></span><br><span class="line">conn *websocket.Conn</span><br><span class="line"></span><br><span class="line">isNew <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>broadcaster：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcaster 广播器</span></span><br><span class="line"><span class="keyword">type</span> broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 所有聊天室用户</span></span><br><span class="line">users <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 channel 统一管理，可以避免外部乱用</span></span><br><span class="line"></span><br><span class="line">enteringChannel <span class="keyword">chan</span> *User</span><br><span class="line">leavingChannel  <span class="keyword">chan</span> *User</span><br><span class="line">messageChannel  <span class="keyword">chan</span> *Message</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该昵称用户是否可进入聊天室（重复与否）：true 能，false 不能</span></span><br><span class="line">checkUserChannel      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">checkUserCanInChannel <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户列表</span></span><br><span class="line">requestUsersChannel <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">usersChannel        <span class="keyword">chan</span> []*User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给用户发送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 哪个用户发送的消息</span></span><br><span class="line">User    *User     <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">Type    <span class="type">int</span>       <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">Content <span class="type">string</span>    <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">MsgTime time.Time <span class="string">`json:&quot;msg_time&quot;`</span></span><br><span class="line"></span><br><span class="line">ClientSendTime time.Time <span class="string">`json:&quot;client_send_time&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息 @ 了谁</span></span><br><span class="line">Ats []<span class="type">string</span> <span class="string">`json:&quot;ats&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>offlineProcessor：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> offlineProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存所有用户最近的 n 条消息</span></span><br><span class="line">recentRing *ring.Ring</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存某个用户离线消息（一样 n 条）</span></span><br><span class="line">userRing <span class="keyword">map</span>[<span class="type">string</span>]*ring.Ring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>本项目的核心流程分为两个部分，一个是前端的设计，另一个是后端的 API 开发。有关前端的部分我想可能还得一段时间才会去学习，所以这一部分就只写后端的内容。</p><h2 id="新用户来了"><a href="#新用户来了" class="headerlink" title="新用户来了"></a>新用户来了</h2><p>由于在第二个项目中已经把注册登录功能实现的很好了，所以在本聊天室中并未设置注册登录功能，为了方便识别用户，我们简单地要求用户输入昵称。</p><p>昵称在建立 WebSocket 连接时，通过 HTTP 协议传递，因此可以通过 http.Request 获取到。虽然没有注册功能，但依然要解决昵称重复的问题。这里必须引出 Broadcaster 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 所有聊天室用户</span></span><br><span class="line">users <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 channel 统一管理，可以避免外部乱用</span></span><br><span class="line"></span><br><span class="line">enteringChannel <span class="keyword">chan</span> *User</span><br><span class="line">leavingChannel  <span class="keyword">chan</span> *User</span><br><span class="line">messageChannel  <span class="keyword">chan</span> *Message</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该昵称用户是否可进入聊天室（重复与否）：true 能，false 不能</span></span><br><span class="line">checkUserChannel      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">checkUserCanInChannel <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Broadcaster.Broadcast() 在一个单独的 goroutine 中运行，按照 Go 语言的原则，应该通过通信来共享内存。因此，我们定义了 5 个 channel，用于和其他 goroutine 进行通信。</p><ul><li>enteringChannel：用户进入聊天室时，通过该 channel 告知 Broadcaster，即将该用户加入 Broadcaster 的 users 中；</li><li>leavingChannel：用户离开聊天室时，通过该 channel 告知 Broadcaster，即将该用户从 Broadcaster 的 users 中删除，同时需要关闭该用户对应的 messageChannel，避免 goroutine 泄露，后文会讲到；</li><li>messageChannel：用户发送的消息，通过该 channel 告知 Broadcaster，之后 Broadcaster 将它发送给 users 中的用户；</li><li>checkUserChannel：用来接收用户昵称，方便 Broadcaster 所在 goroutine 能够无锁判断昵称是否存在；</li><li>checkUserCanInChannel：用来回传该用户昵称是否已经存在；</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/user-exists-goroutine.png" alt="image"></p><p>两个 goroutine 通过两个 channel 进行通讯，因为 conn goroutine（代表用户连接 goroutine）可能很多，通过这种方式，避免了使用锁。</p><p>如果用户已存在，连接会断开；否则创建该用户的实例（新建 <code>User</code> 类型）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := logic.NewUser(conn, nickname, req.RemoteAddr)</span><br></pre></td></tr></table></figure><p>至此，用户算是进入了聊天室，新用户进入，一方面给 TA 发送欢迎的消息，另一方面需要通知聊天室的其他人，有新用户进来了（新建 <code>Message</code> 类型）。</p><p>接下来看看发送消息的过程，发送消息分两情况，它们的处理方式有些差异：</p><ul><li>给单个用户（当前）用户发送消息</li><li>给聊天室其他用户广播消息</li></ul><p>给当前用户发送消息的情况比较简单：conn goroutine 通过用户实例（User）的字段 MessageChannel 将 Message 发送给 write goroutine。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/send-message-single.png" alt="image"></p><p>给聊天室其他用户广播消息自然需要通过 broadcaster goroutine 来实现：conn goroutine 通过 Broadcaster 的 MessageChannel 将 Message 发送出去，broadcaster goroutine 遍历自己维护的聊天室用户列表，通过 User 实例的 MessageChannel 将消息发送给 write goroutine。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/send-message-broadcast.png" alt="image"></p><h2 id="用户走了"><a href="#用户走了" class="headerlink" title="用户走了"></a>用户走了</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 用户离开</span></span><br><span class="line">logic.Broadcaster.UserLeaving(user)</span><br><span class="line">msg = logic.NewNoticeMessage(user.NickName + <span class="string">&quot; 离开了聊天室&quot;</span>)</span><br><span class="line">logic.Broadcaster.Broadcast(msg)</span><br><span class="line">log.Println(<span class="string">&quot;user:&quot;</span>, nickname, <span class="string">&quot;leaves chat&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据读取时的错误执行不同的 Close</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  conn.Close(websocket.StatusNormalClosure, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  log.Println(<span class="string">&quot;read from client error:&quot;</span>, err)</span><br><span class="line">  conn.Close(websocket.StatusTryAgainLater, <span class="string">&quot;Read from client error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了三件事情：</p><ul><li>在 Broadcaster 中注销该用户；</li><li>给聊天室中其他还在线的用户发送通知，告知该用户已离开；</li><li>根据 err 处理不同的 Close 行为。关于 Close 的 Status 可以参考 rfc6455 的 第 7.4 节；</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>Go 不是完全面向对象的语言，只支持部分面向对象的特性。面向对象中的单例模式是一个常见、简单的模式。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该模式规定一个类只允许有一个实例，而且自行实例化并向整个系统提供这个实例。因此单例模式的要点有：</p><ol><li>只有一个实例；</li><li>必须自行创建；</li><li>必须自行向整个系统提供这个实例。</li></ol><p>单例模式主要避免一个全局使用的类频繁地创建与销毁。当你想控制实例的数量，或有时候不允许存在多实例时，单例模式就派上用场了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/singleton.png" alt="image"></p><p>通过该类图我们可以看出，实现一个单例模式有如下要求：</p><ul><li>私有、静态的类实例变量；</li><li>构造函数私有化；</li><li>静态工厂方法，返回此类的唯一实例；</li></ul><p>根据实例化的时机，单例模式一般分成饿汉式和懒汉式。</p><ul><li>饿汉式：在定义 instance 时直接实例化，private static Singleton instance = new Singleton();</li><li>懒汉式：在 getInstance 方法中进行实例化；</li></ul><p>那两者有什么区别或优缺点？</p><ul><li>饿汉式单例类在自己被加载时就将自己实例化。即便加载器是静态的，饿汉式单例类被加载时仍会将自己实例化。单从资源利用率角度讲，这个比懒汉式单例类稍差些。从速度和反应时间角度讲，则比懒汉式单例类稍好些。</li><li>然而，懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器在实例化时必须涉及资源初始化，而资源初始化很有可能耗费时间。这意味着出现多线程同时首次引用此类的几率变得较大。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Instance = <span class="built_in">new</span>(singleton)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> Add() <span class="type">int</span> &#123;</span><br><span class="line">  s.count++</span><br><span class="line">  <span class="keyword">return</span> s.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line">c := singleton.Instance.Add()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  instance *singleton</span><br><span class="line">  mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">  mutex.Lock()</span><br><span class="line">  <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">    instance = <span class="built_in">new</span>(singleton)</span><br><span class="line">  &#125;</span><br><span class="line">  mutex.Unlock()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> Add() <span class="type">int</span> &#123;</span><br><span class="line">  s.count++</span><br><span class="line">  <span class="keyword">return</span> s.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><p>单例模式同时解决了两个问题， 所以违反了<strong>单一职责原则</strong>：</p><ol><li><p><strong>保证一个类只有一个实例</strong>。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p><p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p><p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/singleton-comic-1-zh.png" alt="一个对象的全局访问节点"></p><ol><li><p><strong>为该实例提供一个全局访问节点</strong>。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p><p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p><p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p></li></ol><h1 id="goroutine-泄露"><a href="#goroutine-泄露" class="headerlink" title="goroutine 泄露"></a>goroutine 泄露</h1><p>在 Go 中，goroutine 的创建成本低廉且调度效率高。Go 运行时能很好的支持具有成千上万个 goroutine 的程序运行，数十万个也并不意外。但是，goroutine 在内存占用方面却需要谨慎，内存资源是有限的，因此你不能创建无限的 goroutine。</p><p>每当你在程序中使用 go 关键字启动 goroutine 时，你必须知道该 goroutine 将在何时何地退出。如果你不知道答案，那可能会内存泄漏。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>造成goroutine泄露的几个原因：</p><ul><li><ol><li>从 channel 里读，但是同时没有写入操作</li></ol></li><li><ol><li>向 无缓冲 channel 里写，但是同时没有读操作</li></ol></li><li><ol><li>向已满的 有缓冲 channel 里写，但是同时没有读操作</li></ol></li><li><ol><li>select操作在所有case上都阻塞()</li></ol></li><li><ol><li>goroutine进入死循环，一直结束不了</li></ol></li></ul><p>可见，很多都是因为channel使用不当造成阻塞，从而导致goroutine也一直阻塞无法退出导致的。</p><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><h3 id="生产者消费者场景"><a href="#生产者消费者场景" class="headerlink" title="生产者消费者场景"></a>生产者消费者场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;newRandStream closure exited.&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"><span class="comment">// 死循环：不断向channel中放数据，直到阻塞</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">randStream &lt;- rand.Int()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">randStream := newRandStream()</span><br><span class="line">fmt.Println(<span class="string">&quot;3 random ints:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只消耗3个数据，然后去做其他的事情，此时生产者阻塞，</span></span><br><span class="line"><span class="comment">// 若主goroutine不处理生产者goroutine，则就产生了泄露</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %d\n&quot;</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产协程进入死循环，不断产生数据。消费协程，也就是主协程只消费期中的 3 个值，然后主协程就再也不消费 <code>channel</code> 中的数据，去做其他事情了。此时生产协程放了一个数据到 <code>channel</code> 中，但已经不会有协程消费该数据，所以生产协程阻塞。此时，若没有人再消费 <code>channel</code> 中的数据，生产协程是被泄露的协程</p><p><strong>解决方法：</strong></p><p>总的来说，要解决channel引起的goroutine leak问题，主要是看在channel阻塞goroutine时，该goroutine的阻塞是正常的，还是可能导致协程永远没有机会执行。若可能导致协程永远没有机会执行，则可能会导致协程泄露。 所以，在创建协程时就要考虑到它该如何终止。</p><p>解决一般问题的办法就是，当主线程结束时，告知生产线程，生产线程得到通知后，进行清理工作：或退出，或做一些清理环境的工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;newRandStream closure exited.&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> randStream &lt;- rand.Int():</span><br><span class="line"><span class="keyword">case</span> &lt;-done:  <span class="comment">// 得到通知，结束自己</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">randStream := newRandStream(done)</span><br><span class="line">fmt.Println(<span class="string">&quot;3 random ints:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %d\n&quot;</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知子协程结束自己</span></span><br><span class="line">    <span class="comment">// done &lt;- struct&#123;&#125;&#123;&#125;</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line"><span class="comment">// Simulate ongoing work</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，协程通过一个channel来得到结束的通知，这样它就可以清理现场。防止协程泄露。 通知协程结束的方式，可以是发送一个空的struct，更加简单的方式是直接close channel。如上图所示。</p><h3 id="master-work-场景"><a href="#master-work-场景" class="headerlink" title="master work 场景"></a>master work 场景</h3><p>在该场景下，我们一般是把工作划分成多个子工作，把每个子工作交给每个goroutine来完成。此时若处理不当，也是有可能发生goroutine泄漏的。我们来看一下实际的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function to add an array of numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker_adder</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// writes the sum to the go routines.</span></span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// spin up a goroutine.</span></span><br><span class="line"><span class="keyword">go</span> worker_adder(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c1)</span><br><span class="line"><span class="comment">// spin up a goroutine.</span></span><br><span class="line"><span class="keyword">go</span> worker_adder(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//x, y := &lt;-c1, &lt;-c2 // receive from c1 aND C2</span></span><br><span class="line">x, _:= &lt;-c1</span><br><span class="line"><span class="comment">// 输出从channel获取到的值</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在主协程中，把一个数组分成两个部分，分别交给两个worker协程来计算其值，这两个协程通过channel把结果传回给主协程。 但，在以上代码中，我们只接收了一个channel的数据，导致另一个协程在写channel时阻塞，再也没有执行的机会。 要是我们把这段代码放入一个常驻服务中，看的更加明显：</p><h3 id="http-server-场景"><a href="#http-server-场景" class="headerlink" title="http server 场景"></a>http server 场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数组s中的数字加起来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumInt</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP handler for /sum</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumConcurrent2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sumInt(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c1)</span><br><span class="line"><span class="keyword">go</span> sumInt(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里故意不在c2中读取数据，导致向c2写数据的协程阻塞。</span></span><br><span class="line">x := &lt;-c1</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the response.</span></span><br><span class="line">fmt.Fprintf(w, strconv.Itoa(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">StasticGroutine := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">total := runtime.NumGoroutine()</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> StasticGroutine()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/sum&quot;</span>, sumConcurrent2)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:8001&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行以上程序，并在浏览器中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8001/sum</span><br></pre></td></tr></table></figure><p>并不断刷新浏览器，来不断发送请求，可以看到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>这个输出是我们的http server的协程数量，可以看到：每请求一次，协程数就增加一个，而且不会减少。说明已经发生了协程泄露(goroutine leak)。</p><p><strong>解决方法：</strong></p><p>解决的办法就是不管在任何情况下，都必须要有协程能够读写channel，让协程不会阻塞。 </p><h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMessage</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle `s`</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Minute):</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在标准库 time.After 的文档中有一段说明：</p><blockquote><p>等待持续时间过去，然后在返回的 channel 上发送当前时间。它等效于 NewTimer().C。在计时器触发之前，计时器不会被垃圾收集器回收。</p></blockquote><p>所以，如果还没有到 5 分钟，该函数返回了，计时器就不会被 GC 回收，因此出现了内存泄露。因此大家使用 time.After 时一定要仔细，一般建议不用它，而是使用 time.NewTimer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMessage</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">idleDuration := <span class="number">5</span> * time.Minute</span><br><span class="line">idleDelay := time.NewTimer(idleDuration)</span><br><span class="line">  <span class="comment">// 这句必须的</span></span><br><span class="line"><span class="keyword">defer</span> idleDelay.Stop()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">idleDelay.Reset(idleDuration)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle `s`</span></span><br><span class="line"><span class="keyword">case</span> &lt;-idleDelay.C:</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="敏感词处理"><a href="#敏感词处理" class="headerlink" title="敏感词处理"></a>敏感词处理</h1><p>任何由用户产生内容的公开软件，都必须做好敏感词的处理。作为一个聊天室，当然要处理敏感词。</p><p>其实敏感词（包括广告）检测一直以来都是让人头疼的话题，很多大厂，比如微信、微博、头条等，每天产生大量内容，它们在处理敏感词这块，会投入很多资源。所以，这不是一个简单的问题，本书不可能深入探讨，但尽可能多涉及一些相关内容。</p><p>一般来说，目前敏感词处理有如下方法：</p><ul><li>简单替换或正则替换</li><li>DFA（Deterministic Finite Automaton，确定性有穷自动机算法）</li><li>基于朴素贝叶斯分类算法</li></ul><h2 id="简单替换或正则替换"><a href="#简单替换或正则替换" class="headerlink" title="简单替换或正则替换"></a>简单替换或正则替换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. strings.Replace</span></span><br><span class="line">keywords := []<span class="type">string</span>&#123;<span class="string">&quot;坏蛋&quot;</span>, <span class="string">&quot;坏人&quot;</span>, <span class="string">&quot;发票&quot;</span>, <span class="string">&quot;傻子&quot;</span>, <span class="string">&quot;傻大个&quot;</span>, <span class="string">&quot;傻人&quot;</span>&#125;</span><br><span class="line">content := <span class="string">&quot;不要发票，你就是一个傻子，只会发呆&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, keyword := <span class="keyword">range</span> keywords &#123;</span><br><span class="line">  content = strings.ReplaceAll(content, keyword, <span class="string">&quot;**&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. strings.Replacer</span></span><br><span class="line">replacer := strings.NewReplacer(<span class="string">&quot;坏蛋&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;坏人&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;发票&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻子&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻大个&quot;</span>, <span class="string">&quot;**&quot;</span>, <span class="string">&quot;傻人&quot;</span>, <span class="string">&quot;**&quot;</span>)</span><br><span class="line">fmt.Println(replacer.Replace(<span class="string">&quot;不要发票，你就是一个傻子，只会发呆&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: 不要**，你就是一个**，只会发呆</span></span><br></pre></td></tr></table></figure><p>类似于上面的代码（两种代码类似），我们会使用一个敏感词列表（坏蛋、发票、傻子、傻大个、傻人），来对目标字符串进行检测与替换。比较适合于敏感词列表和待检测目标字符串都比较小的场景，否则性能会有较大影响。（正则替换和这个是类似的）</p><h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>DFA全称为：Deterministic Finite Automaton,即确定有穷自动机。其特征为：有一个有限状态集合和一些从一个状态通向另一个状态的边，每条边上标记有一个符号，其中一个状态是初态，某些状态是终态。但不同于不确定的有限自动机，DFA中不会有从同一状态出发的两条边标志有相同的符号。</p><p>敏感词过滤很适合用DFA算法，用户每次输入都是状态的切换，如果出现敏感词，既是终态，就可以结束判断。</p><p>我们把数组形式的敏感词整理为一个树状结构，准确的说是一个森林。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sensitive-tree.png" alt="image"></p><p>这样查找敏感词就变成了一个查找路径的问题，如果用户输入的内容中包含一个从根节点到叶子节点的完整路径，就说明包含敏感词。</p><p>算法实现逻辑是循环用户输入的字符串，依次查找每个字符是否出现在树的节点上，比如用户输入“你是傻大个”，从第一个字开始判断，“你”不在树的根节点上，进入下一步，“是”也不在根节点上，进入下一步，“傻”出现在了根节点上，这时状态切换，下一步的查找范围变为“傻”的子节点；“大”出现在子节点中，状态再次切换为“大”的子节点；“个”出现在子节点中，并且为叶子节点，所以包含敏感词。</p><h2 id="基于朴素贝叶斯分类算法"><a href="#基于朴素贝叶斯分类算法" class="headerlink" title="基于朴素贝叶斯分类算法"></a>基于朴素贝叶斯分类算法</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。这是一种“半学习”形式的方法，它的准确性依赖于先验概率的准确性。</p><p><strong>敏感词检测步骤：</strong></p><ol><li>分词：对获取的评论进行分词处理，采用的是jieba分词</li><li>去除无意义词：采用的是哈工大的词表，遍历每一条评论，判断是否在无用词表（这里主要包含特殊字符，标点符号，感叹词等）中，从而达到去除无意词的效果</li><li>通过评论建立自己的词库，采用并集处理，达到词库中词的唯一性</li><li>建立向量：将去除无意词后的评论装换成稀疏矩阵，采用的是多项式模型，这里考虑到评论一般都比较短小，相对来说，几乎每一个词都会影响到最终的判断，所以采用多项式模型，而没有采用伯努利模型</li><li>划分训练集和测试集：采用random.shuffle()函数将数据随机排序，然后再通过切片处理划分数据，为了保证每条评论与其对应的标签保持一致，采用zip()函数将评论和标签绑定在一起</li><li>调用sklearn里面内置的贝叶斯算法接口</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里本项目也已经基本完成了，就行文章开始写的那样，这并不是一片详细的教程，只是用来记录一下完成这个项目所学到的东西。</p><p>总的来说，这个项目的教程写的也不是很详细，很多函数的实现还是要自己去完成，但是核心的内容作者都会很详细地解释，而且重要的内容其实都可以搜到。</p><p>现在我知道为什么这个项目是基于 TCP，而不是 UDP 的了。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>WebSocket：</p><ul><li><a href="https://apifox.com/apiskills/what-is-websocket/">https://apifox.com/apiskills/what-is-websocket/</a></li><li><a href="https://apifox.com/apiskills/websocket-socket-tcp-http/">https://apifox.com/apiskills/websocket-socket-tcp-http/</a></li><li><a href="https://xie.infoq.cn/article/1b9128d59e2538604e441bc53">https://xie.infoq.cn/article/1b9128d59e2538604e441bc53</a></li></ul><p>单例模式：</p><ul><li><a href="https://refactoringguru.cn/design-patterns/singleton">https://refactoringguru.cn/design-patterns/singleton</a></li></ul><p>goroutine 泄露：</p><ul><li><a href="https://hoverzheng.github.io/post/technology-blog/go/goroutine-leak%E5%92%8C%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/">https://hoverzheng.github.io/post/technology-blog/go/goroutine-leak%E5%92%8C%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/</a></li><li><a href="https://segmentfault.com/a/1190000040161853">https://segmentfault.com/a/1190000040161853</a></li></ul><p>敏感词检测：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/505941559">https://zhuanlan.zhihu.com/p/505941559</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次真成全栈工程师了。第三个 Go 语言项目，简单地实现了一个基于 TCP 连接的聊天室。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-2024042512</summary>
      
    
    
    
    <category term="聊天室" scheme="http://example.com/categories/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub——日志</title>
    <link href="http://example.com/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2024/04/18/Gohub%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-18T14:50:36.000Z</published>
    <updated>2024-04-20T15:32:58.411Z</updated>
    
    <content type="html"><![CDATA[<p>正经人谁写日记啊？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image" alt="img"></p><p>欸欸欸，不好意思，来错片场了（手动狗头）。今天介绍的是项目中必不可少的一部分——日志。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>虽然正经人不写日记，但是正经项目一定要记录日志。总所周知啊，Gohub 就是一个非常正经的项目，虽然还没有到企业级这么高的层次，但是也差不多了。</p><p>在 Gohub 中，我们使用日志来记录整个系统的运行情况，可能但不限于：</p><ul><li>HTTP 请求数据</li><li>数据库 SQL 请求日志</li><li>Panic/Error 错误日志</li><li>请求第三方接口日志（发送短信、发送邮件等）</li><li>……</li></ul><p>好了，是时候掏出祖传的几个问题了，什么是日志？该怎么设置日志？下面将会一一解答。</p><h2 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h2><p>日志系统是一种记录系统活动、事件或消息的工具或机制。在计算机领域，日志系统通常用于记录应用程序、操作系统或者其他软件系统的运行时信息。这些信息可以包括错误、警告、调试信息、用户操作记录等等。</p><p>日志系统的主要目的是帮助开发人员或管理员了解系统的状态和运行情况，以便进行故障排除、性能优化、安全审计等工作。通过分析日志，可以追踪问题的根源，监视系统的健康状况，并且可以在系统发生故障或异常时进行及时的响应和处理。</p><p>日志系统通常具有以下特点：</p><ol><li><strong>可配置性：</strong> 可以根据需求配置日志记录的级别、格式、存储位置等参数。</li><li><strong>实时性：</strong> 能够实时记录系统的运行状态，以便及时发现问题。</li><li><strong>可扩展性：</strong> 能够处理大量的日志数据，并支持水平扩展以应对不断增长的系统负载。</li><li><strong>安全性：</strong> 对日志数据进行安全存储和访问控制，以防止未经授权的访问或篡改。</li><li><strong>分析性：</strong> 提供日志分析工具或接口，帮助用户对日志数据进行搜索、过滤、统计、可视化等操作。</li></ol><p>常见的日志系统包括开源项目如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk、Fluentd等，以及云服务提供商提供的日志管理服务。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>本地开发</strong></p><p>本地开发时，虽然我们可以很方便地使用 Debuger 来调试程序，但是日志将会是我们最廉价】最便捷地作物定位工具。</p><p><strong>线上环境</strong></p><p>日志是程序在生产环境下的健康监控。当程序出错时，或者某块业务逻辑出现问题，我们将依赖日志来知道具体哪一行代码出了问题。</p><p><strong>如何记录？</strong></p><div class="table-container"><table><thead><tr><th>使用环境</th><th>记录的载体</th><th>说明</th></tr></thead><tbody><tr><td>开发环境（local）</td><td>命令行终端</td><td>高亮、打印调用堆栈</td></tr><tr><td>线上环境（production）</td><td>记录到日志文件</td><td>JSON 格式，方便导入专业的日志工具</td></tr></tbody></table></div><p>日志系统在计算机领域有广泛的使用场景，以下是一些常见的应用场景：</p><ol><li><p><strong>故障排查与调试：</strong> 当系统出现错误或异常时，日志可以记录错误信息、异常堆栈跟踪等，帮助开发人员快速定位并修复问题。</p></li><li><p><strong>性能优化：</strong> 通过分析系统的性能日志，可以了解系统各个组件的性能瓶颈，从而进行优化，提升系统整体性能。</p></li><li><p><strong>安全审计与监控：</strong> 日志记录系统的操作、访问权限、安全事件等信息，有助于进行安全审计和监控，及时发现潜在的安全威胁。</p></li><li><p><strong>用户行为分析：</strong> 在网络应用或移动应用中，记录用户的操作行为可以帮助分析用户偏好、行为趋势，从而进行个性化推荐、用户体验优化等工作。</p></li><li><p><strong>合规性需求：</strong> 许多行业或政府监管机构要求企业记录和保留特定类型的数据，日志系统可以满足这些合规性需求，并提供必要的审计跟踪。</p></li><li><p><strong>容灾备份与恢复：</strong> 日志记录系统的备份和恢复功能可以帮助恢复因硬件故障、自然灾害或人为错误导致的数据丢失或损坏。</p></li><li><p><strong>业务分析与决策支持：</strong> 通过分析系统产生的日志数据，可以了解业务运营情况、用户行为趋势等，为业务决策提供数据支持。</p></li><li><p><strong>监控与警报：</strong> 基于日志数据设定监控规则，当系统出现异常或达到预定的阈值时，触发警报并通知相关人员进行处理。</p></li></ol><p>这些场景只是日志系统的一部分应用，实际上日志系统在各个领域都有着重要的作用，帮助保障系统的稳定性、安全性和可靠性。</p><h2 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h2><p>日志系统通常定义了不同的日志等级，用于标识和区分不同类型的日志信息，常见的日志等级包括：</p><div class="table-container"><table><thead><tr><th>日志等级</th><th>说明</th></tr></thead><tbody><tr><td><strong>debug</strong></td><td>信息量大，一般调试时打开。<strong>系统模块详细运行的日志</strong>，例如 HTTP 请求、数据库请求、发送邮件、发送短信</td></tr><tr><td><strong>info</strong></td><td><strong>业务级别的运行日志</strong>，如用户登录、用户退出、订单撤销。</td></tr><tr><td><strong>warn</strong></td><td><strong>感兴趣、需要引起关注的信息。</strong> 例如，调试时候打印调试信息（命令行输出会有高亮）。</td></tr><tr><td><strong>error</strong></td><td><strong>记录错误信息</strong>，用于记录程序发生的错误，这些错误可能导致程序无法正常工作，但不会使程序完全崩溃。Panic 或者 Error。如数据库连接错误、HTTP 端口被占用等。一般生产环境使用的等级。</td></tr></tbody></table></div><p><strong>日志等级规则：</strong></p><ul><li>日志等级在两个地方使用；<ul><li>配置信息（config）中可以配置日志等级；</li><li>代码中调用不同的方法（<code>Debug()</code>、<code>Info()</code>…）记录不同等级的日志。</li></ul></li><li>日志等级具备<strong>过滤信息</strong>的属性；</li><li>配置信息里设置为高等级时，低于这个等级的信息将忽略。如日志等级设为 <strong>warn</strong> ，只有 <code>Warn()</code> 和 <code>Error()</code> 方法记录的日志会有效，<code>Debug()</code> 和 <code>Info()</code> 方法记录的日志会被忽略；</li></ul><h2 id="日志过载"><a href="#日志过载" class="headerlink" title="日志过载"></a>日志过载</h2><p>日志过载是指日志系统产生的日志数量超出了处理能力或存储容量，导致系统无法有效地处理和存储所有的日志信息。这种情况可能会对系统的性能、稳定性和安全性造成负面影响。</p><p>日志过载可能出现在以下几种情况下：</p><ol><li><p><strong>异常情况爆发：</strong> 当系统遭遇大规模的异常或错误时，日志系统可能会产生大量的错误日志，导致日志系统过载。</p></li><li><p><strong>频繁的警告信息：</strong> 如果系统产生大量的警告信息，而这些警告信息又被记录在日志中，就会增加日志系统的负担。</p></li><li><p><strong>日志频率过高：</strong> 如果系统的日志频率过高，比如记录了过多的调试信息或者每个请求都生成了大量的日志记录，就会导致日志系统过载。</p></li><li><p><strong>存储容量不足：</strong> 如果日志系统的存储容量不足以存储所有的日志数据，就会导致部分日志被丢弃或被覆盖，从而丧失了一部分重要的信息。</p></li><li><p><strong>日志记录不当：</strong> 如果日志记录的内容过于冗长或者包含了大量的无关信息，会增加日志系统的负担，导致日志过载。</p></li></ol><p>日志过载可能会导致以下问题：</p><ul><li><strong>性能下降：</strong> 过多的日志记录会占用系统资源，降低系统的性能和响应速度。</li><li><strong>数据丢失：</strong> 如果日志系统无法处理所有的日志数据，部分重要的日志信息可能会被丢弃，导致问题的排查和分析变得困难。</li><li><strong>安全风险：</strong> 日志过载可能会导致系统无法及时记录和响应安全事件，增加系统遭受攻击的风险。</li></ul><p>为了避免日志过载，需要合理配置日志系统的参数，包括日志等级、存储策略、日志格式等，并定期清理和归档历史日志数据，确保日志系统能够有效地处理和存储日志信息。</p><p>记录日志的行为完全掌控在开发者手上。日志等级的错误使用，会导致<strong>日志信息过载</strong>，有违『快速定位问题』的设计初衷。</p><p>所以记录日志时，参与项目的开发者之间需要做好约定，或者说<strong>规范</strong>。</p><ul><li>功能模块的详细运行情况，使用 <code>Debug()</code> 方法，如 HTTP 请求日志、数据库 SQL 日志；</li><li>业务级别的运行日志，使用 <code>Info()</code>，如果信息量太大，例如说一个请求会记录十几条 <code>Info()</code> 日志，要改用 <code>Debug()</code>；</li><li>控制好记录日志的量，切勿滥用，滥用会导致日志信息过载；</li><li>开发调试时，使用 <code>Warn()</code> ，调试完成后记得删除调试信息；</li><li>保持 warn 及以上日志级别的干净；</li><li>线上环境开启 error 等级，接到错误反馈时，再开启 debug 进行调试，调试完成后重新设置为 error 等级，保持线上日志的干净；</li><li>系统运行出错，才能使用 <code>Error()</code> 记录，如数据库连接出错，或出现 500 错误。</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在开发 Go 项目时，我们的项目目录下经常会出现一些文件，例如编译文件、log 文件、编辑器配置文件、系统生成的一些文件，这些文件我们不希望提交到代码仓库中。</p><p>在任何当前工作的 Git 仓库中，每个文件都是这样的：</p><ul><li><strong>追踪的（tracked）</strong>- 这些是 Git 所知道的所有文件或目录。这些是新添加（用 <code>git add</code> 添加）和提交（用 <code>git commit</code> 提交）到主仓库的文件和目录。</li><li><strong>未被追踪的（untracked）</strong> - 这些是在工作目录中创建的，但还没有被暂存（或用 <code>git add</code> 命令添加）的任何新文件或目录。</li><li><strong>被忽略的（ignored）</strong> - 这些是 Git 知道的要全部排除、忽略或在 Git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 Git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。</li></ul><p>所有被忽略的文件都会被保存在一个 <code>.gitignore</code> 文件中。</p><p><code>.gitignore</code> 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。</p><p>在 <code>.gitignore</code> 中，可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。也可以用同样的方法告诉 Git 忽略多个文件或文件夹。</p><h2 id="配置信息的设置"><a href="#配置信息的设置" class="headerlink" title="配置信息的设置"></a>配置信息的设置</h2><p>在项目中，配置信息通常指的是一些参数、选项或设置，这些信息用于指导项目的行为、功能或外部依赖的配置。</p><p>Gohub 中的配置信息，将分为两个层级：</p><ul><li>env</li><li>config</li></ul><h3 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h3><p>一般来讲，项目会运行在多个环境下，例如：</p><ul><li>local —— 本地开发环境（我的机器上、其他开发同事的机器上）</li><li>testing —— 自动化测试环境</li><li>stage —— 接近线上环境的测试环境，方便其他成员访问和测试（编辑人员、产品经理、项目经理）</li><li>production —— 线上生产环境</li></ul><p>不同的环境下，我们将使用不同的配置。例如 local 环境里，发送短信使用的是测试账号，production 环境下，我们将使用验证了公司信息的发信账号。</p><p><code>.env</code> 文件通常用于存储环境变量和敏感配置信息，它的作用包括：</p><ol><li><strong>配置管理：</strong> <code>.env</code> 文件可以用来集中管理项目的配置信息，如数据库连接信息、API 密钥、密码、密钥等。将这些配置信息存储在 <code>.env</code> 文件中有助于统一管理，减少硬编码，提高项目的灵活性和可维护性。</li><li><strong>环境分离：</strong> 使用 <code>.env</code> 文件可以将不同环境（如开发环境、测试环境和生产环境）的配置信息分离开来，避免在代码中硬编码不同环境下的配置，提高代码的可移植性和可重用性。</li><li><strong>安全性：</strong> <code>.env</code> 文件通常位于项目根目录之外，并且可以通过 <code>.gitignore</code> 文件排除在版本控制系统中，从而保护敏感信息不被泄露到公共代码仓库中，提高项目的安全性。</li><li><strong>便捷性：</strong> 通过 <code>.env</code> 文件，可以方便地修改和管理项目的配置信息，无需修改源代码，减少了部署和维护的复杂性。</li><li><strong>跨平台兼容性：</strong> <code>.env</code> 文件的格式通常是简单的键值对格式，易于解析和处理，可以跨多种编程语言和操作系统使用。</li></ol><hr><p>单独的 .env 的设计，是满足一台机器一套环境变量的需求。<strong>多个 .env 文件是满足一台机器上运行多套环境变量的需求</strong>。</p><p>开发时，除了 local 环境变量，很多时候还需要 testing 测试相关的环境变量，testing 的配置有别于 local 。例如测试时，一般需要使用不同的数据库，这样才能不污染我们的开发数据库。</p><p>我们可以利用程序参数，在命令行运行主程序时，传参 <code>--env=testing</code> 的参数，程序接收到这个参数后会读取 <strong>.env.testing</strong> 文件，而不是 <code>.env</code> 文件。</p><p><code>--env</code> 的参数不需要限制值，取到以后直接读取对应的文件即可。以下是几个例子：</p><ul><li><code>--env=testing</code> 读取 <strong>.env.testing</strong> 文件，用以在测试环境使用不同的数据库</li><li><code>--env=production</code> 读取 <strong>.env.production</strong> 文件，用以在本地环境中调试线上的第三方服务配置信息（短信、邮件）</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 是将配置信息存放于 config 目录下，按照单独的逻辑区分单独的配置文件，例如数据库连接信息存放于 config/database.go 文件下。</p><p>config 里加载 .env 里的配置项，且可设置缺省值。</p><p><strong>既然有 .env 文件，为何还要 config 呢？</strong></p><p>config 可以提高配置方案灵活度。在 config 里，我们可以为每个配置项设置默认值。也可以做一些简单的数学运算，或者调用 Go 函数进行默认值的处理。我们甚至可以为配置项设置一个回调函数。</p><p>config 文件是要加入代码版本控制器中的，这些代码是固定的。如果要修改一个 config 配置项，就修改其对应的 .env 文件中的配置项即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文较短，主要记录了在 Gohub 开发设计日志时学到的相关的知识。其实在这个项目中用户使用的功能并没有什么太大的变化，即使增加了一些功能也都只是一种变式，核心并没有发生太大的变化，因此也就没有像之前一样逐个功能地去记录。那为什么还要去做新的项目呢，主要是因为舍友吧两个教程都买了，白嫖完了第一个肯定要继续白嫖第二个了。</p><p>做完第二个项目发现虽然一个叫 Gohub，一个叫 Goblog，两个看起来好像一样，但是实际开发地体验简直就是天上地下。Goblog 入门项目开发，学习怎么搭建 Web 应用；Gohub 才是真正的后端开发，更加专业，也让我学到了更多的东西。后悔啊，为什么上学期开始学 Go 的时候不好好写项目呢，要不然面试的时候也不会被拷打的那么惨了。不过这两个月确实还是学到了不少东西，比前两年半（没有玩梗，非常认真）加一起的都多了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>传统艺能了，每篇文章都像一个模子里刻出来的，不过本文并没有参考什么文章，只参考了教程和 ChatGPT的回答。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正经人谁写日记啊？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image&quot; alt=</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub——注册</title>
    <link href="http://example.com/2024/04/16/Gohub%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/"/>
    <id>http://example.com/2024/04/16/Gohub%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/</id>
    <published>2024-04-16T07:18:28.000Z</published>
    <updated>2024-04-18T15:00:18.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍新项目中第一部分的内容——身份验证接口的设计思路。</p><p>身份验证接口主要包括以下模块：</p><ul><li>注册</li><li>登录</li><li>找回密码</li></ul><p>基本流程为：</p><ol><li>填写手机号或者邮箱</li><li>填写图片验证码中的内容</li><li>填写数字验证码以完成身份验证</li><li>操作完成</li></ol><h1 id="双重验证"><a href="#双重验证" class="headerlink" title="双重验证"></a>双重验证</h1><p>在调用接口时，用户需要完成图片验证码 + 短信验证码，我们在日常使用相关的功能时也是采用这样的双重验证的策略。那我们为什么要用这么繁琐的验证方式呢？在了解为什么之前，我们先来看以下这两种验证码的作用。</p><ul><li>图片验证码 —— 区分机器人和正常用户</li><li>数字验证码——区分用户是否为手机号或邮箱的主人</li></ul><p>采用双重验证，主要还是考虑到开放注册登录接口所带来的安全隐患。在知道了这两种验证码的作用后，我们来看缺少了其中一种会带来什么样的安全隐患。</p><p>黑客容易利用的地方，大致可以分为两部分：</p><ul><li>滥用</li><li>暴力破解</li></ul><h2 id="滥用-轰炸机"><a href="#滥用-轰炸机" class="headerlink" title="滥用(轰炸机)"></a>滥用(轰炸机)</h2><p>删除图片验证，保留短信验证。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>短信验证码轰炸一般基于web方式，主要有两个模块组成：一个前端web网页，提供输入被攻击者手机号码的输入窗口；一个后台攻击页面(如PHP)，利用从各个网站上找到的动态短信URL 和前端输入的被攻击者手机号码，发送HTTP 请求，每次请求给用户发送一个动态短信。原理和实施过程如下：</p><ol><li><p>恶意攻击者在前端中输入被攻击者的手机号；</p></li><li><p>短信炸弹后台服务器，将该手机号与互联网收集的可不需要经过认证即可发送动态短信的URL 进行组合，形成可发送动态短信的URL 请求；</p></li><li>通过后台请求页面，伪造用户的请求发给不同的业务服务器；</li><li>业务服务器收到该请求后，发送动态短信到被攻击用户的手机上。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8ad9cb41-13ad-4bf7-aba9-dbec5c3e6d4c.jpg" alt="img"></p><p>GitHub 上也有一些轰炸机的项目，例如这个 <a href="https://github.com/shellvon/smsBomb/blob/master/config/sms.json">github.com/shellvon/smsBomb/blob/m…</a> ，门槛非常低。</p><p>轰炸机的配置示例：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/CcqRHrK7Fa.png!large" alt="身份验证接口设计"></p><h3 id="如何防治"><a href="#如何防治" class="headerlink" title="如何防治"></a>如何防治</h3><p>短信炸弹形成的原因是因为非授权的动态短信获取，由于在使用动态短信业务前系统并不能建立业务关联。因此，在未建立业务关联的情况下，需要进一步严格限制保证业务使用的安全性。可以采用增加<strong>图形验证码</strong>、<strong>限制单IP请求次数</strong>、<strong>限制用户短信请求间隔</strong>等方式，保护短信通道。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7bca2ddb-f4b1-44e6-b9c7-8d5b5e490a67.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/5b7d30bd-3ed2-4cde-b210-3d1ed5d78ba0.png" alt="img"></p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>用户使用密码登录时，很容易被黑客暴力破解。</p><p>所谓暴力破解，就是针对某个用户名，不断尝试可能出现的密码，直到最终成功登录。</p><p>互联网上有大量的常用密码词典，GitHub 上随便一搜就能找到如 <a href="https://github.com/TheKingOfDuck/fuzzDicts/blob/master/passwordDict/top1000.txt">这个</a> 和 <a href="https://github.com/berzerk0/Probable-Wordlists/blob/master/Real-Passwords/Top207-probable-v2.txt">这个</a> 。也极大的降低了黑客暴力破解的门槛。</p><p>防止暴力破解，是一个系统性工程。用户注册时候，我们会要求密码至少六位数（要求太严格也不好，影响用户体验）。</p><p>另外 API 也会加入限流措施，不会让黑客无止境的尝试，这也是现在主流的防范机制。</p><p>防止暴力破解，一个行之有效的方式，是使用图片验证码。</p><p>图片验证码的设计初衷，是用来区分人和机器的输入：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/mNTpWgMD4R.png!large" alt="mNTpWgMD4R.png!large"></p><p>如果一个验证码很容易破解，我们还可以增加其难度：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/uDpbpHfEpb.png!large" alt="uDpbpHfEpb.png!large"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/X1wXrgsdWb.png!large" alt="X1wXrgsdWb.png!large"></p><p>另外，不止用户密码，有时候<strong>短信验证码和邮箱验证码</strong>，也很容易被破解，因为一般情况下我们只会提供六位数的数字。</p><p>六位数，意味着 999999 种可能性。虽然会加入过期时间，例如说 15 分钟内有效，但是如果接口不做限制的话，黑客写个程序，很容易就能在几分钟内尝试完所有的 999999 个可能性。最终短信验证码形同虚设，黑客可以很轻松的通过验证码来重置用户的密码。最终导致用户账号丢失。</p><h1 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h1><p>OK啊，也是好起来了，新项目用到了 Redis，第一次面试也有被面试官问过类似的问题。</p><p>用 Redis 来干吗呢，当然是用来存储图片验证码了，后续也会用 Redis 来完成友情链接的存储。</p><p>提到 Redis，相信找过工作的都知道，只要在简历上写了关于 Redis 的内容，就会触发面试官的被动技能，那就是提问 Redis 三兄弟。那么也来简单看一看关于 Redis 的内容吧。</p><hr><p>Redis 是 <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice 三个单词中加粗字母的组合，是一种基于键值对（key-value）的 NoSQL 数据库。</p><p>但比一般的键值对，Redis 中的 value 支持 string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数估算）、GEO（地理信息定位）等多种数据结构。</p><p>而且因为 Redis 的所有数据都存放在<strong>内存</strong>当中，所以它的<strong>读写性能非常出色</strong>。</p><p>不仅如此，Redis 还可以将内存数据持久化到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据并不会“丢失”。</p><p>除此之外，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 脚本等附加功能，是互联网技术领域中使用最广泛的缓存中间件。</p><h2 id="Redis-有什么用"><a href="#Redis-有什么用" class="headerlink" title="Redis 有什么用"></a>Redis 有什么用</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-b02e44b3-3299-450f-b767-4a862b5ac8ff.png" alt="三分恶面渣逆袭：Redis的作用"></p><ol><li>缓存</li></ol><p>Redis 最常见的用途就是作为缓存，由于所有数据都存储在内存中，所以 Redis 的读写速度非常快，远超基于磁盘存储的数据库。使用 Redis 缓存可以极大地提高应用的响应速度和吞吐量。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png" alt="三分恶面渣逆袭：Redis缓存"></p><ol><li>排行榜/计数器</li></ol><p>Redis 的 ZSet 非常适合用来实现排行榜的功能，同时 Redis 的原子递增操作可以用来实现计数器功能。</p><ol><li>分布式锁</li></ol><p>Redis 可以实现分布式锁，用来控制跨多个进程或服务器的资源访问。</p><p>实例：</p><ul><li>Redis 可以用来存储 Token：用户登录成功之后，使用 Redis 的 hash 存储 Token</li><li>使用 Redis 的 Zset 计数，登录失败超过一定次数，锁定账号</li><li>使用 Redisson 实现分布式环境下的登录、注册等操作</li></ul><h2 id="Redis-中的数据类型"><a href="#Redis-中的数据类型" class="headerlink" title="Redis 中的数据类型"></a>Redis 中的数据类型</h2><p>Redis 有五种基本数据类型，这五种数据类型分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、sorted set（有序集合，也叫 zset）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.png" alt="三分恶面渣逆袭：Redis基本数据类型"></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串是最基础的数据类型，key 是一个字符串，不用多说，value 可以是：</p><ul><li>字符串（简单的字符串、复杂的字符串（例如 JSON、XML））</li><li>数字 （整数、浮点数）</li><li>甚至是二进制（图片、音频、视频），但最大不能超过 512MB。</li></ul><p>字符串主要有以下几个典型的使用场景：</p><ul><li>缓存功能</li><li>计数</li><li>共享 Session</li><li>限速</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>键值对集合，key 是字符串，value 是一个 Map 集合，比如说 <code>value = &#123;name: &#39;沉默王二&#39;, age: 18&#125;</code>，name 和 age 属于字段 field，沉默王二 和 18 属于值 value。</p><p>哈希主要有以下两个典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><p>来感受一下，用户字符串类型存储用户信息和用哈希类型存储用户信息的区别：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240315115713.png" alt="img"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 是一个简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表主要有以下两个使用场景：</p><ul><li>消息队列</li><li>文章列表</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>集合是字符串的无序集合，集合中的元素是唯一的，不允许重复。和 Java 集合框架中的 Set 有相似之处。</p><p>集合主要有以下两个使用场景：</p><ul><li>标签（tag）</li><li>共同关注</li></ul><h3 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h3><p>Zset，有序集合，比 set 多了一个排序属性 score（分值）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240315120652.png" alt="img"></p><p>主要应用场景有：</p><ul><li>用户点赞统计</li><li>用户排序</li></ul><h2 id="Redis-三兄弟"><a href="#Redis-三兄弟" class="headerlink" title="Redis 三兄弟"></a>Redis 三兄弟</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询不存在的数据，由于缓存没有命中（因为数据根本就不存在），请求每次都会穿过缓存去查询数据库。如果这种查询非常频繁，就会给数据库造成很大的压力。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-029951e6-8b99-4364-a570-010853deb594.png" alt="三分恶面渣逆袭：缓存穿透"></p><p>缓存穿透意味着缓存失去了减轻数据压力的意义。</p><p>缓存穿透可能有两种原因：</p><ul><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ul><p>它主要有两种解决办法：</p><ol><li>缓存空值/默认值</li></ol><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-288af5a2-ae5a-427a-95e9-b4a658b01386.png" alt="三分恶面渣逆袭：缓存空值/默认值"></p><p>缓存空值有两大问题：</p><ul><li><p>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。</p></li></ul><p>例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。</p><p>这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。</p><ol><li>布隆过滤器</li></ol><p>除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。</p><p>布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-0e18ea40-a2e5-4fa6-989e-e771f6e4b0fc.png" alt="布隆过滤器"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-e8a382c9-4379-44ab-b1dc-fb598a228105.png" alt="缓存空对象核布隆过滤器方案对比"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指某一个或少数几个数据被高频访问，当这些数据在缓存中过期的那一刻，大量请求就会直接到达数据库，导致数据库瞬间压力过大。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-86579ee6-9dae-4274-a5cc-af6812f48da4.png" alt="三分恶面渣逆袭：缓存击穿"></p><p>解决⽅案：</p><ol><li>加锁更新，⽐如请求查询 A，发现缓存中没有，对 A 这个 key 加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-cf63911a-8501-493e-a375-8b47a9f33358.png" alt="三分恶面渣逆袭：加锁更新"></p><ol><li>将过期时间组合写在 value 中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某一个时间点，由于大量的缓存数据同时过期或缓存服务器突然宕机了，导致所有的请求都落到了数据库上（比如 MySQL），从而对数据库造成巨大压力，甚至导致数据库崩溃的现象。</p><p>总之就是，崩了，崩的非常严重，就叫雪崩了（电影电视里应该看到过，非常夸张）。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-1464fe22-c463-4850-8989-b899510cb10e.png" alt="三分恶面渣逆袭：缓存雪崩"></p><p>解决方案：</p><p>第一种：提高缓存可用性</p><ol><li><strong>集群部署</strong>：采用分布式缓存而不是单一缓存服务器，可以降低单点故障的风险。即使某个缓存节点发生故障，其他节点仍然可以提供服务，从而避免对数据库的大量直接访问。</li></ol><p>可以利用 Redis Cluster。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240326220634.png" alt="Rajat Pachauri：Redis Cluster"></p><p>或者第三方集群方案 Codis。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/redis-20240326220408.png" alt="极客时间：Codis"></p><ol><li><strong>备份缓存</strong>：对于关键数据，除了在主缓存中存储，还可以在备用缓存中保存一份。当主缓存不可用时，可以快速切换到备用缓存，确保系统的稳定性和可用性。</li></ol><p>第二种：过期时间</p><p>对于缓存数据，设置不同的过期时间，避免大量缓存数据同时过期。可以通过在原有过期时间的基础上添加一个随机值来实现，这样可以分散缓存过期时间，减少同一时间对数据库的访问压力。</p><p>第三种：限流和降级</p><p>通过设置合理的系统限流策略，如令牌桶或漏斗算法，来控制访问流量，防止在缓存失效时数据库被打垮。</p><p>此外，系统可以实现降级策略，在缓存雪崩或系统压力过大时，暂时关闭一些非核心服务，确保核心服务的正常运行。</p><hr><p>本项目中对 Redis 的使用并不多，主要是用来存储一些不会经常发生变化的内容，所以更加深层次的内容会在后面继续学习，在这里就不再写了。</p><h1 id="JWT-授权"><a href="#JWT-授权" class="headerlink" title="JWT 授权"></a>JWT 授权</h1><p>互联网服务离不开用户认证。一般流程是下面这样。</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">  <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bg2018072304.jpg" alt="img"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p>写成一行，就是下面的样子。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bg2018072303.jpg" alt="img"></p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，JWT 默认是<strong>不加密</strong>的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 <strong>Header</strong> 里面指定的签名算法（默认是 <strong>HMAC SHA256</strong>），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h3><p>前面提到，<strong>Header</strong> 和 <strong>Payload</strong> 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h2><p>客户端收到服务器返回的 <strong>JWT</strong>，可以储存在 <strong>Cookie</strong> 里面，也可以储存在 <strong>localStorage</strong>。</p><p>此后，客户端每次与服务器通信，都要带上这个 <strong>JWT</strong>。你可以把它放在 <strong>Cookie</strong> 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><hr><p>说了这么多的基础内容，JWT 在本项目中又起到了什么作用呢。使用 JWT 主要用于产生 token，以此来进行授权，未被授权的用户不能执行相关操作，如 A 发布的话题，只有 A 才能对话题进行修改和删除，其他用户只能引用这个话题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录完上面的这三个问题，其实已经解决了我在做这个项目时的一大部分疑问了，因为项目主题其实很类似，这也是为什么后面会使用模板文件进行自动化生成模型、控制器、验证请求、请求授权等这些机制的原因。</p><p>当然，本文中所写到的也都只是相关技术的一些皮毛，后续的深入学习还会进行记录。关于本项目的还会有包括日志、命令行模式、make命令以及关于数据库方面的东西。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li><li><a href="https://javabetter.cn/sidebar/sanfene/redis.html">https://javabetter.cn/sidebar/sanfene/redis.html</a></li><li><a href="https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724">https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍新项目中第一部分的内容——身份验证接口的设计思路。&lt;/p&gt;
&lt;p&gt;身份验证接口主要包括以下模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册&lt;/li&gt;
&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;找回密码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;填写手机号或</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gohub开发</title>
    <link href="http://example.com/2024/04/15/Gohub%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/04/15/Gohub%E5%BC%80%E5%8F%91/</id>
    <published>2024-04-15T07:41:08.000Z</published>
    <updated>2024-04-18T14:55:42.144Z</updated>
    
    <content type="html"><![CDATA[<p>本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。</p><p>本项目主要设计一下三部分的知识点：</p><ul><li>API 开发</li><li>命令行开发</li><li>构建高效率的程序结构</li></ul><p>主要功能为：</p><ul><li>用户的注册和登录</li><li>安全验证码和图片验证码</li><li>JWT 授权</li><li>用户修改个人信息</li></ul><h1 id="项目统计"><a href="#项目统计" class="headerlink" title="项目统计"></a>项目统计</h1><h2 id="实现路由"><a href="#实现路由" class="headerlink" title="实现路由"></a>实现路由</h2><div class="table-container"><table><thead><tr><th>请求方法</th><th>API 地址</th><th>说明</th></tr></thead><tbody><tr><td>POST</td><td>/api/v1/auth/login/using-phone</td><td>短信 + 手机号登录</td></tr><tr><td>POST</td><td>/api/v1/auth/login/using-password</td><td>手机号、用户名、邮箱 + 密码</td></tr><tr><td>POST</td><td>/api/v1/auth/login/refresh-token</td><td>刷下 Token</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-email</td><td>邮件密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-phone</td><td>短信验证码密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-phone</td><td>使用手机号注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-email</td><td>使用邮箱注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/phone/exist</td><td>手机号是否已注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/email/exist</td><td>email 是否已支持</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/phone</td><td>发送短信验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/email</td><td>发送邮件验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/captcha</td><td>获取图片验证码</td></tr><tr><td>GET</td><td>/api/v1/user</td><td>获取当前用户</td></tr><tr><td>GET</td><td>/api/v1/users</td><td>用户列表</td></tr><tr><td>PUT</td><td>/api/v1/users</td><td>修改个人资料</td></tr><tr><td>PUT</td><td>/api/v1/users/email</td><td>修改邮箱</td></tr><tr><td>PUT</td><td>/api/v1/users/phone</td><td>修改手机号</td></tr><tr><td>PUT</td><td>/api/v1/users/password</td><td>修改密码</td></tr><tr><td>PUT</td><td>/api/v1/users/avatar</td><td>上传头像</td></tr><tr><td>GET</td><td>/api/v1/categories</td><td>分类列表</td></tr><tr><td>POST</td><td>/api/v1/categories</td><td>创建分类</td></tr><tr><td>PUT</td><td>/api/v1/categories/:id</td><td>更新分类</td></tr><tr><td>DELETE</td><td>/api/v1/categories/:id</td><td>删除分类</td></tr><tr><td>GET</td><td>/api/v1/topics</td><td>话题列表</td></tr><tr><td>POST</td><td>/api/v1/topics</td><td>创建话题</td></tr><tr><td>PUT</td><td>/api/v1/topics/:id</td><td>更新话题</td></tr><tr><td>DELETE</td><td>/api/v1/topics/:id</td><td>删除话题</td></tr><tr><td>GET</td><td>/api/v1/topics/:id</td><td>获取话题</td></tr><tr><td>GET</td><td>/api/v1/links</td><td>友情链接列表</td></tr></tbody></table></div><h2 id="第三方依赖"><a href="#第三方依赖" class="headerlink" title="第三方依赖"></a>第三方依赖</h2><p>使用到的开源库：</p><ul><li><a href="https://github.com/gin-gonic/gin">gin</a> —— 路由、路由组、中间件</li><li><a href="https://github.com/gin-contrib/zap">zap</a> —— 高性能日志方案</li><li><a href="https://github.com/go-gorm/gorm">gorm</a> —— ORM 数据操作</li><li><a href="https://github.com/spf13/cobra">cobra</a> —— 命令行结构</li><li><a href="https://github.com/spf13/viper">viper</a> —— 配置信息</li><li><a href="https://github.com/spf13/cast">cast</a> —— 类型转换</li><li><a href="https://github.com/go-redis/redis/v8">redis</a> —— Redis 操作</li><li><a href="https://github.com/golang-jwt/jwt">jwt</a> —— JWT 操作</li><li><a href="https://github.com/mojocn/base64Captcha">base64Captcha</a> —— 图片验证码</li><li><a href="https://github.com/thedevsaddam/govalidator">govalidator</a> —— 请求验证器</li><li><a href="https://github.com/ulule/limiter/v3">limiter</a> —— 限流器</li><li><a href="https://github.com/jordan-wright/email">email</a> —— SMTP 邮件发送</li><li><a href="https://github.com/KenmyZhang/aliyun-communicate">aliyun-communicate</a> —— 发送阿里云短信</li><li><a href="https://github.com/mgutz/ansi">ansi</a> —— 终端高亮输出</li><li><a href="https://github.com/iancoleman/strcase">strcase</a> —— 字符串大小写操作</li><li><a href="https://github.com/gertd/go-pluralize">pluralize</a> —— 英文字符单数复数处理</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/bxcodec/faker">faker</a> —— 假数据填充</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/disintegration/imaging">imaging</a> —— 图片裁切</li></ul><h2 id="自定义的包"><a href="#自定义的包" class="headerlink" title="自定义的包"></a>自定义的包</h2><p>现在来看下我们自建的库：</p><ul><li>app —— 应用对象</li><li>auth —— 用户授权</li><li>cache —— 缓存</li><li>captcha —— 图片验证码</li><li>config —— 配置信息</li><li>console —— 终端</li><li>database —— 数据库操作</li><li>file —— 文件处理</li><li>hash —— 哈希</li><li>helpers —— 辅助方法</li><li>jwt —— JWT 认证</li><li>limiter —— API 限流</li><li>logger —— 日志记录</li><li>mail —— 邮件发送</li><li>migrate —— 数据库迁移</li><li>paginator —— 分页器</li><li>redis —— Redis 数据库操作</li><li>response —— 响应处理</li><li>seed —— 数据填充</li><li>sms —— 发送短信</li><li>str —— 字符串处理</li><li>verifycode —— 数字验证码</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>配置信息（使用 Viper，支持 .env 和 config 目录 ）</li><li>API 版本</li><li>API 错误码</li><li>API 限流<ol><li>支持秒、分钟、小时、天级的请求限制</li><li>支持返回 API 请求量标头（限制数，剩余量、重置时间）</li></ol></li><li>注册登录<ol><li>注册<ol><li>判断手机是否注册</li><li>判断 Email 是否注册</li><li>支持手机 + 短信验证码进行注册</li><li>支持使用邮箱注册账号</li></ol></li><li>登录<ol><li>支持手机 + 短信进行登录</li><li>支持密码登录（手机号、Email、用户名任选）</li><li>支持更加安全的 Token Refresh 机制</li></ol></li><li>找回密码<ol><li>支持使用手机 + 短信验证码找回</li><li>支持使用邮箱 + 邮箱验证码找回</li></ol></li></ol></li><li>JWT 授权</li><li>整个应用使用命令行模式（默认运行 web 服务）</li><li>内置命令行（ cobra，对比 cli 和 cobra）<ol><li>key 命令生成 app key</li><li>make 命令<ul><li>make seeder —— 生成数据填充</li><li>make policy —— 生成授权文件</li><li>make apicontroller —— 生成 Restful API 控制器</li><li>make model —— 生成模型文件</li><li>make request —— 生成请求验证文件</li><li>make factory —— 生成模型工厂文件</li><li>make cmd —— 生成自定义命令文件</li><li>make migration —— 生成数据库迁移文件</li></ul></li><li>seed 数据填充<ul><li>seed 所有数据</li><li>seed 单条数据</li><li>支持使用 faker 填充假数据</li><li>支持模型工厂（ factory ）</li></ul></li><li>migrate 数据库迁移<ol><li>up —— 执行迁移</li><li>rollback (down) —— 回滚上一步执行的迁移</li><li>fresh —— 删除所有表，然后执行所有迁移</li><li>reset —— 回滚所有迁移</li><li>refresh —— 回滚所有迁移，然后再执行所有迁移</li></ol></li><li>cache 缓存处理<ul><li>cache clear —— 清除缓存</li><li>cache forget —— 忘记某个 KEY 对应的缓存</li></ul></li></ol></li><li>分页<ol><li>支持返回上下页链接，方便客户端调用</li></ol></li><li>Cache 缓存包<ol><li>支持 redis 缓存</li><li>使用 interface ，支持使用多驱动</li></ol></li><li>Redis 操作</li><li>安全验证码<ol><li>Email （发送邮箱，使用 Mailhog 进行测试）</li><li>手机验证码（发送手机短信）</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>图片验证码，防机器人滥用<ol><li>支持通过配置信息自定义复杂度</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>日志记录<ol><li>集成 zap 高性能日志库</li><li>支持命令行记录（方便开发时快速定位问题）</li><li>命令行日志高亮</li><li>支持文件记录（多文件和按日期分隔）</li><li>记录 gorm 的 query log</li><li>记录 HTTP 请求 log</li><li>Panic Recovery 中间件</li><li>合理的日志等级（debug, info, error, panic, fatal）</li></ol></li><li>Policy 授权策略结构</li><li>Request 请求验证方案<ol><li>支持 JSON 请求、表单请求、URL Query</li></ol></li><li>API 图片上传</li><li>图片裁切</li><li>数据库支持 mysql 和 sqlite</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于本项目是一个完全只涉及到 API 设计的内容，所以测试功能是否符合预期则是采用了 Postman 这款测试软件，有关 Redis 的可视化则是采用了 Another Redis Desktop Manager。</p><p>考虑到篇幅的问题，项目的知识点总结会分开来写。所以这篇文章是用来提醒我去学习的。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。&lt;/p&gt;
&lt;p&gt;本项目主要设计一下三部分的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 开发&lt;/li&gt;
&lt;li&gt;命令行开发&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Gohub" scheme="http://example.com/categories/Gohub/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>唉……</title>
    <link href="http://example.com/2024/04/14/%E5%94%89%E2%80%A6%E2%80%A6/"/>
    <id>http://example.com/2024/04/14/%E5%94%89%E2%80%A6%E2%80%A6/</id>
    <published>2024-04-14T09:21:21.000Z</published>
    <updated>2024-04-14T09:50:50.924Z</updated>
    
    <content type="html"><![CDATA[<p>文章是越写越慢，质量是越来越差，这周的甚至连标题都想不出来了，离谱。从标题也能看出来，这周应该是不太愉悦的，二面被挂就算了，还被另一个面试官给戏耍了。我懂了，找实习就一个字——摆。</p><h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>清明假期三天，每天都是两三个小时的做题时间，本周倒是没怎么做题。</p><p>原因是觉得刷了一个月的题了，还是在看到题目后几分钟就有思路了，但是不知道代码该怎么写，所以决定先沉淀几天。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>虽然最近几天算法进展不怎么样，项目进展还是不错的。</p><p>上周六开的新项目，其实还是这周才开始，项目内容和之前的项目好像没有什么太大的区别，一个是博客，一个是论坛。但是实际开发就是天差地别了，不仅仅将框架全部换了 <code>gin</code> ，还用上了 <code>redis</code>。是的，就是那个只要出现在简历上就会触发面试官被动的 <code>redis</code> ，当然，以防万一，我非常认真地背了 Redis 三兄弟。</p><p>项目中更加详细地内容还是等到下周专门来写吧，写在周报里好像不是很好记录。</p><h2 id="Go语言设计哲学"><a href="#Go语言设计哲学" class="headerlink" title="Go语言设计哲学"></a>Go语言设计哲学</h2><p>没想到这一块竟然还有后续，因为上一篇有些一些相关的内容，后续也有去了解 Go 和 C++ 的不同，也查了一些资料，感觉很有意思，后续应该会继续写相关的内容。</p><h2 id="找实习的进展"><a href="#找实习的进展" class="headerlink" title="找实习的进展"></a>找实习的进展</h2><p>有什么进展呢，最接近成功的也就是清明假期前的那次了，结果挂在了横向对比上，只能怪一面的时候回答的确实不怎么样。腾讯约了第三次面试，结果是个 KPI 面，一共就二十几分钟，面试官还迟到了，连自我介绍都没让做。</p><p>字节和小米都是简历直接就给挂了，其他的公司也看不上我的简历，只有等月底的华为喽。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，本周学的东西不算很多，因为考试加上心情不是很好，决定开摆一周，也没整理这周学的内容，所以周报也没什么好写的。那为什么还写呢，因为想找一个地方记录并发泄一下。</p><p>下周会把项目全部完成，调整后会继续刷题，那就期待着后续的博客更新吧。完成项目后会继续完善自己的简历，我想这个暑假应该是能找到实习的吧，希望是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章是越写越慢，质量是越来越差，这周的甚至连标题都想不出来了，离谱。从标题也能看出来，这周应该是不太愉悦的，二面被挂就算了，还被另一个面试官给戏耍了。我懂了，找实习就一个字——摆。&lt;/p&gt;
&lt;h1 id=&quot;学习内容&quot;&gt;&lt;a href=&quot;#学习内容&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Go语言设计哲学</title>
    <link href="http://example.com/2024/04/03/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
    <id>http://example.com/2024/04/03/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</id>
    <published>2024-04-03T13:16:08.000Z</published>
    <updated>2024-04-06T09:05:59.758Z</updated>
    
    <content type="html"><![CDATA[<p>实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。</p><p>在学习一门语言时，有没有考虑过这个语言的语法和格式为什么要这么设计？这个问题一听就是一个好的话题啊，为什么这么设计？为什么在已经有了那么多语言后，还要设计出Go语言？</p><p>那么好，闲话少说，这周的主要内容就改为Go语言的设计哲学。当然，文章内容并不是我原创的，更多的还是网上查到的资料。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Go 编程语言构思于 2007 年底，构思的目的是：为了解决在 Google 开发软件基础设施时遇到的一些问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b73ae4ab1b1ceb693aad4f978f1f2cc.jpg" alt="Go 语言之父"></p><p>图中的三位大佬就是 Go 语言最初的设计者，从左到右依次为：</p><ul><li>Robert Griesemer：参与过 Google V8 JavaScript 引擎和 Java HotSpot 虚拟机的研发。</li><li>Rob Pike：Unix 操作系统早期开发者之一，UTF-8 创始人之一，Go 语言吉祥物设计者是 Rob Pike 的媳妇。</li><li>Ken Thompson：图灵奖得主，Unix 操作系统早期开发者之一，UTF-8 创始人之一，C 语言（前身 B 语言）的设计者。</li></ul><p>那么好，我们来解释第一个问题，为什么这几个大佬要设计 Go 语言。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>曾经在早期的采访中，Google 大佬们反馈感觉 “编程” 太麻烦了，他们很不喜欢 C++，对于现在工作所用的语言和环境感觉比较沮丧，充满着许多不怎么好用的特性。</p><p>具体遭遇到的问题。如下：</p><ul><li>软件复杂：多核处理器、网络系统、大规模计算集群和网络编程模型所带来的问题只能暂时绕开，没法正面解决。</li><li>软件规模：软件规模也发生了变化，今天的服务器程序由数千万行代码组成，由数百甚至数千名程序员进行工作，而且每天都在更新（据闻 Go 就是在等编译的 45 分钟中想出来的）。</li><li>编译耗时：在大型编译集群中，构建时间也延长到了几分钟，甚至几小时。</li></ul><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>为了解决上述的问题，如果在既有语言上进行修改，需要解决很多根本性的问题，因此，他们决定重新设计一个语言。</p><p>这门新语言需要符合以下需求：</p><ul><li>目的：<strong>设计和开发 Go 是为了使在这种环境下能够提高工作效率</strong>。</li><li>设计：在 Go 的设计上，除了比较知名的方面：如内置并发和垃圾收集。还考虑到：严格的依赖性管理，随着系统的发展，软件架构的适应性，以及跨越组件之间边界的健壮性。</li></ul><p>这门新语言就是现在的 Go。</p><h1 id="Go-在-Google"><a href="#Go-在-Google" class="headerlink" title="Go 在 Google"></a>Go 在 Google</h1><p>Google 整体的应用软件很庞大，硬件也很庞大，有数百万行的软件，服务器主要是 C++ 语言，其他部分则是大量的 Java 和 Python。</p><p>数以千计的工程师在代码上工作，在一个由所有软件组成的单一树的 “头 “ 上工作，所以每天都会对该树的所有层次进行重大改变。一个大型的定制设计的分布式构建系统使得这种规模的开发是可行的，但它仍然很大。当然，所有这些软件都在几十亿台机器上运行，这些机器被视为数量不多的独立、联网的计算集群。</p><p>简而言之，Google 的开发规模很大，速度可能是缓慢的，而且往往是笨拙的。但它是有效的。</p><p>Go 项目的目标是：消除 Google 软件开发的缓慢和笨拙，从而使这个过程更富有成效和可扩展。<strong>这门语言是由编写、阅读、调试和维护大型软件系统的人设计的，也是为他们设计的</strong>。</p><p>因此 Go 的目的不是为了研究编程语言的设计，而是为了改善其设计者及其同事的工作环境。</p><h1 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h1><p>Go 的诞生，更多是为了方便程序员进行编程，而不是为了某项科学研究，这就是 Go 语言与其他编程语言的最大的不同。</p><p>当 Go 发布时，有些人声称它缺少被认为是现代语言的必要条件的特定功能或方法。在缺乏这些设施的情况下，Go怎么可能有价值？</p><p>我们的答案是：<strong>Go 所拥有的特性可以解决那些使大规模软件开发变得困难的问题。</strong></p><p>这些问题包括：</p><ul><li>构建速度缓慢。</li><li>不受控制的依赖关系。</li><li>每个程序员使用不同的语言子集。</li><li>对程序的理解不透彻（代码可读性差，文档不全等）。</li><li>工作的重复性。</li><li>更新的成本。</li><li>版本偏移（version skew）。</li><li>编写自动工具的难度。</li><li>跨语言的构建。</li></ul><p>纯粹一门语言的单个功能并不能解决这些问题，我们需要对软件工程有一个更大的看法。因此在 Go 的设计中，我们试图把重点放在这些问题的解决方案上。</p><h1 id="少即是多"><a href="#少即是多" class="headerlink" title="少即是多"></a>少即是多</h1><p>相信对 Go 语言有过了解的人都会经常听到诸如：less is more、少即是多、大道至简、大道不停地至简等黑话。</p><p>那么少即是多这种观点是谁提起的呢，正是 Go 语言之父的 Rob Pike。</p><p>Rob Pike 在多个场合提到过类似 “少即是多” 的观点，该观点广为流传。这种设计理念体现在 Go 语言的语法设计上，它的语法非常简洁，没有复杂的继承和泛型，也没有异常处理，但这并不影响它的功能性和表达力。</p><p>以下内容多为 Rob Pike 在一次演讲时提到的内容，对此感兴趣的可以去阅读一下 Rob Pike 的 <a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">Less is exponentially more</a> 演讲稿。</p><h2 id="Go-特性清单"><a href="#Go-特性清单" class="headerlink" title="Go 特性清单"></a>Go 特性清单</h2><ul><li>规范的语法（无需用于解析的符号表）。</li><li>垃圾收集（唯一）。</li><li>没有头文件。</li><li>明确依赖</li><li>无循环依赖。</li><li>常量只能为数字。</li><li>int 和 int32 是不同的类型。</li><li>字母大小写设定可见性。</li><li>任何类型都可以有方法（没有类）。</li><li>没有子类型继承（没有子类）。</li><li>包级别初始化和定义好的初始化顺序。</li><li>文件编译到一个包中。</li><li>包级别的全局表达与顺序无关。</li><li>没有算术转换（常量做了辅助处理）。</li><li>隐式的接口实现（无需“implements”定义）。</li><li>嵌入（没有向父类的升级）。</li><li>方法如同函数一样进行定义（没有特的别位置要求）。</li><li>方法就是函数。</li><li>接口仅仅包含方法（没有数据）。</li><li>方法仅通过名字匹配（而不是通过类型）。</li><li>没有构造或者析构方法。</li><li>后自增和后自减是语句，而不是表达式。</li><li>没有前自增或前自减。</li><li>赋值不是表达式。</li><li>按照赋值、函数调用定义时的顺序执行（没有“sequence point”）。</li><li>没有指针运算。</li><li>内存总是零值初始化。</li><li>对局部变量取地址合法。</li><li>方法没有“this”。</li><li>分段的堆栈。</li><li>没有静态或其他类型注解。</li><li>没有模板。</li><li>没有异常。</li><li>内建 string、slice、map。</li><li>数组边界检查。</li></ul><p>除了这个简化清单和一些未提及的琐碎内容，我相信，Go 相比 C 或者 C++ 是更加有表达力的。少既是多。</p><h2 id="无法想象没有泛型"><a href="#无法想象没有泛型" class="headerlink" title="无法想象没有泛型"></a>无法想象没有泛型</h2><p>当然明显缺少的是类型层次化。</p><p>在 Go 最初的版本中，有人告诉我他无法想像用一个没有泛型范型的语言来工作。就像之前在某些地方提到过的，我认为这绝对是神奇的评论。</p><p>公平的说，他可能正在用其自己的方式来表达非常喜欢 STL 在 C++ 中为他做的事情。在辩论的前提下，让我们先相信他的观点。</p><p>他说编写像 int 列表或 map string 这样的容器是一个无法忍受的负担。我觉得这是个神奇的观点。</p><p>即便是那些没有泛型范型的语言，我也只会花费很少的时间在这些问题上。</p><h2 id="面向对象的方式"><a href="#面向对象的方式" class="headerlink" title="面向对象的方式"></a>面向对象的方式</h2><p>但是更重要的是，他说类型是放下这些负担的解决途径。类型。不是函数多态，不是语言基础，或者其他协助，仅仅用类型。</p><p>这就是卡住我的细节问题。</p><p>从 C++ 和 Java 转过来 Go 的程序员怀念工作在类型上的编程方式，尤其是继承和子类，以及所有相关的内容。可能对于类型来说，我是门外汉，不过我真得从未发现这个模型十分具有表达力。</p><p>我已故的朋友 Alain Fournier 有一次告诉我说他认为学术的最低级形式就是分类。那么你知道吗？类型层次化就是分类。</p><p>你必须对哪块进哪个盒子作出决策，包括每个类型的父级，不论是 A 继承自 B，还是 B 继承自 A。</p><p>一个可排序的数组是一个排序过的数组还是一个数组表达的排序器？如果你坚信所有问题都是由类型驱动设计的，那么你就必须作出决策。</p><p>我相信这样思考编程是荒谬可笑的。核心不是东西之间的祖宗关系，而是它们可以为你做什么。</p><p>当然，这就是接口进入 Go 的地方。但是它们已经是蓝图的一部分，那是真正的 Go 哲学。</p><p>如果说 C++ 和 Java 是关于类型继承和类型分类的，Go 就是关于组合的。</p><p>Unix pipe 的最终发明人 Doug McIlroy 在 1964 (!) 这样写到：</p><blockquote><p>我们应当像连接花园里的龙头和软管一样，用某种方式一段一段的将消息数据连接起来。这同样是 IO 使用的办法。</p></blockquote><p>这也是 Go 使用的办法。Go 用了这个主意，并且将其向前推进了一大步。这是一个关于组合与连接的语言。</p><p>一个显而易见的例子就是接口为我们提供的组合元件的方式。只要它实现了方法 M，就可以放在合适的地方，而不关心它到底是什么东西。</p><p>另一个重要的例子是并发如何连接独立运行的计算。并且也有一个不同寻常（却非常简单）的类型组合模式：嵌入。</p><p>这就是 Go 特有的组合技术，滋味与 C++ 或 Java 程序完全不同。</p><h2 id="为什么-Go-不被-C-程序员喜欢"><a href="#为什么-Go-不被-C-程序员喜欢" class="headerlink" title="为什么 Go 不被 C++ 程序员喜欢"></a>为什么 Go 不被 C++ 程序员喜欢</h2><p>从上面的内容中，我们不难看出，Go 语言的设计者是十分不喜欢使用C++ 进行编程设计的。当然，在 Go 语言被设计并发布后，程序员没有了更多的选择。但是，相较于 C++ 程序员，其他语言的使用者好像更加喜欢 Go 语言。</p><p><strong>为什么 Go，一个被设计为用于摧毁 C++ 的语言，并为并未获得 C++ 程序员的芳心？</strong></p><p>这是因为 Go 和 C++ 有着完全不同的哲学。</p><p><strong>C++ 是让你的指尖解决所有的问题</strong>：</p><ul><li>C++ 与那些巨大增长的特别编写的手工代码相比，具有更加广泛的抽象，优雅、灵活并且零成本的表达能力。</li></ul><p><strong>Go 的主张更多考虑的是最小化程序员的工作量</strong>：</p><ul><li>Go 不是无所不包的。你无法通过内建获得所有东西。你无法精确控制每个细微的执行。</li><li><strong>你得到的是功能强大，但是容易理解的，容易用来构建一些用于连接组合解决问题的模块</strong>。</li><li>这可能最终不像你使用其他语言编写的解决方案那么快，那么精致，在思想体系上那么明确，但它确实会更加容易编写，容易阅读，容易理解，容易维护，并且更加安全。</li></ul><p>换句话说，当然，有些过于简单：</p><ul><li>Python 和 Ruby 程序员：转到 Go 是因为他们并未放弃太多的表达能力，但是获得了性能，并且与并发共舞。</li><li>C++ 程序员：无法转到 Go 是因为他们经过艰辛的战斗才获得对其语言的精确控制能力，而且也不想放弃任何已经获得的东西。对于他们，软件不仅仅是关于让工作完成，而是关于用一个确定的方式完成。</li></ul><h1 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h1><p>本段则是来自《<a href="https://www.youtube.com/watch?v=YXV7sa4oM4I">The Go Programming Language and Environment</a>》这篇演讲稿。</p><p>出身 Google 的 Go 语言严格意义上来说就是出身于名门望族了，那么十多年过去了，它发展地怎么样了？</p><h2 id="Go-怎么样了"><a href="#Go-怎么样了" class="headerlink" title="Go 怎么样了"></a>Go 怎么样了</h2><p>Rob Pike 表示其实 Go 目前还不能算做主流语言，但是在全世界的影响力和发展都大大的超出了预期。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/958c55da2ff41616a0ae6c88bade062a.png" alt="img"></p><p>像在国内的我们，能够很明显感知到，Go 在近 3~5 年的用户群体不断增大，一些大厂也已经开始转 Go ，甚至有的公司就是全部用 Go 语言来进行工作的。</p><p>Go 并不是那种非常 “有趣” 的语言，在技术上（语言理论、设计）几乎没有什么大进步。当然，这也不是 Go 核心团队的设计目标。</p><p>但就是这么一门语言，他主导了大部分 CNCF 中的项目，例如：K8s、Docker 等，特别牛。<strong>Go 是云基础设施的语言，这是怎么发生的</strong>？</p><h2 id="Go-为什么成功"><a href="#Go-为什么成功" class="headerlink" title="Go 为什么成功"></a>Go 为什么成功</h2><p>Go 从一门无人问津的语言，到现在承担了各云基础设施的核心，变得很重要，也是一种成功实践。</p><p>Rob Pike 认为成功的因素有如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/408cea989ce5e27baff2038e2c99377b.png" alt="img"></p><p>核心观点：<strong>一门编程语言的成功取决于其他很多方面，Go 语言是面向软件开发的，而不仅仅只是编程</strong>。</p><p>为此，Go 就是为了解决软件开发而生，而非只是编程，这是成功的关键因素。</p><h1 id="回答面试官的问题"><a href="#回答面试官的问题" class="headerlink" title="回答面试官的问题"></a>回答面试官的问题</h1><p>在最后<strong>回答一下面试官的问题</strong>，不知道还有没有机会了，就在自己的博客里写一下吧。</p><p>问：一个语言在设计时将其语法结构设计成某种特殊的样子，如 Go 语言中花括号必须要和语句在同一行、Python 中使用缩进来替代花括号，这样的设计有什么原因吗？</p><p>答：无论结构怎么设计，对于机器来说都是没有区别的，无论是花括号还是缩进，能影响的就是有人。那么对于设计者来说，设计语言的一些特性主要还是根据他的思路以及设计哲学。</p><p>Python使用缩进替代花括号的原因有以下几种：</p><ul><li>缩进语法，更加优雅</li><li>缩进语法，更加清晰</li><li>使用缩进，保持一致性，避免造成误读</li><li>使用缩进，代码更紧凑，便于浏览，没有累赘</li><li>使用缩进，已足够令解释器执行，没必要使用多余的符号</li><li>强制缩进，源自古老的 ABC 语言，Guido 是这门语言的设计者之一</li><li>其思想可能出自 Don Knuth(高德纳，著名计算机科学家，经典巨著《计算机程序设计艺术》的作者)，他在 1974 年提出，在当时是很时髦和前卫的思想</li><li>使用缩进，可以终结大括号放在函数名后面还是再换一行的终极争论(据说此话题能令不同派系的程序员大打出手！)</li></ul><p>从 Python 发布至今，关于缩进是不是其设计的败笔就一直被大家讨论，我只能说见仁见智。</p><hr><p>对了，还有一个问题，关于我的博客界面左上角一直显示的加载中的字样，已经修复好了。</p><p>至于是怎么修好的，其实到现在我都不知道是哪里出了问题，也找不到类似的情况和解决方法，就只能把前端的美化“恢复出厂设置”了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们大致了解了 Go 语言的开发背景和开发理念。</p><p>当然本文中的大多数内容都是我看到别人的文章以及 Go 语言之父的演讲稿。</p><p>关于更加细节的开发和设计理念，我还在学习当中，后续会根据学习的情况更新文章，Go语言最为重要的并发还没开始，这个系列就肯定不会结束。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://golang3.eddycjy.com/posts/started-go/">https://golang3.eddycjy.com/posts/started-go/</a></li><li><a href="https://zhuanlan.zhihu.com/p/645695890">https://zhuanlan.zhihu.com/p/645695890</a></li><li><a href="https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f">https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f</a></li><li><a href="https://blog.csdn.net/weixin_39915668/article/details/111451430">https://blog.csdn.net/weixin_39915668/article/details/111451430</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。&lt;/p&gt;
&lt;p&gt;在学习一门语言时，有没有考虑过这个语言的语法和格式为什么</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
