<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  <subtitle>继续摇摆吧，我的天真老朋友；只有滚动的石头，才能不长青苔。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-11-22T16:22:59.186Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/03/07/Untitled/"/>
    <id>http://example.com/2025/03/07/Untitled/</id>
    <published>2025-03-07T06:39:56.000Z</published>
    <updated>2025-11-22T16:22:59.186Z</updated>
    
    <content type="html"><![CDATA[<p>testtesttesttest</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;testtesttesttest&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741099573219/"/>
    <id>http://example.com/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741099573219/</id>
    <published>2025-03-04T14:46:16.000Z</published>
    <updated>2025-11-22T16:22:37.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gohub开发"><a href="#Gohub开发" class="headerlink" title="Gohub开发"></a>Gohub开发</h1><hr><p>title: Gohub开发<br>categories: Go语言<br>tags: 项目开发<br>abbrlink: 25069</p><h2 id="date-2024-04-15-15-41-08"><a href="#date-2024-04-15-15-41-08" class="headerlink" title="date: 2024-04-15 15:41:08"></a>date: 2024-04-15 15:41:08</h2><p>本项目为从零构建一个高性能、功能齐全的 API 程序框架，主体内容和第一个项目相似。但是并没有做前端的内容，只针对相应功能做了 API 开发。</p><p>本项目主要设计一下三部分的知识点：</p><ul><li>API 开发</li><li>命令行开发</li><li>构建高效率的程序结构</li></ul><p>主要功能为：</p><ul><li>用户的注册和登录</li><li>安全验证码和图片验证码</li><li>JWT 授权</li><li>用户修改个人信息</li></ul><h1 id="项目统计"><a href="#项目统计" class="headerlink" title="项目统计"></a>项目统计</h1><h2 id="实现路由"><a href="#实现路由" class="headerlink" title="实现路由"></a>实现路由</h2><div class="table-container"><table><thead><tr><th>请求方法</th><th>API 地址</th><th>说明</th></tr></thead><tbody><tr><td>POST</td><td>/api/v1/auth/login/using-phone</td><td>短信 + 手机号登录</td></tr><tr><td>POST</td><td>/api/v1/auth/login/using-password</td><td>手机号、用户名、邮箱 + 密码</td></tr><tr><td>POST</td><td>/api/v1/auth/login/refresh-token</td><td>刷下 Token</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-email</td><td>邮件密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/password-reset/using-phone</td><td>短信验证码密码重置</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-phone</td><td>使用手机号注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/using-email</td><td>使用邮箱注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/phone/exist</td><td>手机号是否已注册</td></tr><tr><td>POST</td><td>/api/v1/auth/signup/email/exist</td><td>email 是否已支持</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/phone</td><td>发送短信验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/email</td><td>发送邮件验证码</td></tr><tr><td>POST</td><td>/api/v1/auth/verify-codes/captcha</td><td>获取图片验证码</td></tr><tr><td>GET</td><td>/api/v1/user</td><td>获取当前用户</td></tr><tr><td>GET</td><td>/api/v1/users</td><td>用户列表</td></tr><tr><td>PUT</td><td>/api/v1/users</td><td>修改个人资料</td></tr><tr><td>PUT</td><td>/api/v1/users/email</td><td>修改邮箱</td></tr><tr><td>PUT</td><td>/api/v1/users/phone</td><td>修改手机号</td></tr><tr><td>PUT</td><td>/api/v1/users/password</td><td>修改密码</td></tr><tr><td>PUT</td><td>/api/v1/users/avatar</td><td>上传头像</td></tr><tr><td>GET</td><td>/api/v1/categories</td><td>分类列表</td></tr><tr><td>POST</td><td>/api/v1/categories</td><td>创建分类</td></tr><tr><td>PUT</td><td>/api/v1/categories/:id</td><td>更新分类</td></tr><tr><td>DELETE</td><td>/api/v1/categories/:id</td><td>删除分类</td></tr><tr><td>GET</td><td>/api/v1/topics</td><td>话题列表</td></tr><tr><td>POST</td><td>/api/v1/topics</td><td>创建话题</td></tr><tr><td>PUT</td><td>/api/v1/topics/:id</td><td>更新话题</td></tr><tr><td>DELETE</td><td>/api/v1/topics/:id</td><td>删除话题</td></tr><tr><td>GET</td><td>/api/v1/topics/:id</td><td>获取话题</td></tr><tr><td>GET</td><td>/api/v1/links</td><td>友情链接列表</td></tr></tbody></table></div><h2 id="第三方依赖"><a href="#第三方依赖" class="headerlink" title="第三方依赖"></a>第三方依赖</h2><p>使用到的开源库：</p><ul><li><a href="https://github.com/gin-gonic/gin">gin</a> —— 路由、路由组、中间件</li><li><a href="https://github.com/gin-contrib/zap">zap</a> —— 高性能日志方案</li><li><a href="https://github.com/go-gorm/gorm">gorm</a> —— ORM 数据操作</li><li><a href="https://github.com/spf13/cobra">cobra</a> —— 命令行结构</li><li><a href="https://github.com/spf13/viper">viper</a> —— 配置信息</li><li><a href="https://github.com/spf13/cast">cast</a> —— 类型转换</li><li><a href="https://github.com/go-redis/redis/v8">redis</a> —— Redis 操作</li><li><a href="https://github.com/golang-jwt/jwt">jwt</a> —— JWT 操作</li><li><a href="https://github.com/mojocn/base64Captcha">base64Captcha</a> —— 图片验证码</li><li><a href="https://github.com/thedevsaddam/govalidator">govalidator</a> —— 请求验证器</li><li><a href="https://github.com/ulule/limiter/v3">limiter</a> —— 限流器</li><li><a href="https://github.com/jordan-wright/email">email</a> —— SMTP 邮件发送</li><li><a href="https://github.com/KenmyZhang/aliyun-communicate">aliyun-communicate</a> —— 发送阿里云短信</li><li><a href="https://github.com/mgutz/ansi">ansi</a> —— 终端高亮输出</li><li><a href="https://github.com/iancoleman/strcase">strcase</a> —— 字符串大小写操作</li><li><a href="https://github.com/gertd/go-pluralize">pluralize</a> —— 英文字符单数复数处理</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/bxcodec/faker">faker</a> —— 假数据填充</li><li><a href="https://learnku.com/courses/go-api/1.19/finish-up/github.com/disintegration/imaging">imaging</a> —— 图片裁切</li></ul><h2 id="自定义的包"><a href="#自定义的包" class="headerlink" title="自定义的包"></a>自定义的包</h2><p>现在来看下我们自建的库：</p><ul><li>app —— 应用对象</li><li>auth —— 用户授权</li><li>cache —— 缓存</li><li>captcha —— 图片验证码</li><li>config —— 配置信息</li><li>console —— 终端</li><li>database —— 数据库操作</li><li>file —— 文件处理</li><li>hash —— 哈希</li><li>helpers —— 辅助方法</li><li>jwt —— JWT 认证</li><li>limiter —— API 限流</li><li>logger —— 日志记录</li><li>mail —— 邮件发送</li><li>migrate —— 数据库迁移</li><li>paginator —— 分页器</li><li>redis —— Redis 数据库操作</li><li>response —— 响应处理</li><li>seed —— 数据填充</li><li>sms —— 发送短信</li><li>str —— 字符串处理</li><li>verifycode —— 数字验证码</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>配置信息（使用 Viper，支持 .env 和 config 目录 ）</li><li>API 版本</li><li>API 错误码</li><li>API 限流<ol><li>支持秒、分钟、小时、天级的请求限制</li><li>支持返回 API 请求量标头（限制数，剩余量、重置时间）</li></ol></li><li>注册登录<ol><li>注册<ol><li>判断手机是否注册</li><li>判断 Email 是否注册</li><li>支持手机 + 短信验证码进行注册</li><li>支持使用邮箱注册账号</li></ol></li><li>登录<ol><li>支持手机 + 短信进行登录</li><li>支持密码登录（手机号、Email、用户名任选）</li><li>支持更加安全的 Token Refresh 机制</li></ol></li><li>找回密码<ol><li>支持使用手机 + 短信验证码找回</li><li>支持使用邮箱 + 邮箱验证码找回</li></ol></li></ol></li><li>JWT 授权</li><li>整个应用使用命令行模式（默认运行 web 服务）</li><li>内置命令行（ cobra，对比 cli 和 cobra）<ol><li>key 命令生成 app key</li><li>make 命令<ul><li>make seeder —— 生成数据填充</li><li>make policy —— 生成授权文件</li><li>make apicontroller —— 生成 Restful API 控制器</li><li>make model —— 生成模型文件</li><li>make request —— 生成请求验证文件</li><li>make factory —— 生成模型工厂文件</li><li>make cmd —— 生成自定义命令文件</li><li>make migration —— 生成数据库迁移文件</li></ul></li><li>seed 数据填充<ul><li>seed 所有数据</li><li>seed 单条数据</li><li>支持使用 faker 填充假数据</li><li>支持模型工厂（ factory ）</li></ul></li><li>migrate 数据库迁移<ol><li>up —— 执行迁移</li><li>rollback (down) —— 回滚上一步执行的迁移</li><li>fresh —— 删除所有表，然后执行所有迁移</li><li>reset —— 回滚所有迁移</li><li>refresh —— 回滚所有迁移，然后再执行所有迁移</li></ol></li><li>cache 缓存处理<ul><li>cache clear —— 清除缓存</li><li>cache forget —— 忘记某个 KEY 对应的缓存</li></ul></li></ol></li><li>分页<ol><li>支持返回上下页链接，方便客户端调用</li></ol></li><li>Cache 缓存包<ol><li>支持 redis 缓存</li><li>使用 interface ，支持使用多驱动</li></ol></li><li>Redis 操作</li><li>安全验证码<ol><li>Email （发送邮箱，使用 Mailhog 进行测试）</li><li>手机验证码（发送手机短信）</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>图片验证码，防机器人滥用<ol><li>支持通过配置信息自定义复杂度</li><li>内置 Redis 驱动，以接口方式编写，支持多驱动</li></ol></li><li>日志记录<ol><li>集成 zap 高性能日志库</li><li>支持命令行记录（方便开发时快速定位问题）</li><li>命令行日志高亮</li><li>支持文件记录（多文件和按日期分隔）</li><li>记录 gorm 的 query log</li><li>记录 HTTP 请求 log</li><li>Panic Recovery 中间件</li><li>合理的日志等级（debug, info, error, panic, fatal）</li></ol></li><li>Policy 授权策略结构</li><li>Request 请求验证方案<ol><li>支持 JSON 请求、表单请求、URL Query</li></ol></li><li>API 图片上传</li><li>图片裁切</li><li>数据库支持 mysql 和 sqlite</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于本项目是一个完全只涉及到 API 设计的内容，所以测试功能是否符合预期则是采用了 Postman 这款测试软件，有关 Redis 的可视化则是采用了 Another Redis Desktop Manager。</p><p>考虑到篇幅的问题，项目的知识点总结会分开来写。所以这篇文章是用来提醒我去学习的。 </p><h1 id="Gohub——日志"><a href="#Gohub——日志" class="headerlink" title="Gohub——日志"></a>Gohub——日志</h1><hr><p>title: Gohub——日志<br>abbrlink: 24717<br>date: 2024-04-18 22:50:36<br>categories: Go语言</p><h2 id="tags-项目开发"><a href="#tags-项目开发" class="headerlink" title="tags: 项目开发"></a>tags: 项目开发</h2><p>正经人谁写日记啊？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16c628a43e9b4afb882181cbc6372cfb%7Enoop.image" alt="img"></p><p>欸欸欸，不好意思，来错片场了（手动狗头）。今天介绍的是项目中必不可少的一部分——日志。</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>虽然正经人不写日记，但是正经项目一定要记录日志。总所周知啊，Gohub 就是一个非常正经的项目，虽然还没有到企业级这么高的层次，但是也差不多了。</p><p>在 Gohub 中，我们使用日志来记录整个系统的运行情况，可能但不限于：</p><ul><li>HTTP 请求数据</li><li>数据库 SQL 请求日志</li><li>Panic/Error 错误日志</li><li>请求第三方接口日志（发送短信、发送邮件等）</li><li>……</li></ul><p>好了，是时候掏出祖传的几个问题了，什么是日志？该怎么设置日志？下面将会一一解答。</p><h2 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h2><p>日志系统是一种记录系统活动、事件或消息的工具或机制。在计算机领域，日志系统通常用于记录应用程序、操作系统或者其他软件系统的运行时信息。这些信息可以包括错误、警告、调试信息、用户操作记录等等。</p><p>日志系统的主要目的是帮助开发人员或管理员了解系统的状态和运行情况，以便进行故障排除、性能优化、安全审计等工作。通过分析日志，可以追踪问题的根源，监视系统的健康状况，并且可以在系统发生故障或异常时进行及时的响应和处理。</p><p>日志系统通常具有以下特点：</p><ol><li><strong>可配置性：</strong> 可以根据需求配置日志记录的级别、格式、存储位置等参数。</li><li><strong>实时性：</strong> 能够实时记录系统的运行状态，以便及时发现问题。</li><li><strong>可扩展性：</strong> 能够处理大量的日志数据，并支持水平扩展以应对不断增长的系统负载。</li><li><strong>安全性：</strong> 对日志数据进行安全存储和访问控制，以防止未经授权的访问或篡改。</li><li><strong>分析性：</strong> 提供日志分析工具或接口，帮助用户对日志数据进行搜索、过滤、统计、可视化等操作。</li></ol><p>常见的日志系统包括开源项目如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk、Fluentd等，以及云服务提供商提供的日志管理服务。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>本地开发</strong></p><p>本地开发时，虽然我们可以很方便地使用 Debuger 来调试程序，但是日志将会是我们最廉价】最便捷地作物定位工具。</p><p><strong>线上环境</strong></p><p>日志是程序在生产环境下的健康监控。当程序出错时，或者某块业务逻辑出现问题，我们将依赖日志来知道具体哪一行代码出了问题。</p><p><strong>如何记录？</strong></p><div class="table-container"><table><thead><tr><th>使用环境</th><th>记录的载体</th><th>说明</th></tr></thead><tbody><tr><td>开发环境（local）</td><td>命令行终端</td><td>高亮、打印调用堆栈</td></tr><tr><td>线上环境（production）</td><td>记录到日志文件</td><td>JSON 格式，方便导入专业的日志工具</td></tr></tbody></table></div><p>日志系统在计算机领域有广泛的使用场景，以下是一些常见的应用场景：</p><ol><li><p><strong>故障排查与调试：</strong> 当系统出现错误或异常时，日志可以记录错误信息、异常堆栈跟踪等，帮助开发人员快速定位并修复问题。</p></li><li><p><strong>性能优化：</strong> 通过分析系统的性能日志，可以了解系统各个组件的性能瓶颈，从而进行优化，提升系统整体性能。</p></li><li><p><strong>安全审计与监控：</strong> 日志记录系统的操作、访问权限、安全事件等信息，有助于进行安全审计和监控，及时发现潜在的安全威胁。</p></li><li><p><strong>用户行为分析：</strong> 在网络应用或移动应用中，记录用户的操作行为可以帮助分析用户偏好、行为趋势，从而进行个性化推荐、用户体验优化等工作。</p></li><li><p><strong>合规性需求：</strong> 许多行业或政府监管机构要求企业记录和保留特定类型的数据，日志系统可以满足这些合规性需求，并提供必要的审计跟踪。</p></li><li><p><strong>容灾备份与恢复：</strong> 日志记录系统的备份和恢复功能可以帮助恢复因硬件故障、自然灾害或人为错误导致的数据丢失或损坏。</p></li><li><p><strong>业务分析与决策支持：</strong> 通过分析系统产生的日志数据，可以了解业务运营情况、用户行为趋势等，为业务决策提供数据支持。</p></li><li><p><strong>监控与警报：</strong> 基于日志数据设定监控规则，当系统出现异常或达到预定的阈值时，触发警报并通知相关人员进行处理。</p></li></ol><p>这些场景只是日志系统的一部分应用，实际上日志系统在各个领域都有着重要的作用，帮助保障系统的稳定性、安全性和可靠性。</p><h2 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h2><p>日志系统通常定义了不同的日志等级，用于标识和区分不同类型的日志信息，常见的日志等级包括：</p><div class="table-container"><table><thead><tr><th>日志等级</th><th>说明</th></tr></thead><tbody><tr><td><strong>debug</strong></td><td>信息量大，一般调试时打开。<strong>系统模块详细运行的日志</strong>，例如 HTTP 请求、数据库请求、发送邮件、发送短信</td></tr><tr><td><strong>info</strong></td><td><strong>业务级别的运行日志</strong>，如用户登录、用户退出、订单撤销。</td></tr><tr><td><strong>warn</strong></td><td><strong>感兴趣、需要引起关注的信息。</strong> 例如，调试时候打印调试信息（命令行输出会有高亮）。</td></tr><tr><td><strong>error</strong></td><td><strong>记录错误信息</strong>，用于记录程序发生的错误，这些错误可能导致程序无法正常工作，但不会使程序完全崩溃。Panic 或者 Error。如数据库连接错误、HTTP 端口被占用等。一般生产环境使用的等级。</td></tr></tbody></table></div><p><strong>日志等级规则：</strong></p><ul><li>日志等级在两个地方使用；<ul><li>配置信息（config）中可以配置日志等级；</li><li>代码中调用不同的方法（<code>Debug()</code>、<code>Info()</code>…）记录不同等级的日志。</li></ul></li><li>日志等级具备<strong>过滤信息</strong>的属性；</li><li>配置信息里设置为高等级时，低于这个等级的信息将忽略。如日志等级设为 <strong>warn</strong> ，只有 <code>Warn()</code> 和 <code>Error()</code> 方法记录的日志会有效，<code>Debug()</code> 和 <code>Info()</code> 方法记录的日志会被忽略；</li></ul><h2 id="日志过载"><a href="#日志过载" class="headerlink" title="日志过载"></a>日志过载</h2><p>日志过载是指日志系统产生的日志数量超出了处理能力或存储容量，导致系统无法有效地处理和存储所有的日志信息。这种情况可能会对系统的性能、稳定性和安全性造成负面影响。</p><p>日志过载可能出现在以下几种情况下：</p><ol><li><p><strong>异常情况爆发：</strong> 当系统遭遇大规模的异常或错误时，日志系统可能会产生大量的错误日志，导致日志系统过载。</p></li><li><p><strong>频繁的警告信息：</strong> 如果系统产生大量的警告信息，而这些警告信息又被记录在日志中，就会增加日志系统的负担。</p></li><li><p><strong>日志频率过高：</strong> 如果系统的日志频率过高，比如记录了过多的调试信息或者每个请求都生成了大量的日志记录，就会导致日志系统过载。</p></li><li><p><strong>存储容量不足：</strong> 如果日志系统的存储容量不足以存储所有的日志数据，就会导致部分日志被丢弃或被覆盖，从而丧失了一部分重要的信息。</p></li><li><p><strong>日志记录不当：</strong> 如果日志记录的内容过于冗长或者包含了大量的无关信息，会增加日志系统的负担，导致日志过载。</p></li></ol><p>日志过载可能会导致以下问题：</p><ul><li><strong>性能下降：</strong> 过多的日志记录会占用系统资源，降低系统的性能和响应速度。</li><li><strong>数据丢失：</strong> 如果日志系统无法处理所有的日志数据，部分重要的日志信息可能会被丢弃，导致问题的排查和分析变得困难。</li><li><strong>安全风险：</strong> 日志过载可能会导致系统无法及时记录和响应安全事件，增加系统遭受攻击的风险。</li></ul><p>为了避免日志过载，需要合理配置日志系统的参数，包括日志等级、存储策略、日志格式等，并定期清理和归档历史日志数据，确保日志系统能够有效地处理和存储日志信息。</p><p>记录日志的行为完全掌控在开发者手上。日志等级的错误使用，会导致<strong>日志信息过载</strong>，有违『快速定位问题』的设计初衷。</p><p>所以记录日志时，参与项目的开发者之间需要做好约定，或者说<strong>规范</strong>。</p><ul><li>功能模块的详细运行情况，使用 <code>Debug()</code> 方法，如 HTTP 请求日志、数据库 SQL 日志；</li><li>业务级别的运行日志，使用 <code>Info()</code>，如果信息量太大，例如说一个请求会记录十几条 <code>Info()</code> 日志，要改用 <code>Debug()</code>；</li><li>控制好记录日志的量，切勿滥用，滥用会导致日志信息过载；</li><li>开发调试时，使用 <code>Warn()</code> ，调试完成后记得删除调试信息；</li><li>保持 warn 及以上日志级别的干净；</li><li>线上环境开启 error 等级，接到错误反馈时，再开启 debug 进行调试，调试完成后重新设置为 error 等级，保持线上日志的干净；</li><li>系统运行出错，才能使用 <code>Error()</code> 记录，如数据库连接出错，或出现 500 错误。</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在开发 Go 项目时，我们的项目目录下经常会出现一些文件，例如编译文件、log 文件、编辑器配置文件、系统生成的一些文件，这些文件我们不希望提交到代码仓库中。</p><p>在任何当前工作的 Git 仓库中，每个文件都是这样的：</p><ul><li><strong>追踪的（tracked）</strong>- 这些是 Git 所知道的所有文件或目录。这些是新添加（用 <code>git add</code> 添加）和提交（用 <code>git commit</code> 提交）到主仓库的文件和目录。</li><li><strong>未被追踪的（untracked）</strong> - 这些是在工作目录中创建的，但还没有被暂存（或用 <code>git add</code> 命令添加）的任何新文件或目录。</li><li><strong>被忽略的（ignored）</strong> - 这些是 Git 知道的要全部排除、忽略或在 Git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 Git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。</li></ul><p>所有被忽略的文件都会被保存在一个 <code>.gitignore</code> 文件中。</p><p><code>.gitignore</code> 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。</p><p>在 <code>.gitignore</code> 中，可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。也可以用同样的方法告诉 Git 忽略多个文件或文件夹。</p><h2 id="配置信息的设置"><a href="#配置信息的设置" class="headerlink" title="配置信息的设置"></a>配置信息的设置</h2><p>在项目中，配置信息通常指的是一些参数、选项或设置，这些信息用于指导项目的行为、功能或外部依赖的配置。</p><p>Gohub 中的配置信息，将分为两个层级：</p><ul><li>env</li><li>config</li></ul><h3 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h3><p>一般来讲，项目会运行在多个环境下，例如：</p><ul><li>local —— 本地开发环境（我的机器上、其他开发同事的机器上）</li><li>testing —— 自动化测试环境</li><li>stage —— 接近线上环境的测试环境，方便其他成员访问和测试（编辑人员、产品经理、项目经理）</li><li>production —— 线上生产环境</li></ul><p>不同的环境下，我们将使用不同的配置。例如 local 环境里，发送短信使用的是测试账号，production 环境下，我们将使用验证了公司信息的发信账号。</p><p><code>.env</code> 文件通常用于存储环境变量和敏感配置信息，它的作用包括：</p><ol><li><strong>配置管理：</strong> <code>.env</code> 文件可以用来集中管理项目的配置信息，如数据库连接信息、API 密钥、密码、密钥等。将这些配置信息存储在 <code>.env</code> 文件中有助于统一管理，减少硬编码，提高项目的灵活性和可维护性。</li><li><strong>环境分离：</strong> 使用 <code>.env</code> 文件可以将不同环境（如开发环境、测试环境和生产环境）的配置信息分离开来，避免在代码中硬编码不同环境下的配置，提高代码的可移植性和可重用性。</li><li><strong>安全性：</strong> <code>.env</code> 文件通常位于项目根目录之外，并且可以通过 <code>.gitignore</code> 文件排除在版本控制系统中，从而保护敏感信息不被泄露到公共代码仓库中，提高项目的安全性。</li><li><strong>便捷性：</strong> 通过 <code>.env</code> 文件，可以方便地修改和管理项目的配置信息，无需修改源代码，减少了部署和维护的复杂性。</li><li><strong>跨平台兼容性：</strong> <code>.env</code> 文件的格式通常是简单的键值对格式，易于解析和处理，可以跨多种编程语言和操作系统使用。</li></ol><hr><p>单独的 .env 的设计，是满足一台机器一套环境变量的需求。<strong>多个 .env 文件是满足一台机器上运行多套环境变量的需求</strong>。</p><p>开发时，除了 local 环境变量，很多时候还需要 testing 测试相关的环境变量，testing 的配置有别于 local 。例如测试时，一般需要使用不同的数据库，这样才能不污染我们的开发数据库。</p><p>我们可以利用程序参数，在命令行运行主程序时，传参 <code>--env=testing</code> 的参数，程序接收到这个参数后会读取 <strong>.env.testing</strong> 文件，而不是 <code>.env</code> 文件。</p><p><code>--env</code> 的参数不需要限制值，取到以后直接读取对应的文件即可。以下是几个例子：</p><ul><li><code>--env=testing</code> 读取 <strong>.env.testing</strong> 文件，用以在测试环境使用不同的数据库</li><li><code>--env=production</code> 读取 <strong>.env.production</strong> 文件，用以在本地环境中调试线上的第三方服务配置信息（短信、邮件）</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 是将配置信息存放于 config 目录下，按照单独的逻辑区分单独的配置文件，例如数据库连接信息存放于 config/database.go 文件下。</p><p>config 里加载 .env 里的配置项，且可设置缺省值。</p><p><strong>既然有 .env 文件，为何还要 config 呢？</strong></p><p>config 可以提高配置方案灵活度。在 config 里，我们可以为每个配置项设置默认值。也可以做一些简单的数学运算，或者调用 Go 函数进行默认值的处理。我们甚至可以为配置项设置一个回调函数。</p><p>config 文件是要加入代码版本控制器中的，这些代码是固定的。如果要修改一个 config 配置项，就修改其对应的 .env 文件中的配置项即可。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>本文较短，主要记录了在 Gohub 开发设计日志时学到的相关的知识。其实在这个项目中用户使用的功能并没有什么太大的变化，即使增加了一些功能也都只是一种变式，核心并没有发生太大的变化，因此也就没有像之前一样逐个功能地去记录。那为什么还要去做新的项目呢，主要是因为舍友吧两个教程都买了，白嫖完了第一个肯定要继续白嫖第二个了。</p><p>做完第二个项目发现虽然一个叫 Gohub，一个叫 Goblog，两个看起来好像一样，但是实际开发地体验简直就是天上地下。Goblog 入门项目开发，学习怎么搭建 Web 应用；Gohub 才是真正的后端开发，更加专业，也让我学到了更多的东西。后悔啊，为什么上学期开始学 Go 的时候不好好写项目呢，要不然面试的时候也不会被拷打的那么惨了。不过这两个月确实还是学到了不少东西，比前两年半（没有玩梗，非常认真）加一起的都多了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>传统艺能了，每篇文章都像一个模子里刻出来的，不过本文并没有参考什么文章，只参考了教程和 ChatGPT的回答。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gohub开发&quot;&gt;&lt;a href=&quot;#Gohub开发&quot; class=&quot;headerlink&quot; title=&quot;Gohub开发&quot;&gt;&lt;/a&gt;Gohub开发&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;title: Gohub开发&lt;br&gt;categories: Go语言&lt;br&gt;tags: 项</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741098965071/"/>
    <id>http://example.com/2025/03/04/%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B-%E5%90%88%E5%B9%B6md%E6%96%87%E4%BB%B6-1741098965071/</id>
    <published>2025-03-04T14:36:08.000Z</published>
    <updated>2025-11-22T16:22:37.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言设计哲学"><a href="#Go语言设计哲学" class="headerlink" title="Go语言设计哲学"></a>Go语言设计哲学</h1><hr><p>title: Go语言设计哲学<br>categories: Go语言<br>tags: 随想<br>abbrlink: 29814</p><h2 id="date-2024-04-03-21-16-08"><a href="#date-2024-04-03-21-16-08" class="headerlink" title="date: 2024-04-03 21:16:08"></a>date: 2024-04-03 21:16:08</h2><p>实在是想不到啊，我的博客里面竟然还会出现如此高大上的文章——设计哲学。为什么会想写关于这方面的文章呢，主要还是在跟面试官闲聊的时候提到了这方面的问题。面试还是能学到不少东西的嘛，毕竟我的眼界还是太窄了。</p><p>在学习一门语言时，有没有考虑过这个语言的语法和格式为什么要这么设计？这个问题一听就是一个好的话题啊，为什么这么设计？为什么在已经有了那么多语言后，还要设计出Go语言？</p><p>那么好，闲话少说，这周的主要内容就改为Go语言的设计哲学。当然，文章内容并不是我原创的，更多的还是网上查到的资料。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Go 编程语言构思于 2007 年底，构思的目的是：为了解决在 Google 开发软件基础设施时遇到的一些问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/4b73ae4ab1b1ceb693aad4f978f1f2cc.jpg" alt="Go 语言之父"></p><p>图中的三位大佬就是 Go 语言最初的设计者，从左到右依次为：</p><ul><li>Robert Griesemer：参与过 Google V8 JavaScript 引擎和 Java HotSpot 虚拟机的研发。</li><li>Rob Pike：Unix 操作系统早期开发者之一，UTF-8 创始人之一，Go 语言吉祥物设计者是 Rob Pike 的媳妇。</li><li>Ken Thompson：图灵奖得主，Unix 操作系统早期开发者之一，UTF-8 创始人之一，C 语言（前身 B 语言）的设计者。</li></ul><p>那么好，我们来解释第一个问题，为什么这几个大佬要设计 Go 语言。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>曾经在早期的采访中，Google 大佬们反馈感觉 “编程” 太麻烦了，他们很不喜欢 C++，对于现在工作所用的语言和环境感觉比较沮丧，充满着许多不怎么好用的特性。</p><p>具体遭遇到的问题。如下：</p><ul><li>软件复杂：多核处理器、网络系统、大规模计算集群和网络编程模型所带来的问题只能暂时绕开，没法正面解决。</li><li>软件规模：软件规模也发生了变化，今天的服务器程序由数千万行代码组成，由数百甚至数千名程序员进行工作，而且每天都在更新（据闻 Go 就是在等编译的 45 分钟中想出来的）。</li><li>编译耗时：在大型编译集群中，构建时间也延长到了几分钟，甚至几小时。</li></ul><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>为了解决上述的问题，如果在既有语言上进行修改，需要解决很多根本性的问题，因此，他们决定重新设计一个语言。</p><p>这门新语言需要符合以下需求：</p><ul><li>目的：<strong>设计和开发 Go 是为了使在这种环境下能够提高工作效率</strong>。</li><li>设计：在 Go 的设计上，除了比较知名的方面：如内置并发和垃圾收集。还考虑到：严格的依赖性管理，随着系统的发展，软件架构的适应性，以及跨越组件之间边界的健壮性。</li></ul><p>这门新语言就是现在的 Go。</p><h1 id="Go-在-Google"><a href="#Go-在-Google" class="headerlink" title="Go 在 Google"></a>Go 在 Google</h1><p>Google 整体的应用软件很庞大，硬件也很庞大，有数百万行的软件，服务器主要是 C++ 语言，其他部分则是大量的 Java 和 Python。</p><p>数以千计的工程师在代码上工作，在一个由所有软件组成的单一树的 “头 “ 上工作，所以每天都会对该树的所有层次进行重大改变。一个大型的定制设计的分布式构建系统使得这种规模的开发是可行的，但它仍然很大。当然，所有这些软件都在几十亿台机器上运行，这些机器被视为数量不多的独立、联网的计算集群。</p><p>简而言之，Google 的开发规模很大，速度可能是缓慢的，而且往往是笨拙的。但它是有效的。</p><p>Go 项目的目标是：消除 Google 软件开发的缓慢和笨拙，从而使这个过程更富有成效和可扩展。<strong>这门语言是由编写、阅读、调试和维护大型软件系统的人设计的，也是为他们设计的</strong>。</p><p>因此 Go 的目的不是为了研究编程语言的设计，而是为了改善其设计者及其同事的工作环境。</p><h1 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h1><p>Go 的诞生，更多是为了方便程序员进行编程，而不是为了某项科学研究，这就是 Go 语言与其他编程语言的最大的不同。</p><p>当 Go 发布时，有些人声称它缺少被认为是现代语言的必要条件的特定功能或方法。在缺乏这些设施的情况下，Go怎么可能有价值？</p><p>我们的答案是：<strong>Go 所拥有的特性可以解决那些使大规模软件开发变得困难的问题。</strong></p><p>这些问题包括：</p><ul><li>构建速度缓慢。</li><li>不受控制的依赖关系。</li><li>每个程序员使用不同的语言子集。</li><li>对程序的理解不透彻（代码可读性差，文档不全等）。</li><li>工作的重复性。</li><li>更新的成本。</li><li>版本偏移（version skew）。</li><li>编写自动工具的难度。</li><li>跨语言的构建。</li></ul><p>纯粹一门语言的单个功能并不能解决这些问题，我们需要对软件工程有一个更大的看法。因此在 Go 的设计中，我们试图把重点放在这些问题的解决方案上。</p><h1 id="少即是多"><a href="#少即是多" class="headerlink" title="少即是多"></a>少即是多</h1><p>相信对 Go 语言有过了解的人都会经常听到诸如：less is more、少即是多、大道至简、大道不停地至简等黑话。</p><p>那么少即是多这种观点是谁提起的呢，正是 Go 语言之父的 Rob Pike。</p><p>Rob Pike 在多个场合提到过类似 “少即是多” 的观点，该观点广为流传。这种设计理念体现在 Go 语言的语法设计上，它的语法非常简洁，没有复杂的继承和泛型，也没有异常处理，但这并不影响它的功能性和表达力。</p><p>以下内容多为 Rob Pike 在一次演讲时提到的内容，对此感兴趣的可以去阅读一下 Rob Pike 的 <a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html">Less is exponentially more</a> 演讲稿。</p><h2 id="Go-特性清单"><a href="#Go-特性清单" class="headerlink" title="Go 特性清单"></a>Go 特性清单</h2><ul><li>规范的语法（无需用于解析的符号表）。</li><li>垃圾收集（唯一）。</li><li>没有头文件。</li><li>明确依赖</li><li>无循环依赖。</li><li>常量只能为数字。</li><li>int 和 int32 是不同的类型。</li><li>字母大小写设定可见性。</li><li>任何类型都可以有方法（没有类）。</li><li>没有子类型继承（没有子类）。</li><li>包级别初始化和定义好的初始化顺序。</li><li>文件编译到一个包中。</li><li>包级别的全局表达与顺序无关。</li><li>没有算术转换（常量做了辅助处理）。</li><li>隐式的接口实现（无需“implements”定义）。</li><li>嵌入（没有向父类的升级）。</li><li>方法如同函数一样进行定义（没有特的别位置要求）。</li><li>方法就是函数。</li><li>接口仅仅包含方法（没有数据）。</li><li>方法仅通过名字匹配（而不是通过类型）。</li><li>没有构造或者析构方法。</li><li>后自增和后自减是语句，而不是表达式。</li><li>没有前自增或前自减。</li><li>赋值不是表达式。</li><li>按照赋值、函数调用定义时的顺序执行（没有“sequence point”）。</li><li>没有指针运算。</li><li>内存总是零值初始化。</li><li>对局部变量取地址合法。</li><li>方法没有“this”。</li><li>分段的堆栈。</li><li>没有静态或其他类型注解。</li><li>没有模板。</li><li>没有异常。</li><li>内建 string、slice、map。</li><li>数组边界检查。</li></ul><p>除了这个简化清单和一些未提及的琐碎内容，我相信，Go 相比 C 或者 C++ 是更加有表达力的。少既是多。</p><h2 id="无法想象没有泛型"><a href="#无法想象没有泛型" class="headerlink" title="无法想象没有泛型"></a>无法想象没有泛型</h2><p>当然明显缺少的是类型层次化。</p><p>在 Go 最初的版本中，有人告诉我他无法想像用一个没有泛型范型的语言来工作。就像之前在某些地方提到过的，我认为这绝对是神奇的评论。</p><p>公平的说，他可能正在用其自己的方式来表达非常喜欢 STL 在 C++ 中为他做的事情。在辩论的前提下，让我们先相信他的观点。</p><p>他说编写像 int 列表或 map string 这样的容器是一个无法忍受的负担。我觉得这是个神奇的观点。</p><p>即便是那些没有泛型范型的语言，我也只会花费很少的时间在这些问题上。</p><h2 id="面向对象的方式"><a href="#面向对象的方式" class="headerlink" title="面向对象的方式"></a>面向对象的方式</h2><p>但是更重要的是，他说类型是放下这些负担的解决途径。类型。不是函数多态，不是语言基础，或者其他协助，仅仅用类型。</p><p>这就是卡住我的细节问题。</p><p>从 C++ 和 Java 转过来 Go 的程序员怀念工作在类型上的编程方式，尤其是继承和子类，以及所有相关的内容。可能对于类型来说，我是门外汉，不过我真得从未发现这个模型十分具有表达力。</p><p>我已故的朋友 Alain Fournier 有一次告诉我说他认为学术的最低级形式就是分类。那么你知道吗？类型层次化就是分类。</p><p>你必须对哪块进哪个盒子作出决策，包括每个类型的父级，不论是 A 继承自 B，还是 B 继承自 A。</p><p>一个可排序的数组是一个排序过的数组还是一个数组表达的排序器？如果你坚信所有问题都是由类型驱动设计的，那么你就必须作出决策。</p><p>我相信这样思考编程是荒谬可笑的。核心不是东西之间的祖宗关系，而是它们可以为你做什么。</p><p>当然，这就是接口进入 Go 的地方。但是它们已经是蓝图的一部分，那是真正的 Go 哲学。</p><p>如果说 C++ 和 Java 是关于类型继承和类型分类的，Go 就是关于组合的。</p><p>Unix pipe 的最终发明人 Doug McIlroy 在 1964 (!) 这样写到：</p><blockquote><p>我们应当像连接花园里的龙头和软管一样，用某种方式一段一段的将消息数据连接起来。这同样是 IO 使用的办法。</p></blockquote><p>这也是 Go 使用的办法。Go 用了这个主意，并且将其向前推进了一大步。这是一个关于组合与连接的语言。</p><p>一个显而易见的例子就是接口为我们提供的组合元件的方式。只要它实现了方法 M，就可以放在合适的地方，而不关心它到底是什么东西。</p><p>另一个重要的例子是并发如何连接独立运行的计算。并且也有一个不同寻常（却非常简单）的类型组合模式：嵌入。</p><p>这就是 Go 特有的组合技术，滋味与 C++ 或 Java 程序完全不同。</p><h2 id="为什么-Go-不被-C-程序员喜欢"><a href="#为什么-Go-不被-C-程序员喜欢" class="headerlink" title="为什么 Go 不被 C++ 程序员喜欢"></a>为什么 Go 不被 C++ 程序员喜欢</h2><p>从上面的内容中，我们不难看出，Go 语言的设计者是十分不喜欢使用C++ 进行编程设计的。当然，在 Go 语言被设计并发布后，程序员没有了更多的选择。但是，相较于 C++ 程序员，其他语言的使用者好像更加喜欢 Go 语言。</p><p><strong>为什么 Go，一个被设计为用于摧毁 C++ 的语言，并为并未获得 C++ 程序员的芳心？</strong></p><p>这是因为 Go 和 C++ 有着完全不同的哲学。</p><p><strong>C++ 是让你的指尖解决所有的问题</strong>：</p><ul><li>C++ 与那些巨大增长的特别编写的手工代码相比，具有更加广泛的抽象，优雅、灵活并且零成本的表达能力。</li></ul><p><strong>Go 的主张更多考虑的是最小化程序员的工作量</strong>：</p><ul><li>Go 不是无所不包的。你无法通过内建获得所有东西。你无法精确控制每个细微的执行。</li><li><strong>你得到的是功能强大，但是容易理解的，容易用来构建一些用于连接组合解决问题的模块</strong>。</li><li>这可能最终不像你使用其他语言编写的解决方案那么快，那么精致，在思想体系上那么明确，但它确实会更加容易编写，容易阅读，容易理解，容易维护，并且更加安全。</li></ul><p>换句话说，当然，有些过于简单：</p><ul><li>Python 和 Ruby 程序员：转到 Go 是因为他们并未放弃太多的表达能力，但是获得了性能，并且与并发共舞。</li><li>C++ 程序员：无法转到 Go 是因为他们经过艰辛的战斗才获得对其语言的精确控制能力，而且也不想放弃任何已经获得的东西。对于他们，软件不仅仅是关于让工作完成，而是关于用一个确定的方式完成。</li></ul><h1 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h1><p>本段则是来自《<a href="https://www.youtube.com/watch?v=YXV7sa4oM4I">The Go Programming Language and Environment</a>》这篇演讲稿。</p><p>出身 Google 的 Go 语言严格意义上来说就是出身于名门望族了，那么十多年过去了，它发展地怎么样了？</p><h2 id="Go-怎么样了"><a href="#Go-怎么样了" class="headerlink" title="Go 怎么样了"></a>Go 怎么样了</h2><p>Rob Pike 表示其实 Go 目前还不能算做主流语言，但是在全世界的影响力和发展都大大的超出了预期。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/958c55da2ff41616a0ae6c88bade062a.png" alt="img"></p><p>像在国内的我们，能够很明显感知到，Go 在近 3~5 年的用户群体不断增大，一些大厂也已经开始转 Go ，甚至有的公司就是全部用 Go 语言来进行工作的。</p><p>Go 并不是那种非常 “有趣” 的语言，在技术上（语言理论、设计）几乎没有什么大进步。当然，这也不是 Go 核心团队的设计目标。</p><p>但就是这么一门语言，他主导了大部分 CNCF 中的项目，例如：K8s、Docker 等，特别牛。<strong>Go 是云基础设施的语言，这是怎么发生的</strong>？</p><h2 id="Go-为什么成功"><a href="#Go-为什么成功" class="headerlink" title="Go 为什么成功"></a>Go 为什么成功</h2><p>Go 从一门无人问津的语言，到现在承担了各云基础设施的核心，变得很重要，也是一种成功实践。</p><p>Rob Pike 认为成功的因素有如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/408cea989ce5e27baff2038e2c99377b.png" alt="img"></p><p>核心观点：<strong>一门编程语言的成功取决于其他很多方面，Go 语言是面向软件开发的，而不仅仅只是编程</strong>。</p><p>为此，Go 就是为了解决软件开发而生，而非只是编程，这是成功的关键因素。</p><h1 id="回答面试官的问题"><a href="#回答面试官的问题" class="headerlink" title="回答面试官的问题"></a>回答面试官的问题</h1><p>在最后<strong>回答一下面试官的问题</strong>，不知道还有没有机会了，就在自己的博客里写一下吧。</p><p>问：一个语言在设计时将其语法结构设计成某种特殊的样子，如 Go 语言中花括号必须要和语句在同一行、Python 中使用缩进来替代花括号，这样的设计有什么原因吗？</p><p>答：无论结构怎么设计，对于机器来说都是没有区别的，无论是花括号还是缩进，能影响的就是有人。那么对于设计者来说，设计语言的一些特性主要还是根据他的思路以及设计哲学。</p><p>Python使用缩进替代花括号的原因有以下几种：</p><ul><li>缩进语法，更加优雅</li><li>缩进语法，更加清晰</li><li>使用缩进，保持一致性，避免造成误读</li><li>使用缩进，代码更紧凑，便于浏览，没有累赘</li><li>使用缩进，已足够令解释器执行，没必要使用多余的符号</li><li>强制缩进，源自古老的 ABC 语言，Guido 是这门语言的设计者之一</li><li>其思想可能出自 Don Knuth(高德纳，著名计算机科学家，经典巨著《计算机程序设计艺术》的作者)，他在 1974 年提出，在当时是很时髦和前卫的思想</li><li>使用缩进，可以终结大括号放在函数名后面还是再换一行的终极争论(据说此话题能令不同派系的程序员大打出手！)</li></ul><p>从 Python 发布至今，关于缩进是不是其设计的败笔就一直被大家讨论，我只能说见仁见智。</p><hr><p>对了，还有一个问题，关于我的博客界面左上角一直显示的加载中的字样，已经修复好了。</p><p>至于是怎么修好的，其实到现在我都不知道是哪里出了问题，也找不到类似的情况和解决方法，就只能把前端的美化“恢复出厂设置”了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们大致了解了 Go 语言的开发背景和开发理念。</p><p>当然本文中的大多数内容都是我看到别人的文章以及 Go 语言之父的演讲稿。</p><p>关于更加细节的开发和设计理念，我还在学习当中，后续会根据学习的情况更新文章，Go语言最为重要的并发还没开始，这个系列就肯定不会结束。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://golang3.eddycjy.com/posts/started-go/">https://golang3.eddycjy.com/posts/started-go/</a></li><li><a href="https://zhuanlan.zhihu.com/p/645695890">https://zhuanlan.zhihu.com/p/645695890</a></li><li><a href="https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f">https://xie.infoq.cn/article/1bfe76aefa2d3c7f1f022274f</a></li><li><a href="https://blog.csdn.net/weixin_39915668/article/details/111451430">https://blog.csdn.net/weixin_39915668/article/details/111451430</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go语言设计哲学&quot;&gt;&lt;a href=&quot;#Go语言设计哲学&quot; class=&quot;headerlink&quot; title=&quot;Go语言设计哲学&quot;&gt;&lt;/a&gt;Go语言设计哲学&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;title: Go语言设计哲学&lt;br&gt;categories: Go语言&lt;br&gt;ta</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>顺序存储两兄弟——数组和切片，到底有什么区别？</title>
    <link href="http://example.com/2024/11/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%A4%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2024/11/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%A4%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2024-11-07T05:04:09.000Z</published>
    <updated>2024-11-07T06:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数组是一个长度固定的数据类型，其长度在定义时就已经确定，不能动态改变；切片是一个长度可变的数据类型，其长度在定义时可以为空，也可以指定一个初始长度。</p></blockquote><p>在 Go 语言中，数组和切片看起来很像，但其实它们又有很多的不同之处，这篇文章就来说说他们到底有哪些不同。</p><p>另外，这个问题在面试中也经常会被问到，属于入门级题目，看完文章之后，相信你会有一个很好的答案。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组——一个几乎所有主流语言都支持的数据结构，它是一篇连续的内存区域。Go 语言中的数组和其他语言中的数组有显著不同的特性，例如，其不能进行扩容、在复制和传递时为值复制。开发者通常将数组与 Go 语言中另一个重要的结构——切片进行对比，这个会在后面的部分介绍和对比。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数组是由相同类型的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一味的线性数组，而多维数组在数值和图形计算领域有着比较常见的应用。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c6552fc033d6528426b11992d8ab4166b00234.png" alt="图片"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2019-02-20-3D-array.jpg" alt="3D-array"></p><p>数组作为一种基本的数据结构，我们通常会从两个维度描述一个数组，也就是数组中<strong>存储的元素类型</strong>和数组<strong>最大能存储元素的个数</strong>。</p><p>Go 语言数组在初始化之后大小就无法改变，存储元素类型相同但是大小不同的数组类型在 Go 语言看起来也是完全不同的，只有两个条件都相同才是同一类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">(elem *Type, bound <span class="type">int64</span>)</span></span> *Type &#123;</span><br><span class="line"><span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">Fatalf(<span class="string">&quot;NewArray: invalid bound %v&quot;</span>, bound)</span><br><span class="line">&#125;</span><br><span class="line">t := New(TARRAY)</span><br><span class="line">t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;</span><br><span class="line">t.SetNotInHeap(elem.NotInHeap())</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译期间的数组类型是由上述的 <code>cmd/compile/internal.types.NewArray</code> 函数生成的，该类型包含两个字段，分别是<strong>元素类型 <code>Elem</code></strong> 和<strong>数组大小 <code>Bound</code> </strong>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期间就确定了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Array <span class="keyword">struct</span> &#123;</span><br><span class="line">Elme*Type</span><br><span class="line">    Bound <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">3</span>]<span class="type">int</span>   <span class="comment">// 声明并初始化为默认零值</span></span><br><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;  <span class="comment">// 声明同时初始化</span></span><br><span class="line"><span class="keyword">var</span> nums2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// ...可以表示后面初始化值的长度</span></span><br></pre></td></tr></table></figure><p>前两种声明方式严格意义上来说其实是同一种类型，区别在于是否进行初始化。第三种声明方式是 Go 语言中对于数组的一种语法糖，可以不指定长度，编译器会自动推断，在编译期间就会被转换成前一种。</p><p>下面我们来看一下编译器的推导过程。</p><h3 id="上限推导"><a href="#上限推导" class="headerlink" title="上限推导"></a>上限推导</h3><p>两种不同的声明方式导致编译器做出完全不同的处理，如果使用的是第一种方式，那么变量的类型在编译进行到类型检查阶段就会被提取出来，随后使用 <code>cmd/compile/internal/types.NewArray</code> 创建包含数组大小的 <code>cmd/compile/internal/types.Array</code> 结构体。</p><p>当使用第二种声明方式时，编译器会在 <code>cmd/compile/internal/gc.typecheckcomplit</code> 函数中对该数组的大小进行推导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckcomplit</span><span class="params">(n *Node)</span></span> (res *Node) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != <span class="literal">nil</span> &amp;&amp; n.Right.Left.Op == ODDD &#123;</span><br><span class="line">n.Right.Right = typecheck(n.Right.Right, ctxType)</span><br><span class="line"><span class="keyword">if</span> n.Right.Right.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">elemType := n.Right.Right.Type</span><br><span class="line"></span><br><span class="line">length := typecheckarraylit(elemType, <span class="number">-1</span>, n.List.Slice(), <span class="string">&quot;array literal&quot;</span>)</span><br><span class="line"></span><br><span class="line">n.Op = OARRAYLIT</span><br><span class="line">n.Type = types.NewArray(elemType, length)</span><br><span class="line">n.Right = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line"><span class="keyword">case</span> TARRAY:</span><br><span class="line">typecheckarraylit(t.Elem(), t.NumElem(), n.List.Slice(), <span class="string">&quot;array literal&quot;</span>)</span><br><span class="line">n.Op = OARRAYLIT</span><br><span class="line">n.Right = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个删减后的 <code>cmd/compile/internal/gc.typecheckcomplit</code> 会调用 <code>cmd/compile/internal/gc.typecheckarraylit</code> 通过遍历元素的方式来计算数组中元素的数量。</p><p>所以我们可以看出 <code>[...]T&#123;1, 2, 3&#125;</code> 和 <code>[3]T&#123;1, 2, 3&#125;</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。</p><h3 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <code>cmd/compile/internal/gc.anylit</code> 函数中做两种不同的优化：</p><ol><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">t := n.Type</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line"><span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixedlit(inInitFunction, initKindLocalCode, n, var_, init)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组的元素<strong>小于或者等于四个</strong>时，<code>cmd/compile/internal/gc.fixedlit</code> 会负责在函数编译之前将 <code>[3]&#123;1, 2, 3&#125;</code> 转换成更加原始的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedlit</span><span class="params">(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> splitnode <span class="function"><span class="keyword">func</span><span class="params">(*Node)</span></span> (a *Node, value *Node)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">a, value := splitnode(r)</span><br><span class="line">a = nod(OAS, a, value)</span><br><span class="line">a = typecheck(a, ctxStmt)</span><br><span class="line"><span class="keyword">switch</span> kind &#123;</span><br><span class="line"><span class="keyword">case</span> initKindStatic:</span><br><span class="line">genAsStatic(a)</span><br><span class="line"><span class="keyword">case</span> initKindLocalCode:</span><br><span class="line">a = orderStmtInPlace(a, <span class="keyword">map</span>[<span class="type">string</span>][]*Node&#123;&#125;)</span><br><span class="line">a = walkstmt(a)</span><br><span class="line">init.Append(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组中元素的个数小于或者等于四个并且 <code>cmd/compile/internal/gc.fixedlit</code> 函数接收的 <code>kind</code> 是 <code>initKindLocalCode</code> 时，上述代码会将原有的初始化语句 <code>[3]int&#123;1, 2, 3&#125;</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>但是如果当前数组的元素大于四个，<code>cmd/compile/internal/gc.anylit</code> 会先获取一个唯一的 <code>staticname</code>，然后调用 <code>cmd/compile/internal/gc.fixedlit</code> 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">t := n.Type</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line"><span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">vstat := staticname(t)</span><br><span class="line">vstat.Name.SetReadonly(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">fixedlit(inNonInitFunction, initKindStatic, n, vstat, init)</span><br><span class="line"></span><br><span class="line">a := nod(OAS, var_, vstat)</span><br><span class="line">a = typecheck(a, ctxStmt)</span><br><span class="line">a = walkexpr(a, init)</span><br><span class="line">init.Append(a)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设代码需要初始化 <code>[5]int&#123;1, 2, 3, 4, 5&#125;</code>，那么我们可以将上述过程理解成以下的伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">statictmp_0[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">statictmp_0[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">statictmp_0[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">statictmp_0[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">statictmp_0[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">arr = statictmp_0</span><br></pre></td></tr></table></figure><p>总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入<strong>中间代码生成</strong>和<strong>机器码生成</strong>两个阶段，最后生成可以执行的二进制文件。</p><h2 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h2><p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据。</p><p>数组访问越界时非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，<code>cmd/compile/internal/gc.typecheck1</code> 会验证访问数组的索引：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="type">int</span>)</span></span> (res *Node) &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OINDEX:</span><br><span class="line">ok |= ctxExpr</span><br><span class="line">l := n.Left  <span class="comment">// array</span></span><br><span class="line">r := n.Right <span class="comment">// index</span></span><br><span class="line"><span class="keyword">switch</span> n.Left.Type.Etype &#123;</span><br><span class="line"><span class="keyword">case</span> TSTRING, TARRAY, TSLICE:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> n.Right.Type != <span class="literal">nil</span> &amp;&amp; !n.Right.Type.IsInteger() &#123;</span><br><span class="line">yyerror(<span class="string">&quot;non-integer array index %v&quot;</span>, n.Right)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">x := n.Right.Int64()</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">yyerror(<span class="string">&quot;invalid array index %v (index must be non-negative)&quot;</span>, n.Right)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() &#123;</span><br><span class="line">yyerror(<span class="string">&quot;invalid array index %v (out of bounds for %d-element array)&quot;</span>, n.Right, n.Left.Type.NumElem())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>访问数组的索引是非整数时，报错 “non-integer array index %v”；</li><li>访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)”；</li><li>访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)”；</li></ol><p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误。</p><p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>如果数组作为函数的参数，那么实际传递的是一份数组的拷贝，而不是数组的指针。这也就意味着，在函数中修改数组的元素是不会影响到原始数组的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0383cab49f5ba2bbbb9328165db34f553d0bfa.png" alt="图片"></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><blockquote><p>Go语言中的切片（Slice）在某种程度上和其他语言（例如C语言）中的数组在使用中有许多相似的地方。但是 Go语言中的切片有许多独特之处，例如，切片是长度可变的序列。序列中的每个元素都有相同的类型。一个切片一般写作 []T，其中T代表 Slice 中元素的类型。和数组不同的是，切片不用指定固定长度。</p></blockquote><p>由于数组 Array 的特性，在 Go 代码中适用场景有限，而切片 Slice 会用得非常多。切片 Slice 基于数组，但提供了更高的灵活性，它可以动态地扩容。切片的类型和长度无关。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Slice 的底层数据是数组，Slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 <code>[3]int</code> 和 <code>[4]int</code> 就是不同的类型。</p><p>数组就是一片连续的内存， Slice 实际上是一个结构体，包含三个字段：<strong>长度</strong>、<strong>容量</strong>、<strong>底层数组</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度，实际切片中存储数据的数量</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量，底层数组最多容纳元素的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的 <code>len</code>和 <code>cap</code>函数可以分别获取切片的长度和容量。</p><p>slice 的数据结构如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0.png" alt="切片数据结构"></p><p>注意，底层数组是可以被多个 Slice 同时指向的，因此对一个 Slice 的元素进行操作是有可能影响到其他 Slice 的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241107142015248.png" alt="image-20241107142015248"></p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> slice2 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> slice3 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">slice4 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>切片有长度和容量的区别，可以在初始化时指定。由于切片具有可扩展性，所以当它的容量比长度大时，意味着为切片元素的增长预留了内存空间。</p><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><h2 id="参数传递-1"><a href="#参数传递-1" class="headerlink" title="参数传递"></a>参数传递</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数组是一个长度固定的数据类型，其长度在定义时就已经确定，不能动态改变；切片是一个长度可变的数据类型，其长度在定义时可以为空，也可以指定一个初始长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Go 语言中，数组和切片看起来很像，但其实它们又有很</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>了解基础数据类型</title>
    <link href="http://example.com/2024/10/24/%E4%BA%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2024/10/24/%E4%BA%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-10-24T09:57:13.000Z</published>
    <updated>2024-10-24T10:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>各位码农朋友们，在了解完 Go语言是如何声明变量和常量之后，我们要进行学习的就是变量和常量的类型了。只有真正地了解了这些数据类型的特性以及实现原理，我们才能在后面的编程生活中过的得心应手。</p><h1 id="了解基础数据类型"><a href="#了解基础数据类型" class="headerlink" title="了解基础数据类型"></a>了解基础数据类型</h1><p>Go 是一种强类型语言。 这意味着你声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。</p><p>Go 有<strong>四类数据类型</strong>：</p><ul><li><strong>基本类型</strong>：数字、字符串和布尔值</li><li><strong>聚合类型</strong>：数组和结构</li><li><strong>引用类型</strong>：指针、切片、映射、函数和通道</li><li><strong>接口类型</strong>：接口</li></ul><p>在此模块中，我们仅介绍基本类型（数字类型、布尔类型）的特性、原理以及注意事项。 如果你不知道其他类型是什么，请不要担心。 我们将在后续模块中进行介绍。</p><h1 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h1><div class="table-container"><table><thead><tr><th>类型</th><th>有无符号</th><th>占用存储空间</th><th>表示范围</th><th>备注</th></tr></thead><tbody><tr><td>int8</td><td>有</td><td>1字节</td><td>-2^7 ~ 2^7-1</td><td></td></tr><tr><td>int16</td><td>有</td><td>2字节</td><td>-2^15 ~ 2^15-1</td><td></td></tr><tr><td>int32</td><td>有</td><td>4字节</td><td>-2^31 ~ 2^31-1</td><td></td></tr><tr><td>int64</td><td>有</td><td>8,字节</td><td>-2^63 ~ 2^63-1</td><td></td></tr><tr><td>uint8</td><td>无</td><td>1字节</td><td>0~2^8-1</td><td></td></tr><tr><td>uint16</td><td>无</td><td>2字节</td><td>0~2^16-1</td><td></td></tr><tr><td>uint32</td><td>无</td><td>4字节</td><td>0~2^32-1</td><td></td></tr><tr><td>uint64</td><td>无</td><td>8字节</td><td>0~2^64-1</td><td></td></tr><tr><td>int</td><td>有</td><td>32位系统4字节</td><td>-2^31 ~ 2^31-1</td><td></td></tr><tr><td></td><td></td><td>64位系统8字节</td><td>-2^63 ~ 2^63-1</td><td></td></tr><tr><td>uint</td><td>无</td><td>32位系统4字节</td><td>0 ~ 2^32-1</td><td></td></tr><tr><td></td><td></td><td>64位系统8字节</td><td>0~2^64-1</td><td></td></tr><tr><td>rune</td><td>有</td><td>与int32一样</td><td>-2^31 ~ 2^31-1</td><td>等价int32，表示一个unicode码</td></tr><tr><td>byte</td><td>无</td><td>与uint8一样</td><td>0~2^8-1</td><td>当要存储字符时使用byte</td></tr></tbody></table></div><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>当没有明显指明整数的类型时，Go编译器会自动推断，默认为<code>int</code>。</li><li>使用 <code>int</code> 时，32 位系统上的大小为 32 位，64 位系统上则为 64 位（大多数情况下如此，不过在不同计算机上或有所不同）。 </li><li>如果需要将值表示为无符号数字，则可以使用 <code>uint</code>，但仅当有特定原因时才使用此类型。 此外，Go 还提供 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 类型。</li><li><code>rune</code> 只是 <code>int32</code> 数据类型的别名。 它用于表示 Unicode 字符（或 Unicode 码位）。 </li><li><code>byte</code> 是 <code>uint</code> 数据类型的别名。可以理解为 C语言中的 <code>char</code>，表示 ASCII 字符。</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>这些整数类型在内存中的存储方式其实就是二进制的位表示。比如<code>int8</code>用 8 个位来存储数字，<code>int16</code>用 16 个位，以此类推。这样就可以通过不同的位数来表示不同范围的数字啦。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>大多数情况下，你将使用 <code>int</code>，但需要了解其他整数类型，因为在 Go 中，<code>int</code> 与 <code>int32</code> 不同，即使整数的自然大小为 32 位也是如此。 换句话说，需要强制转换时，你需要进行显式转换。 如果尝试在不同类型之间执行数学运算，将会出现错误。</li><li>在进行整数运算的时候，要注意溢出问题。如果两个很大的<code>int32</code>数字相加，结果可能会超出<code>int32</code>的范围，这时候就会出现奇怪的结果，就像数学考试算错了答案一样尴尬。</li></ul><h1 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h1><div class="table-container"><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表示范围</th></tr></thead><tbody><tr><td>单精度float32</td><td>4字节</td><td>-3.403E38~3.403E38</td></tr><tr><td>双精度float64</td><td>8字节</td><td>-1.798E308~1.798E308</td></tr></tbody></table></div><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul><li><code>float32</code>和<code>float64</code>分别表示 32 位和 64 位的浮点数。<code>float64</code>的精度更高，可以表示更大范围的小数。</li><li>浮点数在计算机中的存储方式可不是精确的哦，就像你用尺子量东西，总是会有一点误差。</li><li>可以使用 <code>math</code> 包中提供的 <code>math.MaxFloat32</code> 和 <code>math.MaxFloat64</code> 常量来查找这两种类型的限制。</li><li>整数部分为 0 时，可以省略不写；小数部分为 0 时，可以省略不写；但是要加上小数点 <code>.</code>。</li></ul><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>浮点数在内存中的存储方式是采用科学计数法的形式。比如一个浮点数可以表示为<code>m × 2^e</code>，其中<code>m</code>是尾数，<code>e</code>是指数。这样就可以用有限的位数来表示很大范围的小数啦。</p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>浮点数的比较可不能直接用<code>==</code>哦，因为浮点数有误差。比如你想判断两个浮点数是否相等，可能会得到错误的结果。正确的做法是比较它们的差值是否在一个很小的范围内。</li><li>在进行浮点数运算的时候，也要注意精度问题。比如多次进行浮点数运算，误差可能会累积，最后得到的结果可能和你预期的不一样。就像你走迷宫，每一步都有点偏差，最后可能就走不到终点啦。</li></ul><h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h1><p>布尔类型只有两个值：<code>true</code>和<code>false</code>。它就像一个黑白分明的小法官，判断事情只有对和错。</p><h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><ul><li>布尔类型非常简单明了，要么是真，要么是假。</li><li>可以用于条件判断、循环控制等地方。</li></ul><h2 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h2><p>布尔类型在内存中可能只占用一个位，0 表示<code>false</code>，1 表示<code>true</code>。不过具体的实现方式取决于编译器和操作系统。</p><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>在 Go 中，不能将布尔类型隐式转换为 0 或 1，必须显式执行此操作。</li><li>布尔类型的赋值要小心哦，别把其他类型的值误赋值给布尔类型。比如把一个整数赋值给布尔类型，那肯定会出问题，就像你把苹果当成橘子吃，味道肯定不对呀！</li><li>在进行布尔运算的时候，要注意逻辑的正确性。比如<code>&amp;&amp;</code>（与）和<code>||</code>（或）的运算顺序，别搞混了，不然程序可能会做出错误的判断。</li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>在 Go 语言中，不同类型之间进行操作需要进行显式的强制转换。</p><ul><li>数字之间可以直接通过 <code>类型(变量名/变量值)</code>实现强制转换；</li><li>字符串和数字之间的转换需要借助 <code>strconv</code> 包来实现；</li></ul><p>不同类型之间的转换可能会出现精度的丢失，需要谨慎使用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 Go语言中，基础的变量类型在使用时需要注意的点并不是很多，这也是其简单特性的体现之一。只有在使用浮点数类型时，需要注意其精度问题，有可能会出现一些奇怪的错误。由于字符串类型(string) 在Go语言中是一个比较特殊的存在，所以后面会单独去分析，这里就不提了，只需要知道字符串是不可更改的即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/yinzhengjie2020/p/12247502.html">Golang的基础数据类型-浮点型</a></li><li><a href="https://www.quanxiaoha.com/golang/golang-data-type-float.html">Go 语言浮点型 (小数类型)</a></li><li><a href="https://zsy-cn.github.io/ch1-07-%E4%BA%86%E8%A7%A3%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html">Go 了解基本数据类型</a></li><li><a href="https://www.cnblogs.com/xiximayou/p/11826991.html">（七）golang—变量之基本数据类型（看这篇就够了）</a></li></ul><p>写完博客不耽误做一个笔试，狗头保命。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;各位码农朋友们，在了解完 Go语言是如何声明变量和常量之后，我们要进行学习的就是变量和常量的类型了。只有真正地了解了这些数据类型的特性以及实现原理，我们才能在后面的编程生活中过的得心应手。&lt;/p&gt;
&lt;h1 id=&quot;了解基础数据类型&quot;&gt;&lt;a href=&quot;#了解基础数据类型&quot; </summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>查询效率最快的数据结构——map</title>
    <link href="http://example.com/2024/10/23/%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9C%80%E5%BF%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94map/"/>
    <id>http://example.com/2024/10/23/%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9C%80%E5%BF%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94map/</id>
    <published>2024-10-23T06:40:53.000Z</published>
    <updated>2024-10-24T09:45:06.000Z</updated>
    
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>特殊的存在——string</title>
    <link href="http://example.com/2024/10/23/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%98%E5%9C%A8%E2%80%94%E2%80%94string/"/>
    <id>http://example.com/2024/10/23/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%98%E5%9C%A8%E2%80%94%E2%80%94string/</id>
    <published>2024-10-23T06:39:48.000Z</published>
    <updated>2024-11-07T04:50:45.000Z</updated>
    
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>命名、声明和赋值</title>
    <link href="http://example.com/2024/10/23/%E5%91%BD%E5%90%8D%E3%80%81%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC/"/>
    <id>http://example.com/2024/10/23/%E5%91%BD%E5%90%8D%E3%80%81%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC/</id>
    <published>2024-10-23T06:35:15.000Z</published>
    <updated>2024-10-24T09:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用 <code>if</code> 和 <code>for</code> 之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。</p><p>在本章中，我们将深入讨论在 Go语言中变量和常量的命名、声明以及赋值方式，学习不同声明方式的区别和使用方法，以及变量和常量的特点。通过简单学习基础的变量和常量的结构来进入 Go语言的世界。此外，关于一些非常细节或者简单的声明要注意的点，在本文中不会显示。</p><h1 id="Go语言是什么类型的语言？"><a href="#Go语言是什么类型的语言？" class="headerlink" title="Go语言是什么类型的语言？"></a>Go语言是什么类型的语言？</h1><p><strong>Go 语言是一个什么类型的语言？强/弱类型、动态/静态检查类型。</strong></p><p>首先需要明确的是，什么是强/弱类型？什么是动态/静态类型？</p><ul><li><strong>强类型：</strong>强类型的编程语言在编译期间会有严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误。</li><li><strong>弱类型：</strong>弱类型的编程语言在出现类型错误时可能会在运行时进行隐式类型转化，这可能会造成运行错误。</li><li><strong>动态检查类型：</strong>静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。</li><li><strong>静态检查类型：</strong>动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性。</li></ul><p>因此，Go 语言是静态强类型语言，同时 Go 语言也是编译型语言。</p><h1 id="如何命名？"><a href="#如何命名？" class="headerlink" title="如何命名？"></a>如何命名？</h1><p><strong>命名规则如下：</strong></p><ul><li>以字母或下划线开头(Go语言中多不以_开头)；</li><li>后面可以是任意数量的字符、数字和下划线；</li><li>区分大小写；</li><li>不能是关键字(关键字具备特定含义)；</li></ul><p><strong>关键字如下：</strong></p><div class="table-container"><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>defer</strong></td><td><strong>go</strong></td><td><strong>map</strong></td><td><strong>struct</strong></td></tr><tr><td><strong>chan</strong></td><td><strong>else</strong></td><td><strong>goto</strong></td><td><strong>package</strong></td><td><strong>switch</strong></td></tr><tr><td><strong>const</strong></td><td><strong>fallthrough</strong></td><td><strong>if</strong></td><td><strong>range</strong></td><td><strong>type</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>for</strong></td><td><strong>import</strong></td><td><strong>return</strong></td><td><strong>var</strong></td></tr></tbody></table></div><ul><li>可以是保留字,但是建议不使用保留字做为变量名；</li></ul><p><strong>保留字如下：</strong></p><div class="table-container"><table><thead><tr><th>true</th><th>false</th><th>iota</th><th>nil</th><th>int</th></tr></thead><tbody><tr><td><strong>int8</strong></td><td><strong>int16</strong></td><td><strong>int32</strong></td><td><strong>int64</strong></td><td><strong>unit</strong></td></tr><tr><td><strong>unit8</strong></td><td><strong>unit16</strong></td><td><strong>unit32</strong></td><td><strong>unitptr</strong></td><td><strong>float32</strong></td></tr><tr><td><strong>float64</strong></td><td><strong>complex128</strong></td><td><strong>complex64</strong></td><td><strong>bool</strong></td><td><strong>byte</strong></td></tr><tr><td><strong>rune</strong></td><td><strong>string</strong></td><td><strong>error</strong></td><td><strong>make</strong></td><td><strong>len</strong></td></tr><tr><td><strong>cap</strong></td><td><strong>new</strong></td><td><strong>append</strong></td><td><strong>copy</strong></td><td><strong>close</strong></td></tr><tr><td><strong>deletecomplex</strong></td><td><strong>real</strong></td><td><strong>imag</strong></td><td><strong>panic</strong></td><td><strong>recover</strong></td></tr></tbody></table></div><ul><li>在同一范围内不允许出现同名变量</li><li>Go语言要求变量声明后至少使用一次(赋值不属于使用)</li></ul><hr><p>Go语言为开发者提供了简单的基础语法，开发者在短期内即可完全掌握这些语法并编写可用于生成环境的代码。本部分将详述在Go基础语法层面有哪些高质量 Go 代码的惯用法和有效实践，内容涵盖变量声明、无类型常量的作用、枚举常量的定义、零值可用类型的意义等。</p><h1 id="使用一致的变量声明形式"><a href="#使用一致的变量声明形式" class="headerlink" title="使用一致的变量声明形式"></a>使用一致的变量声明形式</h1><p>和Python、Ruby等动态脚本语言不同，Go语言沿袭了静态编译型语言的传统：<strong>使用变量之前需要先进行变量的声明</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">13</span></span><br><span class="line">n := <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    crlf       = []<span class="type">byte</span>(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    colonSpace = []<span class="type">byte</span>(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go语言有两类变量：</p><ul><li>包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。</li><li>局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。</li></ul><p>下面来分别说明实现这两类变量在声明形式选择上保持一致性的一些最佳实践。</p><h2 id="包级变量的声明方式"><a href="#包级变量的声明方式" class="headerlink" title="包级变量的声明方式"></a>包级变量的声明方式</h2><p>包级变量只能使用带有 <code>var</code> 关键字的变量声明形式，但在形式细节上仍然有一定的灵活度。我们从生命变量时是否延迟初始化这个角度对包级变量进行一次分类。</p><h3 id="声明并同时显式初始化"><a href="#声明并同时显式初始化" class="headerlink" title="声明并同时显式初始化"></a>声明并同时显式初始化</h3><p>源码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/pipe.go</span></span><br><span class="line"><span class="keyword">var</span> ErrClosedPipe = errors.New(<span class="string">&quot;io: read/write on closed pipe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ErrShortWrite = errors.New(<span class="string">&quot;short write&quot;</span>)</span><br></pre></td></tr></table></figure><p>从上面的源码可以看出，对于声明变量的同时进行显式初始化的这类包级别变量，实践中常常会用到的格式是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableName = InitExpression</span><br></pre></td></tr></table></figure><p>Go 编译器会自动根据等号右侧的 <code>InitExpression</code> 表达式求值的类型确定左侧所声明变量的类型。</p><p>如果 <code>InitExpression</code> 采用的是不带有类型信息的常量表达式，如下面的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>则包级变量会被设置为常量表达式的默认类型：</p><ul><li>以整型值初始化的变量a，Go编译器会将之设置为默认类型<code>int</code>；</li><li>而以浮点值初始化的变量f，Go编译器会将之设置为默认类型<code>float64</code>。</li></ul><p>如果不接受默认类型，而是要显式为包级变量a和f指定类型，那么有以下两种声明方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line"><span class="keyword">var</span> f = <span class="type">float32</span>(<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure><p>从声明一致性的角度出发，Go语言官方更推荐后者，这样就统一了接受默认类型和显式指定类型两种声明形式。尤其是在将这些变量放在一个var块中声明时，我们更青睐这样的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a = <span class="number">17</span></span><br><span class="line">    f = <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而不是下面这种看起来不一致的声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a  = <span class="number">17</span></span><br><span class="line">    f <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="声明但延迟初始化"><a href="#声明但延迟初始化" class="headerlink" title="声明但延迟初始化"></a>声明但延迟初始化</h3><p>对于声明时并不显式初始化的包级变量，我们使用最基本的声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>虽然没有显式初始化，但 Go语言会让这些变量拥有初始的<strong>“零值”</strong>。如果是自定义的类型，<strong>保证其零值可用</strong>是非常必要的。</p><h3 id="声明聚类与就近原则"><a href="#声明聚类与就近原则" class="headerlink" title="声明聚类与就近原则"></a>声明聚类与就近原则</h3><p>Go语言提供 <code>var</code> 块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在 <code>var</code> 块中的声明类型。</p><p>但是我们一般将同一类的变量声明放在一个 <code>var</code> 块中，将不同类的声明放在不同的 <code>var</code> 块中；或者将延迟初始化的变量声明放在一个 <code>var</code> 块中，而将声明并显式初始化的变量放在另一个 <code>var</code> 块中，可以称之为<strong>“声明聚类”</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/http/server.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    bufioReaderPool   sync.Pool</span><br><span class="line">    bufioWriter2kPool sync.Pool</span><br><span class="line">    bufioWriter4kPool sync.Pool</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyBufPool = sync.Pool &#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>*<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;b</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/net/net.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    aLongTimeAgo = time.Unix(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    noDeadline = time.Time&#123;&#125;</span><br><span class="line">    noCancel   = (<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> threadLimit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>关于声明包级变量，或许大家还会有一个新的问题：<strong>是否应当将包级变量的声明全部集中放在源文件头部呢？</strong></p><p>使用静态编程语言的开发人员都知道，变量声明最佳实践中还有一条：<strong>就近原则</strong>，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。</p><h2 id="局部变量的声明方式"><a href="#局部变量的声明方式" class="headerlink" title="局部变量的声明方式"></a>局部变量的声明方式</h2><p>与包级变量相比，局部变量多了一种短变量声明形式，这也是局部变量采用最多的一种声明形式。</p><h3 id="对于延迟初始化的局部变量声明，采用带有-var-关键字的声明形式"><a href="#对于延迟初始化的局部变量声明，采用带有-var-关键字的声明形式" class="headerlink" title="对于延迟初始化的局部变量声明，采用带有 var 关键字的声明形式"></a>对于延迟初始化的局部变量声明，采用带有 var 关键字的声明形式</h3><p>和全局变量类似，看个例子就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = Bar()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于声明且显式初始化的局部变量，建议使用短变量生命形式"><a href="#对于声明且显式初始化的局部变量，建议使用短变量生命形式" class="headerlink" title="对于声明且显式初始化的局部变量，建议使用短变量生命形式"></a>对于声明且显式初始化的局部变量，建议使用短变量生命形式</h3><p>短变量声明形式是局部变量最常用的声明形式，它遍布Go标准库代码。对于接受默认类型的变量，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">17</span></span><br><span class="line">f := <span class="number">3.14</span></span><br><span class="line">s := <span class="string">&quot;hello, gopher!&quot;</span></span><br></pre></td></tr></table></figure><p>同样，Go 编译器会根据右边的数据类型自动推测左边变量的类型，如果没有明显声明，则使用默认类型。</p><p>对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在<code>:=</code>右侧要进行显式转型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line">f := <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">s := []<span class="type">byte</span>(<span class="string">&quot;hello, gopher!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="尽量在分支控制时应用短变量声明形式"><a href="#尽量在分支控制时应用短变量声明形式" class="headerlink" title="尽量在分支控制时应用短变量声明形式"></a>尽量在分支控制时应用短变量声明形式</h3><p>这应该是Go中短变量声明形式应用最广泛的场景了。在编写Go代码时，我们很少单独声明在分支控制语句中使用的变量，而是通过短变量声明形式将其与<code>if</code>、<code>for</code>等融合在一起。</p><p>由于良好的函数/方法设计讲究的是“<strong>单一职责</strong>”，因此每个函数/方法规模都不大，很少需要应用var块来聚类声明局部变量。当然，如果你在声明局部变量时遇到适合聚类的应用场景，你也应该毫不犹豫地使用var块来声明多个局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Resolver)</span></span> resolveAddrList(ctx context.Context, op, network,</span><br><span class="line">                            addr <span class="type">string</span>, hint Addr) (addrList, <span class="type">error</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        tcp      *TCPAddr</span><br><span class="line">        udp      *UDPAddr</span><br><span class="line">        ip       *IPAddr</span><br><span class="line">        wildcard <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>要想做好代码中变量声明的一致性，需要明确要声明的变量是包级变量还是局部变量、是否要延迟初始化、是否接受默认类型、是否为分支控制变量，并结合聚类和就近原则。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241024163145530.png" alt="image-20241024163145530"></p><h1 id="使用无类型常量简化代码"><a href="#使用无类型常量简化代码" class="headerlink" title="使用无类型常量简化代码"></a>使用无类型常量简化代码</h1><p>常量是现代编程语言中最常见的语法元素。在类型系统十分严格的Go语言中，常量还兼具特殊的作用。</p><h2 id="Go常量溯源"><a href="#Go常量溯源" class="headerlink" title="Go常量溯源"></a>Go常量溯源</h2><p>在看 Go语言的常量之前，我们先来回顾一下 C语言中的常量是什么样的。</p><p>在 C语言中，字面量（literal）担负着常量的角色（针对整型值，还可以使用枚举常量）。可以使用整型、浮点型、字符串型、字符型字面值来满足不同场合下对常量的需求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x12345678</span></span><br><span class="line"><span class="number">10086</span></span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line"><span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>为了不让这些魔数（magic number）充斥于源码各处，早期C语言的常用实践是使用宏（macro）定义记号来指代这些字面值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 0x12345678</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMCC_SERVICE_PHONE_NUMBER 10086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WELCOME_TO_GO <span class="string">&quot;Hello, Gopher&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_CHAR <span class="string">&#x27;a&#x27;</span></span></span><br></pre></td></tr></table></figure><p>这种定义“具名字面值”的实践也被称为宏定义常量。虽然后续的 C标准中提供了 <code>const</code> 关键字来定义在程序运行过程中不可改变的变量（又称“只读变量”），但使用宏定义常量的习惯依然被沿袭下来，并且依旧是 C编码中的主流风格。</p><p>宏定义的常量有着诸多不足，比如：</p><ul><li>仅是预编译阶段进行替换的字面值，继承了宏替换的复杂性和易错性；</li><li>是类型不安全的；</li><li>无法在调试时通过宏名字输出常量的值。</li></ul><p>而 C语言中 <code>const</code> 修饰的标识符本质上还是变量，和其他变量一样，编译器不能像对待真正的常量那样对其进行代码优化，也无法将其作为数组声明时的初始长度。</p><p>Go语言是站在 C语言等编程语言的肩膀之上诞生的，它原生提供常量定义的关键字<code>const</code>。<strong>Go语言中的<code>const</code>整合了 C语言中宏定义常量、<code>const</code>只读变量和枚举常量三种形式，并消除了每种形式的不足，使得Go常量成为类型安全且对编译器优化友好的语法元素。</strong>Go中所有与常量有关的声明都通过const来进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/os/file.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY</span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY</span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR</span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面对常量的声明方式仅仅是Go标准库中的少数个例，绝大多数情况下，Go常量在声明时并不显式指定类型，也就是说使用的是无类型常量（untyped constant）。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SeekStart   = <span class="number">0</span></span><br><span class="line">    SeekCurrent = <span class="number">1</span></span><br><span class="line">    SeekEnd     = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>无类型常量是Go语言在语法设计方面的一个“微创新”，也是“追求简单”设计哲学的又一体现，它可以让你的Go代码更加简洁。</p><h2 id="有类型常量带来的烦恼"><a href="#有类型常量带来的烦恼" class="headerlink" title="有类型常量带来的烦恼"></a>有类型常量带来的烦恼</h2><p>Go是对类型安全要求十分严格的编程语言。Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> b myInt = <span class="number">6</span></span><br><span class="line">    fmt.Println(a + b) <span class="comment">// 编译器会给出错误提示：invalid operation: a + b (mismatched  types int and myInt)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，Go 在处理不同类型的变量间的运算时不支持隐式的类型转换。Go 的设计者认为，隐式转换带来的便利性不足以抵消其带来的诸多问题。要解决上面的编译错误，必须进行显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> b myInt = <span class="number">6</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(b)) <span class="comment">// 输出：11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而将有类型常量与变量混合在一起进行运算求值时也要遵循这一要求，即如果有类型常量与变量的类型不同，那么混合运算的求值操作会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = n + <span class="number">5</span>        <span class="comment">// 编译器错误提示：cannot use n + 5 (type myInt) as type  int in const initializer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + n)     <span class="comment">// 编译器错误提示：invalid operation: a + n (mismatched  types int and myInt)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯有进行显式类型转换才能让上面的代码正常工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = <span class="type">int</span>(n) + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(n)) <span class="comment">// 输出：18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有类型常量给代码简化带来了麻烦，但这也是Go语言对类型安全严格要求的结果。</p><h2 id="无类型常量消除烦恼，简化代码"><a href="#无类型常量消除烦恼，简化代码" class="headerlink" title="无类型常量消除烦恼，简化代码"></a>无类型常量消除烦恼，简化代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> myFloat <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j myInt = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> f myFloat = <span class="number">3.1415926</span></span><br><span class="line">    <span class="keyword">var</span> str myString = <span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(j)    <span class="comment">// 输出：5</span></span><br><span class="line">    fmt.Println(f)    <span class="comment">// 输出：3.1415926</span></span><br><span class="line">    fmt.Println(str)  <span class="comment">// 输出：Hello, Gopher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这三个字面值无须显式类型转换就可以直接赋值给对应的三个自定义类型的变量，这等价于下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j myInt = myInt(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> f myFloat = myFloat(<span class="number">3.1415926</span>)</span><br><span class="line"><span class="keyword">var</span> str myString = myString(<span class="string">&quot;Hello, Gopher&quot;</span>)</span><br></pre></td></tr></table></figure><p>但显然之前的无须显式类型转换的代码更为简洁。</p><p>Go的无类型常量恰恰就拥有像字面值这样的特性，该特性使得无类型常量在参与变量赋值和计算过程时无须显式类型转换，从而达到简化代码的目的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a  = <span class="number">5</span></span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line">    s  = <span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line">    c  = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    b  = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> myFloat <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j myInt = a</span><br><span class="line">    <span class="keyword">var</span> f myFloat = pi</span><br><span class="line">    <span class="keyword">var</span> str myString = s</span><br><span class="line">    <span class="keyword">var</span> e <span class="type">float64</span> = a + pi</span><br><span class="line"></span><br><span class="line">    fmt.Println(j)    <span class="comment">// 输出：5</span></span><br><span class="line">    fmt.Println(f)                <span class="comment">// 输出：3.1415926</span></span><br><span class="line">    fmt.Println(str)              <span class="comment">// 输出：Hello, Gopher</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, e, e)  <span class="comment">// float64, 8.1415926</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无类型常量使得Go在处理表达式混合数据类型运算时具有较大的灵活性，代码编写也有所简化，我们无须再在求值表达式中做任何显式类型转换了。</p><p>除此之外，无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为bool、int、int32(rune)、float64、complex128和string。当常量被赋值给无类型变量、接口变量时，常量的默认类型对于确定无类型变量的类型及接口对应的动态类型是至关重要的。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    s = <span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := a</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, n)         <span class="comment">// 输出：int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)         <span class="comment">// 输出：int</span></span><br><span class="line">    i = s</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)         <span class="comment">// 输出：string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-itoa-实现枚举常量"><a href="#使用-itoa-实现枚举常量" class="headerlink" title="使用 itoa 实现枚举常量"></a>使用 itoa 实现枚举常量</h1><p>C家族的主流编程语言（如C++、Java等）都提供定义枚举常量的语法。比如在C语言中，枚举是一个具名的整型常数的集合。下面是使用枚举定义的Weekday类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语法</span></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">    SUNDAY,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    enum Weekday d = SATURDAY;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, d); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言针对枚举类型提供了很多语法上的便利，比如：如果没有显式给枚举常量赋初始值，那么枚举类型的第一个常量的值为0，后续常量的值依次加1。</p><p>与使用define宏定义的常量相比，C编译器可以对专用的枚举类型进行严格的类型检查，使得程序更为安全。</p><p>枚举的存在代表了一类现实需求：有限数量标识符构成的集合，且多数情况下并不关心集合中标识符实际对应的值；注重类型安全。</p><p>与其他C家族主流语言（如C++、Java）不同，Go语言没有提供定义枚举常量的语法。我们通常使用常量语法定义枚举常量，比如要在Go中定义上面的Weekday类型，可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday    = <span class="number">0</span></span><br><span class="line">    Monday    = <span class="number">1</span></span><br><span class="line">    Tuesday   = <span class="number">2</span></span><br><span class="line">    Wednesday = <span class="number">3</span></span><br><span class="line">    Thursday  = <span class="number">4</span></span><br><span class="line">    Friday    = <span class="number">5</span></span><br><span class="line">    Saturday  = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果仅仅能支持到这种程度，那么Go就算不上是“站在巨人的肩膀上”了。Go的<code>const</code>语法提供了“隐式重复前一个<strong>“非空表达式”</strong>的机制，来看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape</span><br><span class="line">    Pear, Watermelon</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量定义的后两行没有显式给予初始赋值，Go编译器将为其隐式使用第一行的表达式，这样上述定义等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不过这显然仍无法满足枚举的要求，Go在这个机制的基础上又提供了神器iota。有了iota，我们就可以定义满足各种场景的枚举常量了。</p><p><code>iota</code>是 Go语言的一个预定义标识符，它表示的是<code>const</code>声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的<code>iota</code>自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。下面是Go标准库中<code>sync/mutex.go</code>中的一段枚举常量的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/sync/mutex.go (go 1.12.7)</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span><span class="comment">//1</span></span><br><span class="line">    mutexWoken<span class="comment">//2</span></span><br><span class="line">    mutexStarving<span class="comment">//4</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span><span class="comment">//3</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span><span class="comment">//1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 的本质：它仅代表常量声明的索引，所以它会表示出以下<strong>特征</strong>：</p><ul><li>单个 const 声明块中从 0 开始取值；</li><li>单个 const 声明块中，每增加一行声明，iota 的取值增 1，即便声明中没有使用 iota 也是如此；</li><li>单行声明语句中，即便出现多个 iota，iota 的取值也保持不变。</li></ul><p>iota的加入让Go在枚举常量定义上的表达力大增，主要体现在如下几方面：</p><ol><li>iota预定义标识符能够以更为灵活的形式为枚举常量赋初值；</li><li>Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量；</li><li>iota使得维护枚举常量列表更容易；</li><li>使用有类型枚举常量保证类型安全；</li></ol><h1 id="尽量定义零值可用的类型"><a href="#尽量定义零值可用的类型" class="headerlink" title="尽量定义零值可用的类型"></a>尽量定义零值可用的类型</h1><blockquote><p>保持零值可用。——Go谚语</p></blockquote><p>在Go语言中，零值不仅在变量初始化阶段避免了变量值不确定可能带来的潜在问题，而且定义零值可用的类型也是Go语言积极倡导的最佳实践之一，就像上面那句Go谚语所说的那样。</p><h2 id="Go-语言中的零值"><a href="#Go-语言中的零值" class="headerlink" title="Go 语言中的零值"></a>Go 语言中的零值</h2><p>在使用 C语言进行开发时，我们不难发现一个问题，在声明一个变量但没有显式初始化时，它的值是不确定的。即<strong>未被显式初始化且具有自动存储持续时间的对象，其值是不确定的。</strong></p><p>Go 语言的选择却恰恰相反，<strong>当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值</strong>。</p><p>Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）：</p><ul><li>整型类型：0</li><li>浮点类型：0.0</li><li>布尔类型：false</li><li>字符串类型：””</li><li>指针、interface、切片（slice）、channel、map、function：nil</li><li>另外，Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</li></ul><h2 id="零值可用"><a href="#零值可用" class="headerlink" title="零值可用"></a>零值可用</h2><p>当我们申明了一个变量，但是未对其进行显示初始化时，go语言编译器就会把该变量置为默认零值，且可以直接使用该变量。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span>              </span><br><span class="line">fmt.Println(a)</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">6</span>)</span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/be08366185f042319777d3bb24f6b064%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p><p>但是不能直接对<strong>切片</strong>进行赋值操作这样会出现错误，同样的还有<strong>map</strong>。</p><h2 id="零值可用的好处"><a href="#零值可用的好处" class="headerlink" title="零值可用的好处"></a>零值可用的好处</h2><ul><li>开箱即用：Go语言零值让程序变得简单了，有些场景我们不需要初始化变量就可以直接进行使用。 例如上面的slice、map还有基础类型。</li><li>方法的归纳：利用零值可用的特性，我们可以通过定义一个空的结构体，配合空结构体方法接收者属性，将一些方法组合起来，在业务代码中便于后续的拓展和维护。</li><li>标准库中可以不显示初始化：在GO标准库和运行时代码中,典型的零值可用：<code>sync.Mutex</code> 和 <code>bytes.Buffer</code>。</li></ul><p>零值可用的类型要注意尽量避免值复制。</p><h1 id="使用复合字面值作为初值构造器"><a href="#使用复合字面值作为初值构造器" class="headerlink" title="使用复合字面值作为初值构造器"></a>使用复合字面值作为初值构造器</h1><p>在上一条中，我们了解到零值可用对于编写出符合Go惯用法的代码是大有裨益的。</p><p>但有些时候，零值并非最好的选择，我们有必要为变量赋予适当的初值以保证其后续以正确的状态参与业务流程计算，尤其是Go语言中的一些复合类型的变量。</p><p>Go语言中的复合类型包括结构体、数组、切片和map。对于复合类型变量，最常见的值构造方式就是对其内部元素进行逐个赋值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s myStruct</span><br><span class="line">s.name = <span class="string">&quot;tony&quot;</span></span><br><span class="line">s.age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">13</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">14</span></span><br><span class="line">...</span><br><span class="line">a[<span class="number">4</span>] = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">sl[<span class="number">0</span>] = <span class="number">23</span></span><br><span class="line">sl[<span class="number">1</span>] = <span class="number">24</span></span><br><span class="line">...</span><br><span class="line">sl[<span class="number">4</span>] = <span class="number">27</span></span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;gopher&quot;</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure><p>但这样的值构造方式让代码显得有些烦琐，尤其是在构造组成较为复杂的复合类型变量的初值时。Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。上述代码可以使用复合字面值改写成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;<span class="string">&quot;tony&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;</span><br><span class="line">sl := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;<span class="number">1</span>:<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>:<span class="string">&quot;gopher&quot;</span>, <span class="number">3</span>:<span class="string">&quot;!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>显然，最初的代码得到了大幅简化。</p><p>复合字面值由两部分组成：一部分是<strong>类型</strong>，比如上述示例代码中赋值操作符右侧的<code>myStruct</code>、<code>[5]int</code>、<code>[]int</code>和<code>map[int]string</code>；另一部分是由<strong>大括号<code>&#123;&#125;</code>包裹的字面值</strong>。这里的字面值形式仅仅是Go复合字面值作为值构造器的基本用法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 Go 语言中，变量和常量是非常重要的概念。变量用于存储可以在程序运行过程中被修改的数据，而常量用于存储在程序的整个生命周期中都不会改变的数据。通过不同的声明方式，可以方便地声明和初始化变量和常量。在使用变量和常量时，需要注意它们的作用域和特点，以确保程序的正确性和可读性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_27870421/article/details/118493425">Go 语言变量声明和赋值</a></li><li><a href="https://juejin.cn/post/7081885129978675236">Go 零值可用类型</a></li><li><a href="https://www.cnblogs.com/lianshuiwuyi/p/17828972.html">理解 Go 中的零值</a></li></ul><p>难得有一两天没什么笔试和面试的事情，还是要好好整理一下最近学习的内容，但是翻过来覆过去又好像一直都是这些东西。但是这些内容又是常看常新，还是边复习就内容边学习新内容吧。如果时间合适的话，还是想最近一段时间学一学关于测试开发相关的东西。</p><p>加油，祝我面试顺利！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; 之类的控制语句来组织和</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>傻傻分不清之Cookie、Session、Tokenb和JWT</title>
    <link href="http://example.com/2024/10/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Tokenb%E5%92%8CJWT/"/>
    <id>http://example.com/2024/10/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Tokenb%E5%92%8CJWT/</id>
    <published>2024-10-21T13:08:06.000Z</published>
    <updated>2024-10-24T16:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是无状态的协议，对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。</p><p>每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><p>本文将要介绍常见的实现用户身份认证的几种方式、优缺点以及如何取舍，希望能够通过本文对实际的项目设计和计算机网络都有一些新的认识。</p><h1 id="什么是认证（Authentication）？"><a href="#什么是认证（Authentication）？" class="headerlink" title="什么是认证（Authentication）？"></a>什么是认证（Authentication）？</h1><p>认证是验证用户身份的过程。它确保试图访问系统或资源的用户是他们所声称的那个人。</p><p>通俗地讲就是<strong>验证当前用户的身份</strong>，证明”你是你自己“（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）。</p><p>在 <strong>Web 应用</strong>中，认证通常通过用户提供的凭据（如用户名和密码）来完成。当用户提交这些凭据时，系统会验证它们是否与存储在数据库中的信息匹配。如果匹配成功，用户就被认证为合法用户，可以继续访问应用的特定部分或执行特定操作。</p><ul><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li><li>只要你能收到邮箱/验证码，就默认你是账号的主人</li></ul><h1 id="什么是授权（Authorization）？"><a href="#什么是授权（Authorization）？" class="headerlink" title="什么是授权（Authorization）？"></a>什么是授权（Authorization）？</h1><p>授权是在认证用户身份后，确定用户具有哪些权限来访问资源或执行操作的过程。假设你通过了门禁进入大楼，但不同的楼层和房间可能有不同的访问权限。你可能被授权进入某些办公室，但不能进入限制区域。</p><p>在 Web 应用中，授权决定了用户可以访问哪些页面、执行哪些功能（如创建、读取、更新或删除数据）。它基于用户的角色、组或其他属性来分配权限。</p><ul><li><p><strong>用户授予第三方应用访问该用户某些资源的权限</strong></p><ul><li><p>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</p></li><li><p>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</p></li></ul></li><li><p>实现授权的方式有：cookie、session、token、OAuth</p></li></ul><h1 id="什么是凭证（Credentials）？"><a href="#什么是凭证（Credentials）？" class="headerlink" title="什么是凭证（Credentials）？"></a>什么是凭证（Credentials）？</h1><p><strong>实现认证和授权的前提</strong>是需要一种<strong>媒介（证书）</strong> 来标记访问者的身份</p><ul><li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</li><li>在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是<strong>认证的凭证。</strong></li><li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li></ul><p>最常见的凭证类型是用户名和密码组合。当用户在登录页面输入这些信息时，它们被发送到服务器进行验证。其他类型的凭证还包括数字证书、生物识别信息（如指纹、面部识别等）。凭证就像是打开 Web 应用资源大门的钥匙，只有拥有正确凭证的用户才能获得访问权限。</p><h1 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h1><ul><li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong>                                                                                      - 如果值为 Unicode 字符，需要为字符编码。                                                                                                                      - 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong>。                                                                                                           如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。                                                                                                                                                                                                     - <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。                                                                                                      一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。                                                                                                                                                                                         当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。</td></tr></tbody></table></div><h2 id="Cookie-的工作原理"><a href="#Cookie-的工作原理" class="headerlink" title="Cookie 的工作原理"></a>Cookie 的工作原理</h2><p>当用户首次访问一个 Web 应用时，如果用户进行了登录等认证操作，服务器会在响应中设置一个 Cookie，其中可能包含用户的标识符或其他相关信息。浏览器会将这个 Cookie 存储在本地。在后续的请求中，浏览器会自动在请求头中携带这个 Cookie，服务器就可以通过读取 Cookie 来识别用户身份，从而实现无需每次都重新输入用户名和密码的便捷登录体验。</p><p>例如，当你在一个电商网站上登录后，下次再访问该网站时，它可能会自动识别你并显示你的用户名，这就是 Cookie 在起作用。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点<ul><li><strong>状态保持</strong>：能够在用户和服务器之间保持状态，使得用户在浏览网站的不同页面时，服务器能够识别用户身份，提供连贯的体验。</li><li><strong>简单易用</strong>：浏览器自动处理 Cookie 的发送和接收，对于开发者来说使用相对简单。</li></ul></li><li>缺点<ul><li><strong>安全性问题</strong>：Cookie 存储在客户端，如果被攻击者窃取，可能会导致用户信息泄露。例如，通过恶意软件或网络钓鱼攻击获取用户的 Cookie，攻击者就可以冒充用户访问网站。</li><li><strong>存储限制</strong>：浏览器对 Cookie 的存储大小有限制，一般每个域名下的 Cookie 存储量不能超过几 KB 到几十 KB，这限制了它能存储的信息量。</li></ul></li></ul><h1 id="什么是-Session？"><a href="#什么是-Session？" class="headerlink" title="什么是 Session？"></a>什么是 Session？</h1><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li></ul><h2 id="Session-的工作原理"><a href="#Session-的工作原理" class="headerlink" title="Session 的工作原理"></a>Session 的工作原理</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16f523a04d0b3cf5%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="session.png"></p><p><strong>session 认证流程：</strong></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点<ul><li><strong>安全性相对较高</strong>：因为关键信息存储在服务器端，相比于 Cookie，不容易被直接窃取。用户只能通过合法的认证方式获取 Session 中的信息。</li><li><strong>可存储大量数据</strong>：服务器端的存储限制相对较少，可以存储更丰富的用户信息。</li></ul></li><li>缺点<ul><li><strong>服务器资源消耗</strong>：每个活跃的 Session 都需要占用服务器的内存等资源。如果有大量用户同时访问，可能会对服务器性能产生一定影响。</li><li><strong>跨设备使用不便</strong>：Session 通常与特定的浏览器会话相关联，如果用户在不同设备上访问应用，需要重新进行认证来创建新的 Session，不像 Cookie 可以在不同设备上共享一些基本的用户状态信息（当然，这也有一定的安全风险）。</li></ul></li></ul><h1 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h1><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h1 id="什么是-Token（令牌）？"><a href="#什么是-Token（令牌）？" class="headerlink" title="什么是 Token（令牌）？"></a>什么是 Token（令牌）？</h1><h2 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h2><p><strong>访问资源接口（API）时所需要的资源凭证</strong></p><p><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p><p><strong>特点：</strong></p><ul><li><strong>服务端无状态化、可扩展性好</strong></li><li><strong>支持移动端设备</strong></li><li>安全</li><li>支持跨程序调用</li></ul><p><strong>token 的身份验证流程：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16f523a04d9c745f%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="img"></p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p>另外一种 token——refresh token</p><p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16f523a04d1c887b%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="img"></p><ul><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li></ul><h1 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h1><ul><li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></li><li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></li><li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：<strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></li></ul><h1 id="什么是-JWT？"><a href="#什么是-JWT？" class="headerlink" title="什么是 JWT？"></a>什么是 JWT？</h1><ul><li>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</li><li>是一种<strong>认证授权机制</strong>。</li><li>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（<a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7519">RFC 7519</a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li><li>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</li></ul><h2 id="跨域认证的问题"><a href="#跨域认证的问题" class="headerlink" title="跨域认证的问题"></a>跨域认证的问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">  <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241024235121072.png" alt="image-20241024235121072"></p><p>实际的 JWT 大概就像下面这样。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241025001244440.png" alt="image-20241025001244440"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p>写成一行，就是下面的样子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Header</span>.<span class="property">Payload</span>.<span class="property">Signature</span></span><br></pre></td></tr></table></figure></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241025001315468.png" alt="image-20241025001315468"></p><ul><li><p>Header</p><ul><li>一个 JSON 对象，描述 JWT 的元数据，通常包含：<ul><li><code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；</li><li><code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</li></ul></li><li>最后将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</li></ul></li><li><p>Payload</p><ul><li>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。</li><li>JWT 规定了7个官方字段，供选用：<ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li><li>除了官方字段，还可以在这个部分定义私有字段。</li><li>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</li><li>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</li></ul></li><li><p>Signature </p><ul><li><p>Signature 部分是对前两部分的签名，防止数据篡改。</p></li><li><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p></li><li><pre><code>HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（`.`）分隔，就可以返回给用户。</span><br><span class="line"></span><br><span class="line">&gt; 前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</span><br><span class="line">&gt;</span><br><span class="line">&gt; JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。这就是 Base64URL 算法。</span><br><span class="line"></span><br><span class="line">## 使用方式</span><br><span class="line"></span><br><span class="line">客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</span><br><span class="line"></span><br><span class="line">此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。</span><br><span class="line"></span><br></pre></td></tr></table></figure>Authorization: Bearer &lt;token&gt;</code></pre></li></ul></li></ul><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ol><h1 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a>Token 和 JWT 的区别</h1><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><h1 id="常见的前后端鉴权方式"><a href="#常见的前后端鉴权方式" class="headerlink" title="常见的前后端鉴权方式"></a>常见的前后端鉴权方式</h1><ol><li>Session-Cookie</li><li>Token 验证（包括 JWT，SSO）</li><li>OAuth2.0（开放授权）</li></ol><h1 id="常见的加密算法"><a href="#常见的加密算法" class="headerlink" title="常见的加密算法"></a>常见的加密算法</h1><ul><li>哈希算法(Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。</li><li>哈希算法主要用来保障数据真实性(即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。</li><li>哈希算法通常有以下几个特点：<ul><li>正像快速：原始数据可以快速计算出哈希值</li><li>逆向困难：通过哈希值基本不可能推导出原始数据</li><li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大</li><li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：<ul><li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别</li><li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别</li><li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方</li></ul></li></ul></li></ul><p><strong>注意：</strong></p><ol><li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用RSA 公钥私钥方案，再配合哈希值。</li><li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="使用-Cookie-时需要考虑的问题"><a href="#使用-Cookie-时需要考虑的问题" class="headerlink" title="使用 Cookie 时需要考虑的问题"></a>使用 Cookie 时需要考虑的问题</h2><ul><li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li><li>不要存储敏感数据，比如用户密码，账户余额</li><li>使用 httpOnly 在一定程度上提高安全性</li><li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，减少数据传输</li><li><strong>cookie 无法跨域</strong></li><li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h2 id="使用-Session-时需要考虑的问题"><a href="#使用-Session-时需要考虑的问题" class="headerlink" title="使用 Session 时需要考虑的问题"></a>使用 Session 时需要考虑的问题</h2><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用<strong>集群部署</strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h2 id="使用-token-时需要考虑的问题"><a href="#使用-token-时需要考虑的问题" class="headerlink" title="使用 token 时需要考虑的问题"></a>使用 token 时需要考虑的问题</h2><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li><li><strong>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</strong></li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h2 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h2><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><h2 id="使用加密算法时需要考虑的问题"><a href="#使用加密算法时需要考虑的问题" class="headerlink" title="使用加密算法时需要考虑的问题"></a>使用加密算法时需要考虑的问题</h2><ul><li>绝不要以<strong>明文存储</strong>密码</li><li><strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码</strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li><li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</li><li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 <strong>一次性的</strong>（这点很重要）密码，然后把这个密码发送给用户。</li></ul><h2 id="分布式架构下-session-共享方案"><a href="#分布式架构下-session-共享方案" class="headerlink" title="分布式架构下 session 共享方案"></a>分布式架构下 session 共享方案</h2><h3 id="session-复制"><a href="#session-复制" class="headerlink" title="session 复制"></a>session 复制</h3><p>任何一个服务器上的 session 发生改变，该节点会把这个 session 的所有内容序列化，然后广播给所有其他节点，不管其他服务需不需要 session，以此来保证 session 同步。</p><ul><li><strong>优点：</strong> 可容错，各个服务器间 session 能够实时响应。</li><li><strong>缺点：</strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。</li></ul><h3 id="粘性-session-IP-绑定策略"><a href="#粘性-session-IP-绑定策略" class="headerlink" title="粘性 session/IP 绑定策略"></a>粘性 session/IP 绑定策略</h3><p><strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。</strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</p><ul><li><strong>优点：</strong> 简单，不需要对 session 做任何处理。 </li><li><strong>缺点：</strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。 </li><li><strong>适用场景：</strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。</li><li><strong>实现方式：</strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</li></ul><h3 id="session-共享（常用）"><a href="#session-共享（常用）" class="headerlink" title="session 共享（常用）"></a>session 共享（常用）</h3><ul><li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群</li><li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：<ul><li>实现了 session 共享；</li><li>可以水平扩展（增加 Redis 服务器）；</li><li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新/失效机制）；</li><li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16f523a04fb8b4b8%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="img"></p><h3 id="session-持久化"><a href="#session-持久化" class="headerlink" title="session 持久化"></a>session 持久化</h3><p>将 session 存储到数据库中，保证 session 的持久化</p><ul><li><strong>优点：</strong> 服务器出现问题，session 不会丢失</li><li><strong>缺点：</strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</li></ul><h2 id="只要关闭浏览器，session-真的就消失了？"><a href="#只要关闭浏览器，session-真的就消失了？" class="headerlink" title="只要关闭浏览器，session 真的就消失了？"></a>只要关闭浏览器，session 真的就消失了？</h2><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。</p><p>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 sessionid，而关闭浏览器后这个 sessionid 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。</p><p>恰恰是<strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 Web 开发中，我们需要根据具体的应用场景和需求来选择合适的认证和授权机制以及相关的凭证技术。Cookie、Session、Token 和 JWT 都有各自的特点和适用范围，理解它们的工作原理和优缺点，能够帮助我们构建更安全、高效和用户友好的 Web 应用程序。无论是为了保护用户数据安全，还是提供流畅的用户体验，这些技术都在现代 Web 开发中发挥着不可或缺的作用。希望通过这篇文章，你对它们有了更深入的了解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844904034181070861">傻傻分不清之 Cookie、Session、Token、JWT</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a></li><li><a href="https://blog.csdn.net/tianpengfei123/article/details/127589638">Web应用中用户身份认证</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTTP 是无状态的协议，对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。&lt;/p&gt;
&lt;p&gt;每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Go语言创世纪</title>
    <link href="http://example.com/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
    <id>http://example.com/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/</id>
    <published>2024-10-19T07:02:08.000Z</published>
    <updated>2024-12-21T14:22:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>到今天，笔者学习 Go 语言也差不多有一年了，好像都没有认真地了解过 Go 语言的前世今生以及为什么要学习 Go 语言。不如趁着这个机会，好好地了解一下 Go 语言的特点吧。</p><p>本部分分为全书的开篇，在本部分中，笔者将和读者一起穿越时空，回顾历史，详细了解 Go 语言的诞生、演进以及今天的发展，归纳总结 Go 语言的设计哲学；和读者一起站在语言设计者的高度去理解 Go 语言与众不同的设计，深刻体会 Go 设计者在那些看似陈旧、实则经过深思熟虑的设计上的付出。</p><p>希望经过本部分的学习，读者能够在更改层次上与 Go 语言的设计者形成共鸣，产生认同感。或许这种认同会在你后续的 Go 语言的学习和精进之路持续激发你的 Go 语言学习和精进之路上持续激发你的热情，帮助你快速领悟Go语言原生编程思维，并更快、更好地达成编写出高质量 Go 代码的目标。</p><p>或者你可以在阅读本文时先想一想下面三个问题：</p><ol><li>为什么会出现 Go 语言？</li><li>Go 语言的设计哲学是什么？</li><li>Go 语言与 C++、Java 有什么区别？特性是什么？</li></ol><h1 id="Go-语言的出现和发展"><a href="#Go-语言的出现和发展" class="headerlink" title="Go 语言的出现和发展"></a>Go 语言的出现和发展</h1><p>Go语言诞生于何时？它的最初设计者是谁？它为什么被命名为Go？它的设计目标是什么？它如今发展得怎么样？带着这些问题，我们一起穿越时空，回到2007年9月Go语言诞生的那一历史时刻吧。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Go 语言（也称为 Golang）是一种由 Google 开发的开源编程语言。</p><p>过去，许多开发者在使用 C++ 来开发大型的服务端软件时，由于二进制文件一般都非常大，需要耗费大量的时间在编译文件上，同时编程语言的设计思想也已经非常陈旧，这些情况都充分表明了现有的编程语言已不符合时下的生产环境。</p><p>学者们坐下来总结出了现在生产环境与软件开发之间的主要矛盾，并尝试设计一门全新的编程语言来解决这些问题。他们讨论得出的对编程语言的设计要求：</p><ul><li>能够以更快的速度开发软件</li><li>开发出的软件能够很好地在现代的多核计算机上工作</li><li>开发出的软件能够很好地在网络环境下工作</li><li>使人们能够享受软件开发的过程</li></ul><p>Go 语言就在这样的环境下诞生了，它的主要目标是“兼具 Python 等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性”。</p><p>Go 语言出现的目的是在编程领域中创造出最实用的方式来进行软件开发。它并不是要用奇怪的语法或晦涩难懂的概念来从根本上推翻已有的编程语言，而是重建并改善了 C、C#、Java 中的许多语法风格。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Go 语言的起源可以追溯到 2007 年。</p><p>在 2007 年的时候，谷歌开发工作的规模与正在部署的生产系统规模暴增，需要有个好的解决方案应对这些挑战。</p><p>当时 Robert Griesemer、Rob Pike 和 Ken Thompson 都是用的 C++，编译一个分布式集群大概要花费 45 分钟，这个过程让三个人都很难以忍受。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhCkP.jpg" alt="XKCD 中的一幅漫画"></p><p>2007 年 9 月 20 日星期四下午，在等待编译的时候 Rob Pike 把 Robert Griesemer 和 Ken Thompson 喊到一起决定要做些什么：<strong>他们不想永远使用 C++，并且想要很好处理并发的问题</strong>。希望创造一个能够摒弃其他语言的缺点的新语言，保持静态类型和运行时效率、具有可读性和可用性、具备高性能网络和并发处理。</p><p>Go 这个名字是 Rob Pike 取的，认为它很短、易于输入，非常合适这一新语言的特性。</p><p>最初的一周内，他们就讨论出来了很多 Go 语言的风格和特性，并着手开发。</p><p>经过两年的努力，于 2009 年 11 月，Google 宣布了 Go 语言的首个公开发布版本，即 Go 1。</p><p><img src="C:\Users\lenovo\Desktop\7KhmzP.png" alt="Robert Griesemer、Rob Pike 、Ken Thompson（2012年，Google I/O大会）"></p><blockquote><p>顶级初创团队：</p><p>① Robert Griesemer，参与开发 Java HotSpot 虚拟机，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 JavaScript 引擎的代码生成部分。</p><p>② Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言。</p><p>③ Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。</p></blockquote><p>随着更多有才华的程序员加入到 Go 开发团队中，更多贡献者开始为 Go 语言项目添砖加瓦。使得 Go 在发布的当年就成为了著名编程语言排行榜 TIOBE 的年度最佳编程语言。</p><p>Go 发布后就吸引了一些公司，尤其是云计算领域的初创公司成为了 Go 语言的早期接纳者。在经过若干年的磨合后，在这些公司中诞生了不乏像 Docker（容器引擎）、Kubernetes（云原生事实标准平台）、Ethereum（区块链公链以太坊）等“杀手级”或示范性项目，这些项目也让 Go 被誉为<code>云计算基础设施新兴语言</code>或直接称为<code>云计算语言</code>。</p><p>Go 在近些年云原生领域的广泛应用也让其跻身云原生时代的头部编程语言。</p><h2 id="Logo-的诞生"><a href="#Logo-的诞生" class="headerlink" title="Logo 的诞生"></a>Logo 的诞生</h2><p>在 Go 立项的时候，Rob Pike 的妻子 Renee French（著名美国插画师、漫画家和作家，以其独特的风格和奇特的创意而闻名）就帮他们画了一个标志，然后这个图标就出现在 Google Code 网站和第一件 Go T 恤上，该 Logo 被用来体现 Go 的速度：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhIqQ.png" alt="04"></p><p>2009 年 11 月 10 日 Go 准备开源发布的之前，Rob Pike 的妻子建议，将她在 1999 年左右为新泽西州 WFMU 广播电台年度筹款活动设计的，作为宣传的形象，改编成为 Go 的吉祥物 ——— Gopher（地鼠）：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhMaf.png" alt="big gopher"></p><p>发错了，是这个 ~(～￣▽￣)～：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhfMc.png" alt="06"></p><p>之后，Rob Pike 的妻子又绘制了更多的 Go gopher 形象，代表着 Go 项目和各地的 Go 程序员。这些可爱的形象成为 Go 世界中最受欢迎的事物之一，被世界各地的 Go 程序员广泛使用：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7Kh0H6.png" alt="Go Gopher"></p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p><a href="https://go.dev/doc/devel/release">Go 语言发展历程</a></p><ol><li><p>初期版本（2009 年 - 2012 年）：</p><p>初期版本的 Go 语言主要集中于提供简洁、高效的编程体验，以及强大的并发支持。这些特性使其成为了云服务、网络应用和大规模分布式系统开发的理想选择。</p></li><li><p>Go 1 发布（2012 年）：</p><p>Go 1 是 Go 语言的首个稳定版本，也是第一个被广泛用于生产环境的版本。发布 Go 1 的目标是提供稳定的 API 和 ABI，以便未来版本的兼容性。</p></li><li><p>生态系统的发展（2012 年 - 至今）：</p><p>随着 Go 语言的发展，其生态系统也在不断壮大。包括标准库、第三方库、框架以及工具链在内的生态系统都得到了极大的丰富和改进，使得 Go 语言更加适用于各种类型的应用开发。</p></li><li><p>Go 语言在工业界的应用（2010 年至今）：</p><p>自从 Go 语言发布以来，越来越多的公司和组织开始采用 Go 语言进行开发。一些知名的公司，如 Google、Uber、Dropbox、Docker、Cloudflare、MongoDB 等，都在生产环境中使用 Go 语言开发核心系统。</p></li><li><p>版本更新和改进（2012 年至今）：</p><p>Go 语言的开发团队持续不断地发布新的版本，以改进语言的性能、稳定性和功能。Go 社区也积极参与到语言的发展中，提出改进建议、修复 bug，并贡献各种开源项目。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7Khs33.png" alt="TIOBE 指数中的 Go 语言发展曲线"></p><h1 id="Go-语言的特性"><a href="#Go-语言的特性" class="headerlink" title="Go 语言的特性"></a>Go 语言的特性</h1><ol><li><p>简单易学</p><p>Go 语言的语法设计简洁明了，摒弃了一些繁琐的特性和语法元素，使得代码更易于阅读和维护。这使得 Go 语言成为一门学习曲线较为平缓的编程语言，即使是没有编程经验的人也能相对轻松地上手。</p></li><li><p>高性能并发</p><p>Go 语言天生支持并发编程，通过 goroutine 和 channel 机制，使得并发编程变得非常简单。</p><p>传统编程语言（如 C、C++ 等）的并发实现，实际上就是基于操作系统调度的，即程序负责创建线程（一般通过 pthread 等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂与难于扩展。</p><p>为了解决这些问题，Go 果断放弃了传统的基于操作系统线程的并发模型，而采用了<code>用户层轻量级线程</code>或者说是<code>类协程(coroutine)</code>，Go 将之称为 goroutine。</p><p>goroutine 占用的资源非常少，Go 语言运行时默认为每个 goroutine 分配的栈空间仅 2KB，会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处理器绑定到一个操作系统线程上。这让用户的应用程序执行效率更高，而开发工作量显著减少。</p><p>goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个 Go 程序中可以创建成千上万个并发的 goroutine。所有的 Go 代码都在 goroutine 中执行，哪怕是 Go 的运行时代码也不例外。</p><p>而 channel（通道）则提供了不同 goroutine 之间的通信和同步机制，使得编写并发代码变得直观而安全，可以帮助用户避免在其他语言里常见的共享内存访问的问题。</p></li><li><p>快速编译</p><p>Go 语言的编译速度非常快，这得益于先进的编译器和优化器。快速的编译速度可以大大提高开发效率，特别是在大型项目中。</p></li><li><p>内存管理</p><p>Go 语言拥有自动内存管理功能，也就是垃圾回收机制。这意味着开发者不需要手动管理内存分配和回收，大大减轻了编程的负担，同时也有助于防止内存泄露。</p></li><li><p>静态类型语言</p><p>Go 语言是一门静态类型的编程语言，这意味着在编译期间就能捕获到一些类型相关的错误。静态类型检查有助于提前发现潜在的 Bug，减少在运行时可能出现的错误。</p></li><li><p>跨平台支持</p><p>Go 语言的编译器可以在多种平台上运行，可以轻松地将 Go 程序编译成适用于不同操作系统和硬件架构的可执行文件。这使得 Go 语言成为跨平台开发的理想选择。</p></li><li><p>强调并遵循软件工程原则</p><p>Go 语言鼓励开发者编写清晰、简洁、可维护的代码。它有一套明确的代码风格规范，并自带了一些工具来帮助开发者保持一致的代码风格。</p></li><li><p>丰富的标准库</p><p>Go 语言附带了丰富而强大的标准库，覆盖了网络、文件处理、加密、并发等方面。开发者可以直接使用标准库提供的功能，而无需引入大量的第三方库。</p></li><li><p>工具链</p><p>完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。</p><p>内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器。</p><p>除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。</p></li><li><p>文档资源</p><p>Go 语言拥有丰富的官方文档资源，包括语言规范、标准库文档、命令行工具说明等。此外，Go 语言社区中也有许多优秀的教程、博客和论坛，为开发者提供了学习和交流的平台。</p></li></ol><h2 id="性能测评"><a href="#性能测评" class="headerlink" title="性能测评"></a>性能测评</h2><p>以下是 Go 语言与其他编程语言的对比测试数据（源于网络资料）：</p><ul><li>在相同的环境和执行目标的情况下，Go 程序比 Java 或 Scala 应用程序要快上 2 倍，并比这两门语言使用少占用 70% 的内存，执行效率大约比 C++ 慢 20%；</li><li>Go 的编译速度要比绝大多数语言都要快，比 Java 和 C++ 快 5 至 6 倍，比 Scala 快 10 倍；</li><li>Go 语言通过垃圾回收器自动管理内存，这在某些情况下可能会引入一些运行时开销。相比之下，C/C++ 需要手动管理内存，这可能会导致内存泄漏和悬挂指针等问题；</li><li>Go 和 Python 在一般开发的平均水平测试中，Go 要比 Python 3 快 25 倍左右，少占用三分之二的内存，但比 Python 大概多写一倍的代码，毫无疑问，开发效率上，Python 是要技高一筹的；</li><li>比较 Go 和 Python 在简单的 web 服务器方面的性能，单位为传输量每秒：<br>原生的 Go net/http 包要比 web.py 快 7 至 8 倍，如果使用 web.go 框架则稍微差点，比 web.py 快 6 至 7 倍。如果是使用Python 中的 tornado 异步服务器和框架开发出的Web应用，那么要比传统的 web.py 快很多，此时，Go 大概只比它快 1.2 至 1.5 倍，Go 在 Web 开发的领域比 Python 要快，但目前来看，并非碾压态势。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241021192031073.png" alt="image-20241021192031073"></p><h2 id="业务方向"><a href="#业务方向" class="headerlink" title="业务方向"></a>业务方向</h2><ol><li><p>网络编程：</p><p>Go 语言原生支持高效的并发编程，因此非常适合用于构建网络应用程序和分布式系统。</p></li><li><p>大数据处理：</p><p>Go 语言具有高效的执行性能和并发处理能力，因此很适合用于处理大量数据。</p></li><li><p>云原生开发：</p><p>随着云原生应用的兴起，Go 语言也成为云原生开发的热门选择。Go 的快速启动时间、小内存占用和高并发性能使其非常适合在云环境中构建轻量级容器化应用和无服务器函数。</p></li><li><p>微服务：</p><p>Go 语言对于构建微服务和 API 很有优势，因为它的代码结构简单，易于维护，同时具有高效和高并发特性</p></li><li><p>数据库和存储系统：</p><p>Go 语言提供了丰富的数据库和存储库，包括 SQL 数据库（如 MySQL、PostgreSQL）、NoSQL 数据库（如 MongoDB、Redis）以及分布式存储系统（如 etcd）。这使得 Go 成为开发高性能、可扩展和可靠的数据存储解决方案的理想语言。</p></li><li><p>Web 开发：</p><p>Go 语言拥有轻量级的 HTTP 服务器，使其成为构建高性能 Web 应用程序的理想选择。它支持快速开发和部署，并且具有良好的性能和可靠性。很多人使用 Golang 是因为它非常快，而且它可以用来并行运行进程，这样他们就不必互相等待。</p><p>它内置了对并发的支持，并促进了单个进程中线程和处理器之间的并行性。这可以使你的网站更容易快速加载并为你提供最佳的用户体验。</p></li><li><p>区块链开发：</p><p>Go 语言在区块链开发领域也得到了广泛应用。许多知名的区块链项目（如 Ethereum）使用 Go 语言作为其主要开发语言，因为 Go 具有高效的并发能力和良好的性能，适合处理区块链交易和智能合约。</p></li></ol><h1 id="Go-语言的设计哲学"><a href="#Go-语言的设计哲学" class="headerlink" title="Go 语言的设计哲学"></a>Go 语言的设计哲学</h1><p>从Go语言诞生的那一刻起至今已经有十多年了，Go语言的魅力使得其在世界范围内拥有百万级的拥趸。那么究竟是什么让大量的开发人员开始学习Go语言或从其他语言转向Go语言呢？笔者认为，Go语言的魅力就来自Go语言的设计哲学。</p><p>关于Go语言的设计哲学，Go语言之父们以及Go开发团队并没有给出明确的官方说法。在这里笔者将根据自己对他们以及Go社区主流观点和代码行为的整理、分析和总结，列出4条Go语言的设计哲学。理解这些设计哲学将对读者形成Go原生编程思维、编写高质量Go代码起到积极的作用。</p><h2 id="追求简单，少即是多"><a href="#追求简单，少即是多" class="headerlink" title="追求简单，少即是多"></a>追求简单，少即是多</h2><blockquote><p>简单是一种伟大的美德，但我们需要更艰苦地努力才能实现它，并需要经过一个教育的过程才能去欣赏和领会它。但糟糕的是：复杂的东西似乎更有市场。——Edsger Dijkstra，图灵奖得主</p></blockquote><p>当我们问Gopher“你为什么喜欢Go语言”时，我们通常会得到很多答案，如图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241021192857836.png" alt="image-20241021192857836"></p><p>但在我们得到的众多答案中，排名靠前而又占据多数的总是“简单”（Simplicity）。</p><p>不同于那些通过相互借鉴而不断增加新特性的主流编程语言（如C++、Java等），Go的设计者们在语言设计之初就拒绝走语言特性融合的道路，而选择了“做减法”，选择了“简单”，他们把复杂性留给了语言自身的设计和实现，留给了Go核心开发组自己，而将简单、易用和清晰留给了广大Gopher。因此，今天呈现在我们眼前的是这样的Go语言：</p><ul><li>简洁、常规的语法（不需要解析符号表），它仅有25个关键字；</li><li>内置垃圾收集，降低开发人员内存管理的心智负担；</li><li>没有头文件；</li><li>显式依赖（package）；</li><li>没有循环依赖（package）；</li><li>常量只是数字；</li><li>首字母大小写决定可见性；</li><li>任何类型都可以拥有方法（没有类）；</li><li>没有子类型继承（没有子类）；</li><li>没有算术转换；</li><li>接口是隐式的（无须implements声明）；</li><li>方法就是函数；</li><li>接口只是方法集合（没有数据）；</li><li>方法仅按名称匹配（不是按类型）；</li><li>没有构造函数或析构函数；</li><li>n++和n—是语句，而不是表达式；</li><li>没有++n和—n；</li><li>赋值不是表达式；</li><li>在赋值和函数调用中定义的求值顺序（无“序列点”概念）；</li><li>没有指针算术；</li><li>内存总是初始化为零值；</li><li>没有类型注解语法（如C++中的const、static等）；</li><li>没有模板/泛型；</li><li>没有异常（exception）；</li><li>内置字符串、切片（slice）、map类型；</li><li>内置数组边界检查；</li><li>内置并发支持；</li><li>……</li></ul><p>任何设计都存在权衡与折中。Go 设计者选择的“简单”体现在，站在巨人肩膀上去除或优化在以往语言中已被证明体验不好或难于驾驭的语法元素和语言机制，并提出自己的一些创新性的设计，比如首字母大小写决定可见性，内存分配初始零值，内置以 go 关键字实现的并发支持等）。Go 设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担。</p><p>正如 Go 语言之父 Rob Pike 所说：“Go 语言实际上是复杂的，但只是让大家感觉很简单。”这句话背后的深意就是“简单”选择的背后是 Go语言自身实现层面的复杂性，而这种复杂性被 Go 语言的设计者“隐藏”起来了。比如并发是复杂的，但我们通过一个简单的关键字“go”就可以实现。这种简单其实是 Go 开发团队缜密设计和持续付出的结果。</p><p>此外，Go 的简单哲学还体现在 Go 1兼容性的提出。对于面对工程问题解决的开发人员来说，Go 1大大降低了工程层面语言版本升级所带来的消耗，让 Go 的工程实践变得格外简单。</p><p>从 Go 1.0 发布起至今，Go 1 的兼容性得到很好的保障，当初使用 Go 1.4 编写的代码如今也可以顺利通过最新的 Go 1.16 版本的编译并正常运行起来。正如前面引用的图灵奖得主 Edsger Dijkstra 的名言，这种创新性的简单设计并不是一开始就能得到程序员的理解的，但在真正使用Go之后，这种身处设计哲学层面的简单便延伸到Go语言编程应用的方方面面，持续影响着Go语言编程思维。</p><p>在Go演化进入关键阶段（走向Go 2）的今天，有人向Go开发团队提出过这样一个问题：Go后续演化的最大难点是什么？Go开发团队的一名核心成员回答道：“<strong>最大的难点是如何继续保持Go语言的简单。</strong>”</p><h2 id="偏好组合，正交解耦"><a href="#偏好组合，正交解耦" class="headerlink" title="偏好组合，正交解耦"></a>偏好组合，正交解耦</h2><blockquote><p>当我们有必要采用另一种方式处理数据时，我们应该有一些耦合程序的方式，就像花园里将浇水的软管通过预置的螺丝扣拧入另一段那样，这也是Unix IO采用的方式。——Douglas McIlroy，Unix管道的发明者（1964）</p></blockquote><p>C++、Java等主流面向对象（以下简称OO）语言通过庞大的自上而下的类型体系、继承、显式接口实现等机制将程序的各个部分耦合起来，但在Go语言中我们找不到经典OO的语法元素、类型体系和继承机制，或者说Go语言本质上就不属于经典OO语言范畴。针对这种情况，很多人会问：那Go语言是如何将程序的各个部分有机地耦合在一起的呢？就像上面引述的Douglas McIlroy那句话中的浇水软管那样，<strong>Go语言遵从的设计哲学也是组合</strong>。</p><p>在<strong>语言设计层面</strong>，Go提供了正交的语法元素供后续组合使用，包括：</p><ul><li>Go语言无类型体系（type hierarchy），类型之间是独立的，没有子类型的概念；</li><li>每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；</li><li>接口（interface）与其实现之间隐式关联；</li><li>包（package）之间是相对独立的，没有子包的概念。</li></ul><p>我们看到无论是包、接口还是一个个具体的类型定义（包括类型的方法集合），Go语言为我们呈现了这样一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。现在摆在面前的工作就是以最适当的方式在这些孤岛之间建立关联（耦合），形成一个整体。<strong>Go采用了组合的方式，也是唯一的方式。</strong></p><p>Go语言提供的最为直观的组合的语法元素是<strong>类型嵌入（typeembedding）</strong>。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。这种方式有些类似经典 OO语言中的继承机制，但在原理上与其完全不同，这是一种Go设计者们精心设计的语法糖。<strong>被嵌入的类型和新类型之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典OO语言中的那种父类、子类的关系以及向上、向下转型（type casting）。</strong>在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为<strong>“垂直组合”</strong>，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。</p><p>通过在interface的定义中嵌入interface类型来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为Go语言的一种惯用法。</p><p><strong>interface 是 Go 语言中真正的“魔法”</strong>，是 Go 语言的一个创新设计，它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的 interface 实现会不经意间满足依赖抽象、里氏替换、接口隔离等设计原则，这在其他语言中是需要很刻意的设计谋划才能实现的，但在 Go interface 看来，一切却是自然而然的。通过 interface 将程序各个部分组合在一起的方法，笔者称之为“水平组合”。水平组合的模式有很多，一种常见的方法是通过接受 interface 类型参数的普通函数进行组合。</p><p>此外，Go 语言内置的并发能力也可以通过组合的方式实现对计算能力的串联，比如通过 <code>goroutine+channel</code> 的组合实现类似Unix Pipe的能力。</p><p>综上，组合原则的应用塑造了 Go 程序的骨架结构。类型嵌入为类型提供垂直扩展能力，interface 是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。组合也让遵循简单原则的 Go 语言在表现力上丝毫不逊色于复杂的主流编程语言。</p><h2 id="原生并发，轻量高效"><a href="#原生并发，轻量高效" class="headerlink" title="原生并发，轻量高效"></a>原生并发，轻量高效</h2><blockquote><p>并发是有关结构的，而并行是有关执行的。——Rob Pike（2012）</p></blockquote><p>将时钟回拨到 2007年，那时 Go语言的三位设计者 Rob Pike、Robert Griesemer 和 Ken Thompson 都在 Google 使用 C++ 语言编写服务端代码。当时 C++ 标准委员会正在讨论下一个 C++ 标准（C++0x，也就是后来的 C++11 标准），委员会在标准草案中继续增加大量语言特性的行为让 Go 的三位设计者十分不满，尤其是带有原子类型的新 C++ 内存模型，给本已负担过重的 C++ 类型系统又增加了额外负担。三位设计者认为 C++ 标准委员会在思路上是短视的，因为硬件很可能在未来十年内发生重大变化，将语言与当时的硬件紧密耦合起来是十分不明智的，是没法给开发人员在编写大规模并发程序时带去太多帮助的。</p><p>多年来，处理器生产厂商一直遵循着摩尔定律，在提高时钟频率这条跑道上竞争，各行业对计算能力的需求推动了处理器处理能力的提高。CPU 的功耗和节能问题成为人们越来越关注的焦点。CPU 仅靠提高主频来改进性能的做法遇到了瓶颈。主频提高导致CPU的功耗和发热量剧增，反过来制约了 CPU 性能的进一步提高。依靠主频的提高已无法实现性能提升，人们开始把研究重点转向把多个执行内核放进一个处理器，让每个内核在较低的频率下工作来降低功耗同时提高性能。2007年处理器领域已开始进入一个全新的多核时代，处理器厂商的竞争焦点从主频转向了多核，多核设计也为摩尔定律带来新的生命力。与传统的单核CPU相比，多核CPU带来了更强的并行处理能力、更高的计算密度和更低的时钟频率，并大大减少了散热和功耗。Go 的设计者敏锐地把握了 CPU 向多核方向发展的这一趋势，在决定不再使用C++而去创建一门新语言的时候，果断将面向多核、原生内置并发支持作为新语言的设计原则之一。</p><p>Go语言原生支持并发的设计哲学体现在以下几点。</p><ol><li><p>Go 语言采用轻量级协程并发模型，使用 Go 应用在面向多核硬件时更具可拓展性</p><p>传统编程语言（如C、C++等）的并发实现实际上就是基于操作系统调度的，即程序负责创建线程（一般通过pthread等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂和难于扩展。</p><p>复杂主要体现在以下方面：</p><ul><li>创建容易，退出难：使用C语言的开发人员都知道，创建一个线程时（比如利用pthread库）虽然参数也不少，但还可以接受。而一旦涉及线程的退出，就要考虑线程是不是分离的（detached）？是否需要父线程去通知并等待子线程退出（join）？是否需要在线程中设置取消点（cancel point）以保证进行join操作时能顺利退出？</li><li>并发单元间通信困难，易错：多个线程之间的通信虽然有多种机制可选，但用起来相当复杂；并且一旦涉及共享内存（shared memory），就会用到各种锁（lock），死锁便成为家常便饭。</li><li>线程栈大小的设定：是直接使用默认的，还是设置得大一些或小一些呢？</li></ul><p>难于拓展主要体现在以下方面：</p><ul><li>虽然线程的代价比进程小了很多，但我们依然不能大量创建线程，因为不仅每个线程占用的资源不小，操作系统调度切换线程的代价也不小。</li><li>对于很多网络服务程序，由于不能大量创建线程，就要在少量线程里做网络的多路复用，即使用epoll/kqueue/IoCompletionPort 这套机制。即便有了libevent、libev这样的第三方库的帮忙，写起这样的程序也是很不容易的，存在大量回调（callback），会给程序员带来不小的心智负担。</li></ul><p>为了解决这些问题，Go果断放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程或者说是类协程（coroutine），Go将之称为 goroutine。goroutine 占用的资源非常少，Go运行时默认为每个 goroutine 分配的栈空间仅2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在 goroutine 中执行，哪怕是 Go 的运行时代码也不例外。</p><p>不过，一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现 Go 程序内 goroutine 之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些 goroutine 按照一定算法放到 CPU 上执行的程序就称为 goroutine 调度器（goroutine scheduler）。关于 goroutine 调度的原理，我们将在后面详细说明，这里就不赘述了。</p></li><li><p>Go 语言为开发者提供的支持并发的语法元素和机制</p><p>我们先来看看那些设计并诞生于单核年代的编程语言（如C、C++、Java）在语法元素和机制层面是如何支持并发的。</p><ul><li>执行单元：线程</li><li>创建和销毁的方式：调用库函数或调用对象方法</li><li>并发线程间的通信：多基于操作系统提供的 IPC机制（进程间通信），比如共享内存、Socket、Pipe等，当然也会使用有并发保护的全局变量。</li></ul><p>与上述传统语言相比，Go提供了语言层面内置的并发语法元素和机制。</p><ul><li>执行单元：goroutine</li><li>创建和销毁的方式：go+函数调用；函数退出即 goroutine 退出</li><li>并发线程间的通信：通过语言内置的channel传递消息或实现同步，并通过select实现多路channel的并发控制。</li></ul><p>对比来看，Go对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。</p></li><li><p>并发原则对 Go 开发者在程序结构设计层面的影响</p><p>由于 goroutine 的开销很小（相对线程），Go官方鼓励大家使用 goroutine 来充分利用多核资源。但并不是有了 goroutine 就一定能充分利用多核资源，或者说即便使用 Go 也不一定能写出好的并发程序。</p><p>为此Rob Pike曾做过一次关于“并发不是并行”的主题分享，图文并茂地讲解了并发（Concurrency）和并行（Parallelism）的区别。Rob Pike认为：</p><ul><li>并发是有关结构的，它是一种将一个程序分解成多个小片段并且每个小片段都可以独立执行的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作。</li><li>并行是有关执行的，它表示同时进行一些计算任务。</li></ul><p>采用并发方案设计的程序在单核处理器上也是可以正常运行的（在单核上的处理性能可能不如非并发方案），并且随着处理器核数的增多，并发方案可以自然地提高处理性能，提升吞吐量。而非并发方案在处理器核数提升后，也仅能使用其中的一个核，无法自然扩展，这一切都是程序的结构所决定的。这告诉我们：<strong>并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。</strong></p></li></ol><p>除此之外，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计层面对程序进行拆解组合，再映射到程序执行层面：goroutine 各自执行特定的工作，通过 channel+select 将 goroutine 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go语言更适应现代计算环境。</p><h2 id="面向工程，自带电池"><a href="#面向工程，自带电池" class="headerlink" title="面向工程，自带电池"></a>面向工程，自带电池</h2><blockquote><p>软件工程指引着Go语言的设计。——Rob Pike（2012）</p></blockquote><p>要想理解这条设计哲学，我们依然需要回到三位Go语言之父在设计Go语言时的初衷：<strong>面向真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案</strong>。主要的问题包括：</p><ul><li>程序构建慢；</li><li>失控的依赖管理；</li><li>开发人员使用编程语言的不同子集（比如C++支持多范式，这样有些人用OO，有些人用泛型）；</li><li>代码可理解性差（代码可读性差、文档差等）；</li><li>功能重复实现；</li><li>升级更新消耗大；</li><li>实现自动化工具难度高；</li><li>版本问题；</li><li>跨语言构建问题。</li></ul><p>很多编程语言的设计者或拥趸认为这些问题并不是编程语言应该解决的，但Go语言的设计者并不这么看，他们以更高、更广阔的视角审视软件开发领域尤其是大规模软件开发过程中遇到的各种问题，并在Go语言最初设计阶段就将解决工程问题作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计，这也是Go与那些偏学院派、偏研究性编程语言在设计思路上的一个重大差异。</p><blockquote><p>Go语言取得阶段性成功后，这种思路开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴Go的一些设计，比如越来越多的语言认可统一代码风格的优越之处，并开始提供官方统一的fmt工具（如Rust的rustfmt），又如Go创新提出的最小版本选择（Minimal Version Selection，MVS）被其他语言的包依赖工具所支持（比如Rust的cargo支持MVS）。</p></blockquote><p>Go设计者将所有工程问题浓缩为一个词：<strong>scale</strong>（笔者总觉得将scale这个词翻译为任何中文词都无法传神地表达其含义，暂译为“规模”吧）。从Go1开始，Go的设计目标就是帮助开发者更容易、更高效地管理两类规模。</p><ul><li>生产规模：用Go构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数量等。</li><li>开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等。</li></ul><p>Go设计者期望 Go 可以游刃有余地应对生产规模和开发规模变大带来的各种复杂问题。Go语言的演进方向是优化甚至消除 Go语言自身面对规模化问题时应对不好的地方，比如：Go 1.9引入类型别名（type alias）以应对大型代码仓库代码重构，Go 1.11引入go module机制以解决不完善的包依赖问题等。这种设计哲学的落地让 Go语言具有广泛的规模适应性：既可以被仅有5人的初创团队用于开发终端工具，也能够满足像Google这样的巨型公司大规模团队开发大规模网络服务程序的需要。</p><p>那么Go是如何解决工程领域规模化所带来的问题的呢？我们从语言、标准库和工具链三个方面来看一下。</p><ol><li><p>语言</p><p>语法是编程语言的用户接口，它直接影响开发人员对于一门语言的使用体验。Go语言是一门简单的语言，简单意味着可读性好，容易理解，容易上手，容易修复错误，节省开发者时间，提升开发者间的沟通效率。但作为面向工程的编程语言，光有简单的设计哲学还不够，每个语言设计细节还都要经过“工程规模化”的考验和打磨，需要在细节上进行充分的思考和讨论。</p><ul><li>从工程的安全性和可靠性角度考虑，选择使用大括号代码块结构；</li><li>重新设计编译单元和目标文件格式，实现Go源码快速构建，将大工程的构建时间缩短到接近于动态语言的交互式解释的编译时间；</li><li>不能导入没有使用过的包，否则程序将无法编译。这既可以充分保证Go程序的依赖树是精确的，也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间。</li><li>去除包的循环依赖。循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建速度。</li><li>在处理依赖关系时，有时会通过允许一部分重复代码来避免引入较多依赖关系。</li><li>包路径是唯一的，而包名不必是唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者对如何引用其内容的约定。包名不必是唯一的约定大大降低了开发人员给包起唯一名字的心智负担。</li><li>故意不支持默认函数参数。因为在规模工程中会导致函数拥有太多的参数，降低清晰度和可读性。</li><li>首字母大小写定义标识符可见性，这是Go的一个创新。它让开发人员通过名称即可知晓其可见性，而无须回到标识符定义的位置查找并确定其可见性，这提升了开发人员阅读代码的效率。</li><li>在语义层面，相对于C，Go做了很多改动，提升了语言的健壮性，比如去除指针算术，去除隐式类型转换等。</li><li>内置垃圾收集。这对于大型工程项目来说，大大降低了程序员在内存管理方面的负担，程序员使用GC感受到的好处超过了付出的成本，并且这些成本主要由语言实现者来承担。</li><li>内置并发支持，为网络软件带来了简单性，而简单又带来了健壮，这是大型工程软件开发所需要的。增加类型别名，支持大规模代码库的重构。</li></ul></li><li><p>标准库</p><p>Go被称为“自带电池”（battery-included）的编程语言。“自带电池”原指购买了电子设备后，在包装盒中包含了电池，电子设备可以开箱即用，无须再单独购买电池。如果说一门编程语言“自带电池”，则说明这门语言标准库功能丰富，多数功能无须依赖第三方包或库，Go语言恰是这类编程语言。</p><p>由于诞生年代较晚，且目标较为明确，Go在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto/xx、encoding/xx等包充分迎合了云原生时代关于API/RPC Web服务的构建需求。Go开发者可以直接基于这些包实现满足生产要求的API服务，从而减轻对第三方包或库的依赖，降低工程代码依赖管理的复杂性，也降低开发人员学习第三方库的心智负担。</p><p>仅使用标准库来构建系统，这对于开发人员是很有吸引力的。在很多关于选用何种Go Web开发框架的调查中，选择标准库的依然占大多数，这也是Go社区显著区别于其他编程语言社区的一点。</p><p>Go语言目前在GUI、机器学习（Machine Learning）等开发领域占有的份额较低，这很可能与Go标准库没有内置这类包有关。</p></li><li><p>工具链</p><p>开发人员在做工程的过程中需要使用工具。而Go语言提供了十分全面、贴心的编程语言官方工具链，涵盖了编译、编辑、依赖获取、调试、测试、文档、性能剖析等的方方面面。</p><ul><li>构建和运行：go build/go run</li><li>依赖包查看与获取：go list/go get/go mod xx</li><li>编辑辅助格式化：go fmt/gofmt</li><li>文档查看：go doc/godoc</li><li>单元测试/基准测试/测试覆盖率：go test</li><li>代码静态分析：go vet</li><li>性能剖析与跟踪结果查看：go tool pprof/go tool trace</li><li>升级到新Go版本API的辅助工具：go tool fix</li><li>报告Go语言bug：go bug</li></ul><p>值得重点提及的是 gofmt 统一了 Go语言的编码风格，在其他语言开发者还在为代码风格争论不休的时候，Go开发者可以更加专注于领域业务。同时，相同的代码风格让以往困扰开发者的代码阅读、理解和评审工作变得容易了很多，至少Go开发者再也不会有那种因代码风格的不同而产生的陌生感。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这里做一个简单的总结：</p><p>简单是Go语言贯穿语言设计和应用的主旨设计哲学。德国建筑大师路德维希·密斯·凡德罗将“少即是多”这一哲学理念应用到建筑设计当中后取得了非凡的成功，而Go语言则是这一哲学在编程语言领域为数不多的践行者。“少”绝不是目的，“多”才是其内涵。Go在语言层面的简单让Go收获了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。</p><p>“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。Go在语言设计层面也将这一准则发挥到极致。Go崇尚通过组合的方式将正交的语法元素组织在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。</p><p>不同于C、C++、Java等诞生于20世纪后段的面向单机的编语言，<strong>Go语言是面向未来的</strong>。Go设计者对硬件发展趋势做出了敏锐且准确的判断——多核时代是未来主流趋势，于是将并发作为语言的“一等公民”，提供了内置于语言中的简单并发原语——go（goroutine）、channel 和 select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。Go 生来就肩负着解决面向软件工程领域问题的使命，我们看到的开箱即用的标准库、语言自带原生工具链以及开放的工具链生态的建立都是这一使命落地的结果，Go在面向工程领域的探索也引领着编程语言未来发展的潮流。</p><p>这篇博客是本系列博客的第一篇，主要内容来自于《Go 语言精进之路》一书中，希望通过阅读完上面的内容，让你我对 Go 语言有一个更加清晰的认知。在这里跟大家分享一下 Go语言之父的一些忠告。</p><blockquote><p>Rob Pike 今年已经 68 岁了，大部分时候在澳大利亚生活，现在居住在悉尼新南威尔士州。</p><p>在最近的一次采访中，他总结了自己 40 多年开发经验说：<code>避免倦怠的最好方法是在支持你的环境中做你真正喜欢的事情</code>。他认为自己是幸运的，在贝尔实验室和谷歌都是如此。</p><p>同时他也提醒我们：<code>如果对工作感到压力，应该随时休息或者改变方向</code>。</p></blockquote><p>希望每一个人都能找到自己喜欢做的事情！！！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/ikdl/p/18167778">【Go 语言入门专栏】Go语言的起源与发展</a></p><p><a href="https://weread.qq.com/web/reader/f343248072895ed9f34f408#outline?noScroll=1">Go 语言精进之路：从新手到高手的编程思想、方法和技巧1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;到今天，笔者学习 Go 语言也差不多有一年了，好像都没有认真地了解过 Go 语言的前世今生以及为什么要学习 Go 语言。不如趁着这个机会，好</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Go语言》</title>
    <link href="http://example.com/2024/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E3%80%8B/"/>
    <id>http://example.com/2024/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E3%80%8B/</id>
    <published>2024-10-19T06:34:30.000Z</published>
    <updated>2024-10-24T10:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，断更是因为找到了实习工作确实很忙，还有就是实在不知道要学什么了。好像进入了一种非常迷茫的状态，不过在经过几次新的面试之后，我发现现在自己对 Go 语言的理解还是局限在八股文中。最近也是看了好多关于 Go 语言底层原理的书，觉得可以整合一下，虽然之前也做过类似的整理，但是现在看来有点乱七八糟的，还是重新再来一遍吧。</p><p>所以，这是秋招特辑——《深入理解 Go 语言》，这个系列的博客不再仅仅是解释几个问题或者总结面试的时候常问的问题了，我对这个系列的博客的期望是能够真正的从浅到深地学习和理解Go语言。</p><p>整个系列分为三个部分——基础、并发和内存管理，每一部分会分别从使用方法和场景、实现原理、使用陷阱、历史发展和拓展五个部分来写。下面是目录链接：</p><ol><li>基础篇<ul><li><a href="https://zxh3032.github.io/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/">Go 语言创世纪</a></li><li><a href="https://zxh3032.github.io/2024/10/23/%E5%91%BD%E5%90%8D%E3%80%81%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC/">命名、声明和赋值</a></li><li><a href="https://zxh3032.github.io/2024/10/24/%E4%BA%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">基础数据结构</a></li><li>复合数据结构<ul><li>顺序存储两兄弟——数组和切片，到底有什么区别？</li><li>特殊的存在——只读的string</li><li>查询效率最高的数据结构——map</li><li>变量的合租公寓——结构体</li></ul></li><li>接口</li><li>函数</li><li>方法</li><li>反射</li><li>指针</li><li>defer 延迟调用</li></ul></li><li><p>错误处理</p><ul><li>panic 和 recover</li></ul></li><li><p>并发篇</p><ul><li>Goroutine 和 channel</li></ul></li><li>内存管理篇<ul><li>内存分配</li><li>垃圾回收</li></ul></li></ol><p>参考资料来源：</p><ol><li><p>书籍</p><ul><li><p>《Go 语言专家编程》</p></li><li><p>《Go 语言设计与实现》</p></li><li><p>《深入理解 Go 语言》</p></li><li><p>《Go 程序员面试笔试宝典》</p></li><li><p>《深入理解 Go 并发编程：从原理到实践，看这本就够了》</p></li></ul></li><li><p>AI</p><ul><li>豆包</li><li>ChatGPT</li></ul></li><li><p>博客</p><ul><li><a href="https://www.cnblogs.com/ikdl/p/18167778">【Go 语言入门专栏】Go语言的起源与发展</a></li><li><a href="https://blog.csdn.net/qq_27870421/article/details/118493425">Go 语言变量声明和赋值</a></li><li><a href="https://juejin.cn/post/7081885129978675236">Go 零值可用类型</a></li><li><a href="https://www.cnblogs.com/lianshuiwuyi/p/17828972.html">理解 Go 中的零值</a></li><li><a href="https://www.cnblogs.com/yinzhengjie2020/p/12247502.html">Golang的基础数据类型-浮点型</a></li><li><a href="https://www.quanxiaoha.com/golang/golang-data-type-float.html">Go 语言浮点型 (小数类型)</a></li><li><a href="https://zsy-cn.github.io/ch1-07-%E4%BA%86%E8%A7%A3%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html">Go 了解基本数据类型</a></li><li><a href="https://www.cnblogs.com/xiximayou/p/11826991.html">（七）golang—变量之基本数据类型（看这篇就够了）</a></li></ul></li></ol><p>如果在写的过程中发现这么学习的效率不错的话，后面也会更新一些关于计算机网络、操作系统、MySQL、Redis 的相关内容，也会写一些关于面试和项目设计的东西。</p><p>《秋招特辑》系列博客只是用于帮助笔者学习和记忆知识点的内容，如果恰好你也在找工作，希望能够帮到你。希望大家都能找到一份好工作！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有更新博客了，断更是因为找到了实习工作确实很忙，还有就是实在不知道要学什么了。好像进入了一种非常迷茫的状态，不过在经过几次新的面试之后，我发现现在自己对 Go 语言的理解还是局限在八股文中。最近也是看了好多关于 Go 语言底层原理的书，觉得可以整合一下，虽然之前也做过</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>gRPC入门</title>
    <link href="http://example.com/2024/07/05/gRPC%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2024/07/05/gRPC%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-05T13:12:05.000Z</published>
    <updated>2024-07-05T14:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPC 和 gRPC 其实是笔者在几个月前就开始接触的东西，但是由于当时在 Windows 上配不好环境加上学起来确实有点难度，所以就放下没去做项目，就简单地了解了一下。最近几天实在是没什么想学的，在拿起来看看吧，环境已经在 WSL 上配置好了，回头可以直接开始做项目了。</p><p>那今天就先来学习总结一下基础概念吧。</p><h1 id="关于-RPC"><a href="#关于-RPC" class="headerlink" title="关于 RPC"></a>关于 RPC</h1><p>对 RPC 不了解地人，或许会纠结其与 TCP、HTTP 等的关系。后者是网络传输种的协议，而 RPC 是一种设计、实现框架。通讯协议只是其中一部分，RPC 不仅要解决协议通讯的问题，还有序列化与反序列化，以及消息通知。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>从本质上讲，它使一台机器上的程序能够调用另一台机器上的子程序，而不会意识到它是远程的。RPC 是一种软件通信协议，一个程序可以用来向位于网络上另一台计算机的程序请求服务，而不必了解网络的细节。</p><p>一个完整的 RPC 框架里面包含了四个核心的组件，分别是 <code>CLient</code>, <code>Server</code>, <code>ClientOptions</code> 以及 <code>ServerOptions</code>，这个 Options 就是 RPC 需要设计实现的东西。</p><ul><li>客户端（Client）：服务的调用方。</li><li>服务端（Server）：真正的服务提供方。</li><li>客户端存根（ClientOption）：socket 管理，网络收发包的序列化。</li><li>服务端存根（ServerOption）：socket 管理，提醒 server 层 rpc 方法调用，以及网络收发包的序列化。</li></ul><p>RPC 的逻辑示意图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705212612357.png" alt="image-20240705212612357"></p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>为什么会有 RPC？RPC 和 HTTP 是什么关系？</p><blockquote><p>Socket 和 HTTP 编程使用消息传递范式。客户端向服务器发送一个消息，而服务器通常会发送一个消息回来。双方都负责以双方都能理解的格式创建消息，并从这些消息中读出数据。</p><p>然而，大多数独立的应用程序并没有那么多地使用消息传递技术。一般来说，首选的机制是函数（或方法或过程）的调用。在这种方式中，程序将调用一个带有参数列表的函数，并在完成函数调用后有一组返回值。这些值可能是函数值，或者如果地址被作为参数传递，那么这些地址的内容可能已经被改变。地址的内容可能已经被改变。</p><p>RPC 就是将这种编程方式引入网络世界的一种尝试。因此，客户端将进行在它看来是正常的过程调用。客户端会将其打包成网络消息并传送给服务器。服务器会将其解包，并在服务器端将其转回为过程调用。服务器端的过程调用。这个调用的结果将被打包，以便返回给客户端。</p></blockquote><p>上面的解释可谓是非常官方，看过之后也不是很清楚 RPC 到底是什么，有什么用，<a href="https://xiaolincoding.com/network/2_http/http_rpc.html">建议去看这篇博客</a>，解释的非常清楚，这里给一下结论：</p><ul><li>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 <strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP/2.0</strong> 在 <strong>HTTP/1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><h2 id="RPC-和-REST-的区别"><a href="#RPC-和-REST-的区别" class="headerlink" title="RPC 和 REST 的区别"></a>RPC 和 REST 的区别</h2><p>RPC 与 REST 最大的区别就在于 RPC 提供了更好的抽象，RPC 甚至将网络传输细节彻底隐藏了，而 REST 没有。具体来说，REST 至少要求用于提供 URL 以及请求参数，而 RPC 隐藏了与网络传输的相关实现细节。另一方面，RPC 可以基于任何网络通信协议，而 REST 通常基于 HTTP（或者 HTTPS）协议。RPC 调用者并不会关心具体的协议是：HTTP、TCP 还是其他任何自定义协议。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>以下是 RPC 为开发人员和应用程序管理员提供的一些优势：</p><ul><li>帮助客户端通过传统使用高级语言的过程调用与服务器进行通信。</li><li>可以在分布式环境以及本地环境中使用。</li><li>支持面向进程和面向线程的模型。</li><li>对用户隐藏内部消息传递机制。</li><li>只需极少的努力即可重写和重新开发代码。</li><li>提供抽象，即对用户隐藏网络通信的消息传递性质。</li><li>省略许多协议层以提高性能。</li></ul><p>另一方面，RPC 的一些缺点包括：</p><ul><li>客户端和服务器对各自的例程使用不同的执行环境，并且资源（例如，文件）的使用也更加复杂。因此，RPC 系统并不总是适合传输大量数据。</li><li>RPC 非常容易发生故障，因为它涉及通信系统，另一台计算机和另一个进程。</li><li>RPC 没有统一的标准;它可以通过多种方式实现。</li><li>RPC 只是基于交互的，因此，在硬件架构方面，它不提供任何灵活性。</li></ul><h1 id="关于-gRPC"><a href="#关于-gRPC" class="headerlink" title="关于 gRPC"></a>关于 gRPC</h1><p>gRPC 是 RPC 的一种，它使用 Protocol Buffer (简称 Protobuf) 作为序列化格式，Protocol Buffer 是来自 Google 的序列化框架，比 Json 更加轻便高效，同时基于 HTTP/2 标准设计，<strong>带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求</strong>等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。用 protoc 就能使用 proto 文件帮助我们生成上面的 option 层代码。</p><p>在 gRPC 中，客户端应用程序可以直接在另一台计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。</p><p>gRPC 的调用模型如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705215225298.png" alt="image-20240705215225298"></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><strong>分布式场景</strong> ：gRPC 设计为低延迟和高吞吐量通信，非常适用于效率至关重要的轻型微服务。</li><li><strong>点对点实时通信</strong>： gRPC 对双向流媒体提供出色的支持，可以实时推送消息而无需轮询。</li><li><strong>多语言混合开发</strong> ：支持主流的开发语言，使 gRPC 成为多语言开发环境的理想选择。</li><li><strong>网络受限环境</strong> ： 使用 Protobuf（一种轻量级消息格式）序列化 gRPC 消息。gRPC 消息始终小于等效的 JSON 消息。</li></ul><h2 id="四种调用方式"><a href="#四种调用方式" class="headerlink" title="四种调用方式"></a>四种调用方式</h2><p>学习 gRPC 使用之前，先介绍一下 RPC 中的客户端与服务端。在 RPC 中，服务端会开启服务供客户端调用，每一句 RPC 调用都是一次客户端发请求到服务器获得相应的过程，中间过程被封装了，看起来像本地的一次调用一样，一次 RPC 调用也就是一次通讯过程。</p><p>RPC 调用通常根据双端是否流式交互，分为了<code>单项 RPC (Simple RPC)</code>、<code>服务端流式（Server-side streaming RPC）</code>、<code>客户端流式（Client-side streaming RPC）</code>、和<code>双向流式（Bidirectional streaming RPC）</code>四种方式。</p><ul><li><code>单项 RPC(Simple RPC)</code>：客户端发起请求并等待服务端响应，就是普通的 Ping-Pong 模式。</li><li><code>服务端流式 RPC（Server-side streaming RPC）</code>：服务端发送数据，客户端接收数据。客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。</li><li><code>客户端流式 RPC（Client-side streaming RPC）</code>：与服务端数据流模式相反，这次是客户端源源不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。</li><li><code>双向流式 RPC（Bidirectional streaming RPC）</code>：双方使用读写流去发送一个消息序列，两个流独立操作，双方可以同时发送和同时接收。</li></ul><p>为了便于大家理解四种 gRPC 调用的应用场景，这里举一个例子，假设你是小超，有一个女朋友叫婷婷，婷婷的每种情绪代表一个微服务，你们之间的每一次对话可以理解为一次 PRC 调用，为了便于画流程图，RPC 请求被封装成 client.SayHello，请求包为 HelloRequest，响应为 HelloReply。</p><h3 id="单项-RPC"><a href="#单项-RPC" class="headerlink" title="单项 RPC"></a>单项 RPC</h3><p>当你在等婷婷回去吃饭，婷婷在加班时，你们之间的 rpc 调用可能是这样的：</p><p><em>小超：回来吃饭吗</em></p><p><em>婷婷：还在加班</em></p><p>这就是单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220032151.png" alt="image-20240705220032151"></p><ul><li>client 层调用 SayHello 接口，把 HelloRequest 包进行序列化</li><li>client option 将序列化的数据发送到 server 端</li><li>server option 接收到 rpc 请求</li><li>将 rpc 请求返回给 server 端，server 端进行处理，将结果给 server option</li><li>server option 将 HelloReply 进行序列化并发给 client</li><li>client option 做反序列化处理，并返回给 client 层</li></ul><h3 id="服务端流式-RPC"><a href="#服务端流式-RPC" class="headerlink" title="服务端流式 RPC"></a>服务端流式 RPC</h3><p>当你比赛输了给婷婷发消息时：</p><p><em>小超：今天比赛输了</em></p><p><em>婷婷：没事，一次比赛而已</em></p><p><em>婷婷：晚上带你去吃好吃的</em></p><p>这就是服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220316542.png" alt=""></p><ul><li>client 层调用 SayHello 接口，把 HelloRequest 包进行序列化</li><li>client option 将序列化的数据发送到 server 端</li><li>server option 接收到 rpc 请求</li><li>将 rpc 请求返回给 server 端，server 端进行处理，将将数据流给 server option</li><li>server option 将 HelloReply 进行序列化并发给 client</li><li>client option 做反序列化处理，并返回给 client 层</li></ul><h3 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h3><p>当你惹婷婷生气的时候：</p><p><em>小超：怎么了，宝贝</em></p><p><em>小超：别生气了，带你吃好吃的</em></p><p><em>婷婷：滚</em></p><p>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220455218.png" alt="image-20240705220455218"></p><ul><li>client 层调用 SayHello 接口，把 HelloRequest 包进行序列化</li><li>client option 将序列化的数据流发送到 server 端</li><li>server option 接收到 rpc 请求</li><li>将 rpc 请求返回给 server 端，server 端进行处理，将结果给 server option</li><li>server option 将 HelloReply 进行序列化并发给 client</li><li>client option 做反序列化处理，并返回给 client 层</li></ul><h3 id="双向流-RPC"><a href="#双向流-RPC" class="headerlink" title="双向流 RPC"></a>双向流 RPC</h3><p>当你哄好婷婷时：</p><p><em>小超：今天看了一个超好看的视频</em></p><p><em>婷婷：什么视频</em></p><p><em>小超：发给你看看</em></p><p><em>婷婷：这也叫好看？</em></p><p>双向流 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220534237.png" alt="image-20240705220534237"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实弄懂了单项 RPC、服务端流式 RPC、客户端流式 RPC、双向流 PRC 四种 grpc 应用场景，实现起来非常容易</p><ol><li>根据应用场景选择好哪种 gRPC 服务</li><li>写好 proto 文件，用 protoc 生成.pb.go 文件</li><li>服务端实现接口 -&gt;listen -&gt; grpc.NewServer () -&gt; pb.RegisterGreetsServer (server, &amp;Server {}) -&gt; s.Serve (lis)</li><li>客户端 grpc.Dial-&gt;pb.NewGreetsClient-&gt;context.WithTimeout-&gt;client.SayHello (调用接口)-&gt; 如果是流传输则循环读取数据</li></ol><p>代码实现这里就不实现了，因为就算写也不是我实现的，所以这里就我自己在下面理解了。</p><p>最近这两天什么都没干，做什么事都提不起来兴趣，有一种抽离感，好煎熬啊，快点出结果吧，祝我面试顺利！！！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learnku.com/articles/58641">https://learnku.com/articles/58641</a></p><p><a href="https://grpc.io/blog/principles/">https://grpc.io/blog/principles/</a></p><p><a href="https://www.cnblogs.com/rickiyang/p/14758485.html">https://www.cnblogs.com/rickiyang/p/14758485.html</a></p><p><a href="https://bbs.huaweicloud.com/blogs/337073#H21">https://bbs.huaweicloud.com/blogs/337073#H21</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RPC 和 gRPC 其实是笔者在几个月前就开始接触的东西，但是由于当时在 Windows 上配不好环境加上学起来确实有点难度，所以就放下没去做项目，就简单地了解了一下。最近几天实在是没什么想学的，在拿起来看看吧，环境已经在 WSL 上配置好了，回头可以直接开始做项目了。&lt;</summary>
      
    
    
    
    <category term="技术剖析" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法——ZAB</title>
    <link href="http://example.com/2024/07/03/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94ZAB/"/>
    <id>http://example.com/2024/07/03/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94ZAB/</id>
    <published>2024-07-03T13:44:52.000Z</published>
    <updated>2024-07-03T15:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是分布式一致性算法的第三个——ZAB 算法。</p><h1 id="关于-ZAB-算法"><a href="#关于-ZAB-算法" class="headerlink" title="关于 ZAB 算法"></a>关于 ZAB 算法</h1><p>ZAB协议，全称 Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。它是专门为分布式协调服务——Zookeeper，设计的一种支持 <strong>崩溃恢复</strong> 和 <strong>原子广播</strong> 的协议。</p><p>从设计上看，ZAB协议和 Raft 很类似。ZooKeeper集群中，只有一个Leader节点，其余均为Follower节点。整个ZAB协议一共定义了四个阶段：<strong>选举（Leader Election）</strong>、 <strong>发现（Discovery）</strong> 、 <strong>同步（Synchronization）</strong> 、 <strong>广播（Broadcast）</strong> 。</p><p>ZAB借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。</p><p>在Zookeeper中主要依赖ZAB 协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。 这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后 Leader 客户端将数据同步到其他 Follower 节点。</p><p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；</p><p>如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>相比Paxos，Zab最大的特点是保证强一致性(strong consistency，或叫线性一致性linearizable consistency)。</p><ol><li><p>ZAB 协议需要确保那些已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交。</p></li><li><p>ZAB 协议需要确保丢弃那些只在 Leader 上被提出而没有被提交的事务。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1053629-d32b630b65a7a0b2.png" alt="zab 协议特性"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以事务 proposal （事务提议）的形式广播到所有的副本（Follower）进程上去。</p></li><li><p>保证一个全局的变更序列被顺序引用。</p><p>Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。</p><p>为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</p></li><li><p>当主进程出现异常的时候，整个zk集群依旧能正常工作。</p></li></ol><h1 id="直观理解：Zookeeper分布式一致性协议ZAB"><a href="#直观理解：Zookeeper分布式一致性协议ZAB" class="headerlink" title="直观理解：Zookeeper分布式一致性协议ZAB"></a>直观理解：Zookeeper分布式一致性协议ZAB</h1><p>基于ZAB协议，Zookeeper实现一种<strong>主备模式的系统架构来保持集群中主备副本之间数据的一致性</strong>。</p><p>ZAB算法分为两大块内容，<strong>消息广播 </strong>和 <strong>崩溃恢复</strong>。</p><ul><li>消息广播（boardcast）：Zab 协议中，所有的写请求都由 leader 来处理。正常工作状态下，leader 接收请求并通过广播协议来处理。 </li><li>崩溃恢复（recovery）：当服务初次启动，或者 leader 节点挂了，系统就会进入恢复模式，直到选出了有合法数量 follower 的新 leader，然后新 leader 负责将整个系统同步到最新状态。</li></ul><p>下面来详细介绍这两种基本模式的实现过程：</p><h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>消息广播是 Zookeeper 用来保证写入一致性的方法，在 Zookeeper 集群中，存在三种角色的节点：</p><ul><li>Leader：Zookeeper集群的核心角色，在集群启动或崩溃恢复中通过 Follower 参与选举产生，<strong>为客户端提供读写服务，并对事务请求进行处理</strong>。</li><li>Follower：Zookeeper 集群的核心角色，在集群启动或崩溃恢复中参加选举，没有被选上就是这个角色，<strong>为客户端提供读取服务</strong>，也就是处理非事务请求，Follower 不能处理事务请求，对于收到的事务请求会转发给Leader。</li><li>Observer：观察者角色，<strong>不参加选举，为客户端提供读取服务，处理非事务请求</strong>，对于收到的事务请求会转发给 Leader。使用 Observer 的目的是为了扩展系统，提高读取性能。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1.png" alt="img"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>下面通过几张图对ZAB的消息广播过程进行简单的介绍：</p><ol><li><p>Zookeeper各节点会接收来自客户端的请求，如果是非事务请求，各节点自行进行相应的处理。若接收到的是客户端的事务请求，如果当前节点是Follower则将该请求<strong>转发给当前集群中的Leader节点</strong>进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-4f5e54ed3eaa3ffc.png" alt="处理"></p></li><li><p>Leader接收到事务处理的请求后，将向所有的Follower节点发出Proposal提议，并等待各Follower的Ack反馈。</p><p>在广播事务之前Leader服务器会先给这个事务分配一个<strong>全局单调递增的唯一ID</strong>，也就是<strong>事务ID（zxid）</strong>，每一个事务必须按照zxid的先后顺序进行处理。</p><p>而且Leader服务器会为每一个Follower分配一个单独的队列，然后将需要广播的事务放到队列中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-5c507cccac9af7bd.png" alt="广播"></p></li><li><p>各Follower节点对Leader节点的Proposal进行Ack反馈，Leader对接收到的Ack进行统计，如果<strong>超多半数Follower进行了Ack，此时进行下一步操作</strong>，否则之间向客户端进行事务请求失败的Response。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-87240c31b1eea272.png" alt="超过一半"></p></li><li><p>如果Leader节点接收到了超过半数的Ack响应，此时Leader会向所有的Follower发出事务Commit的指令，同时自己也执行一次Commit，并向客户端进行事务请求成功的Response。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-2d0f4e7526b50878.png" alt="成功"></p></li></ol><p>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。</p><p>这也是 CAP/BASE 实现最终一致性的一个体现。</p><p>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO 消息队列进行收发消息，使用队列消息可以做到异步解耦。</p><p>Leader 和 Follower 之间只需要往队列中发消息即可。</p><p>如果使用同步的方式会引起阻塞，性能要下降很多。</p><h3 id="丢弃的事务proposal处理过程："><a href="#丢弃的事务proposal处理过程：" class="headerlink" title="丢弃的事务proposal处理过程："></a>丢弃的事务proposal处理过程：</h3><p>ZAB协议中使用ZXID作为事务编号，ZXID为64位数字，低32位为一个递增的计数器，每一个客户端的一个事务请求时Leader产生新的事务后该计数器都会加1， 高32位为Leader周期epoch编号，当新选举出一个Leader节点时Leader会取出本地日志中最大事务Proposal的ZXID解析出对应的epoch把该值加1作为新的epoch，将低32位从0开始生成新的ZXID；</p><p>ZAB使用epoch来区分不同的Leader周期，能有效避免了不同的leader服务器错误的使用相同的ZXID编号提出不同的事务proposal的异常情况，大大简化了提升了数据恢复流程；</p><p>所以这个崩溃的机器启动时，也无法成为新一轮的Leader，因为当前集群中的机器一定包含了更高的epoch的事务proposal。</p><hr><p>Zookeeper的消息广播过程类似 2PC（Two Phase Commit），ZAB <strong>仅需要超过一半以上的Follower返回 Ack 信息就可以执行提交，大大减小了同步阻塞，提高了可用性</strong>。</p><p>ZAB协议简化了2PC事务提交：</p><ol><li>去除中断逻辑移除，follower要么ack，要么抛弃Leader；</li><li>leader不需要所有的Follower都响应成功，只要一个多数派ACK即可。</li></ol><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>在 Zookeeper 集群启动、运行过程中，如果 Leader 出现崩溃、网络断开、服务停止或重启等异常情况，或集群中有新服务器加入时，ZAB 会让当前集群快速进入崩溃恢复模式并选举出新的 Leader 节点，在此期间，整个集群<strong>不对外提供任何读取服务</strong>。</p><p>当产生新的 Leader 后，并且集群中有过半的 Follower 完成了与 Leader 的状态同步，那么 ZAB 协议就会让 Zookeeper 集群从崩溃恢复模式转换成消息广播模式。</p><p>崩溃恢复的<strong>目的</strong>就是保证当前Zookeeper集群快速选举出一个新的Leader并完成与其他Follower的状态同步，以便尽快进入消息广播模式对外提供服务。</p><p>Zookeeper崩溃恢复的主要任务就是选举Leader（Leader Election），Leader选举分两个场景：一个是Zookeeper服务器启动时Leader选举，另一个是Zookeeper集群运行过程中Leader崩溃后的Leader选举。</p><p><strong>参数</strong></p><p>在详细介绍Leader选举过程之前，需要先介绍几个参数：</p><ul><li><p>myid: 服务器ID，这个是在安装 Zookeeper 时配置的，myid 越大，该服务器在选举中被选为 Leader 的优先级会越大。</p></li><li><p>zxid: 事务ID，这个是由 Zookeeper 集群中的 Leader 节点进行 Proposal 时生成的全局唯一的事务ID，由于只有 Leader 才能进行Proposal，所以这个zxid很容易做到全局唯一且自增。因为 Follower 没有生成zxid的权限。zxid越大，表示当前节点上提交成功了最新的事务，这也是为什么在崩溃恢复的时候，需要优先考虑zxid的原因。</p></li><li><p>epoch: 投票轮次，每完成一次Leader选举的投票，当前Leader节点的epoch会增加一次。在没有Leader时，本轮此的epoch会保持不变。</p></li></ul><p><strong>优先选择 myid + zxid 最大的数据。</strong></p><p>另外在选举的过程中，每个节点的当前状态会在以下几种状态之中进行转变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOOKING: 竞选状态。 </span><br><span class="line"></span><br><span class="line">FOLLOWING: 随从状态，同步Leader 状态，参与Leader选举的投票过程。 </span><br><span class="line"></span><br><span class="line">OBSERVING: 观察状态，同步Leader 状态，不参与Leader选举的投票过程。 </span><br><span class="line"></span><br><span class="line">LEADING: 领导者状态。</span><br></pre></td></tr></table></figure><h3 id="集群启动时的-Leader-选举"><a href="#集群启动时的-Leader-选举" class="headerlink" title="集群启动时的 Leader 选举"></a>集群启动时的 Leader 选举</h3><p>假设现在存在一个由5个Zookeeper服务器组成的集群Sever1，Sever2，Sever3，Sever4和Sever5，集群的myid分别为：1， 2，3，4，5。</p><p>依次按照myid递增的顺序进行启动。</p><p>由于<strong>刚启动时zxid和epoch都为0，因此Leader选举的关键因素成了myid</strong>。</p><ol><li>启动Sever1，此时整个集群中只有Sever1启动，Sever1无法与其他任何服务建立通信，立即进入LOOKING状态，此时Server1给自己投1票（上来都觉得自己可以做Leader），由于1不大于集群总数的一半，即2，此时Sever1保持LOOKING状态。</li><li>启动Sever2，此时Sever2与Server1建立通信，Sever1和Sever2互相交换投票信息，Server1投票的myid为1，Server2投票的myid为2，此时选取myid最大的，因此Sever1的投票会变成2，但是由于目前投票Server2的服务器数量为2台，小于集群总数的一半2，因此Sever1和Sever2继续保持LOOKING状态。</li><li>启动Sever3，此时三台服务器之间建立了通信，Server3进入LOOKING状态，并与前两台服务器交换投票信息，Server1和Server2的投票信息为2，Server3投票自己，即myid为3，这个时候选择myid最大的作为Leader。此时集群中投票3的服务器数量变成了3台，此时3&gt;2，Sever3立刻变成LEADING状态，Sever1和Sever2变成FOLLOWING状态。</li><li>启动Sever4，Sever4进入LOOKING状态并与前三台服务器建立通信，由于集群中已经存在LEADING状态的节点，因此，Sever4立刻变为FOLLOWING状态，此时Sever3依旧处于LEADING状态。</li><li>启动动Sever5，Sever5与Sever4一样，在与其他服务器建立通信后会立刻变为FOLLOWING状态，此时Sever3依旧处于LEADING状态。</li></ol><p>最终整个Zookeeper集群中，Server3成为Leader，Server1，Server2，Server4和Server5成为Follower，最终Server3的epoch加一。</p><p>ps: 启动时，都给自己投一票，选举时，优先按照 myid 对比。超过一半的数量，则成为 leader。</p><h3 id="Leader-崩溃时的-Leader-选举"><a href="#Leader-崩溃时的-Leader-选举" class="headerlink" title="Leader 崩溃时的 Leader 选举"></a>Leader 崩溃时的 Leader 选举</h3><p>在Zookeeper集群刚启动的时候，zxid和epoch并不参与群首选举。</p><p>但是如果Zookeeper集群在运行了一段时间之后崩溃了，那么epoch和zxid在Leader选举中的重要性将大于myid。</p><p>重要性的排序为：<code>epoch &gt; zxid &gt; myid</code>。</p><p>当某一个Follower与Leader失去通信的时候，就会进入Leader选举，此时Follower会跟集群中的其他节点进行通信，但此时会存在两种情况：</p><p>1) Follower与Leader失去通信，但此时集群中的Follower并未崩溃，且与其他Follower保持正常通信。此时当该Follower与其他Follower进行通信时，其他Follower会告诉他，老大还活着，这个时候，Follower仅需要与Leader建立通信即可。<br>2) Leader真的崩溃了，此时集群中所有节点之间会进行通信，当得知老大挂了之后，每个节点都会开启争老大模式，各自会将当前节点最新的epoch，zxid和myid发送出来，参与投票，此时各节点之间会参照 <code>epoch &gt; zxid &gt; myid</code> 进行Leader选举，最后投票数超过集群数量一般的节点会成为新的Leader。</p><p>这种崩溃后的Leader选举机制也很好理解，如果Leader挂了，优先选择集群中最后做过（epoch）Leader的节点为新的Leader节点，其次选取有最新事务提交的节点（zxid）为Leader，最后才按默认的最大机器编号（myid）进行投票。</p><h1 id="保持数据一致性"><a href="#保持数据一致性" class="headerlink" title="保持数据一致性"></a>保持数据一致性</h1><p>ZooKeeper从以下几点保证了数据的一致性</p><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>来自任意特定客户端的更新都会按其发送顺序被提交。</p><p>也就是说，如果一个客户端将Znode z的值更新为a，在之后的操作中，它又将z的值更新为b，则没有客户端能够在看到z的值是b之后再看到值a（如果没有其他对z的更新）。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果。</p><h2 id="单一系统映像"><a href="#单一系统映像" class="headerlink" title="单一系统映像"></a>单一系统映像</h2><p>一个客户端无论连接到哪一台服务器，它看到的都是同样的系统视图。</p><p>这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比在之前服务器上所看到的更老。</p><p>当一台服务器出现故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有滞后于故障服务器的服务器都不会接受该连接请求，除非这些服务器赶上故障服务器。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一个更新一旦成功，其结果就会持久存在并且不会被撤销。</p><p>这表明更新不会受到服务器故障的影响。</p><h1 id="Zab特殊情况下需要解决的两个问题"><a href="#Zab特殊情况下需要解决的两个问题" class="headerlink" title="Zab特殊情况下需要解决的两个问题"></a>Zab特殊情况下需要解决的两个问题</h1><p>崩溃恢复过程中，为了保证数据一致性需要处理特殊情况：</p><ol><li><p>已经被Leader提交的proposal确保最终被所有的服务器follower提交</p></li><li><p>确保那些只在Leader被提出的proposal被丢弃</p></li></ol><p>针对这个要求,如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高的ZXID事务proposal，就可以保证这个新选举出来的Leader一定具有所有已经提交的提案，也可以省去Leader服务器检查proposal的提交与丢弃的工作。</p><h2 id="已经被处理的事务请求（proposal）不能丢（commit的）"><a href="#已经被处理的事务请求（proposal）不能丢（commit的）" class="headerlink" title="已经被处理的事务请求（proposal）不能丢（commit的）"></a>已经被处理的事务请求（proposal）不能丢（commit的）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 收到合法数量 follower 的 ACKs 后，就向各个 follower 广播 COMMIT 命令，同时也会在本地执行 COMMIT 并向连接的客户端返回「成功」。但是如果在各个 follower 在收到COMMIT 命令前 leader 就挂了，导致剩下的服务器并没有执行都这条消息。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol><li><p>选举拥有 proposal 最大值（即 zxid 最大） 的节点作为新的 leader。</p><blockquote><p>由于所有提案被 COMMIT 之前必须有合法数量的 follower ACK，即必须有合法数量的服务器的事务日志上有该提案的 proposal，因此，zxid最大也就是数据最新的节点保存了所有被 COMMIT 消息的 proposal 状态。</p></blockquote></li><li><p>新的 leader 将自己事务日志中 proposal 但未 COMMIT 的消息处理。</p></li><li><p>新的 leader 与 follower 建立先进先出的队列， 先将自身有而 follower 没有的 proposal 发送给 follower，再将这些 proposal 的 COMMIT 命令发送给 follower，以保证所有的 follower 都保存了所有的 proposal、所有的 follower 都处理了所有的消息</p></li></ol><h2 id="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"><a href="#没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？" class="headerlink" title="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"></a>没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 接收到消息请求生成 proposal 后就挂了，其他 follower 并没有收到此 proposal，因此经过恢复模式重新选了 leader 后，这条消息是被跳过的。 此时，之前挂了的 leader 重新启动并注册成了 follower，他保留了被跳过消息的 proposal 状态，与整个系统的状态是不一致的，需要将其删除。</p><h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>Zab 通过巧妙的设计 zxid 来实现这一目的。</strong></p><p>一个 zxid 是64位，高 32 是纪元（epoch）编号，每经过一次 leader 选举产生一个新的 leader，新 leader 会将 epoch 号 +1。低 32 位是消息计数器，每接收到一条消息这个值 +1，新 leader 选举后这个值重置为 0。</p><p>这样设计的好处是旧的 leader 挂了后重启，它不会被选举为 leader，因为此时它的 zxid 肯定小于当前的新 leader。当旧的 leader 作为 follower 接入新的 leader 后，新的 leader 会让它将所有的拥有旧的 epoch 号的未被 COMMIT 的 proposal 清除。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近的几篇文章都是围绕着分布式系统来开展的，学习了一些一致性算法和 ID 生成算法，每次开始学习这种新的知识的时候我都会感慨他们简直就是天才，十分神奇。有机会的话还会去更加全面的学习，现在还是只停留在纸面上，还没找到合适的机会去实战。</p><p>今天上午面试结束了，准备了很长时间也确实收获了很多东西，应该算是找到了比较正确的学习方法。除了学习方面的问题，通过昨天准备 HR 面的时候好好反思了自己的一些问题，还是觉得做事急于求成和功利心这方面的问题要及时纠正，最近两周也有在做一些调整，还是需要改掉这些毛病的，最起码要保证做一些事情的时候不要老是想成功了之后怎样怎样、失败了怎样怎样。</p><p>昨天晚上紧张的整晚都没睡好觉，今天早上六点多就起来了，准备了一下面试的东西，虽然面试的时候没有问，但是我确实有了不小的底气。至于结果怎么样，我非常希望会是一个好的结果，估计要到一周之后见分晓了。在北京、字节的王牌部门，如果能进去实习当然会往转正的方向努力。祝我面试成功！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是分布式一致性算法的第三个——ZAB 算法。&lt;/p&gt;
&lt;h1 id=&quot;关于-ZAB-算法&quot;&gt;&lt;a href=&quot;#关于-ZAB-算法&quot; class=&quot;headerlink&quot; title=&quot;关于 ZAB 算法&quot;&gt;&lt;/a&gt;关于 ZAB 算法&lt;/h1&gt;&lt;p&gt;ZAB协议，全称 Z</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法——Raft</title>
    <link href="http://example.com/2024/07/01/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Raft/"/>
    <id>http://example.com/2024/07/01/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Raft/</id>
    <published>2024-07-01T13:04:35.000Z</published>
    <updated>2024-07-01T14:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>几天前更新的文章里降到了一致性算法，也详细地写了 Paxos 算法的内部原理，今天我们继续学习分布式一致性算法的其他两种，由于篇幅有限，所以一篇博客写一个算法。</p><h1 id="关于-Raft-算法"><a href="#关于-Raft-算法" class="headerlink" title="关于 Raft 算法"></a>关于 Raft 算法</h1><p>Raft 是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的 Paxos。</p><p>Paxos 算法是分布式系统领域最重要的一致性算法，同时也是公认的极为艰深难懂的算法。为了解决这个晦涩难懂的问题，斯坦福大学的Diego Ongaro、John Ousterhout教授以容易理解（Understandability）为目标设计了这个新的一致性算法：Raft，并在2013年发布了论文：《In Search of an Understandable Consensus Algorithm》。为了验证这个容易理解的特性，他们分别在斯坦福大学和加州大学伯克利分校的分布式计算课程上，使用了Raft和Paxos两种算法，采用视频教学的方式来传授给学生，之后采用小测验的方式来验证。结果表明 Raft 比 Paxos 容易理解很多。</p><p>Raft 和 Paxos 一样只要保证 n/2+1 节点（即超过半数节点）正常工作就能够提供服务。在设计层面，Raft 把算法流程分为三个子问题：领导选举（Leader election）、日志复制（Log replication）、安全性（Safety）。 Raft 开始时在集群中选举出 Leader 负责日志复制的管理，Leader 接受来自客户端的事务请求（日志），并将它们复制给集群的其他节点，然后负责通知集群中其他节点提交日志，Leader 负责保证其他节点与他的日志同步，当 Leader 宕机后集群其他节点会发起选举选出新的 Leader。</p><h2 id="Raft-算法使用场景"><a href="#Raft-算法使用场景" class="headerlink" title="Raft 算法使用场景"></a>Raft 算法使用场景</h2><p>一般用作两种场景：<strong>元数据管理</strong>：比如 etcd，特点是数据规模小，主要保证<strong>数据一致性</strong>和<strong>集群的高可用（Raft选主）</strong>，所以一套 Raft 集群就够了，<strong>分布式数据库</strong>：这种会用 parttion group，每个 group 有一个 Raft 集群，当数据变大的时候会做拓展。</p><blockquote><p>Raft只是个共识算法来保证数据的一致性，与数据库客户端、事务没有关系</p></blockquote><h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><p>Reft 算法流程分为三个子问题：领导选举（Leader election）、日志复制（Log replication）、安全性（Safety）。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li>领导者 Leader：接收处理客户端请求、向 Follower 进行日志同步、同一时刻最多只能有一个可行的 Leader。</li><li>追随者 Follower：接受并持久化 Leader 同步的日志，在 Leader 告之日志可以提交之后，提交日志，处在完全被动状态。</li><li>候选人 Candidate：临时角色，处于 Leader 和 Follower 之间的暂时状态。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/39ba62045eb5c0f8cbbc2b8aa99badad.png" alt="img"></p><p>Raft算法中在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a7531168a16a5b7cb5091b2fe06eb8ca.png" alt="img"></p><p><strong>状态切换流程：</strong></p><ol><li>Raft 刚启动的时候，所有节点初始状态都是 Follower</li><li>超时时间内如果没有收到 Leader 的请求，则转换为 Candidate 角色并发起 Leader 选举</li><li>如果 Candidate 收到了多数节点的选票则转换为 Leader</li><li>如果在发起选举期间发现已经有 Leader 了，或者收到更高任期的请求则转换为 Follower</li><li>Leader 在收到更高任期的请求后转换为 Follower</li></ol><h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><p>可以理解为是节点担任 Leader 职务的时间期限。</p><p>Raft 将时间划分为一个一个的任期（term），每个任期由单调递增的数字（人气编号）标识，工作期可长可短可能不存在。</p><blockquote><p>任期时间 = 选举时间 + 正常运行时间</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7fc521859d0fb400f01877953d410b96.png" alt="img"></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>Raft 中服务器节点之间通信通过两个 RPC 调用：</p><ul><li>请求投票 RequestVote：候选人(Candidate) 选举期间发起</li><li>日志复制 AppendEntries：领导人(Leader)发起，用于复制 log 和发送心跳</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7ccfe7004ee130b435c7f808be0839f8.png" alt="img"></p><h1 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h1><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>初始状态时，每个节点的角色都是 Follower (跟随者)，Term 任期编号为 1 (假设任期编号从1开始)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/26963445b747cd52f7534d03d3cfe213.png" alt="img"></p><p>不过这两种情况会触发选举：</p><ul><li>Raft 初次启动时，不存在 Leader，这时候会触发 Leader 选举</li><li>Follower 在自己的超时时间内没有接收到 Leader 的心跳 heartBeat，触发选举超时，从而 Follower 的角色切换成 Candidate，Candidate 会发起选举</li></ul><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>既然有两种情况下会触发选举，一个是初次启动，一个是Leader故障未发送心跳给Follower，那么我们假设有五个节点，然后分别用图来看下是如何选举的！</p><p><strong>初始启动时：</strong></p><p>初次启动节点都是正常流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d01d252e6630b2a6594f5cc3a2cf2516.png" alt="img"></p><p><strong>Leader 故障时：</strong></p><p>Node2此时是Leader 节点，结果故障了，剩下四个节点参与选举：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/175a55e163fb0e173eb3cf8971dec5ad.png" alt="img"></p><h2 id="当选条件"><a href="#当选条件" class="headerlink" title="当选条件"></a>当选条件</h2><p>在一个任期（Term）内只可以投票给一个结点，得到超过半数的投票才可成为 Leader，从而保证了一个任期内只会有一个 Leader 产生。</p><h1 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h1><p>概括成一句话就是：<strong>保证Leader上日志能完全相同地复制到多台Follower服务器上。</strong></p><p>OK！我们看下是如何进行同步的。</p><h2 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h2><p>Raft算法中，每个节点维护着一份日志，其中包含了系统中所有状态变更的记录，每一次状态变更被称为一个日志条目。</p><p>我们先看日志结构和右侧说明：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/213828ecfbb19cea31428ec6a8cd6cc9.png" alt="img"></p><p>图中每个节点存储自己的日志副本(log[])，每条日志记录包含：</p><ul><li>索引 (log index)：记录在日志中的位置，是一个连续单调递增整数</li><li>任期号 (term)：日志记录被创建时Leader的任期号，上图中有三个任期</li><li>命令 (command)：客户端请求指定的、状态机需要执行的指令</li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>了解完日志结构后，我们来看日志是如何发起同步的。</p><p><strong>日志持久化存储的条件</strong></p><p>Follower节点必须先将记录安全写到磁盘，才能向Leader节点返回写入成功响应。</p><p>如果一条日志记录被存储在超过半数的节点上，我们认为该记录已提交(committed)——这是 Raft 非常重要的特性！如果一条记录已提交，意味着状态机可以安全地执行该记录</p><p><strong>流程如下图：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7a78999c1896181c3ca0eb79f03a8acf.png" alt="img"></p><ol><li>客户端向 Leader 发送命令，希望该命令被所有状态机执行；</li><li>Leader 先将该命令追加到自己的日志中；</li><li>Leader 并行地向其它节点发送AppendEntries RPC，等待响应；</li><li>收到超过半数节点的响应，则认为新的日志记录是被提交的：</li><li>Leader 将命令传给自己的状态机，然后向客户端返回响应</li><li>此外，一旦 Leader 知道一条记录被提交了，将在后续的AppendEntries RPC中通知已经提交记录的 Followers</li><li>Follower 将已提交的命令传给自己的状态机</li><li>如果 Follower 宕机/超时：Leader 将反复尝试发送 RPC；</li></ol><blockquote><p>Leader 不必等待每个 Follower 做出响应，只需要超过半数的成功响应（确保日志记录已经存储在超过半数的节点上），一个很慢的节点不会使系统变慢，因为 Leader 不必等待。</p></blockquote><h2 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h2><p>Raft 通过 AppendEntries RPC 消息来检测。</p><ul><li>每个AppendEntries RPC包含新日志记录之前那条记录的索引 (prevLogIndex) 和任期 (prevTerm)；</li><li>Follower接收到消息后检查自己的 log index 、 term 与 prevLogIndex 、 prevTerm 进行匹配</li><li>匹配成功则接收该记录，添加最新log，匹配失败则拒绝该消息</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0f1b62539e3fbb42d6b1effd2bedf236.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f3966f5f1a26d6a30aef6c55b6c02e4b.png" alt="img"></p><h2 id="日志一致性"><a href="#日志一致性" class="headerlink" title="日志一致性"></a>日志一致性</h2><p>Raft算法的目的是保证所有节点的一致性，即一个日志条目在某个节点被提交，那么这个日志条目也必须在所有节点上被提交。</p><blockquote><p>通过【<strong>一致性检查</strong>】就保证了日志一致性的这两点内容。</p></blockquote><ul><li>如果两个节点的日志在相同的索引位置上的任期号相同，则认为他们具有一样的命令，从头到这个索引位置之间的日志完全相同</li><li>如果给定的记录已提交，那么所有前面的记录也已提交</li></ul><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>Raft增加了如下两条限制以保证安全性:</p><ul><li><p>拥有最新的已提交的 log entry 的 Follower才有资格成为Leader。</p><p>这个保证是在 RequestVote RPC中做的，Candidate 在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新。</p></li><li><p>Leader只能推进commit index来提交当前 term 的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交(log index 小于 commit index的日志被间接提交)。</p></li></ul><p>之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-8.jpg" alt="img"></p><p>在阶段a，term为2，S1是Leader，且S1写入日志(term, index)为(2, 2)，并且日志被同步写入了S2；</p><p>在阶段b，S1离线，触发一次新的选主，此时S5被选为新的 Leader，此时系统 term 为3，且写入了日志(term, index)为(3， 2);</p><p>S5尚未将日志推送到 Followers 就离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志(2， 2)同步到了S3，而此时由于该日志已经被同步到了多数节点(S1, S2, S3)，因此，此时日志(2，2)可以被提交了。；</p><p>在阶段d，S1又下线了，触发一次选主，而S5有可能被选为新的Leader(这是因为S5可以满足作为主的一切条件: 1. term = 5 &gt; 4，2. 最新的日志为(3，2)，比大多数节点(如S2/S3/S4的日志都新)，然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志(2，2)被截断了。</p><p>增加上述限制后，即使日志(2，2)已经被大多数节点(S1、S2、S3)确认了，但是它不能被提交，因为它是来自之前term(2)的日志，直到S1在当前term(4)产生的日志(4， 4)被大多数Followers确认，S1方可提交日志(4，4)这条日志，当然，根据Raft定义，(4，4)之前的所有日志也会被提交。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志(4，4)。</p><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p><p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p><p>Snapshot中包含以下内容:</p><ul><li>日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。</li><li>系统当前状态。</li></ul><p>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC。</p><p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p><p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p><h2 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h2><p>成员变更是在集群运行过程中副本发生变化，如增加/减少副本数、节点替换等。</p><p>成员变更也是一个分布式一致性问题，既所有服务器对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的一致性达成的过程中，参与投票的进程会发生变化。</p><p>如果将成员变更当成一般的一致性问题，直接向Leader发送成员变更请求，Leader复制成员变更日志，达成多数派之后提交，各服务器提交成员变更日志后从旧成员配置(Cold)切换到新成员配置(Cnew)。</p><p>因为各个服务器提交成员变更日志的时刻可能不同，造成各个服务器从旧成员配置(Cold)切换到新成员配置(Cnew)的时刻不同。</p><p>成员变更不能影响服务的可用性，但是成员变更过程的某一时刻，可能出现在Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-9.jpg" alt="img"></p><p>由于成员变更的这一特殊性，成员变更不能当成一般的一致性问题去解决。</p><p>为了解决这一问题，Raft提出了两阶段的成员变更方法。集群先从旧成员配置Cold切换到一个过渡成员配置，称为共同一致(joint consensus)，共同一致是旧成员配置Cold和新成员配置Cnew的组合Cold U Cnew，一旦共同一致Cold U Cnew被提交，系统再切换到新成员配置Cnew。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-10.jpg" alt="img"></p><p>Raft两阶段成员变更过程如下:</p><ul><li>Leader收到成员变更请求从Cold切成Cnew；</li><li>eader在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧成员配置共存，写入本地日志，同时将该log entry复制至Cold∪Cnew中的所有副本。在此之后新的日志同步需要保证得到Cold和Cnew两个多数派的确认；</li><li>Follower收到Cold∪Cnew的log entry后更新本地日志，并且此时就以该配置作为自己的成员配置；</li><li>如果Cold和Cnew中的两个多数派确认了Cold U Cnew这条日志，Leader就提交这条log entry；</li><li>接下来Leader生成一条新的log entry，其内容是新成员配置Cnew，同样将该log entry写入本地日志，同时复制到Follower上；</li><li>Follower收到新成员配置Cnew后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在Cnew这个成员配置中会自动退出；</li><li>Leader收到Cnew的多数派确认后，表示成员变更成功，后续的日志只要得到Cnew多数派确认即可。Leader给客户端回复成员变更执行成功。</li></ul><p>异常分析:</p><ul><li>如果Leader的Cold U Cnew尚未推送到Follower，Leader就挂了，此后选出的新Leader并不包含这条日志，此时新Leader依然使用Cold作为自己的成员配置。</li><li>如果Leader的Cold U Cnew推送到大部分的Follower后就挂了，此后选出的新Leader可能是Cold也可能是Cnew中的某个Follower。</li><li>如果Leader在推送Cnew配置的过程中挂了，那么同样，新选出来的Leader可能是Cold也可能是Cnew中的某一个，此后客户端继续执行一次改变配置的命令即可。</li><li>如果大多数的Follower确认了Cnew这个消息后，那么接下来即使Leader挂了，新选出来的Leader肯定位于Cnew中。</li><li>两阶段成员变更比较通用且容易理解，但是实现比较复杂，同时两阶段的变更协议也会在一定程度上影响变更过程中的服务可用性，因此我们期望增强成员变更的限制，以简化操作流程。</li></ul><p>两阶段成员变更，之所以分为两个阶段，是因为对Cold与Cnew的关系没有做任何假设，为了避免Cold和Cnew各自形成不相交的多数派选出两个Leader，才引入了两阶段方案。</p><p>如果增强成员变更的限制，假设Cold与Cnew任意的多数派交集不为空，这两个成员配置就无法各自形成多数派，那么成员变更方案就可能简化为一阶段。</p><p>那么如何限制Cold与Cnew，使之任意的多数派交集不为空呢? 方法就是每次成员变更只允许增加或删除一个成员。</p><p>可从数学上严格证明，只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派。</p><p>一阶段成员变更:</p><ul><li>成员变更限制每次只能增加或删除一个成员(如果要变更多个成员，连续变更多次)。</li><li>成员变更由Leader发起，Cnew得到多数派确认后，返回客户端成员变更成功。</li><li>一次成员变更成功前不允许开始下一次成员变更，因此新任Leader在开始提供服务前要将自己本地保存的最新成员配置重新投票形成多数派确认。</li><li>Leader只要开始同步新成员配置，即可开始使用新的成员配置进行日志同步。</li></ul><h1 id="Raft-和-Multi-Paxos对比"><a href="#Raft-和-Multi-Paxos对比" class="headerlink" title="Raft 和 Multi-Paxos对比"></a>Raft 和 Multi-Paxos对比</h1><p>Raft与Multi-Paxos都是基于领导者的一致性算法，乍一看有很多地方相同，下面总结一下Raft与Multi-Paxos的异同。</p><p>Raft与Multi-Paxos中相似的概念:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-11.jpg" alt="img"></p><p>Raft与Multi-Paxos的不同:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-12.jpg" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>没更新的几天去干嘛了，有在学习，只是没去学习全新的东西，回过头去看了看之前没注意的一些知识点，收获非常大。不过不打算写博客来记录了，学到最多的还是一些关于 Go 底层实现的一些东西，我也是在看别人写的书，没有什么实际收获，只是去理解了一下，所以觉得没有再写博客的必要。</p><p>学习使我快乐，学习使我快乐，学习是我快乐。幸亏最近几天有去做算法题，才不至于在做笔试的时候手忙脚乱的。老规矩，祝我面试顺利！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几天前更新的文章里降到了一致性算法，也详细地写了 Paxos 算法的内部原理，今天我们继续学习分布式一致性算法的其他两种，由于篇幅有限，所以一篇博客写一个算法。&lt;/p&gt;
&lt;h1 id=&quot;关于-Raft-算法&quot;&gt;&lt;a href=&quot;#关于-Raft-算法&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法——Paxos</title>
    <link href="http://example.com/2024/06/27/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Paxos/"/>
    <id>http://example.com/2024/06/27/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Paxos/</id>
    <published>2024-06-27T11:23:50.000Z</published>
    <updated>2024-06-28T04:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在正式学习一致性算法之前，先来看一个问题。</p><p>基于前面对分布式系统环境下一致性与共识算法的基础理论，在分布式系统中进行节点通信大部分采用基于消息传递通信模型，不可避免的会发生如进程可能会变慢、被杀死或者重启等问题，会对分布式系统中各节点对某一值达成一致性产生问题。</p><p>如何解决这一问题，这就要引出今天的主角——Paxos。</p><h1 id="关于-Paxos"><a href="#关于-Paxos" class="headerlink" title="关于 Paxos"></a>关于 Paxos</h1><p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/莱斯利·兰伯特">莱斯利·兰伯特open in new window</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p><p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p><p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p><p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p><p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">《The Part-Time Parliament》open in new window</a></p><p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">《Paxos Made Simple》open in new window</a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p><p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/paxos-made-simple-v2KTTWQx.png" alt="img"></p><blockquote><p>The Paxos algorithm, when presented in plain English, is very simple.</p></blockquote><p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p><p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p><hr><p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p><p>自Paxos问世以来就持续垄断了分布式一致性算法，Paxos 这个名词几乎等同于分布式一致性。</p><p>Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如<strong>Chubby</strong>、<strong>Megastore</strong>以及Spanner等。开源的<strong>ZooKeeper</strong>，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p><p>但是它也有两个明显的缺点：</p><ol><li>难以理解</li><li>在工程是实现上比较复杂。</li></ol><hr><p>回到上面的问题，在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序还有网络分区）等情况。</p><p>Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><blockquote><p>这里的<strong>某个数据</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令。根据场景的不同，<strong>某个数据的值</strong>有不同的含义。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308090054350-634944220.png" alt="img"></p><h2 id="Paxos-中的角色"><a href="#Paxos-中的角色" class="headerlink" title="Paxos 中的角色"></a>Paxos 中的角色</h2><p>在 Paxos 算法中，有三种角色：</p><ul><li>Proposer (提案者)</li><li>Acceptor (人大代表)</li><li>Learners (广大群众)</li></ul><p>需要注意的是，在具体的算法实现中，并不是一个进程只能担任一种角色，它有可能会同时充当多个。比如一个进程<strong>既是Proposer又是Acceptor还是Learner</strong>。</p><p>还有一个很重要的概念叫<strong>提案（Proposal）</strong>，最终要达成一致的 value 就在提案里。</p><p>这个提案到底是什么？是仅仅包含一个信息数值吗？目前咱们先认为仅仅是一个普普通通的 value。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308091709138-1381398784.png" alt="img"></p><p>Paxos 算法过程和我国的立法过程是极其相似的（法律案的提出、法律案的审议、法律案的表决、法律的公布四个阶段），所谓的提案就是新颁布法律。</p><p>Proposer (提案者)可以提出（propose）提案；Accoptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p><p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p><ul><li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li><li>Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。</li><li>Learner：作为一个学习者，Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li></ul><h2 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h2><p>假设有一组可以<strong>提出（propose）value</strong>的进程集合（提案者团队），一个一致性算法需要保证提出的这么多value中，仅仅<strong>只有一个相同的</strong>value被选定（chosen）。也就是说要么没有value被提出，只要提出了value并且被选定，那么大家最终学习到的value必须是一致的。对于一致性算法，<strong>安全性（safaty）</strong>要求如下：</p><ul><li>只有被提出的value才能被选定。</li><li>只有一个value被选定。</li><li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li></ul><blockquote><p>“Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>如果假设不同角色之间可以通过发送消息来进行通信，那么：</p><ul><li>每个角色以各自任意的速度进行通信执行，在这个过程中可能会因为各种原因出错而导致执行停止或重启。当一个value被选定之后，因为故障原因才恢复正常的角色因为失去了某些重要的信息，导致它们无法确定被选定的值。</li><li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li></ul><p>以上都是可能会遇到的问题，要怎么解决？？？</p><h1 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h1><h2 id="最简单的方案——只有一个-Acceptor"><a href="#最简单的方案——只有一个-Acceptor" class="headerlink" title="最简单的方案——只有一个 Acceptor"></a>最简单的方案——只有一个 Acceptor</h2><p>假设只有一个 Acceptor（可以有多个 Proposer），只要 Acceptor 接受它收到的第一提案，则该提案被选定，该提案中的 value 就是被选定的 value。这样就保证只有一个 value 会被选定。</p><p>但是，如果唯一的 Acceptor 宕机了，那么整个系统就<strong>无法工作</strong>了！</p><p>因此，一个 Acceptor 是不可行的，必须要有多个 Acceptor！</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308093407946-175720911.png" alt="img"></p><h2 id="多个-Acceptor"><a href="#多个-Acceptor" class="headerlink" title="多个 Acceptor"></a>多个 Acceptor</h2><p>当有多个 Acceptor 的时候，如何保证在多个 Proposal 和多个 Acceptor 的情况下选定一个 value。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308094655679-884014389.png" alt="img"></p><p>首先，我们的目标是无论有多少个 Proposal 提出天，有且仅有一个 value 被选定？</p><p>那么，我们可以先定义一个约束：</p><p><strong>“P1：一个 Acceptor 必须接受它受到的第一个提案。”</strong></p><p>但是，这样又会出现其他的问题：如果每个 Proposal 所提出的提案 value 是不同的，并且将提案发送给不同的 Acceptor。根据 P1 约束，每个 Acceptor 都接受它收到的第一个提案，就会出现不同的 value 被选定的情况不一样，出现了不一致。</p><p>为了解决新出现的问题，我们加入一个新的<strong>规定</strong>：</p><p><strong>“规定：一个提案被选定需要半数以上的 Acceptor 接受”</strong></p><p>一个提案被半数以上接受，说明『一个 Acceptor 必须能够接受不止一个提案！』，不然可能导致最终没有 value 被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个 Acceptor 的接受，并没有被超过半数以上的 Acceptor 接受。</p><p>最开始将【<strong>提案</strong> <strong>= value</strong>】已经无法满足现在的需求，因为当一个 Proposer 发送多个提案到一个 Acceptor 的时候，需要使用一个编号来区分被提出的顺序。现在【<strong>提案=提案编号+value</strong>】。</p><p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的 value 值，否则又会出现不一致。</p><p><strong>“P2：如果某个 value 为 v 的提案被选定了，那么每个编号更高的被选定提案的 value 必须也是 v”</strong></p><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><p><strong>“P2a：如果某个 value 为 v 的提案被选定了，那么每个编号更高的被 Acceptor 接受的提案的 value 必须也是 v。”</strong></p><p>只要满足了P2a，就能满足P2。</p><hr><p>但是，考虑如下的情况：以立法过程为背景，假设总的有5个人大代表（Acceptor）。</p><p><strong>人民法院</strong>（Proposer2）提出[M1,V1]的提案，<strong>人大代表2-5号</strong>（半数以上）均接受了该提案，于是对于人大代表2-5号和人民法院来讲，它们都认为V1提案是被选定的。此时，<strong>人大代表1</strong>在办完其它事务之后也参与到其中（之前人大代表1没有收到过任何提案），此时<strong>最高人民检察院</strong>（另一个提案者Proposer1）向人大代表1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于人大代表1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,人大代表1必须接受该提案！同时人大代表1认为V2被选定。这就出现了两个问题：</p><ol><li>人大代表1认为V2被选定，人大代表2-5和人民法院认为V1被选定。出现了不一致。</li><li>V1被选定了，但是编号更高的被人大代表1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308102821869-269261256.png" alt="img"></p><p>所以，我们要对 P2a 约束进行加强。</p><p>P2a 是对 Acceptor 接受的提案约束，但其实提案是 Proposer 提出来的，所有我们可以对 Proposer 提出的提案进行约束。得到 P2b：</p><p><strong>P2b：如果某个 value 为 v 的提案被选定了，那么之后任何 Proposer 提出的编号更高的提案的 value 必须也是 v。”</strong></p><p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p><p>只要满足P2c即可：</p><p><strong>“P2c：对于任意的 N 和 V，如果提案[N, V]被提出，那么存在一个半数以上的 Acceptor 组成的集合S，满足以下两个条件中的任意一个：</strong></p><ul><li><strong>S中每个 Acceptor 都没有接受过编号小于 N 的提案。</strong></li><li><strong>S中 Acceptor 接受过的最大编号的提案的 value 为 V。”</strong></li></ul><h2 id="Proposal-生成提案"><a href="#Proposal-生成提案" class="headerlink" title="Proposal 生成提案"></a>Proposal 生成提案</h2><p>为了满足 P2b，这里有个比较重要的思想：Proposal 生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的 value，然后以该 value 作为自己提出的提案的 value。如果没有 value 被选定，Proposal 才可以自己决定 value 的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p><p>于是我们得到了如下的<strong>提案生成算法：</strong></p><ul><li>Proposal 选择一个<strong>新的提案编号 N</strong>，然后向<strong>某个 Acceptor 集合</strong>（半数以上）发送请求，要求该集合中的每一个 Acceptor 做出以下响应（response）。<ul><li>向 Proposal 承诺保证<strong>不再接受</strong>任何编号<strong>小于 N 的提案</strong>。</li><li>如果 Acceptor 已经接受过提案，那么就向 Proposer 响应<strong>已经接受过</strong>的编号小于 N 的<strong>最大编号的提案</strong>。</li></ul></li></ul><p>我们将该请求成为<strong>编号 N </strong>的 <strong>Prepare 请求</strong>。 </p><ol><li>如果 Proposer 收到<strong>半数以上</strong>的 Acceptor 的响应，那么它就可以生成编号为 N， Value 为 V 的提案[N, V]。</li><li><strong>这里的 V 是所有的响应中编号最大的提案的 value</strong>。</li><li>如果所有的响应中<strong>都没有提案</strong>，那么此时 V 就可以由 Proposer <strong>自己选择</strong>(一般为当前提案)。</li><li>生成提案后，Proposer 将该<strong>提案</strong>发送给<strong>半数以上</strong>的 Acceptor 集合，并期望这些 Acceptor 能接受该提案。我们称该请求为<strong>Accept</strong>请求。（注意：此时接受 Accept 请求的 Acceptor 集合<strong>不一定</strong>是之前响应 Prepare 请求的 Acceptor 集合）。</li></ol><h2 id="Acceptor-接受提案"><a href="#Acceptor-接受提案" class="headerlink" title="Acceptor 接受提案"></a>Acceptor 接受提案</h2><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p><p>我们对Acceptor接受提案给出如下约束：</p><p><strong>“P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。”</strong></p><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p><p>因此，一个Acceptor<strong>只需记住</strong>：</p><ol><li>已接受的编号最大的提案</li><li>已响应的请求的最大编号。</li></ol><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>经过上面的推导，我们总结下Paxos算法的流程。</p><p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p><p><strong>阶段一：</strong></p><ol><li>Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</li><li>如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong> 作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</li></ol><p><strong>阶段二：</strong></p><ol><li>如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对[N,V]提案的Accept请求给<strong>半数以上</strong>的Acceptor（和之前的Acceptor不一定相同）。注意：V就是收到的响应中编号最大的提案的value，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</li><li>如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N的Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</li></ol><h2 id="算法实现流程"><a href="#算法实现流程" class="headerlink" title="算法实现流程"></a>算法实现流程</h2><ol><li>提议者发出提案，发起一次投票，发现者接收到投票请求，讲提案发给参与者；</li><li>参与者接收到投票请求后，会对提案进行投票，投票正确时发送投票确认消息；</li><li>发起者收到参与者发回的投票确认消息，如果收到确认消息超过半数，则发起者发出 accept 消息，将提案接受；</li><li>参与者接收到 accept 消息后，如果投票正确，则发送 accept 确认消息；</li><li>发起者收到 accept 确认消息后，如果收到的 accept 确认消息超过半数，则发起者发出 commit 消息，将提案接受，并执行操作；</li><li>参与者接收到 commit 消息后，如果投票正确，则发送 commit 确认消息；</li><li>发起者收到 commit 确认消息后，如果收到的 commit 确认消息超过半数，则发起者发出 ack 消息，将提案接受，并将操作结果返回给发起者；</li><li>参与者接收到 ack 消息后，如果投票正确，则发送 ack 确认消息；</li><li>发起者收到 ack 确认消息后，如果收到的 ack 确认消息超过半数，则发起者发出完成消息，将提案接受，并将操作结果返回给发起者，完成 Paxos 算法。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308151245081-381992641.png" alt="img"></p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="Learner-如何学习被选定的-value？"><a href="#Learner-如何学习被选定的-value？" class="headerlink" title="Learner 如何学习被选定的 value？"></a>Learner 如何学习被选定的 value？</h2><p>Learner学习（获取）被选定的value有如下三种方案：</p><p><strong>方案一：</strong></p><p>Acceptor接受到一个提案，就将该提案发送给所有 Learners.</p><ul><li>优点：Learner 能够快速获取被选定的 value</li><li>缺点：通信次数为M*N（M为提案数，N为 Learner数）</li></ul><p><strong>方案二：</strong></p><p>Acceptor接受一个提案，就将提案发送给<strong>主Learner</strong>，主 Learner 再通知其它 Learner</p><ul><li>优点：通信次数减少（M+N-1）（M为提案数，N为Learner数，M个提案发送给主Learner，然后主Learner通知N-1个Learner）</li><li>缺点：单点故障问题（主Learner可能出现故障）</li></ul><p><strong>方案三：</strong></p><p>Acceptor接受一个提案，就将提案发送给<strong>Learner**</strong>团**,Learner团再通知其它Learner</p><ul><li>优点：解决了方案二单点故障问题，可靠性好</li><li>缺点：实现复杂，网络通信复杂度高</li></ul><h2 id="如何保证-Paxos-算法的活性？"><a href="#如何保证-Paxos-算法的活性？" class="headerlink" title="如何保证 Paxos 算法的活性？"></a>如何保证 Paxos 算法的活性？</h2><p>通过选取<strong>主Proposer</strong>，就可以保证Paxos算法的活性。通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230310094013145-1967792588.png" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Paxos算法十分重要，现在很多一致性算法都是由其演变过来的，在互联网时代分布式环境应用非常广泛。但在查询资料时发现学习难度还是比较大的，主要是因为大家的文章写得都不太一样，加上大多都是抽象的描述，理解起来需要一点时间。</p><p>最近更新的频率明显变低了很多，其实是在转过头来学之前学过的东西，之前都是囫囵吞枣，重新看一遍会有很大的收获。</p><p>字节面试进三面了，这几天还是要好好把项目和基础知识搞明白，加油加油加油，祝我面试顺利！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在正式学习一致性算法之前，先来看一个问题。&lt;/p&gt;
&lt;p&gt;基于前面对分布式系统环境下一致性与共识算法的基础理论，在分布式系统中进行节点通信大部分采用基于消息传递通信模型，不可避免的会发生如进程可能会变慢、被杀死或者重启等问题，会对分布式系统中各节点对某一值达成一致性产生问题</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统——理论基础</title>
    <link href="http://example.com/2024/06/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/06/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2024-06-24T09:22:59.000Z</published>
    <updated>2024-06-25T15:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于分布式系统相关的内容， 在之前的博客里面也提到过不少，主要包括一致性算法、分布式存储等相关的内容，但是对于分布式系统，并没有一个清晰的概念。今天主要来看一下分布式系统的基础概念和理论基础，分布式系统涉及很多的技术、理论和协议，很多人也说，分布式系统是“入门容易，深入难”，我之前的学习也只算是管中窥豹，只见得其中一斑。</p><p>在网上搜索“如何学习分布式系统”，看完之后还是觉得云里雾里，不进行记录不太容易理清楚这里边的内容。本系列的博客主要关注一些实际应用场景中的技术实现，偏向于算法方向，更多的还是作为了解的内容。</p><h1 id="什么是分布式系统？"><a href="#什么是分布式系统？" class="headerlink" title="什么是分布式系统？"></a>什么是分布式系统？</h1><blockquote><p>一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样。</p><p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。</p></blockquote><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。简单来说就是<strong>一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样</strong>。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p><p>从分布式系统的概念中我们知道，各个主机之间通信和协调主要通过网络进行，所以分布式系统中的计算机在空间上几乎没有任何限制，这些计算机可能被放在不同的机柜上，也可能被部署在不同的机房中，还可能在不同的城市中，对于大型的网站甚至可能分布在不同的国家和地区。</p><p>在很多文章中，主要讲分布式系统分为分布式计算（computation）与分布式存储（storage）。计算与存储是相辅相成的，计算需要数据，要么来自实时数据（流数据），要么来自存储的数据；而计算的结果也是需要存储的。在操作系统中，对计算与存储有非常详尽的讨论，分布式系统只不过将这些理论推广到多个节点罢了。</p><p>那么分布式系统怎么将任务分发到这些计算机节点呢，很简单的思想，分而治之，即分片（<strong>partition）</strong>。对于计算，那么就是对计算任务进行切换，每个节点算一些，最终汇总就行了，这就是MapReduce的思想；对于存储，更好理解一下，每个节点存一部分数据就行了。当数据规模变大的时候，Partition是唯一的选择，同时也会带来一些好处：</p><ol><li><p>提升性能和并发，操作被分发到不同的分片，相互独立</p></li><li><p>提升系统的可用性，即使部分分片不能用，其他分片不会受到影响</p></li></ol><p>理想的情况下，有分片就行了，但事实的情况却不大理想。原因在于，分布式系统中有大量的节点，且通过网络通信。单个节点的故障（进程crash、断电、磁盘损坏）是个小概率事件，但整个系统的故障率会随节点的增加而指数级增加，网络通信也可能出现断网、高延迟的情况。在这种一定会出现的“异常”情况下，分布式系统还是需要继续稳定的对外提供服务，即需要较强的容错性。最简单的办法，就是冗余或者复制集（<strong>Replication</strong>），即多个节点负责同一个任务，最为常见的就是分布式存储中，多个节点复杂存储同一份数据，以此增强可用性与可靠性。同时，Replication也会带来性能的提升，比如数据的locality可以减少用户的等待时间。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1089769-20171108093209200-1813701105.png" alt="img"></p><p>Partition和Replication是解决分布式系统问题的一记组合拳，很多具体的问题都可以用这个思路去解决。但这并不是银弹，往往是为了解决一个问题，会引入更多的问题，比如为了可用性与可靠性保证，引用了冗余（复制集）。有了冗余，各个副本间的一致性问题就变得很头疼，一致性在系统的角度和用户的角度又有不同的等级划分。如果要保证强一致性，那么会影响可用性与性能，在一些应用（比如电商、搜索）是难以接受的。如果是最终一致性，那么就需要处理数据冲突的情况。CAP、FLP这些理论告诉我们，在分布式系统中，没有最佳的选择，都是需要权衡，做出最合适的选择。</p><h2 id="分布式系统的主要特征"><a href="#分布式系统的主要特征" class="headerlink" title="分布式系统的主要特征"></a>分布式系统的主要特征</h2><blockquote><p>无论空间上如何分布，一个标准的分布式系统应该具有以下几个主要特征</p></blockquote><ul><li><strong>分布性</strong></li></ul><p>分布式系统中的多台计算机之间在空间位置上可以随意分布，同时，机器的分布情况也会随时变动。</p><ul><li><strong>对等性</strong></li></ul><p>分布式系统中的计算机没有主／从之分，即没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。数据副本是指在不同节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</p><ul><li><strong>自治性</strong></li></ul><p>分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。</p><ul><li><strong>并发性</strong></li></ul><p>在一个计算机网络中，程序运行过程的并发性操作是非常常见的行为。例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。</p><h2 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h2><ul><li><strong>缺乏全局时钟</strong></li></ul><p>在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。</p><ul><li><strong>机器宕机</strong></li></ul><p>机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</p><ul><li><strong>网络异常</strong></li></ul><p>消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</p><ul><li><strong>分布式三态</strong></li></ul><p>如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</p><ul><li><strong>存储数据丢失</strong></li></ul><p>对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。 <em>异常处理原则</em>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</p><h2 id="衡量分布式系统的指标"><a href="#衡量分布式系统的指标" class="headerlink" title="衡量分布式系统的指标"></a>衡量分布式系统的指标</h2><ul><li><strong>性能</strong></li></ul><p>系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</p><ul><li><strong>可用性</strong></li></ul><p>系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</p><ul><li><strong>可扩展性</strong></li></ul><p>系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</p><ul><li><strong>一致性</strong></li></ul><p>分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单。</p><h1 id="分布式基础理论"><a href="#分布式基础理论" class="headerlink" title="分布式基础理论"></a>分布式基础理论</h1><h2 id="同步-异步系统模型"><a href="#同步-异步系统模型" class="headerlink" title="同步/异步系统模型"></a>同步/异步系统模型</h2><p><strong>同步系统模型：</strong>指系统中的各个节点的时钟误差存在上限，并且消息传递必须在一定时间内完成，否则认为失败；同时各个节点完成处理消息的时间是一定的。因此同步系统中可以很容易地判断消息是否丢失。</p><p><strong>异步系统模型</strong>：系统中各个节点可能存在较大的时钟差异；同时消息传输时间是任意长的；各节点对消息进行处理的时间也可能是任意长的。这就造成无法判断某个消息迟迟没有被响应是哪里出了问题（节点故障还是传输故障）。现实生活中的系统往往都是异步系统。</p><h2 id="FLP-不可能原理"><a href="#FLP-不可能原理" class="headerlink" title="FLP 不可能原理"></a>FLP 不可能原理</h2><p>由 Fischer，Lynch 和 Patterson 三位科学家发表的《Impossibility of Distributed Consensus with One Faulty Process》论文中提出，<strong>在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法</strong>。</p><p><strong>描述</strong>：FLP不可能原理假定节点只能因崩溃而失败； 网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制的情况下，假设有A、B、C三个节点进行投票，A投票0，B投票1，而C收到了A与B的投票却没办法响应，A与B就没办法在有限的时间内获知最终结果；如果进行重新投票，类似的情况重复发生，则永远无法达到共识。</p><p>FLP 不可能原理的意义在于，告诉我们不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。</p><h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><p><strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点，只能满足三项中的两项：</p><ul><li><strong>一致性（Consistency）</strong> : 任何事务都应该是原子的，所有副本上的状态都是事务成功提交后的结果，并保持强一致性。</li><li><strong>可用性（Availability）</strong> : 系统正常节点能在有限时间内完成对操作请求的应答。</li><li><strong>分区容错性（Partition tolerance）</strong> : 系统中的网络可能发生分区故障（成为多个子网、节点上线和下线），节点之间的通信无法保障，而网络故障不应该影响到系统正常服务。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8311955763f46820c7886b8e69f4dbf8_MD5.png" alt="图片"></p><p><strong>CAP理论证明</strong>：</p><p>假设有两个通信中的节点出现了网络分区的情况，如果允许其中一个节点更新状态，则需要舍弃一致性（C）；如果为了保证数据一致性，将分区的节点设置为不可用，就需要舍弃可用性（A）；如果两个节点可以互相通信，才能既保证一致性又保证可用性，会丧失分区容错性（P）。</p><p><strong>三类系统模型</strong></p><ul><li>CA（一致性+可用性）：包括完全严格的仲裁协议，例如<strong>2PC（两阶段提交）</strong>。</li><li>CP（一致性+分区容错性）： 包括多数仲裁协议，其中少数分区不可用，<strong>例如Paxos</strong>。</li><li>AP（可用性+分区容错性）： 包括执行最终一致性的协议，<strong>例如Gossip</strong>。</li></ul><p><strong>CA\CP区别</strong>：CA和CP系统设计均提供相同的一致性模型：高度一致性。 唯一的区别是CA系统不能容忍任何节点故障。 CP系统可以容忍 <strong>f</strong> 在给定 <strong>2f+1</strong> 在非拜占庭式故障模型中。</p><p><strong>场景</strong></p><ul><li>CA：弱化了分区容错性，早期分布式关系数据库系统中使用的许多系统设计如两阶段提交，都没有考虑分区容错性。 分区容错性是现代系统的重要属性，因为如果系统在多个地理环境上分布，网络分区出现的概览就会加大。</li><li>CP：弱化了可用性，一些对结果一致性很敏感的应用会选择基于此模型设计，当系统出现故障时会拒绝服务；Paxos、Raft 等共识算法，以及HBase、MongoDB等基于此模型设计。</li><li>AP：弱化了一致性，一些对结果一致性不敏感的应用会选择基于此模型设计，可以允许在新版本上线后过一段时间才最终更新成功，期间不保证一致性；分布式同步协议如 Gossip，以及DynamoDB、 CouchDB、Cassandra 数据库等基于此模型设计。</li></ul><h2 id="ACID原则与BASE原则"><a href="#ACID原则与BASE原则" class="headerlink" title="ACID原则与BASE原则"></a>ACID原则与BASE原则</h2><p><strong>ACID原则</strong></p><p>ACID 即 Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）四种特性的缩写，一般出现在分布式数据库等基于事务过程的系统中；ACID 原则描述了分布式数据库需要满足的一致性需求，同时允许付出可用性的代价。</p><ul><li><strong>Atomicity</strong>: 每次事务是原子的，事务包含的所有操作要么全部成功，要么全部不执行。一旦有操作失败，则需要回退状态到执行事务之前；</li><li><strong>Consistency</strong>: 数据库的状态在事务执行前后的状态是一致的和完整的，无中间状态。即只能处于成功事务提交后的状态；</li><li><strong>Isolation</strong>: 各种事务可以并发执行，但彼此之间互相不影响。按照标准 SQL 规范，从弱到强可以分为未授权读取、授权读取、可重复读取和串行化四种隔离等级；</li><li><strong>Durability</strong>: 状态的改变是持久的，不会失效。一旦某个事务提交，则它造成的状态变更就是永久性的。</li></ul><p><strong>BASE原则</strong></p><p>BASE即 Basic Availability（基本可用），Soft-state（弱状态），Eventual Consistency（最终一致性），为 eBay 技术专家 Dan Pritchett 提出的与ACID相对的一个原则，主要面向大型高可用分布式系统，主张牺牲掉对强一致性的追求，而实现最终一致性，来换取一定的可用性。</p><ul><li>Basic Availability：系统在出现不可预知的故障时候，允许损失部分可用性，保证核心服务可用。</li><li>Soft-state：允许系统在不同节点的数据副本之间进行数据同步的过程中存在延时（允许系统中的数据存在中间状态，不会影响系统的整体可用性）。</li><li>Eventual Consistency：系统中所有的数据副本，在进过一段时间的同步后，最终能够达到一个一致的状态。</li></ul><h1 id="分布式系统下的一致性问题"><a href="#分布式系统下的一致性问题" class="headerlink" title="分布式系统下的一致性问题"></a>分布式系统下的一致性问题</h1><p>一致性为在分布式系统领域中对于多个服务节点，给定一系列操作，在约定协议的保障下，使得它们对处理结果达成某种程度的协同。</p><p>分布式系统中的节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：进程可能会响应慢、被杀死或者重启，消息可能会延迟、丢失、重复；发生上面任意一种异常都会对分布式系统中各个节点对某一个值达成一致性产生问题。</p><p><strong>一致性的要求</strong>：</p><ul><li>可终止性（Termination）：一致的结果在有限时间内能完成（可以保障提供服务的（Liveness））</li><li>约同性（Agreement）：不同节点最终完成决策的结果是相同的（意味着算法要么不给出结果，任何给出的结果必定是达成了共识的，即安全性（Safety））</li><li>合法性（Validity）：决策的结果必须是某个节点提出的提案（即达成的结果必须是节点执行操作的结果）</li></ul><p>解决一致性问题的核心在于对不同空间发生的事件进行全局唯一排序。</p><p><strong>一致性模型</strong>：</p><ul><li>强一致性模型<ul><li>顺序一致性：所有操作都以某种顺序原子执行，该顺序与各个节点上看到的顺序一致，并且在所有节点上都相等；可以基于<a href="https://en.wikipedia.org/wiki/Lamport_timestamp">Lamport timestamp</a> 即逻辑时钟进行实现。</li><li>线性一致性：所有操作都按照操作的全局实时顺序一致的顺序自动执行；在顺序一致性前提下加强了进程间的操作排序，形成唯一的全局顺序；依赖于全局的时钟或锁，有很强的原子性保证，但是比较难实现。</li></ul></li><li>弱一致性模型<ul><li>最终一致性：在未来的某个时间点进行冲突检测和修正，如DNS</li><li>客户端为中心型一致性：通过在client端库中建立额外的缓存来实现，如亚马逊Dynamo</li></ul></li></ul><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><h3 id="共识（Consensus）与一致性（Consistency）"><a href="#共识（Consensus）与一致性（Consistency）" class="headerlink" title="共识（Consensus）与一致性（Consistency）"></a>共识（Consensus）与一致性（Consistency）</h3><p>一致性：含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。在分布式系统场景下，一致性指的是多个副本对外呈现的状态。如之前提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。</p><p>共识：特指在分布式系统中多个节点之间对某个事情达成一致看法的过程。需注意达成某种共识并不意味着就保障了一致性。</p><h3 id="共识算法解决的问题"><a href="#共识算法解决的问题" class="headerlink" title="共识算法解决的问题"></a>共识算法解决的问题</h3><p>共识算法解决的是分布式系统对某个提案（Proposal），大部分节点达成一致意见的过程。提案泛指多个事件发生的顺序、某个键对应的值…对于分布式系而言，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。</p><p>这里共识算法需要解决两个基本问题：</p><ol><li>如何提出一个待共识的提案（令牌传递、随机选取…）</li><li>如何让多个节点对提案达成共识（投票、规则验证…）</li></ol><p>现实网络环境中存在各种各样的问题，在分布式环境下，共识算法还需要解决如通信问题（网络中断、分区）、节点故障、消息伪造…</p><h3 id="共识算法分类"><a href="#共识算法分类" class="headerlink" title="共识算法分类"></a>共识算法分类</h3><p>根据是否允许拜占庭错误（伪造信息恶意响应）的情况，共识算法分为 Crash Fault Tolerance 崩溃容错 (CFT) 和 Byzantine Fault Tolerance（BFT）两类。</p><p>Crash Fault Tolerance (CFT) 算法：Paxos、Raft、ZAB…</p><p>Byzantine Fault Tolerance(BFT) 算法：PBFT为代表的确定性系列算法、PoW为代表的概率算法…</p><h1 id="核心问题-复制"><a href="#核心问题-复制" class="headerlink" title="核心问题-复制"></a>核心问题-复制</h1><p><strong>为什么核心问题是复制</strong>：在文章开头我们说过，分布式系统采用分片来将任务分发到这些计算机节点，为了实现高可用，又引入了冗余。分布式存储相关的系统都必须用某种冗余的方式在廉价硬件的基础上搭建高可靠的存储，而冗余的基础就是复制（多副本策略）, 一份数据存多份. 多副本保证了可靠性, 而副本之间的一致, 就需要各种分布式共识算法来保证。</p><p>复制是一个组通信问题。需要考虑哪种通信方式可以为我们提供我们想要的性能和可用性特性？面对网络分区以及节点同时发生故障，我们如何确保容错性，持久性以及避免分歧。</p><h2 id="基本复制方式"><a href="#基本复制方式" class="headerlink" title="基本复制方式"></a>基本复制方式</h2><ul><li>同步复制：强持久化保证，系统响应慢，对网络延迟敏感</li><li>异步复制：弱持久化保证，性能高，对网络延迟更加宽容</li></ul><h2 id="基本复制算法"><a href="#基本复制算法" class="headerlink" title="基本复制算法"></a>基本复制算法</h2><p>基本复制算法大致可以分为两类：Replication methods that prevent divergence (single copy systems) 防止差异的复制方式（单拷贝系统）与Replication methods that risk divergence (multi-master systems) 有差异风险的复制方式（多主系统）</p><h3 id="Replication-Methods-that-Prevent-Divergence-single-Copy-systems"><a href="#Replication-Methods-that-Prevent-Divergence-single-Copy-systems" class="headerlink" title="Replication Methods that Prevent Divergence (single Copy systems)"></a>Replication Methods that Prevent Divergence (single Copy systems)</h3><blockquote><p>防止差异的复制方式（单拷贝系统）</p></blockquote><p>对外表现得像一个单独的系统；当部分故障发生时，系统确保只有一个系统副本处于活动状态；系统需要确保副本始终保持一致，基于某一种共识算法去实现，一般有如下几种方式：</p><h4 id="Master-Slave（主从复制）"><a href="#Master-Slave（主从复制）" class="headerlink" title="Master/Slave（主从复制）"></a>Master/Slave（主从复制）</h4><p>所有更新都在主服务器上执行，操作日志(或者更改)通过网络传送到备份副本；涉及两种相关的变体异步主/备份、同步主/备份、半同步主/备复制。</p><ol><li>同步复制: 直到数据真的安全的复制到全部的机器上之后, master才告知客户端数据已经完成同步</li></ol><p>   <img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bbc18660dac576b06b99dc0fc13ded8f_MD5.png" alt="image"></p><p>   问题：强一致性持久化保证，但是系统响应慢，对网络延迟的变化非常敏感；并且系统的可用性随着副本数量指数降低，任何一个机器的宕机都会影响到整个系统的写入。</p><ol><li>异步复制: master将更新存储在本地后立即向客户端发回响应，master在之后才进行异步复制到全部的机器上。</li></ol><p>   <img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c5807e8ee0565c259a9d525df73c06c0_MD5.png" alt="image"></p><p>   问题：性能高，但是为弱一致性持久化保证，数据存在丢失风险，会造成数据不一致的情况。</p><ol><li>半同步复制：要求master在应答客户端之前必须把数据复制到足够多的机器上, 而非全部机器. 这样副本数够多可以提供比较高的可靠性; 1台机器宕机也不会让整个系统停止写入; 但系统中还是会存在数据不一致的情况。</li></ol><h4 id="2-phase-commit（两阶段提交）"><a href="#2-phase-commit（两阶段提交）" class="headerlink" title="2-phase commit（两阶段提交）"></a>2-phase commit（两阶段提交）</h4><p>阶段一：投票阶段，协调人向所有参与者发送更新信息。每个参与者处理更新，并投票决定是提交还是放弃。当投票决定提交时，参与者将更新存储到一个临时区域（write-ahead log）。</p><p>阶段二：协调程序决定结果并通知每个参与者。如果所有参与者投票提交，那么更新将从临时区域获得并永久化。</p><p>问题：强一致性持久化保证，但是系统响应慢，对网络延迟的变化非常敏感；系统的可用性随着副本数量指数降低</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ Coordinator ] -&gt; OK to commit?     [ Peers ]</span><br><span class="line">                &lt;- Yes / No</span><br><span class="line">[ Coordinator ] -&gt; Commit / Rollback [ Peers ]</span><br><span class="line">                &lt;- ACK</span><br></pre></td></tr></table></figure><h4 id="Quorum机制（多数派）"><a href="#Quorum机制（多数派）" class="headerlink" title="Quorum机制（多数派）"></a>Quorum机制（多数派）</h4><p><strong>Quorum</strong> 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理；在分布式系统中，Quorum常用于副本的读写控制，容忍最多 <code>(N-1)/2</code> 个节点损坏。</p><p>假设每份数据有V个副本，每个副本对应一票，读、写操作首先要请求副本以获取其票数，定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read quorum R（最小读票数）：读操作获取的票数必须大于该值才允许读；</span><br><span class="line">write quorum W（最小写票数）：写操作获取的票数必须大于该值才允许写；</span><br></pre></td></tr></table></figure><p>V、R、W必须满足：</p><ul><li><code>R + W &gt; V</code>：保证对于每份数据，不会 同时读和写（当一个写操作请求过来的时候，它必须要获得W个写票。而剩下的数量是V-W是不够R的，因此不能再有读请求过来了）。</li><li><code>W &gt; V / 2</code>：保证对于每份数据，不会同时出现 两个写，即写操作是串行的</li></ul><p><strong>其他</strong></p><ul><li>没有规定 <code>R &gt; V / 2</code>，quorum 机制允许 多个读同时发生，即允许 并发读；</li><li>考虑write -&gt; read序列，因为<code>R + W &gt; V</code>，因此 W 和 V 之间至少有一个重叠（鸽巢原理），从而保证 write 之后，read 操作至少会获取一个最新副本；</li><li>在做复制冗余的时候，借助 Quorum 机制，5 个副本只需要完成 3 个写即可响应成功，提升了写操作的响应速度，又没有减弱可靠性；Quorum 机制本质上是把写负载转移到了读负载的一种设计权衡。</li></ul><p><strong>问题</strong>：</p><ul><li>读取不一致状态情况：对于一条数据的更新时, 会产生不一致的状态问题：如第一次client update，nodeA、nodeB写入a=x；第二次client update，nodeB、nodeC写入a=y；如果读取a的客户端联系到nodeA和nodeB，会得到不一致的数据（解决：对每次的写入增加全局时间戳，以后写入的优先）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeA: a=x 1577851200000</span><br><span class="line">nodeB: a=y 1577851230000</span><br><span class="line">nodeC: a=y 1577851230000</span><br></pre></td></tr></table></figure><ul><li>多数派写异常情况：在完成一起完整的多数派写时，发生写入异常，会产生不一致的状态问题：如第一次client update，nodeA、nodeB写入a=x；第二次client update，nodeB、nodeC写入a=y；但是只有nodeC写入成功了，然后client abort了，这时候另一个client 读取到nodeA与nodeB得到的结果与读取到nodeB与nodeC的不一致。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeA: a=x 1577851200000</span><br><span class="line">nodeB: a=x 1577851200000</span><br><span class="line">nodeC: a=y 1577851230000</span><br></pre></td></tr></table></figure><ul><li>并发环境下，因为无法保证顺序执行，所以无法保证系统的正确性。</li></ul><p><strong>结论</strong></p><p>Quorum机制无法保证强一致性，即无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据；后续Paxos对Quorum机制进行了改进，通过2次多数派读写, 实现了严谨的强一致共识算法。</p><h3 id="Replication-Methods-that-risk-Divergence-multi-master-systems"><a href="#Replication-Methods-that-risk-Divergence-multi-master-systems" class="headerlink" title="Replication Methods that risk Divergence (multi-master systems)"></a>Replication Methods that risk Divergence (multi-master systems)</h3><blockquote><p>有差异风险的复制方式（多主系统）</p></blockquote><h4 id="Gossip算法"><a href="#Gossip算法" class="headerlink" title="Gossip算法"></a>Gossip算法</h4><p>Gossip算法Palo Alto研究中心在论文《Epidemic Algorithms for Replicated Database Maintenance》中提出的一种用于分布式数据库在多节点间复制同步数据的算法；特点是要同步的信息如同流言一般传播，最终一致性。</p><p>具体的工作过程如下：</p><ol><li>如果有某一项信息需要在整个网络中所有节点中传播，那从信息源开始，选择一个固定的传播周期（如1秒），随机选择它 相连接的k个节点（称为Fan-Out）进行消息传播。</li><li>每一个节点收到消息后，如果这个消息是它之前没有收到过的，将在下一个周期内，选择除了发送消息给它的那个节点外的 其他相邻k个节点发送相同的消息，理论上最终网络的所有节点都会拥有相同的消息。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/29c4dbf98502c1e297c1fe9c200c0ea3_MD5.png" alt="image"></p><p>上图从一致性、延迟、吞吐量、数据丢失和故障转移对比了各个类型共识算法实现。</p><h1 id="用一个请求串起来"><a href="#用一个请求串起来" class="headerlink" title="用一个请求串起来"></a>用一个请求串起来</h1><p>假设这是一个对外提供服务的大型分布式系统，用户连接到系统，做一些操作，产生一些需要存储的数据，那么在这个过程中，会遇到哪些组件、理论与协议呢？</p><p>用户使用Web、APP、SDK，通过HTTP、TCP连接到系统。在分布式系统中，为了高并发、高可用，一般都是多个节点提供相同的服务。那么，第一个问题就是具体选择哪个节点来提供服务，这个就是负载均衡（load balance）。负载均衡的思想很简单，但使用非常广泛，在分布式系统、大型网站的方方面面都有使用，或者说，只要涉及到多个节点提供同质的服务，就需要负载均衡。</p><p>通过负载均衡找到一个节点，接下来就是真正处理用户的请求，请求有可能简单，也有可能很复杂。简单的请求，比如读取数据，那么很可能是有缓存的，即分布式缓存，如果缓存没有命中，那么需要去数据库拉取数据。对于复杂的请求，可能会调用到系统中其他的服务。</p><p>承上，假设服务A需要调用服务B的服务，首先两个节点需要通信，网络通信都是建立在TCP/IP协议的基础上，但是，每个应用都手写socket是一件冗杂、低效的事情，因此需要应用层的封装，因此有了HTTP、FTP等各种应用层协议。当系统愈加复杂，提供大量的http接口也是一件困难的事情。因此，有了更进一步的抽象，那就是RPC（remote produce call），是的远程调用就跟本地过程调用一样方便，屏蔽了网络通信等诸多细节，增加新的接口也更加方便。</p><p>一个请求可能包含诸多操作，即在服务A上做一些操作，然后在服务B上做另一些操作。比如简化版的网络购物，在订单服务上发货，在账户服务上扣款。这两个操作需要保证原子性，要么都成功，要么都不操作。这就涉及到分布式事务的问题，分布式事务是从应用层面保证一致性：某种守恒关系。</p><p>上面说道一个请求包含多个操作，其实就是涉及到多个服务，分布式系统中有大量的服务，每个服务又是多个节点组成。那么一个服务怎么找到另一个服务（的某个节点呢）？通信是需要地址的，怎么获取这个地址，最简单的办法就是配置文件写死，或者写入到数据库，但这些方法在节点数据巨大、节点动态增删的时候都不大方便，这个时候就需要服务注册与发现：提供服务的节点向一个协调中心注册自己的地址，使用服务的节点去协调中心拉取地址。</p><p>从上可以看见，协调中心提供了中心化的服务：以一组节点提供类似单点的服务，使用非常广泛，比如命令服务、分布式锁。协调中心最出名的就是chubby，zookeeper。</p><p>回到用户请求这个点，请求操作会产生一些数据、日志，通常为信息，其他一些系统可能会对这些消息感兴趣，比如个性化推荐、监控等，这里就抽象出了两个概念，消息的生产者与消费者。那么生产者怎么讲消息发送给消费者呢，RPC并不是一个很好的选择，因为RPC肯定得指定消息发给谁，但实际的情况是生产者并不清楚、也不关心谁会消费这个消息，这个时候消息队列就出马了。简单来说，生产者只用往消息队列里面发就行了，队列会将消息按主题（topic）分发给关注这个主题的消费者。消息队列起到了异步处理、应用解耦的作用。</p><p>上面提到，用户操作会产生一些数据，这些数据忠实记录了用户的操作习惯、喜好，是各行各业最宝贵的财富。比如各种推荐、广告投放、自动识别。这就催生了分布式计算平台，比如Hadoop，Storm等，用来处理这些海量的数据。</p><p>最后，用户的操作完成之后，用户的数据需要持久化，但数据量很大，大到按个节点无法存储，那么这个时候就需要分布式存储：将数据进行划分放在不同的节点上，同时，为了防止数据的丢失，每一份数据会保存多分。传统的关系型数据库是单点存储，为了在应用层透明的情况下分库分表，会引用额外的代理层。而对于NoSql，一般天然支持分布式。</p><h2 id="一个简化的架构图"><a href="#一个简化的架构图" class="headerlink" title="一个简化的架构图"></a>一个简化的架构图</h2><p>　　下面用一个不大精确的架构图，尽量还原分布式系统的组成部分（不过只能体现出技术，不好体现出理论）</p><p> <img src="https://images2017.cnblogs.com/blog/1089769/201711/1089769-20171110170521606-1076859931.png" alt="img"></p><h2 id="概念与实现"><a href="#概念与实现" class="headerlink" title="概念与实现"></a>概念与实现</h2><p>那么对于上面的各种技术与理论，业界有哪些实现呢，下面进行简单罗列。</p><p>当然，下面的这些实现，小部分我用过，知其所以然；大部分听说过，知其然；还有一部分之前闻所未闻，分类也不一定正确，只是从其他文章抄过来的。罗列在这里，以便日后或深或浅的学习。</p><ul><li><p>负载均衡：</p><ul><li><p>Nginx：高性能、高并发的web服务器；功能包括负载均衡、反向代理、静态内容缓存、访问控制；工作在应用层</p></li><li><p>LVS： Linux virtual server，基于集群技术和Linux操作系统实现一个高性能、高可用的服务器；工作在网络层</p></li></ul></li><li><p>webserver：</p><ul><li>Java：Tomcat，Apache，Jboss</li><li>Python：gunicorn、uwsgi、twisted、webpy、tornado</li></ul></li><li><p>service：　　</p><ul><li>SOA、微服务、spring boot，django</li></ul></li><li><p>容器：</p><ul><li>docker，kubernetes</li></ul></li><li><p>cache：</p><ul><li>memcache、redis等</li></ul></li><li><p>协调中心：</p><ul><li>zookeeper、etcd等</li><li>zookeeper使用了Paxos协议Paxos是强一致性，高可用的去中心化分布式。zookeeper的使用场景非常广泛，之后细讲。</li></ul></li><li><p>rpc框架：</p><ul><li>grpc、dubbo、brpc</li><li>dubbo是阿里开源的Java语言开发的高性能RPC框架，在阿里系的诸多架构中，都使用了dubbo + spring boot</li></ul></li><li><p>消息队列：</p><ul><li>kafka、rabbitMQ、rocketMQ、QSP</li><li>消息队列的应用场景：异步处理、应用解耦、流量削锋和消息通讯</li></ul></li><li><p>实时数据平台：</p><ul><li>storm、akka</li></ul></li><li><p>离线数据平台：</p><ul><li>hadoop、spark</li><li>PS: apark、akka、kafka都是scala语言写的，看到这个语言还是很牛逼的</li></ul></li><li><p>dbproxy：</p><ul><li>cobar也是阿里开源的，在阿里系中使用也非常广泛，是关系型数据库的sharding + replica 代理</li></ul></li><li><p>db：</p><ul><li>mysql、oracle、MongoDB、HBase</li></ul></li><li><p>搜索：</p><ul><li>elasticsearch、solr</li></ul></li><li><p>日志：</p><ul><li>rsyslog、elk、flume</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习分布式系统还是比较困难的，资料少而且实战的机会也不多，多以更多还是停留在纸面上的一些东西，所以我们在开头也提到了，本系列的博客更多还是关注分布式系统在实际生产环境中的一些使用方式。</p><p>有了坏消息，就必然会有好消息。坏消息是腾讯的两个全都挂了，好消息是今天字节跳动约了二面，但是我心里没底，害怕又像腾讯二面一样，所以明天和后天上午还是好好看一下八股和项目。一直说已经把项目吃透了，其实并没有，下次面试的时候一定要详细地讲自己的项目，技术选型和数据结构都要说，不能再省略过去了。自信点、自信点、自信点，不要说着说着就没声音了，哪怕不会也不能没气势。进字节不就是一开始学 Go 的原因吗，好好珍惜这次机会。加油，祝我面试成功！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于分布式系统相关的内容， 在之前的博客里面也提到过不少，主要包括一致性算法、分布式存储等相关的内容，但是对于分布式系统，并没有一个清晰的概念。今天主要来看一下分布式系统的基础概念和理论基础，分布式系统涉及很多的技术、理论和协议，很多人也说，分布式系统是“入门容易，深入难”</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯面试(三)</title>
    <link href="http://example.com/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/"/>
    <id>http://example.com/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/</id>
    <published>2024-06-24T07:44:25.000Z</published>
    <updated>2024-06-25T14:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯二面，没想到上次面试还有下文，隔了四天，周日晚上约今天的面试，那时我还躺在南昌酒店的床上享受着美好的假期生活。腾讯是真给机会啊，面完的感受，觉得还是差太多了，面试官问的问题我甚至都没听懂，不知道为什么，感觉很奇怪。面试时间不长，面试官也没开摄像头，没有自我介绍，直接开始拷打项目，但是也没有问什么深入的内容，就让自己介绍、有什么收获、重做一遍会有什么改进、做了多长时间等等，后面问一些八股，答得也不好，二十五分钟结束面试。反问项目组用什么语言、做什么内容，主要用 Go 和 C++，做一些关于大数据的内容（这不刚好吗，我可是千年学府、百年名校的湖南大学的第二届大数据学生）。</p><p>由于问题并不是很多，而且问题好像也不是很难，只是我没懂面试官的意思，脑子坏掉了，我就说我总是关键时刻掉链子。所以就简单记录一下都问了什么问题吧。</p><ol><li>挑一个项目介绍一下。<ul><li>传统项目了，果断挑选博客系统，巴拉巴拉介绍完。</li></ul></li><li>介绍一下项目里用到的数据结构和技术选型。<ul><li>太专业了，脑子没转过来也不知道怎么回答了，就讲了一下GET、POST请求，想继续讲登录操作，被打断了，可能是我太啰嗦了。</li></ul></li><li>项目里前端和后端是怎么通信的，用的是什么协议。<ul><li>这个问题我就更是一头雾水了，没明白什么意思，来回确认了三次我都没动要怎么回答。面试官问用的是 http 协议吗，我说是。中间还说到了 Ngnix，给面试官整笑了，反正这个问题从头到尾我都没明白是怎么回事，后面搜了一下，大概懂了。可能是要我说 http 协议和 RESTful 规范之类的吧。</li></ul></li><li>有没有考虑过项目中的架构问题。<ul><li>说实话，从来没有考虑过这些方面的内容，这个项目连部署我都没做。后面就说有学过秒杀系统的一些架构问题，不知道能不能用到这个上面。</li></ul></li><li>用户登录之后会看到什么？每个用户看到的都一样吗？在拉取文章列表的时候有看过性能方面的问题吗？<ul><li>用户登陆后会看到MySQL中存储的文章，每个用户看到的都一样，因为是直接从MySQL中拉取出来的。</li><li>性能方面的问题并没有去考量，脑子一抽说成了是一次性把所有数据拉去出来，其实在做的时候是设计了分页功能，先拉取一页的内容，后面再看的时候再拉取，我是傻逼，脑子跟不上嘴。</li></ul></li><li>为什么要用 MySQL 来做数据库存储？为什么不用其他的数据库？<ul><li>我知道这里面试官想要我去分析主流的数据库的优缺点，但是选择 MySQL 就是因为我当时只会 MySQL。</li><li>分析了 MongoDB 和 MySQL 的一些区别，就说为了学习效率考虑就选择已经学会的MySQL，而不是MongoDB。</li></ul></li><li>项目一共做了多久？有什么收获？如果重新做一遍会对那些地方进行改进？<ul><li>项目一共做了不到两个月，收获还是很多的，嘴瓢说的含糊不清。主要就是 Go 语言、常用库、数据库、学习能力的提升。</li><li>重做一遍会更多关注在性能上，也会结合实际情况加入更多的功能，补充前端的东西。</li></ul></li><li>八股就问了三个：Linux查看进程占用CPU情况的命令。进程有哪几种状态？端口在TCP/IP协议中的那一层？<ul><li>第一个问题，确实没怎么用过命令行，所以直接回答了不知道，实际是用 <code>top</code> 和 <code>ps</code> 命令。</li><li>三种状态，更扩展的就不记得了，阻塞不能直接到运行状态。</li><li>回答了四元组，说确定端口号和IP地址，脑子一抽胡说了个网络层和链路层，其实是传输层，一边回答着传输要用到四元组，一边回答另外的东西。</li></ul></li><li>了解C++吗？虚拟继承有什么用？<ul><li>这个确实不知道，一面的时候面试官问的都是Go相关的八股。这个确实不知道。</li></ul></li><li>反问：项目组主要用什么语言？主要是做什么的？需要学大数据相关的框架吗？<ul><li>主要用 Go 和 Java，处理大数据的时候会用到 C++。</li><li>主要做跟大数据有关的内容。</li><li>需要学。</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总是这样，在面试之前总是觉得好像已经没什么可学的了，面试完之后就觉得好像什么都没学过。拷打的体无完肤，还是知识储备不够。刚刚也去看了前后端通信的过程，还是不是很清楚要怎么回答面试官的那个问题。</p><p>不管结果如何，我都很感谢腾讯，每一次面试都能发现很多不足，自己确实还是有很多东西都没有考虑到。通过面试查漏补缺属实不是什么好方法，但是我自己在下面又不能全方面地排查问题，所以面试了一场又一场，发现了很多问题，却又被我一直拖着没做。</p><p>其他两个面试也没什么结果，字节都已经过了一周了，还没约二面，应该是没戏了。俊德内推地腾讯云智，我觉得面的还挺好的，也还没消息，可能是不缺人吧，也可能只是我觉得很好。</p><p>唉，总的来说，上一周好像到了巅峰，三场面试，这一周好像又要开始往下走了，祝我面试顺利。</p><p>6月25号更新，显然并没有什么好消息，复盘之后发现二面确实很差，腾讯云智的也被挂了，不太明白为什么，昨天晚上和朋友复盘的时候发现之前的学习方法有问题。在学基础知识的时候，我总是偏向于理解，在自己脑子里有个印象，几乎没有认真地背过，这也导致我在回答这方面问题的时候总是表述不清，因为并没有记住，知识浅显的理解了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;腾讯二面，没想到上次面试还有下文，隔了四天，周日晚上约今天的面试，那时我还躺在南昌酒店的床上享受着美好的假期生活。腾讯是真给机会啊，面完的感受，觉得还是差太多了，面试官问的问题我甚至都没听懂，不知道为什么，感觉很奇怪。面试时间不长，面试官也没开摄像头，没有自我介绍，直接开始</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用：select/poll/epoll</title>
    <link href="http://example.com/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/"/>
    <id>http://example.com/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/</id>
    <published>2024-06-21T07:26:39.000Z</published>
    <updated>2024-06-21T08:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前（三天前），我被问到一个熟悉又陌生的问题，了解I/O多路复用吗？我回答，了解但是还没开始学？是的，我学习的领域就是这么广泛又浅显，名词我都了解，但是就是不知道具体是什么。</p><p>说到 I/O多路复用，我学习的博客都把他归到了操作系统一类里面，我也学过操作系统啊，为什么就不知道这是什么呢？我问了我周围的同学，好像都不知道，应该是当时老师没讲，也可能是讲了我们都没听。我知道这个算法是在学习 Redis 的时候，我们在 Redis 为什么这么快 那篇博客里提到了 多路复用 这个算法，今天我们就来看一看 I/O多路复用的前世今生。</p><h1 id="最基础的-Socket-模型"><a href="#最基础的-Socket-模型" class="headerlink" title="最基础的 Socket 模型"></a>最基础的 <code>Socket</code> 模型</h1><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p><p>Socket 的中文名叫做插口，乍一看还挺迷惑的。事实上，双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。</p><p>创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。</p><p>UDP 的 Socket 编程相对简单些，这里我们只介绍基于 TCP 的 Socket 编程。</p><p>服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。</p><p>服务端首先调用 <code>socket()</code> 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 <code>bind()</code> 函数，给这个 Socket 绑定一个 <strong>IP 地址和端口</strong>，绑定这两个的目的是什么？</p><ul><li>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</li></ul><p>绑定完 IP 地址和端口后，就可以调用 <code>listen()</code> 函数进行监听，此时对应 TCP 状态图中的 <code>listen</code>，如果我们要判定服务器中一个网络程序有没有启动，可以通过 <code>netstat</code> 命令查看对应的端口号是否有被监听。</p><p>服务端进入了监听状态后，通过调用 <code>accept()</code> 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 <code>connect()</code> 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p><p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p><ul><li>一个是「还没完全建立」连接的队列，称为 <strong>TCP 半连接队列</strong>，这个队列都是没有完成三次握手的连接，此时服务端处于 <code>syn_rcvd</code> 的状态；</li><li>一个是「已经建立」连接的队列，称为 <strong>TCP 全连接队列</strong>，这个队列都是完成了三次握手的连接，此时服务端处于 <code>established</code> 状态；</li></ul><p>当 TCP 全连接队列不为空后，服务端的 <code>accept()</code> 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。</p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作<strong>监听 Socket</strong>；</li><li>一个叫作<strong>已连接 Socket</strong>；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <code>read()</code> 和 <code>write()</code> 函数来读写数据。</p><p>至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tcp_socket.png" alt="img"></p><p>看到这，不知道你有没有觉得读写 Socket 的方式，好像读写文件一样。</p><p>是的，基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。</p><h1 id="如何服务更多的用户？"><a href="#如何服务更多的用户？" class="headerlink" title="如何服务更多的用户？"></a>如何服务更多的用户？</h1><p>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p><p>可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。</p><p>在改进网络 I/O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？</p><p>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：<strong>本机IP, 本机端口, 对端IP, 对端端口</strong>。</p><p>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以<strong>最大 TCP 连接数 = 客户端 IP 数×客户端端口数</strong>。</p><p>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是<strong>服务端单机最大 TCP 连接数约为 2 的 48 次方</strong>。</p><p>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p><ul><li><strong>文件描述符</strong>，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li><strong>系统内存</strong>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p><p>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。</p><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</p><p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p><h1 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h1><p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，</p><p>可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。</p><p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" alt="img"></p><p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="img"></p><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 <strong>I/O 多路复用</strong>技术。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="img"></p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p><p>select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><p>select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>Select 实现多路复用的方式是，将以连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 Select 函数将文件描述符<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查有事件产生后，将此 Socket 标记为可读或者可写，接着再把整个文件描述符集合<strong>拷贝</strong>回用户态，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p><p><strong>函数签名与参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> errorfds,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p><p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><h3 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p><p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p><p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p><p>每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。</p><h3 id="socket-与-fd-的关系"><a href="#socket-与-fd-的关系" class="headerlink" title="socket 与 fd 的关系"></a>socket 与 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br></pre></td></tr></table></figure><p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。</p><p>可以这样理解：socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。socket 与 fd 是一一对应的。通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件。这也符合 Unix“一切皆文件”的哲学。</p><p>后面可以将 socket 和 fd 视为同义词。</p><h3 id="fd-set-文件描述符集合"><a href="#fd-set-文件描述符集合" class="headerlink" title="fd_set 文件描述符集合"></a>fd_set 文件描述符集合</h3><p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p><p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;  <span class="comment">// 将 fd_set 所有位置 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;   <span class="comment">// 将 fd_set 某一位置 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fd_set)</span>;  <span class="comment">// 将 fd_set 某一位置 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">// 检测 fd_set 某一位是否为 1</span></span><br></pre></td></tr></table></figure><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><p>下图的代码说明：</p><ol><li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li><li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li><li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li><li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li><li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li><li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li></ol><p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p><p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p><p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/15732186159520.jpg" alt="15732186159520"></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 和 select 几乎没有区别。poll 在用户态通过<strong>数组</strong>方式<strong>传递</strong>文件描述符，在内核会转为<strong>链表</strong>方式<strong>存储</strong>，没有最大数量的限制。</p><p>poll 的函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>fds</code> 是一个 <code>pollfd</code> 结构体类型的数组，调用 <code>poll()</code> 时必须通过 <code>nfds</code> 指出数组 <code>fds</code> 的大小，即文件描述符的数量。</p><p>poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><p>如下的代码中，先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><p><strong>第一点</strong>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p><strong>第二点</strong>， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p>从下图你可以看到 epoll 相关的接口作用：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/epoll.png" alt="img"></p><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><blockquote><p>插个题外话，网上文章不少说，<code>epoll_wait</code> 返回时，对于就绪的事件，epoll 使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。</p><p>这是错的！看过 epoll 内核源码的都知道，<strong>压根就没有使用共享内存这个玩意</strong>。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 <code>__put_user</code> 函数，这个函数就是将数据从内核拷贝到用户空间。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/__put_user.png" alt="img"></p><p>好了，这个题外话就说到这了，我们继续</p></blockquote><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p><p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p><p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p><p><code>epoll</code> 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>fd</code> 表示要监听的目标文件描述符</li><li><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</li><li><code>op</code>表示要对 <code>fd</code> 执行的操作，有以下几种：<ul><li><code>EPOLL_CTL_ADD</code>：为 <code>fd</code> 添加一个监听事件 <code>event</code></li><li><code>EPOLL_CTL_MOD</code>：Change the event event associated with the target file descriptor fd（<code>event</code> 是一个结构体变量，这相当于变量 <code>event</code> 本身没变，但是更改了其内部字段的值）</li><li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code> 的所有监听事件，这种情况下 <code>event</code> 参数没用</li></ul></li></ul><p>返回值 0 或 -1，表示上述操作成功与否。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li><li><code>maxevents</code> 指定 <code>events</code> 的大小</li><li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li></ul><p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）</strong>和<strong>水平触发（level-triggered，LT）</strong>。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><blockquote><p>另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：</p><blockquote><p>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.</p></blockquote><p>我谷歌翻译的结果：</p><blockquote><p>在Linux下，select() 可能会将一个 socket 文件描述符报告为 “准备读取”，而后续的读取块却没有。例如，当数据已经到达，但经检查后发现有错误的校验和而被丢弃时，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 O_NONBLOCK 可能更安全。</p></blockquote><p>简单点理解，就是<strong>多路复用 API 返回的事件并不一定可读写的</strong>，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I/O？"></a>为什么边缘触发必须使用非阻塞 I/O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</li><li><code>select</code> 可以使用阻塞 I/O 通过 <code>select</code> 获取到所有可读的文件描述符后，遍历每个文件描述符，<code>read</code> 一次数据<ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul></li><li>在 <code>epoll</code> 的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知<ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li></ul></li></ul><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。</p><p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。</p><ul><li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li></ul><p>而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。</p><p>I/O 多路复用在一定程度上成就了 Redis，这是我的理解，没有 I/O多路复用，Redis 可能就没这么快了，也许吧。</p><p>说说面试，前两天有三次面试，这让我觉得机会又来了，这也过了两三天了，都还没挂，也是好消息了，这三场面试也是让我学到了不少的东西，之前一直闷着头学习总是觉得没有方向，东一榔头西一棒槌，面试找到了不足，最近这几天也都在去补，所以还没怎么开始学新的内容，不过明天应该就差不多了，不管是学习还是实习又或者是秋招，都祝我好运。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">https://imageslr.com/2020/02/27/select-poll-epoll.html</a></p><p><a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</a></p><p><a href="https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久很久以前（三天前），我被问到一个熟悉又陌生的问题，了解I/O多路复用吗？我回答，了解但是还没开始学？是的，我学习的领域就是这么广泛又浅显，名词我都了解，但是就是不知道具体是什么。&lt;/p&gt;
&lt;p&gt;说到 I/O多路复用，我学习的博客都把他归到了操作系统一类里面，我也学过操作</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法大揭秘</title>
    <link href="http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/"/>
    <id>http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/</id>
    <published>2024-06-20T08:17:28.000Z</published>
    <updated>2024-06-20T12:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。</p><p>学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之前一直拖着没总结的东西重新学习并总结一下。</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法（sorting algorithm）用于对一组数据按照特定的顺序进行排序。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。</p><p>排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620163619694.png" alt="image-20240620163619694"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p><p><strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p><p><strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。</p><p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure><p><strong>自适应性</strong>：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。</p><p>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。</p><p><strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $𝑂(𝑛 log⁡𝑛)$ 。而非比较排序不使用比较运算符，时间复杂度可达 $𝑂(𝑛)$ ，但其通用性相对较差。</p><h2 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h2><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</p><p>接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。先看看各种算法的比较：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="image"></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>选择排序（selection sort）</strong>的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p><p><strong>算法步骤</strong>：</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ol><p><strong>动画演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1c7e20f306ddc02eb4e3a50fa7817ff4.gif" alt="img"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// 外循环：未排序区间为[i, n-1]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="comment">// 内循环：找到未排序区间内最小（大）的元素</span></span><br><span class="line">k := i</span><br><span class="line"><span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[k] &#123;</span><br><span class="line"><span class="comment">// 记录最小元素的值</span></span><br><span class="line">k = j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛2)、非自适应排序</strong>：外循环共 𝑛−1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛−1、…、3、2 轮内循环，求和为 $(𝑛−1)(𝑛+2)/2$ 。</li><li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>非稳定排序</strong>：如图 11-3 所示，元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620170153391.png" alt="image-20240620170153391"></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>冒泡排序（bubble sort）</strong>通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p><p><strong>算法步骤：</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/33a947c71ad62b254cab62e5364d2813.gif" alt="img"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为[0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回。</p><p>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 $𝑂(𝑛^2) $；但当输入数组完全有序时，可达到最佳时间复杂度 $𝑂(𝑛) $。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortWithFlag</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        flag := <span class="literal">false</span> <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">false</span> &#123; <span class="comment">// 此轮“冒泡”未交换任何元素，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 $𝑂(n^2)$、自适应排序</strong>：各轮“冒泡”遍历的数组长度依次为 𝑛−1、𝑛−2、…、2、1 ，总和为$ (𝑛−1)𝑛/2 $。在引入 <code>flag</code> 优化后，最佳时间复杂度可达到 $𝑂(𝑛)$ 。</li><li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>稳定排序</strong>：由于在“冒泡”中遇到相等元素不交换。</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>插入排序（insertion sort）</strong>是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p><p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p><p><strong>算法步骤：</strong></p><p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/91b76e8e4dab9b0cad9a017d7dd431e2.gif" alt="img"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        base := nums[i]</span><br><span class="line">        j := i<span class="number">-1</span></span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 $𝑂(𝑛2)$、自适应排序</strong>：在最差情况下，每次插入操作分别需要循环 𝑛−1、𝑛−2、…、2、1 次，求和得到 $(𝑛−1)𝑛/2 $，因此时间复杂度为 $𝑂(𝑛2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 𝑂(𝑛) 。</li><li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>稳定排序</strong>：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>插入排序的时间复杂度为$ 𝑂(𝑛^2) $，而我们即将学习的快速排序的时间复杂度为$ 𝑂(𝑛log⁡𝑛) $。尽管插入排序的时间复杂度更高，<strong>但在数据量较小的情况下，插入排序通常更快</strong>。</p><p>这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 𝑂(𝑛log⁡𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，𝑛2 和 𝑛log⁡𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。</p><p>实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。</p><p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $𝑂(𝑛^2) $，但在实际情况中，<strong>插入排序的使用频率显著高于冒泡排序和选择排序</strong>，主要有以下原因。</p><ul><li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，<strong>冒泡排序的计算开销通常比插入排序更高</strong>。</li><li>选择排序在任何情况下的时间复杂度都为 $𝑂(𝑛^2)$ 。<strong>如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</strong>。</li><li>选择排序不稳定，无法应用于多级排序。</li></ul><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>希尔排序（Shell Sort）</strong>通过将待排序数组分割成若干子序列，使得每个子序列分别进行插入排序，随着算法的进行逐渐减小子序列的间隔，最终使整个数组变得有序。希尔排序在最后一步中使用一个间隔为 1 的插入排序，这一步能够高效地将几乎有序的数组进行完全排序。</p><p><strong>算法步骤：</strong></p><ol><li><strong>选择初始增量（gap）</strong>：选择一个初始的增量序列，可以是数组长度的一半或者其他一些预定义的序列。</li><li><strong>分割子序列</strong>：根据当前的增量将数组分割成若干子序列，每个子序列由相隔增量距离的元素组成。</li><li><strong>对子序列进行插入排序</strong>：对每个子序列分别进行插入排序。</li><li><strong>缩小增量</strong>：减少增量的值，通常减小为原来的一半或者按照其他规则减小。</li><li><strong>重复上述步骤</strong>：重复分割子序列和排序的过程，直到增量缩小到 1，此时对整个数组进行一次插入排序。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="image"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 初始增量，通常取数组长度的一半</span></span><br><span class="line">    <span class="keyword">for</span> gap := n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := gap; i &lt; n; i++ &#123;</span><br><span class="line">            temp := nums[i]</span><br><span class="line">            j := i</span><br><span class="line">            <span class="keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-3"><a href="#算法特性-3" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度</strong>：希尔排序的时间复杂度依赖于增量序列的选择，最坏情况下为 $O(n^2)$，但在实际应用中通常表现优于插入排序和冒泡排序。</li><li><strong>空间复杂度</strong>：希尔排序是原地排序算法，空间复杂度为$ O(1)$。</li><li><strong>稳定性</strong>：希尔排序不是稳定排序，因为相同元素在不同子序列中的相对位置可能会发生变化。</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。</p><ol><li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ol><p><strong>算法步骤：</strong></p><p><strong>“划分阶段”</strong>从顶至底递归地将数组从中点切分为两个子数组。</p><ol><li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li><li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时终止。</li></ol><p><strong>“合并阶段”</strong>从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。</p><p><strong>动图演示：</strong></p><p><img src="https://static001.geekbang.org/infoq/cd/cdda3f11c6efbc01577f5c29a9066772.gif" alt="img"></p><p>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。</p><ul><li><strong>后序遍历</strong>：先递归左子树，再递归右子树，最后处理根节点。</li><li><strong>归并排序</strong>：先递归左子数组，再递归右子数组，最后处理合并。</li></ul><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 合并左子树组和右子数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span></span><br><span class="line">    <span class="comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化左子树组和右子数组的起始索引</span></span><br><span class="line">    i, j, k := left, mid+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= right &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j] &#123;</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将左子树组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &#123;</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j &lt;= right &#123;</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(tmp); k++ &#123;</span><br><span class="line">        nums[left+k] = tmp[k]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 划分阶段</span></span><br><span class="line">    mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">    mergeSort(nums, left, mid)</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-4"><a href="#算法特性-4" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：划分产生高度为 log⁡𝑛 的递归树，每层合并的总操作数量为 𝑛 ，因此总体时间复杂度为 𝑂(𝑛log⁡𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛)、非原地排序</strong>：递归深度为 log⁡𝑛 ，使用 𝑂(log⁡𝑛) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 𝑂(𝑛) 大小的额外空间。</li><li><strong>稳定排序</strong>：在合并过程中，相等元素的次序保持不变。</li></ul><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>对于链表，归并排序相较于其他排序算法具有显著优势，<strong>可以将链表排序任务的空间复杂度优化至 𝑂(1)</strong> 。</p><ul><li><strong>划分阶段</strong>：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。</li><li><strong>合并阶段</strong>：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p><strong>快速排序（quick sort）</strong>是一种基于分治策略的排序算法，运行高效，应用广泛。</p><p>快速排序的核心操作是 “哨兵划分”，其目标是：选择数组中某个元素作为 “基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p><p><strong>算法步骤：</strong></p><ol><li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li><li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤 <code>2</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ol><p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c411339b79f92499dcb7b5f304c826f4.gif" alt="img"></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>哨兵划分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哨兵划分</span></span><br><span class="line">    pivot := q.partition(nums, left, right)</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    q.quickSort(nums, left, pivot<span class="number">-1</span>)</span><br><span class="line">    q.quickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuickSort 非递归快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        high := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        low := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        p := Partition(arr, low, high)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p<span class="number">-1</span> &gt; low &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, low, p<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p+<span class="number">1</span> &lt; high &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, p+<span class="number">1</span>, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-5"><a href="#算法特性-5" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、自适应排序</strong>：在平均情况下，哨兵划分的递归层数为 log⁡𝑛 ，每层中的总循环数为 𝑛 ，总体使用 𝑂(𝑛log⁡𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 $𝑂(𝑛^2) $时间。</li><li><strong>空间复杂度为 𝑂(𝑛)、原地排序</strong>：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。</li><li><strong>非稳定排序</strong>：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</li></ul><h2 id="快速排序为什么快？"><a href="#快速排序为什么快？" class="headerlink" title="快速排序为什么快？"></a>快速排序为什么快？</h2><p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。</p><ul><li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 $𝑂(𝑛^2) $，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛log⁡𝑛) 的时间复杂度下运行。</li><li><strong>缓存使用效率高</strong>：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。</li><li><strong>复杂度的常数系数小</strong>：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="基准数优化"><a href="#基准数优化" class="headerlink" title="基准数优化"></a>基准数优化</h3><p><strong>快速排序在某些输入下的时间效率可能降低</strong>。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。</p><p>为了尽量避免这种情况发生，<strong>我们可以优化哨兵划分中的基准数的选取策略</strong>。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。</p><p>需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。</p><p>为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），<strong>并将这三个候选元素的中位数作为基准数</strong>。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 $𝑂(𝑛^2) $的概率大大降低。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选取三个候选元素的中位数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> medianThree(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    l, m, r := nums[left], nums[mid], nums[right]</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid <span class="comment">// m 在 l 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">return</span> left <span class="comment">// l 在 m 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哨兵划分（三数取中值）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    med := q.medianThree(nums, left, (left+right)/<span class="number">2</span>, right)</span><br><span class="line">    <span class="comment">// 将中位数交换至数组最左端</span></span><br><span class="line">    nums[left], nums[med] = nums[med], nums[left]</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">//从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">//从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">//返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。</p><p>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过 𝑛/2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序（尾递归优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortTailCall)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        pivot := q.partition(nums, left, right)</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> pivot-left &lt; right-pivot &#123;</span><br><span class="line">            q.quickSort(nums, left, pivot<span class="number">-1</span>) <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q.quickSort(nums, pivot+<span class="number">1</span>, right) <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 𝑂(𝑛log⁡𝑛) 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</p><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。</p><ol><li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li><li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li></ol><p>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。</p><p><strong>算法步骤：</strong></p><p>设数组的长度为 𝑛 </p><ol><li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li><li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。</li><li>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。</li><li>循环执行第 <code>2.</code> 步和第 <code>3.</code> 步。循环 𝑛−1 轮后，即可完成数组排序。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7073c729230e1a2c3c3c9207b25f6b43.gif" alt="img"></p><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(nums *[]<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        r := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">        ma := i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = r</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        siftDown(nums, <span class="built_in">len</span>(*nums), i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span></span><br><span class="line">        (*nums)[<span class="number">0</span>], (*nums)[i] = (*nums)[i], (*nums)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        siftDown(nums, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-6"><a href="#算法特性-6" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：建堆操作使用 𝑂(𝑛) 时间。从堆中提取最大元素的时间复杂度为 𝑂(log⁡𝑛) ，共循环 𝑛−1 轮。</li><li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：几个指针变量使用 𝑂(1) 空间。元素交换和堆化操作都是在原数组上进行的。</li><li><strong>非稳定排序</strong>：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li></ul><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>计数排序（counting sort）不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3c7ddb59df2d21b287e42a7b908409cb.gif" alt="img"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>给定一个长度为 𝑛 的数组 <code>nums</code> ，其中的元素都是“非负整数”。</p><p><strong>算法步骤：</strong></p><ol><li>遍历数组，找出其中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚+1 的辅助数组 <code>counter</code> 。</li><li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加 1 即可。</li><li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字出现次数从小到大的顺序填入 <code>nums</code> 即可。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620202353083.png" alt="image-20240620202353083"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 简单实现，无法用于排序对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortNaive</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="number">0</span>, <span class="number">0</span>; num &lt; m+<span class="number">1</span>; num++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; counter[num]; j++ &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计数排序与桶排序的联系</p><p>从桶排序的角度看，我们可以将计数排序中的计数数组 <code>counter</code> 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。</p></blockquote><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>细心的同学可能已经发现了，<strong>如果输入数据是对象，上述步骤 <code>3.</code> 就失效了</strong>。假设输入数据是商品对象，我们想按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。</p><p>那么如何才能得到原数据的排序结果呢？我们首先计算 <code>counter</code> 的“前缀和”。顾名思义，索引 <code>i</code> 处的前缀和 <code>prefix[i]</code> 等于数组前 <code>i</code> 个元素之和：</p><script type="math/tex; mode=display">prefix[𝑖]=∑_{𝑗=0}^𝑖counter[j]</script><p><strong>前缀和具有明确的意义，<code>prefix[num] - 1</code> 代表元素 <code>num</code> 在结果数组 <code>res</code> 中最后一次出现的索引</strong>。这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 <code>nums</code> 的每个元素 <code>num</code> ，在每轮迭代中执行以下两步。</p><ol><li>将 <code>num</code> 填入数组 <code>res</code> 的索引 <code>prefix[num] - 1</code> 处。</li><li>令前缀和 <code>prefix[num]</code> 减小 1 ，从而得到下次放置 <code>num</code> 的索引。</li></ol><p>遍历完成后，数组 <code>res</code> 中就是排序好的结果，最后使用 <code>res</code> 覆盖原数组 <code>nums</code> 即可。</p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        counter[i+<span class="number">1</span>] += counter[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment">// 初始化数组 res 用于记录结果</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        num := nums[i]</span><br><span class="line">        <span class="comment">// 将 num 放置到对应索引处</span></span><br><span class="line">        res[counter[num]<span class="number">-1</span>] = num</span><br><span class="line">        <span class="comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">        counter[num]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="built_in">copy</span>(nums, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-7"><a href="#算法特性-7" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛+𝑚)、非自适应排序</strong> ：涉及遍历 <code>nums</code> 和遍历 <code>counter</code> ，都使用线性时间。一般情况下 𝑛≫𝑚 ，时间复杂度趋于 𝑂(𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑚)、非原地排序</strong>：借助了长度分别为 𝑛 和 𝑚 的数组 <code>res</code> 和 <code>counter</code> 。</li><li><strong>稳定排序</strong>：由于向 <code>res</code> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <code>nums</code> 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <code>nums</code> 也可以得到正确的排序结果，但结果是非稳定的。</li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>看到这里，你也许会觉得计数排序非常巧妙，仅通过统计数量就可以实现高效的排序。然而，使用计数排序的前置条件相对较为严格。</p><p><strong>计数排序只适用于非负整数</strong>。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去。</p><p><strong>计数排序适用于数据量大但数据范围较小的情况</strong>。比如，在上述示例中 𝑚 不能太大，否则会占用过多空间。而当 𝑛≪𝑚 时，计数排序使用 𝑂(𝑚) 时间，可能比 𝑂(𝑛log⁡𝑛) 的排序算法还要慢。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p><strong>桶排序（bucket sort）</strong>是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p><p><strong>算法步骤：</strong></p><p>考虑一个长度为 𝑛 的数组，其元素是范围 [0,1) 内的浮点数。</p><ol><li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li><li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li><li>按照桶从小到大的顺序合并结果。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620203439496.png" alt="image-20240620203439496"></p><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b29c1a8ee42595e7992b6d2eb1030f76.gif" alt="img"></p><h2 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(nums []<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="type">float64</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        buckets[i] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i := <span class="type">int</span>(num * <span class="type">float64</span>(k))</span><br><span class="line">        <span class="comment">// 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i] = <span class="built_in">append</span>(buckets[i], num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="comment">// 使用内置切片排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        sort.Float64s(buckets[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-8"><a href="#算法特性-8" class="headerlink" title="算法特性"></a>算法特性</h2><p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p><ul><li><strong>时间复杂度为 𝑂(𝑛+𝑘)</strong> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 𝑛𝑘 。假设排序单个桶使用 𝑂(𝑛/𝑘<em>log⁡(𝑛/𝑘)) 时间，则排序所有桶使用 𝑂(𝑛log⁡(𝑛/𝑘)) 时间。<em>*当桶数量 𝑘 比较大时，时间复杂度则趋向于 𝑂(𝑛)</em></em> 。合并结果时需要遍历所有桶和元素，花费 𝑂(𝑛+𝑘) 时间。</li><li><strong>自适应排序</strong>：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 𝑂(𝑛2) 时间。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑘)、非原地排序</strong>：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ul><h2 id="如何实现平均分配"><a href="#如何实现平均分配" class="headerlink" title="如何实现平均分配"></a>如何实现平均分配</h2><p>桶排序的时间复杂度理论上可以达到 𝑂(𝑛) ，<strong>关键在于将元素均匀分配到各个桶中</strong>，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。</p><p>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong>。</p><p>如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204021017.png" alt="image-20240620204021017"></p><p>如果我们提前知道商品价格的概率分布，<strong>则可以根据数据概率分布设置每个桶的价格分界线</strong>。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p><p>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204045066.png" alt="image-20240620204045066"></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>上面介绍了计数排序，它适用于数据量 𝑛 较大但数据范围 𝑚 较小的情况。假设我们需要对 $𝑛=10^6$ 个学号进行排序，而学号是一个 8 位数字，这意味着数据范围 $𝑚=10^8 $非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。</p><h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p><strong>基数排序（radix sort）</strong>的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</p><p><strong>算法步骤：</strong></p><p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的流程如图所示。</p><ol><li>初始化位数 𝑘=1 。</li><li>对学号的第 𝑘 位执行“计数排序”。完成后，数据会根据第 𝑘 位从小到大排序。</li><li>将 𝑘 增加 1 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204242169.png" alt="image-20240620204242169"></p><p>对于一个 𝑑 进制的数字 𝑥 ，要获取其第 𝑘 位 $𝑥_𝑘 $，可以使用以下计算公式：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204349152.png" alt="image-20240620204349152"></p><p>其中 ⌊𝑎⌋ 表示对浮点数 𝑎 向下取整，而 <code>mod d</code> 表示对 𝑑 取模（取余）。对于学号数据，𝑑=10 且 𝑘∈[1,8] 。</p><p>此外，我们需要小幅改动计数排序代码，使之可以根据数字的第 𝑘 位进行排序：</p><blockquote><p>为什么从最低位开始排序？</p><p>在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 𝑎&lt;𝑏 ，而第二轮排序结果 𝑎&gt;𝑏 ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。</p></blockquote><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3a6f1e5059386523ed941f0d6c3a136e.gif" alt="img"></p><h2 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">(num, exp <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序（根据 nums 第 k 位排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortDigit</span><span class="params">(nums []<span class="type">int</span>, exp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        d := digit(nums[i], exp) <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++             <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        counter[i] += counter[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        d := digit(nums[i], exp)</span><br><span class="line">        j := counter[d] - <span class="number">1</span> <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]    <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--        <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    max := math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">            max = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; max &gt;= exp; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        countingSortDigit(nums, exp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-9"><a href="#算法特性-9" class="headerlink" title="算法特性"></a>算法特性</h2><p>相较于计数排序，基数排序适用于数值范围较大的情况，<strong>但前提是数据必须可以表示为固定位数的格式，且位数不能过大</strong>。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 𝑂(𝑛𝑘)≫𝑂(𝑛2) 。</p><ul><li><strong>时间复杂度为 𝑂(𝑛𝑘)、非自适应排序</strong>：设数据量为 𝑛、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 𝑂(𝑛+𝑑) 时间，排序所有 𝑘 位使用 𝑂((𝑛+𝑑)𝑘) 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 𝑂(𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑑)、非原地排序</strong>：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 <code>res</code> 和 <code>counter</code> 。</li><li><strong>稳定排序</strong>：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果。</li></ul><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>Q</strong>：排序算法稳定性在什么情况下是必需的？</p><p>在现实中，我们有可能基于对象的某个属性进行排序。例如，学生有姓名和身高两个属性，我们希望实现一个多级排序：先按照姓名进行排序，得到 <code>(A, 180) (B, 185) (C, 170) (D, 170)</code> ；再对身高进行排序。由于排序算法不稳定，因此可能得到 <code>(D, 170) (C, 170) (A, 180) (B, 185)</code> 。</p><p>可以发现，学生 D 和 C 的位置发生了交换，姓名的有序性被破坏了，而这是我们不希望看到的。</p><p><strong>Q</strong>：哨兵划分中“从右往左查找”与“从左往右查找”的顺序可以交换吗？</p><p>不行，当我们以最左端元素为基准数时，必须先“从右往左查找”再“从左往右查找”。这个结论有些反直觉，我们来剖析一下原因。</p><p>哨兵划分 <code>partition()</code> 的最后一步是交换 <code>nums[left]</code> 和 <code>nums[i]</code> 。完成交换后，基准数左边的元素都 <code>&lt;=</code> 基准数，<strong>这就要求最后一步交换前 <code>nums[left] &gt;= nums[i]</code> 必须成立</strong>。假设我们先“从左往右查找”，那么如果找不到比基准数更大的元素，<strong>则会在 <code>i == j</code> 时跳出循环，此时可能 <code>nums[j] == nums[i] &gt; nums[left]</code></strong>。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。</p><p>举个例子，给定数组 <code>[0, 0, 0, 0, 1]</code> ，如果先“从左向右查找”，哨兵划分后数组为 <code>[1, 0, 0, 0, 0]</code> ，这个结果是不正确的。</p><p>再深入思考一下，如果我们选择 <code>nums[right]</code> 为基准数，那么正好反过来，必须先“从左往右查找”。</p><p><strong>Q</strong>：关于尾递归优化，为什么选短的数组能保证递归深度不超过 log⁡𝑛 ？</p><p>递归深度就是当前未返回的递归方法的数量。每轮哨兵划分我们将原数组划分为两个子数组。在尾递归优化后，向下递归的子数组长度最大为原数组长度的一半。假设最差情况，一直为一半长度，那么最终的递归深度就是 log⁡𝑛 。</p><p>回顾原始的快速排序，我们有可能会连续地递归长度较大的数组，最差情况下为 𝑛、𝑛−1、…、2、1 ，递归深度为 𝑛 。尾递归优化可以避免这种情况出现。</p><p><strong>Q</strong>：当数组中所有元素都相等时，快速排序的时间复杂度是 $𝑂(𝑛^2) $吗？该如何处理这种退化情况？</p><p>是的。对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p><p><strong>Q</strong>：桶排序的最差时间复杂度为什么是$ 𝑂(𝑛^2) $？</p><p>最差情况下，所有元素被分至同一个桶中。如果我们采用一个 $𝑂(𝑛^2)$ 算法来排序这些元素，则时间复杂度为$ 𝑂(𝑛^2) $。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到 𝑂(𝑛) 。</li><li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为 𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li><li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至 𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到 𝑂(log⁡𝑛) 。</li><li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为 𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至 𝑂(1) 。</li><li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配。</li><li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并且要求数据能够转换为正整数。</li><li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li></ul><p>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及正向自适应性等优点。然而，正如其他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据数据的特性来选择合适的排序算法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sorting_algorithms_comparison.png" alt="排序算法对比"></p><p>OK了，今天的算法学习就先到这里，该作题了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.hello-algo.com/chapter_sorting/">https://www.hello-algo.com/chapter_sorting/</a></p><p><a href="https://github.com/MisterBooo/Article">https://github.com/MisterBooo/Article</a></p><p><a href="https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4">https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。&lt;/p&gt;
&lt;p&gt;学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之</summary>
      
    
    
    
    <category term="Hello,算法！" scheme="http://example.com/categories/Hello-%E7%AE%97%E6%B3%95%EF%BC%81/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是一致性哈希算法？</title>
    <link href="http://example.com/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
    <id>http://example.com/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/</id>
    <published>2024-06-20T06:45:14.000Z</published>
    <updated>2024-06-20T08:26:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希算法，一个躺在我书签里两周的知识点，之前就一直说要看要看，结果一直拖，拖到昨天被面试官问了，只能回答说不会。</p><p>一致性哈希算法、一致性算法，这两个内容我一直以为是一样的，所以刚开始决定放在一起学，刚刚得知，两个不是一个东西。露出尴尬的笑容，那就先学一致性哈希算法吧。</p><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p><p>一致性哈希算法是一种常用的分布式算法，其主要用途是在分布式系统中，将数据根据其键（key）进行散列（hash），然后将散列结果映射到环上，再根据数据节点的数量，将环划分为多个区间，每个节点负责处理环上一定区间范围内的数据。</p><p>按照老传统，我们逐步进行学习。</p><h1 id="如何分配请求？"><a href="#如何分配请求？" class="headerlink" title="如何分配请求？"></a>如何分配请求？</h1><p>大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。</p><p>但是问题来了，现在有这么多个节点，要如何保证分配客户端的请求呢？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b752a4f8dcaab8ed4d941ebcc6f606c5.png" alt="img"></p><p>其实这个问题就是负载均衡问题。解决负载均衡问题的算法有很多，不同的负载均衡算法对应的就是不同的分配策略，适应的业务场景也不同。</p><p>最简单的方式，引入一个中间的负载均衡层，让它将外界的请求「轮流」地转发给内部的集群。比如集群有三个节点，外界请求有三个，那么每个节点都会处理一个请求，达到了分配请求的目的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d3279ad754257977f98e702cb156e9cf.png" alt="img"></p><p>考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做加权轮询。</p><p>加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。</p><p>但是，加权轮询算法是无法应对「分布式系统（数据分片的系统）」的。因为分布式系统中，每个节点存储的数据是不相同的。</p><p>当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如<strong>一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的</strong>，不是说任意访问一个节点都可以得到缓存结果的。</p><p>因此，我们要想一个能应对分布式系统的负载均衡算法。</p><h1 id="使用普通哈希的问题"><a href="#使用普通哈希的问题" class="headerlink" title="使用普通哈希的问题"></a>使用普通哈希的问题</h1><p>小脑袋瓜机灵的同学很快就会想到 <strong>哈希算法</strong>。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 <code>key</code> 确定到一个节点了，可以满足系统的负载均衡需求。</p><p>哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 <code>hash(key) % 3</code> 公式对数据进行了映射。</p><p>如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key) % 3</span><br></pre></td></tr></table></figure><p>如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。</p><p>但是有一个很致命的问题，<strong>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</strong>，否则会出现查询不到数据的问题。</p><p>分布式集群中，对机器的添加、删除或者机器故障后自动脱离集群这些操作都是集群管理最基本的功能。如果采用那个常用的 <code>hash(object)%N</code> 取模的方式，在节点进行添加或删除后，需要重新进行迁移改变映射关系，否则可能导致原有的数据无法找到。</p><p><strong>举个例子：</strong></p><p>随着业务和流量的增加，假如我们的 Redis 查询服务节点扩展到了3个，为了将查询请求进行均衡，每次请求都在相同的Redis中，使用hv = hash(key) % 3的方式计算，对每次查询请求都通过hash值计算，得出来0、1 、2的值分别对应服务节点的编号，计算得到的hv的值就去对应的节点处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/462342823ffbc816c623152f48240598.png" alt="img"></p><p>但是这里有个问题，服务增减是需要对此时的key进行重新计算，比如减少一个服务的时候，此时需要按 hv = hash(key) % 2计算，而增加一个服务节点的时候需要按hv = hash(key) % 4计算，而这种取模基数的变化会改变大部分原来的映射关系。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3555435d14a54a088513b8dcc1049521.png" alt="img"></p><p>这个时候只能进行数据迁移，非常麻烦，所以我们应该选择一个更加好用的方案。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法能够很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p><p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</p><p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0ea3960fef48d4cbaeb4bec4345301e7.png" alt="img"></p><p>一致性哈希要进行两步哈希：</p><ul><li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li><li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；</li></ul><p>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p><p>问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？</p><p>答案是，映射的结果值往<strong>顺时针的方向的找到第一个节点</strong>，就是存储该数据的节点。</p><p>举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/83d7f363643353c92d252e34f1d4f687.png" alt="img"></p><p>接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。</p><p>比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。</p><p>所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：</p><ul><li>首先，对 key 进行哈希计算，确定此 key 在环上的位置；</li><li>然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。</li></ul><p>知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？</p><p>假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f8909edef2f3949f8945bb99380baab3.png" alt="img"></p><p>你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。</p><p>假设节点数量从 3 减少到了 2，比如将节点 A 移除：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/31485046f1303b57d8aaeaab103ea7ab.png" alt="img"></p><p>你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。</p><p>因此，<strong>在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</strong>。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。</p><p>但是<strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，这样就会带来一个问题，会有大量的请求集中在一个节点上。</p><p>比如，下图中 3 个节点的映射位置都在哈希环的右半边：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d528bae6fcec2357ba2eb8f324ad9fd5.png" alt="img"></p><p>这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。</p><p>另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。</p><p>比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。</p><p>所以，<strong>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</strong>。</p><h1 id="如何通过虚拟节点提高均衡度？"><a href="#如何通过虚拟节点提高均衡度？" class="headerlink" title="如何通过虚拟节点提高均衡度？"></a>如何通过虚拟节点提高均衡度？</h1><p>要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。</p><p>但问题是，实际中我们没有那么多节点。所以这个时候我们就加入<strong>虚拟节点</strong>，也就是对一个真实节点做多个副本。</p><p>具体做法是，<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</strong></p><p>比如对每个节点分别设置 3 个虚拟节点：</p><ul><li>对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03</li><li>对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03</li><li>对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03</li></ul><p>引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/602393536805bc21c12db2ecff73d4ab.png" alt="img"></p><p>你可以看到，<strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</p><p>上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。</p><p>另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</p><p>比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p><p>而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</p><p>因此，<strong>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同的负载均衡算法适用的业务场景也不同的。</p><p>轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。</p><p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p><p>为了减少迁移的数据量，就出现了一致性哈希算法。</p><p>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><p>但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</p><p>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</p><p>在聊到这个问题之前，我们讨论的是哈希冲突的解决方案，然后面试官抛出了这个问题，幸亏我没有胡乱回答，这和解决哈希冲突好像没什么关系。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93</a></p><p><a href="https://cloud.tencent.com/developer/article/2373162">https://cloud.tencent.com/developer/article/2373162</a></p><p><a href="https://github.com/fupengfei058/blog/blob/master/%E4%BA%94%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(consistent%20hashing).md">https://github.com/fupengfei058/blog/blob/master/%E4%BA%94%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(consistent%20hashing).md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一致性哈希算法，一个躺在我书签里两周的知识点，之前就一直说要看要看，结果一直拖，拖到昨天被面试官问了，只能回答说不会。&lt;/p&gt;
&lt;p&gt;一致性哈希算法、一致性算法，这两个内容我一直以为是一样的，所以刚开始决定放在一起学，刚刚得知，两个不是一个东西。露出尴尬的笑容，那就先学一致</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
