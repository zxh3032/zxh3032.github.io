<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-23T14:16:44.044Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查询效率最快的数据结构——map</title>
    <link href="http://example.com/2024/10/23/%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9C%80%E5%BF%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94map/"/>
    <id>http://example.com/2024/10/23/%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9C%80%E5%BF%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94map/</id>
    <published>2024-10-23T06:40:53.000Z</published>
    <updated>2024-10-23T14:16:44.044Z</updated>
    
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>特殊的存在——string</title>
    <link href="http://example.com/2024/10/23/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%98%E5%9C%A8%E2%80%94%E2%80%94string/"/>
    <id>http://example.com/2024/10/23/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%98%E5%9C%A8%E2%80%94%E2%80%94string/</id>
    <published>2024-10-23T06:39:48.000Z</published>
    <updated>2024-10-23T14:16:42.219Z</updated>
    
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>顺序存储两兄弟——数组和切片，到底有什么区别？</title>
    <link href="http://example.com/2024/10/23/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%A4%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2024/10/23/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%A4%E5%85%84%E5%BC%9F%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2024-10-23T06:37:09.000Z</published>
    <updated>2024-10-23T14:16:39.973Z</updated>
    
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>命名、声明和赋值</title>
    <link href="http://example.com/2024/10/23/%E5%91%BD%E5%90%8D%E3%80%81%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC/"/>
    <id>http://example.com/2024/10/23/%E5%91%BD%E5%90%8D%E3%80%81%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC/</id>
    <published>2024-10-23T06:35:15.000Z</published>
    <updated>2024-10-24T09:44:46.259Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用 <code>if</code> 和 <code>for</code> 之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。</p><p>在本章中，我们将深入讨论在 Go语言中变量和常量的命名、声明以及赋值方式，学习不同声明方式的区别和使用方法，以及变量和常量的特点。通过简单学习基础的变量和常量的结构来进入 Go语言的世界。此外，关于一些非常细节或者简单的声明要注意的点，在本文中不会显示。</p><h1 id="Go语言是什么类型的语言？"><a href="#Go语言是什么类型的语言？" class="headerlink" title="Go语言是什么类型的语言？"></a>Go语言是什么类型的语言？</h1><p><strong>Go 语言是一个什么类型的语言？强/弱类型、动态/静态检查类型。</strong></p><p>首先需要明确的是，什么是强/弱类型？什么是动态/静态类型？</p><ul><li><strong>强类型：</strong>强类型的编程语言在编译期间会有严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误。</li><li><strong>弱类型：</strong>弱类型的编程语言在出现类型错误时可能会在运行时进行隐式类型转化，这可能会造成运行错误。</li><li><strong>动态检查类型：</strong>静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。</li><li><strong>静态检查类型：</strong>动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性。</li></ul><p>因此，Go 语言是静态强类型语言，同时 Go 语言也是编译型语言。</p><h1 id="如何命名？"><a href="#如何命名？" class="headerlink" title="如何命名？"></a>如何命名？</h1><p><strong>命名规则如下：</strong></p><ul><li>以字母或下划线开头(Go语言中多不以_开头)；</li><li>后面可以是任意数量的字符、数字和下划线；</li><li>区分大小写；</li><li>不能是关键字(关键字具备特定含义)；</li></ul><p><strong>关键字如下：</strong></p><div class="table-container"><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>defer</strong></td><td><strong>go</strong></td><td><strong>map</strong></td><td><strong>struct</strong></td></tr><tr><td><strong>chan</strong></td><td><strong>else</strong></td><td><strong>goto</strong></td><td><strong>package</strong></td><td><strong>switch</strong></td></tr><tr><td><strong>const</strong></td><td><strong>fallthrough</strong></td><td><strong>if</strong></td><td><strong>range</strong></td><td><strong>type</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>for</strong></td><td><strong>import</strong></td><td><strong>return</strong></td><td><strong>var</strong></td></tr></tbody></table></div><ul><li>可以是保留字,但是建议不使用保留字做为变量名；</li></ul><p><strong>保留字如下：</strong></p><div class="table-container"><table><thead><tr><th>true</th><th>false</th><th>iota</th><th>nil</th><th>int</th></tr></thead><tbody><tr><td><strong>int8</strong></td><td><strong>int16</strong></td><td><strong>int32</strong></td><td><strong>int64</strong></td><td><strong>unit</strong></td></tr><tr><td><strong>unit8</strong></td><td><strong>unit16</strong></td><td><strong>unit32</strong></td><td><strong>unitptr</strong></td><td><strong>float32</strong></td></tr><tr><td><strong>float64</strong></td><td><strong>complex128</strong></td><td><strong>complex64</strong></td><td><strong>bool</strong></td><td><strong>byte</strong></td></tr><tr><td><strong>rune</strong></td><td><strong>string</strong></td><td><strong>error</strong></td><td><strong>make</strong></td><td><strong>len</strong></td></tr><tr><td><strong>cap</strong></td><td><strong>new</strong></td><td><strong>append</strong></td><td><strong>copy</strong></td><td><strong>close</strong></td></tr><tr><td><strong>deletecomplex</strong></td><td><strong>real</strong></td><td><strong>imag</strong></td><td><strong>panic</strong></td><td><strong>recover</strong></td></tr></tbody></table></div><ul><li>在同一范围内不允许出现同名变量</li><li>Go语言要求变量声明后至少使用一次(赋值不属于使用)</li></ul><hr><p>Go语言为开发者提供了简单的基础语法，开发者在短期内即可完全掌握这些语法并编写可用于生成环境的代码。本部分将详述在Go基础语法层面有哪些高质量 Go 代码的惯用法和有效实践，内容涵盖变量声明、无类型常量的作用、枚举常量的定义、零值可用类型的意义等。</p><h1 id="使用一致的变量声明形式"><a href="#使用一致的变量声明形式" class="headerlink" title="使用一致的变量声明形式"></a>使用一致的变量声明形式</h1><p>和Python、Ruby等动态脚本语言不同，Go语言沿袭了静态编译型语言的传统：<strong>使用变量之前需要先进行变量的声明</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">13</span></span><br><span class="line">n := <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    crlf       = []<span class="type">byte</span>(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    colonSpace = []<span class="type">byte</span>(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go语言有两类变量：</p><ul><li>包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。</li><li>局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。</li></ul><p>下面来分别说明实现这两类变量在声明形式选择上保持一致性的一些最佳实践。</p><h2 id="包级变量的声明方式"><a href="#包级变量的声明方式" class="headerlink" title="包级变量的声明方式"></a>包级变量的声明方式</h2><p>包级变量只能使用带有 <code>var</code> 关键字的变量声明形式，但在形式细节上仍然有一定的灵活度。我们从生命变量时是否延迟初始化这个角度对包级变量进行一次分类。</p><h3 id="声明并同时显式初始化"><a href="#声明并同时显式初始化" class="headerlink" title="声明并同时显式初始化"></a>声明并同时显式初始化</h3><p>源码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/pipe.go</span></span><br><span class="line"><span class="keyword">var</span> ErrClosedPipe = errors.New(<span class="string">&quot;io: read/write on closed pipe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ErrShortWrite = errors.New(<span class="string">&quot;short write&quot;</span>)</span><br></pre></td></tr></table></figure><p>从上面的源码可以看出，对于声明变量的同时进行显式初始化的这类包级别变量，实践中常常会用到的格式是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableName = InitExpression</span><br></pre></td></tr></table></figure><p>Go 编译器会自动根据等号右侧的 <code>InitExpression</code> 表达式求值的类型确定左侧所声明变量的类型。</p><p>如果 <code>InitExpression</code> 采用的是不带有类型信息的常量表达式，如下面的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>则包级变量会被设置为常量表达式的默认类型：</p><ul><li>以整型值初始化的变量a，Go编译器会将之设置为默认类型<code>int</code>；</li><li>而以浮点值初始化的变量f，Go编译器会将之设置为默认类型<code>float64</code>。</li></ul><p>如果不接受默认类型，而是要显式为包级变量a和f指定类型，那么有以下两种声明方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line"><span class="keyword">var</span> f = <span class="type">float32</span>(<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure><p>从声明一致性的角度出发，Go语言官方更推荐后者，这样就统一了接受默认类型和显式指定类型两种声明形式。尤其是在将这些变量放在一个var块中声明时，我们更青睐这样的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a = <span class="number">17</span></span><br><span class="line">    f = <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而不是下面这种看起来不一致的声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a  = <span class="number">17</span></span><br><span class="line">    f <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="声明但延迟初始化"><a href="#声明但延迟初始化" class="headerlink" title="声明但延迟初始化"></a>声明但延迟初始化</h3><p>对于声明时并不显式初始化的包级变量，我们使用最基本的声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>虽然没有显式初始化，但 Go语言会让这些变量拥有初始的<strong>“零值”</strong>。如果是自定义的类型，<strong>保证其零值可用</strong>是非常必要的。</p><h3 id="声明聚类与就近原则"><a href="#声明聚类与就近原则" class="headerlink" title="声明聚类与就近原则"></a>声明聚类与就近原则</h3><p>Go语言提供 <code>var</code> 块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在 <code>var</code> 块中的声明类型。</p><p>但是我们一般将同一类的变量声明放在一个 <code>var</code> 块中，将不同类的声明放在不同的 <code>var</code> 块中；或者将延迟初始化的变量声明放在一个 <code>var</code> 块中，而将声明并显式初始化的变量放在另一个 <code>var</code> 块中，可以称之为<strong>“声明聚类”</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/http/server.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    bufioReaderPool   sync.Pool</span><br><span class="line">    bufioWriter2kPool sync.Pool</span><br><span class="line">    bufioWriter4kPool sync.Pool</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyBufPool = sync.Pool &#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>*<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;b</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/net/net.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    aLongTimeAgo = time.Unix(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    noDeadline = time.Time&#123;&#125;</span><br><span class="line">    noCancel   = (<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> threadLimit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>关于声明包级变量，或许大家还会有一个新的问题：<strong>是否应当将包级变量的声明全部集中放在源文件头部呢？</strong></p><p>使用静态编程语言的开发人员都知道，变量声明最佳实践中还有一条：<strong>就近原则</strong>，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。</p><h2 id="局部变量的声明方式"><a href="#局部变量的声明方式" class="headerlink" title="局部变量的声明方式"></a>局部变量的声明方式</h2><p>与包级变量相比，局部变量多了一种短变量声明形式，这也是局部变量采用最多的一种声明形式。</p><h3 id="对于延迟初始化的局部变量声明，采用带有-var-关键字的声明形式"><a href="#对于延迟初始化的局部变量声明，采用带有-var-关键字的声明形式" class="headerlink" title="对于延迟初始化的局部变量声明，采用带有 var 关键字的声明形式"></a>对于延迟初始化的局部变量声明，采用带有 var 关键字的声明形式</h3><p>和全局变量类似，看个例子就行了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = Bar()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于声明且显式初始化的局部变量，建议使用短变量生命形式"><a href="#对于声明且显式初始化的局部变量，建议使用短变量生命形式" class="headerlink" title="对于声明且显式初始化的局部变量，建议使用短变量生命形式"></a>对于声明且显式初始化的局部变量，建议使用短变量生命形式</h3><p>短变量声明形式是局部变量最常用的声明形式，它遍布Go标准库代码。对于接受默认类型的变量，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">17</span></span><br><span class="line">f := <span class="number">3.14</span></span><br><span class="line">s := <span class="string">&quot;hello, gopher!&quot;</span></span><br></pre></td></tr></table></figure><p>同样，Go 编译器会根据右边的数据类型自动推测左边变量的类型，如果没有明显声明，则使用默认类型。</p><p>对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在<code>:=</code>右侧要进行显式转型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line">f := <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">s := []<span class="type">byte</span>(<span class="string">&quot;hello, gopher!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="尽量在分支控制时应用短变量声明形式"><a href="#尽量在分支控制时应用短变量声明形式" class="headerlink" title="尽量在分支控制时应用短变量声明形式"></a>尽量在分支控制时应用短变量声明形式</h3><p>这应该是Go中短变量声明形式应用最广泛的场景了。在编写Go代码时，我们很少单独声明在分支控制语句中使用的变量，而是通过短变量声明形式将其与<code>if</code>、<code>for</code>等融合在一起。</p><p>由于良好的函数/方法设计讲究的是“<strong>单一职责</strong>”，因此每个函数/方法规模都不大，很少需要应用var块来聚类声明局部变量。当然，如果你在声明局部变量时遇到适合聚类的应用场景，你也应该毫不犹豫地使用var块来声明多个局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Resolver)</span></span> resolveAddrList(ctx context.Context, op, network,</span><br><span class="line">                            addr <span class="type">string</span>, hint Addr) (addrList, <span class="type">error</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        tcp      *TCPAddr</span><br><span class="line">        udp      *UDPAddr</span><br><span class="line">        ip       *IPAddr</span><br><span class="line">        wildcard <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>要想做好代码中变量声明的一致性，需要明确要声明的变量是包级变量还是局部变量、是否要延迟初始化、是否接受默认类型、是否为分支控制变量，并结合聚类和就近原则。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241024163145530.png" alt="image-20241024163145530"></p><h1 id="使用无类型常量简化代码"><a href="#使用无类型常量简化代码" class="headerlink" title="使用无类型常量简化代码"></a>使用无类型常量简化代码</h1><p>常量是现代编程语言中最常见的语法元素。在类型系统十分严格的Go语言中，常量还兼具特殊的作用。</p><h2 id="Go常量溯源"><a href="#Go常量溯源" class="headerlink" title="Go常量溯源"></a>Go常量溯源</h2><p>在看 Go语言的常量之前，我们先来回顾一下 C语言中的常量是什么样的。</p><p>在 C语言中，字面量（literal）担负着常量的角色（针对整型值，还可以使用枚举常量）。可以使用整型、浮点型、字符串型、字符型字面值来满足不同场合下对常量的需求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x12345678</span></span><br><span class="line"><span class="number">10086</span></span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line"><span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>为了不让这些魔数（magic number）充斥于源码各处，早期C语言的常用实践是使用宏（macro）定义记号来指代这些字面值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 0x12345678</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMCC_SERVICE_PHONE_NUMBER 10086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WELCOME_TO_GO <span class="string">&quot;Hello, Gopher&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_CHAR <span class="string">&#x27;a&#x27;</span></span></span><br></pre></td></tr></table></figure><p>这种定义“具名字面值”的实践也被称为宏定义常量。虽然后续的 C标准中提供了 <code>const</code> 关键字来定义在程序运行过程中不可改变的变量（又称“只读变量”），但使用宏定义常量的习惯依然被沿袭下来，并且依旧是 C编码中的主流风格。</p><p>宏定义的常量有着诸多不足，比如：</p><ul><li>仅是预编译阶段进行替换的字面值，继承了宏替换的复杂性和易错性；</li><li>是类型不安全的；</li><li>无法在调试时通过宏名字输出常量的值。</li></ul><p>而 C语言中 <code>const</code> 修饰的标识符本质上还是变量，和其他变量一样，编译器不能像对待真正的常量那样对其进行代码优化，也无法将其作为数组声明时的初始长度。</p><p>Go语言是站在 C语言等编程语言的肩膀之上诞生的，它原生提供常量定义的关键字<code>const</code>。<strong>Go语言中的<code>const</code>整合了 C语言中宏定义常量、<code>const</code>只读变量和枚举常量三种形式，并消除了每种形式的不足，使得Go常量成为类型安全且对编译器优化友好的语法元素。</strong>Go中所有与常量有关的声明都通过const来进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/os/file.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY</span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY</span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR</span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面对常量的声明方式仅仅是Go标准库中的少数个例，绝大多数情况下，Go常量在声明时并不显式指定类型，也就是说使用的是无类型常量（untyped constant）。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SeekStart   = <span class="number">0</span></span><br><span class="line">    SeekCurrent = <span class="number">1</span></span><br><span class="line">    SeekEnd     = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>无类型常量是Go语言在语法设计方面的一个“微创新”，也是“追求简单”设计哲学的又一体现，它可以让你的Go代码更加简洁。</p><h2 id="有类型常量带来的烦恼"><a href="#有类型常量带来的烦恼" class="headerlink" title="有类型常量带来的烦恼"></a>有类型常量带来的烦恼</h2><p>Go是对类型安全要求十分严格的编程语言。Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> b myInt = <span class="number">6</span></span><br><span class="line">    fmt.Println(a + b) <span class="comment">// 编译器会给出错误提示：invalid operation: a + b (mismatched  types int and myInt)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，Go 在处理不同类型的变量间的运算时不支持隐式的类型转换。Go 的设计者认为，隐式转换带来的便利性不足以抵消其带来的诸多问题。要解决上面的编译错误，必须进行显式类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> b myInt = <span class="number">6</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(b)) <span class="comment">// 输出：11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而将有类型常量与变量混合在一起进行运算求值时也要遵循这一要求，即如果有类型常量与变量的类型不同，那么混合运算的求值操作会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = n + <span class="number">5</span>        <span class="comment">// 编译器错误提示：cannot use n + 5 (type myInt) as type  int in const initializer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + n)     <span class="comment">// 编译器错误提示：invalid operation: a + n (mismatched  types int and myInt)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯有进行显式类型转换才能让上面的代码正常工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = <span class="type">int</span>(n) + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(n)) <span class="comment">// 输出：18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有类型常量给代码简化带来了麻烦，但这也是Go语言对类型安全严格要求的结果。</p><h2 id="无类型常量消除烦恼，简化代码"><a href="#无类型常量消除烦恼，简化代码" class="headerlink" title="无类型常量消除烦恼，简化代码"></a>无类型常量消除烦恼，简化代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> myFloat <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j myInt = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> f myFloat = <span class="number">3.1415926</span></span><br><span class="line">    <span class="keyword">var</span> str myString = <span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(j)    <span class="comment">// 输出：5</span></span><br><span class="line">    fmt.Println(f)    <span class="comment">// 输出：3.1415926</span></span><br><span class="line">    fmt.Println(str)  <span class="comment">// 输出：Hello, Gopher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这三个字面值无须显式类型转换就可以直接赋值给对应的三个自定义类型的变量，这等价于下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j myInt = myInt(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> f myFloat = myFloat(<span class="number">3.1415926</span>)</span><br><span class="line"><span class="keyword">var</span> str myString = myString(<span class="string">&quot;Hello, Gopher&quot;</span>)</span><br></pre></td></tr></table></figure><p>但显然之前的无须显式类型转换的代码更为简洁。</p><p>Go的无类型常量恰恰就拥有像字面值这样的特性，该特性使得无类型常量在参与变量赋值和计算过程时无须显式类型转换，从而达到简化代码的目的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a  = <span class="number">5</span></span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line">    s  = <span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line">    c  = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    b  = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> myFloat <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j myInt = a</span><br><span class="line">    <span class="keyword">var</span> f myFloat = pi</span><br><span class="line">    <span class="keyword">var</span> str myString = s</span><br><span class="line">    <span class="keyword">var</span> e <span class="type">float64</span> = a + pi</span><br><span class="line"></span><br><span class="line">    fmt.Println(j)    <span class="comment">// 输出：5</span></span><br><span class="line">    fmt.Println(f)                <span class="comment">// 输出：3.1415926</span></span><br><span class="line">    fmt.Println(str)              <span class="comment">// 输出：Hello, Gopher</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, e, e)  <span class="comment">// float64, 8.1415926</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无类型常量使得Go在处理表达式混合数据类型运算时具有较大的灵活性，代码编写也有所简化，我们无须再在求值表达式中做任何显式类型转换了。</p><p>除此之外，无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为bool、int、int32(rune)、float64、complex128和string。当常量被赋值给无类型变量、接口变量时，常量的默认类型对于确定无类型变量的类型及接口对应的动态类型是至关重要的。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    s = <span class="string">&quot;Hello, Gopher&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := a</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, n)         <span class="comment">// 输出：int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)         <span class="comment">// 输出：int</span></span><br><span class="line">    i = s</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i)         <span class="comment">// 输出：string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-itoa-实现枚举常量"><a href="#使用-itoa-实现枚举常量" class="headerlink" title="使用 itoa 实现枚举常量"></a>使用 itoa 实现枚举常量</h1><p>C家族的主流编程语言（如C++、Java等）都提供定义枚举常量的语法。比如在C语言中，枚举是一个具名的整型常数的集合。下面是使用枚举定义的Weekday类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语法</span></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">    SUNDAY,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    enum Weekday d = SATURDAY;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, d); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言针对枚举类型提供了很多语法上的便利，比如：如果没有显式给枚举常量赋初始值，那么枚举类型的第一个常量的值为0，后续常量的值依次加1。</p><p>与使用define宏定义的常量相比，C编译器可以对专用的枚举类型进行严格的类型检查，使得程序更为安全。</p><p>枚举的存在代表了一类现实需求：有限数量标识符构成的集合，且多数情况下并不关心集合中标识符实际对应的值；注重类型安全。</p><p>与其他C家族主流语言（如C++、Java）不同，Go语言没有提供定义枚举常量的语法。我们通常使用常量语法定义枚举常量，比如要在Go中定义上面的Weekday类型，可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday    = <span class="number">0</span></span><br><span class="line">    Monday    = <span class="number">1</span></span><br><span class="line">    Tuesday   = <span class="number">2</span></span><br><span class="line">    Wednesday = <span class="number">3</span></span><br><span class="line">    Thursday  = <span class="number">4</span></span><br><span class="line">    Friday    = <span class="number">5</span></span><br><span class="line">    Saturday  = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果仅仅能支持到这种程度，那么Go就算不上是“站在巨人的肩膀上”了。Go的<code>const</code>语法提供了“隐式重复前一个<strong>“非空表达式”</strong>的机制，来看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape</span><br><span class="line">    Pear, Watermelon</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量定义的后两行没有显式给予初始赋值，Go编译器将为其隐式使用第一行的表达式，这样上述定义等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不过这显然仍无法满足枚举的要求，Go在这个机制的基础上又提供了神器iota。有了iota，我们就可以定义满足各种场景的枚举常量了。</p><p><code>iota</code>是 Go语言的一个预定义标识符，它表示的是<code>const</code>声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的<code>iota</code>自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。下面是Go标准库中<code>sync/mutex.go</code>中的一段枚举常量的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/sync/mutex.go (go 1.12.7)</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span><span class="comment">//1</span></span><br><span class="line">    mutexWoken<span class="comment">//2</span></span><br><span class="line">    mutexStarving<span class="comment">//4</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span><span class="comment">//3</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span><span class="comment">//1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 的本质：它仅代表常量声明的索引，所以它会表示出以下<strong>特征</strong>：</p><ul><li>单个 const 声明块中从 0 开始取值；</li><li>单个 const 声明块中，每增加一行声明，iota 的取值增 1，即便声明中没有使用 iota 也是如此；</li><li>单行声明语句中，即便出现多个 iota，iota 的取值也保持不变。</li></ul><p>iota的加入让Go在枚举常量定义上的表达力大增，主要体现在如下几方面：</p><ol><li>iota预定义标识符能够以更为灵活的形式为枚举常量赋初值；</li><li>Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量；</li><li>iota使得维护枚举常量列表更容易；</li><li>使用有类型枚举常量保证类型安全；</li></ol><h1 id="尽量定义零值可用的类型"><a href="#尽量定义零值可用的类型" class="headerlink" title="尽量定义零值可用的类型"></a>尽量定义零值可用的类型</h1><blockquote><p>保持零值可用。——Go谚语</p></blockquote><p>在Go语言中，零值不仅在变量初始化阶段避免了变量值不确定可能带来的潜在问题，而且定义零值可用的类型也是Go语言积极倡导的最佳实践之一，就像上面那句Go谚语所说的那样。</p><h2 id="Go-语言中的零值"><a href="#Go-语言中的零值" class="headerlink" title="Go 语言中的零值"></a>Go 语言中的零值</h2><p>在使用 C语言进行开发时，我们不难发现一个问题，在声明一个变量但没有显式初始化时，它的值是不确定的。即<strong>未被显式初始化且具有自动存储持续时间的对象，其值是不确定的。</strong></p><p>Go 语言的选择却恰恰相反，<strong>当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值</strong>。</p><p>Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）：</p><ul><li>整型类型：0</li><li>浮点类型：0.0</li><li>布尔类型：false</li><li>字符串类型：””</li><li>指针、interface、切片（slice）、channel、map、function：nil</li><li>另外，Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</li></ul><h2 id="零值可用"><a href="#零值可用" class="headerlink" title="零值可用"></a>零值可用</h2><p>当我们申明了一个变量，但是未对其进行显示初始化时，go语言编译器就会把该变量置为默认零值，且可以直接使用该变量。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span>              </span><br><span class="line">fmt.Println(a)</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">6</span>)</span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/be08366185f042319777d3bb24f6b064%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p><p>但是不能直接对<strong>切片</strong>进行赋值操作这样会出现错误，同样的还有<strong>map</strong>。</p><h2 id="零值可用的好处"><a href="#零值可用的好处" class="headerlink" title="零值可用的好处"></a>零值可用的好处</h2><ul><li>开箱即用：Go语言零值让程序变得简单了，有些场景我们不需要初始化变量就可以直接进行使用。 例如上面的slice、map还有基础类型。</li><li>方法的归纳：利用零值可用的特性，我们可以通过定义一个空的结构体，配合空结构体方法接收者属性，将一些方法组合起来，在业务代码中便于后续的拓展和维护。</li><li>标准库中可以不显示初始化：在GO标准库和运行时代码中,典型的零值可用：<code>sync.Mutex</code> 和 <code>bytes.Buffer</code>。</li></ul><p>零值可用的类型要注意尽量避免值复制。</p><h1 id="使用复合字面值作为初值构造器"><a href="#使用复合字面值作为初值构造器" class="headerlink" title="使用复合字面值作为初值构造器"></a>使用复合字面值作为初值构造器</h1><p>在上一条中，我们了解到零值可用对于编写出符合Go惯用法的代码是大有裨益的。</p><p>但有些时候，零值并非最好的选择，我们有必要为变量赋予适当的初值以保证其后续以正确的状态参与业务流程计算，尤其是Go语言中的一些复合类型的变量。</p><p>Go语言中的复合类型包括结构体、数组、切片和map。对于复合类型变量，最常见的值构造方式就是对其内部元素进行逐个赋值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s myStruct</span><br><span class="line">s.name = <span class="string">&quot;tony&quot;</span></span><br><span class="line">s.age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">13</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">14</span></span><br><span class="line">...</span><br><span class="line">a[<span class="number">4</span>] = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">sl[<span class="number">0</span>] = <span class="number">23</span></span><br><span class="line">sl[<span class="number">1</span>] = <span class="number">24</span></span><br><span class="line">...</span><br><span class="line">sl[<span class="number">4</span>] = <span class="number">27</span></span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;gopher&quot;</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure><p>但这样的值构造方式让代码显得有些烦琐，尤其是在构造组成较为复杂的复合类型变量的初值时。Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。上述代码可以使用复合字面值改写成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;<span class="string">&quot;tony&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;</span><br><span class="line">sl := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;<span class="number">1</span>:<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>:<span class="string">&quot;gopher&quot;</span>, <span class="number">3</span>:<span class="string">&quot;!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>显然，最初的代码得到了大幅简化。</p><p>复合字面值由两部分组成：一部分是<strong>类型</strong>，比如上述示例代码中赋值操作符右侧的<code>myStruct</code>、<code>[5]int</code>、<code>[]int</code>和<code>map[int]string</code>；另一部分是由<strong>大括号<code>&#123;&#125;</code>包裹的字面值</strong>。这里的字面值形式仅仅是Go复合字面值作为值构造器的基本用法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 Go 语言中，变量和常量是非常重要的概念。变量用于存储可以在程序运行过程中被修改的数据，而常量用于存储在程序的整个生命周期中都不会改变的数据。通过不同的声明方式，可以方便地声明和初始化变量和常量。在使用变量和常量时，需要注意它们的作用域和特点，以确保程序的正确性和可读性。</p><p>难得有一两天没什么笔试和面试的事情，还是要好好整理一下最近学习的内容，但是翻过来覆过去又好像一直都是这些东西。但是这些内容又是常看常新，还是边复习就内容边学习新内容吧。如果时间合适的话，还是想最近一段时间学一学关于测试开发相关的东西。</p><p>加油，祝我面试顺利！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; 之类的控制语句来组织和</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>傻傻分不清之Cookie、Session、Tokenb和JWT</title>
    <link href="http://example.com/2024/10/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Tokenb%E5%92%8CJWT/"/>
    <id>http://example.com/2024/10/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Tokenb%E5%92%8CJWT/</id>
    <published>2024-10-21T13:08:06.000Z</published>
    <updated>2024-10-21T13:10:21.507Z</updated>
    
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Go语言创世纪</title>
    <link href="http://example.com/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
    <id>http://example.com/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/</id>
    <published>2024-10-19T07:02:08.000Z</published>
    <updated>2024-10-21T13:09:47.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>到今天，笔者学习 Go 语言也差不多有一年了，好像都没有认真地了解过 Go 语言的前世今生以及为什么要学习 Go 语言。不如趁着这个机会，好好地了解一下 Go 语言的特点吧。</p><p>本部分分为全书的开篇，在本部分中，笔者将和读者一起穿越时空，回顾历史，详细了解 Go 语言的诞生、演进以及今天的发展，归纳总结 Go 语言的设计哲学；和读者一起站在语言设计者的高度去理解 Go 语言与众不同的设计，深刻体会 Go 设计者在那些看似陈旧、实则经过深思熟虑的设计上的付出。</p><p>希望经过本部分的学习，读者能够在更改层次上与 Go 语言的设计者形成共鸣，产生认同感。或许这种认同会在你后续的 Go 语言的学习和精进之路持续激发你的 Go 语言学习和精进之路上持续激发你的热情，帮助你快速领悟Go语言原生编程思维，并更快、更好地达成编写出高质量 Go 代码的目标。</p><p>或者你可以在阅读本文时先想一想下面三个问题：</p><ol><li>为什么会出现 Go 语言？</li><li>Go 语言的设计哲学是什么？</li><li>Go 语言与 C++、Java 有什么区别？特性是什么？</li></ol><h1 id="Go-语言的出现和发展"><a href="#Go-语言的出现和发展" class="headerlink" title="Go 语言的出现和发展"></a>Go 语言的出现和发展</h1><p>Go语言诞生于何时？它的最初设计者是谁？它为什么被命名为Go？它的设计目标是什么？它如今发展得怎么样？带着这些问题，我们一起穿越时空，回到2007年9月Go语言诞生的那一历史时刻吧。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Go 语言（也称为 Golang）是一种由 Google 开发的开源编程语言。</p><p>过去，许多开发者在使用 C++ 来开发大型的服务端软件时，由于二进制文件一般都非常大，需要耗费大量的时间在编译文件上，同时编程语言的设计思想也已经非常陈旧，这些情况都充分表明了现有的编程语言已不符合时下的生产环境。</p><p>学者们坐下来总结出了现在生产环境与软件开发之间的主要矛盾，并尝试设计一门全新的编程语言来解决这些问题。他们讨论得出的对编程语言的设计要求：</p><ul><li>能够以更快的速度开发软件</li><li>开发出的软件能够很好地在现代的多核计算机上工作</li><li>开发出的软件能够很好地在网络环境下工作</li><li>使人们能够享受软件开发的过程</li></ul><p>Go 语言就在这样的环境下诞生了，它的主要目标是“兼具 Python 等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性”。</p><p>Go 语言出现的目的是在编程领域中创造出最实用的方式来进行软件开发。它并不是要用奇怪的语法或晦涩难懂的概念来从根本上推翻已有的编程语言，而是重建并改善了 C、C#、Java 中的许多语法风格。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Go 语言的起源可以追溯到 2007 年。</p><p>在 2007 年的时候，谷歌开发工作的规模与正在部署的生产系统规模暴增，需要有个好的解决方案应对这些挑战。</p><p>当时 Robert Griesemer、Rob Pike 和 Ken Thompson 都是用的 C++，编译一个分布式集群大概要花费 45 分钟，这个过程让三个人都很难以忍受。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhCkP.jpg" alt="XKCD 中的一幅漫画"></p><p>2007 年 9 月 20 日星期四下午，在等待编译的时候 Rob Pike 把 Robert Griesemer 和 Ken Thompson 喊到一起决定要做些什么：<strong>他们不想永远使用 C++，并且想要很好处理并发的问题</strong>。希望创造一个能够摒弃其他语言的缺点的新语言，保持静态类型和运行时效率、具有可读性和可用性、具备高性能网络和并发处理。</p><p>Go 这个名字是 Rob Pike 取的，认为它很短、易于输入，非常合适这一新语言的特性。</p><p>最初的一周内，他们就讨论出来了很多 Go 语言的风格和特性，并着手开发。</p><p>经过两年的努力，于 2009 年 11 月，Google 宣布了 Go 语言的首个公开发布版本，即 Go 1。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhmzP.png" alt="Robert Griesemer、Rob Pike 、Ken Thompson（2012年，Google I/O大会）"></p><blockquote><p>顶级初创团队：</p><p>① Robert Griesemer，参与开发 Java HotSpot 虚拟机，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 JavaScript 引擎的代码生成部分。</p><p>② Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言。</p><p>③ Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。</p></blockquote><p>随着更多有才华的程序员加入到 Go 开发团队中，更多贡献者开始为 Go 语言项目添砖加瓦。使得 Go 在发布的当年就成为了著名编程语言排行榜 TIOBE 的年度最佳编程语言。</p><p>Go 发布后就吸引了一些公司，尤其是云计算领域的初创公司成为了 Go 语言的早期接纳者。在经过若干年的磨合后，在这些公司中诞生了不乏像 Docker（容器引擎）、Kubernetes（云原生事实标准平台）、Ethereum（区块链公链以太坊）等“杀手级”或示范性项目，这些项目也让 Go 被誉为<code>云计算基础设施新兴语言</code>或直接称为<code>云计算语言</code>。</p><p>Go 在近些年云原生领域的广泛应用也让其跻身云原生时代的头部编程语言。</p><h2 id="Logo-的诞生"><a href="#Logo-的诞生" class="headerlink" title="Logo 的诞生"></a>Logo 的诞生</h2><p>在 Go 立项的时候，Rob Pike 的妻子 Renee French（著名美国插画师、漫画家和作家，以其独特的风格和奇特的创意而闻名）就帮他们画了一个标志，然后这个图标就出现在 Google Code 网站和第一件 Go T 恤上，该 Logo 被用来体现 Go 的速度：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhIqQ.png" alt="04"></p><p>2009 年 11 月 10 日 Go 准备开源发布的之前，Rob Pike 的妻子建议，将她在 1999 年左右为新泽西州 WFMU 广播电台年度筹款活动设计的，作为宣传的形象，改编成为 Go 的吉祥物 ——— Gopher（地鼠）：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhMaf.png" alt="big gopher"></p><p>发错了，是这个 ~(～￣▽￣)～：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7KhfMc.png" alt="06"></p><p>之后，Rob Pike 的妻子又绘制了更多的 Go gopher 形象，代表着 Go 项目和各地的 Go 程序员。这些可爱的形象成为 Go 世界中最受欢迎的事物之一，被世界各地的 Go 程序员广泛使用：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7Kh0H6.png" alt="Go Gopher"></p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p><a href="https://go.dev/doc/devel/release">Go 语言发展历程</a></p><ol><li><p>初期版本（2009 年 - 2012 年）：</p><p>初期版本的 Go 语言主要集中于提供简洁、高效的编程体验，以及强大的并发支持。这些特性使其成为了云服务、网络应用和大规模分布式系统开发的理想选择。</p></li><li><p>Go 1 发布（2012 年）：</p><p>Go 1 是 Go 语言的首个稳定版本，也是第一个被广泛用于生产环境的版本。发布 Go 1 的目标是提供稳定的 API 和 ABI，以便未来版本的兼容性。</p></li><li><p>生态系统的发展（2012 年 - 至今）：</p><p>随着 Go 语言的发展，其生态系统也在不断壮大。包括标准库、第三方库、框架以及工具链在内的生态系统都得到了极大的丰富和改进，使得 Go 语言更加适用于各种类型的应用开发。</p></li><li><p>Go 语言在工业界的应用（2010 年至今）：</p><p>自从 Go 语言发布以来，越来越多的公司和组织开始采用 Go 语言进行开发。一些知名的公司，如 Google、Uber、Dropbox、Docker、Cloudflare、MongoDB 等，都在生产环境中使用 Go 语言开发核心系统。</p></li><li><p>版本更新和改进（2012 年至今）：</p><p>Go 语言的开发团队持续不断地发布新的版本，以改进语言的性能、稳定性和功能。Go 社区也积极参与到语言的发展中，提出改进建议、修复 bug，并贡献各种开源项目。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7Khs33.png" alt="TIOBE 指数中的 Go 语言发展曲线"></p><h1 id="Go-语言的特性"><a href="#Go-语言的特性" class="headerlink" title="Go 语言的特性"></a>Go 语言的特性</h1><ol><li><p>简单易学</p><p>Go 语言的语法设计简洁明了，摒弃了一些繁琐的特性和语法元素，使得代码更易于阅读和维护。这使得 Go 语言成为一门学习曲线较为平缓的编程语言，即使是没有编程经验的人也能相对轻松地上手。</p></li><li><p>高性能并发</p><p>Go 语言天生支持并发编程，通过 goroutine 和 channel 机制，使得并发编程变得非常简单。</p><p>传统编程语言（如 C、C++ 等）的并发实现，实际上就是基于操作系统调度的，即程序负责创建线程（一般通过 pthread 等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂与难于扩展。</p><p>为了解决这些问题，Go 果断放弃了传统的基于操作系统线程的并发模型，而采用了<code>用户层轻量级线程</code>或者说是<code>类协程(coroutine)</code>，Go 将之称为 goroutine。</p><p>goroutine 占用的资源非常少，Go 语言运行时默认为每个 goroutine 分配的栈空间仅 2KB，会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处理器绑定到一个操作系统线程上。这让用户的应用程序执行效率更高，而开发工作量显著减少。</p><p>goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个 Go 程序中可以创建成千上万个并发的 goroutine。所有的 Go 代码都在 goroutine 中执行，哪怕是 Go 的运行时代码也不例外。</p><p>而 channel（通道）则提供了不同 goroutine 之间的通信和同步机制，使得编写并发代码变得直观而安全，可以帮助用户避免在其他语言里常见的共享内存访问的问题。</p></li><li><p>快速编译</p><p>Go 语言的编译速度非常快，这得益于先进的编译器和优化器。快速的编译速度可以大大提高开发效率，特别是在大型项目中。</p></li><li><p>内存管理</p><p>Go 语言拥有自动内存管理功能，也就是垃圾回收机制。这意味着开发者不需要手动管理内存分配和回收，大大减轻了编程的负担，同时也有助于防止内存泄露。</p></li><li><p>静态类型语言</p><p>Go 语言是一门静态类型的编程语言，这意味着在编译期间就能捕获到一些类型相关的错误。静态类型检查有助于提前发现潜在的 Bug，减少在运行时可能出现的错误。</p></li><li><p>跨平台支持</p><p>Go 语言的编译器可以在多种平台上运行，可以轻松地将 Go 程序编译成适用于不同操作系统和硬件架构的可执行文件。这使得 Go 语言成为跨平台开发的理想选择。</p></li><li><p>强调并遵循软件工程原则</p><p>Go 语言鼓励开发者编写清晰、简洁、可维护的代码。它有一套明确的代码风格规范，并自带了一些工具来帮助开发者保持一致的代码风格。</p></li><li><p>丰富的标准库</p><p>Go 语言附带了丰富而强大的标准库，覆盖了网络、文件处理、加密、并发等方面。开发者可以直接使用标准库提供的功能，而无需引入大量的第三方库。</p></li><li><p>工具链</p><p>完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。</p><p>内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器。</p><p>除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。</p></li><li><p>文档资源</p><p>Go 语言拥有丰富的官方文档资源，包括语言规范、标准库文档、命令行工具说明等。此外，Go 语言社区中也有许多优秀的教程、博客和论坛，为开发者提供了学习和交流的平台。</p></li></ol><h2 id="性能测评"><a href="#性能测评" class="headerlink" title="性能测评"></a>性能测评</h2><p>以下是 Go 语言与其他编程语言的对比测试数据（源于网络资料）：</p><ul><li>在相同的环境和执行目标的情况下，Go 程序比 Java 或 Scala 应用程序要快上 2 倍，并比这两门语言使用少占用 70% 的内存，执行效率大约比 C++ 慢 20%；</li><li>Go 的编译速度要比绝大多数语言都要快，比 Java 和 C++ 快 5 至 6 倍，比 Scala 快 10 倍；</li><li>Go 语言通过垃圾回收器自动管理内存，这在某些情况下可能会引入一些运行时开销。相比之下，C/C++ 需要手动管理内存，这可能会导致内存泄漏和悬挂指针等问题；</li><li>Go 和 Python 在一般开发的平均水平测试中，Go 要比 Python 3 快 25 倍左右，少占用三分之二的内存，但比 Python 大概多写一倍的代码，毫无疑问，开发效率上，Python 是要技高一筹的；</li><li>比较 Go 和 Python 在简单的 web 服务器方面的性能，单位为传输量每秒：<br>原生的 Go net/http 包要比 web.py 快 7 至 8 倍，如果使用 web.go 框架则稍微差点，比 web.py 快 6 至 7 倍。如果是使用Python 中的 tornado 异步服务器和框架开发出的Web应用，那么要比传统的 web.py 快很多，此时，Go 大概只比它快 1.2 至 1.5 倍，Go 在 Web 开发的领域比 Python 要快，但目前来看，并非碾压态势。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241021192031073.png" alt="image-20241021192031073"></p><h2 id="业务方向"><a href="#业务方向" class="headerlink" title="业务方向"></a>业务方向</h2><ol><li><p>网络编程：</p><p>Go 语言原生支持高效的并发编程，因此非常适合用于构建网络应用程序和分布式系统。</p></li><li><p>大数据处理：</p><p>Go 语言具有高效的执行性能和并发处理能力，因此很适合用于处理大量数据。</p></li><li><p>云原生开发：</p><p>随着云原生应用的兴起，Go 语言也成为云原生开发的热门选择。Go 的快速启动时间、小内存占用和高并发性能使其非常适合在云环境中构建轻量级容器化应用和无服务器函数。</p></li><li><p>微服务：</p><p>Go 语言对于构建微服务和 API 很有优势，因为它的代码结构简单，易于维护，同时具有高效和高并发特性</p></li><li><p>数据库和存储系统：</p><p>Go 语言提供了丰富的数据库和存储库，包括 SQL 数据库（如 MySQL、PostgreSQL）、NoSQL 数据库（如 MongoDB、Redis）以及分布式存储系统（如 etcd）。这使得 Go 成为开发高性能、可扩展和可靠的数据存储解决方案的理想语言。</p></li><li><p>Web 开发：</p><p>Go 语言拥有轻量级的 HTTP 服务器，使其成为构建高性能 Web 应用程序的理想选择。它支持快速开发和部署，并且具有良好的性能和可靠性。很多人使用 Golang 是因为它非常快，而且它可以用来并行运行进程，这样他们就不必互相等待。</p><p>它内置了对并发的支持，并促进了单个进程中线程和处理器之间的并行性。这可以使你的网站更容易快速加载并为你提供最佳的用户体验。</p></li><li><p>区块链开发：</p><p>Go 语言在区块链开发领域也得到了广泛应用。许多知名的区块链项目（如 Ethereum）使用 Go 语言作为其主要开发语言，因为 Go 具有高效的并发能力和良好的性能，适合处理区块链交易和智能合约。</p></li></ol><h1 id="Go-语言的设计哲学"><a href="#Go-语言的设计哲学" class="headerlink" title="Go 语言的设计哲学"></a>Go 语言的设计哲学</h1><p>从Go语言诞生的那一刻起至今已经有十多年了，Go语言的魅力使得其在世界范围内拥有百万级的拥趸。那么究竟是什么让大量的开发人员开始学习Go语言或从其他语言转向Go语言呢？笔者认为，Go语言的魅力就来自Go语言的设计哲学。</p><p>关于Go语言的设计哲学，Go语言之父们以及Go开发团队并没有给出明确的官方说法。在这里笔者将根据自己对他们以及Go社区主流观点和代码行为的整理、分析和总结，列出4条Go语言的设计哲学。理解这些设计哲学将对读者形成Go原生编程思维、编写高质量Go代码起到积极的作用。</p><h2 id="追求简单，少即是多"><a href="#追求简单，少即是多" class="headerlink" title="追求简单，少即是多"></a>追求简单，少即是多</h2><blockquote><p>简单是一种伟大的美德，但我们需要更艰苦地努力才能实现它，并需要经过一个教育的过程才能去欣赏和领会它。但糟糕的是：复杂的东西似乎更有市场。——Edsger Dijkstra，图灵奖得主</p></blockquote><p>当我们问Gopher“你为什么喜欢Go语言”时，我们通常会得到很多答案，如图所示。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20241021192857836.png" alt="image-20241021192857836"></p><p>但在我们得到的众多答案中，排名靠前而又占据多数的总是“简单”（Simplicity）。</p><p>不同于那些通过相互借鉴而不断增加新特性的主流编程语言（如C++、Java等），Go的设计者们在语言设计之初就拒绝走语言特性融合的道路，而选择了“做减法”，选择了“简单”，他们把复杂性留给了语言自身的设计和实现，留给了Go核心开发组自己，而将简单、易用和清晰留给了广大Gopher。因此，今天呈现在我们眼前的是这样的Go语言：</p><ul><li>简洁、常规的语法（不需要解析符号表），它仅有25个关键字；</li><li>内置垃圾收集，降低开发人员内存管理的心智负担；</li><li>没有头文件；</li><li>显式依赖（package）；</li><li>没有循环依赖（package）；</li><li>常量只是数字；</li><li>首字母大小写决定可见性；</li><li>任何类型都可以拥有方法（没有类）；</li><li>没有子类型继承（没有子类）；</li><li>没有算术转换；</li><li>接口是隐式的（无须implements声明）；</li><li>方法就是函数；</li><li>接口只是方法集合（没有数据）；</li><li>方法仅按名称匹配（不是按类型）；</li><li>没有构造函数或析构函数；</li><li>n++和n—是语句，而不是表达式；</li><li>没有++n和—n；</li><li>赋值不是表达式；</li><li>在赋值和函数调用中定义的求值顺序（无“序列点”概念）；</li><li>没有指针算术；</li><li>内存总是初始化为零值；</li><li>没有类型注解语法（如C++中的const、static等）；</li><li>没有模板/泛型；</li><li>没有异常（exception）；</li><li>内置字符串、切片（slice）、map类型；</li><li>内置数组边界检查；</li><li>内置并发支持；</li><li>……</li></ul><p>任何设计都存在权衡与折中。Go 设计者选择的“简单”体现在，站在巨人肩膀上去除或优化在以往语言中已被证明体验不好或难于驾驭的语法元素和语言机制，并提出自己的一些创新性的设计，比如首字母大小写决定可见性，内存分配初始零值，内置以 go 关键字实现的并发支持等）。Go 设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担。</p><p>正如 Go 语言之父 Rob Pike 所说：“Go 语言实际上是复杂的，但只是让大家感觉很简单。”这句话背后的深意就是“简单”选择的背后是 Go语言自身实现层面的复杂性，而这种复杂性被 Go 语言的设计者“隐藏”起来了。比如并发是复杂的，但我们通过一个简单的关键字“go”就可以实现。这种简单其实是 Go 开发团队缜密设计和持续付出的结果。</p><p>此外，Go 的简单哲学还体现在 Go 1兼容性的提出。对于面对工程问题解决的开发人员来说，Go 1大大降低了工程层面语言版本升级所带来的消耗，让 Go 的工程实践变得格外简单。</p><p>从 Go 1.0 发布起至今，Go 1 的兼容性得到很好的保障，当初使用 Go 1.4 编写的代码如今也可以顺利通过最新的 Go 1.16 版本的编译并正常运行起来。正如前面引用的图灵奖得主 Edsger Dijkstra 的名言，这种创新性的简单设计并不是一开始就能得到程序员的理解的，但在真正使用Go之后，这种身处设计哲学层面的简单便延伸到Go语言编程应用的方方面面，持续影响着Go语言编程思维。</p><p>在Go演化进入关键阶段（走向Go 2）的今天，有人向Go开发团队提出过这样一个问题：Go后续演化的最大难点是什么？Go开发团队的一名核心成员回答道：“<strong>最大的难点是如何继续保持Go语言的简单。</strong>”</p><h2 id="偏好组合，正交解耦"><a href="#偏好组合，正交解耦" class="headerlink" title="偏好组合，正交解耦"></a>偏好组合，正交解耦</h2><blockquote><p>当我们有必要采用另一种方式处理数据时，我们应该有一些耦合程序的方式，就像花园里将浇水的软管通过预置的螺丝扣拧入另一段那样，这也是Unix IO采用的方式。——Douglas McIlroy，Unix管道的发明者（1964）</p></blockquote><p>C++、Java等主流面向对象（以下简称OO）语言通过庞大的自上而下的类型体系、继承、显式接口实现等机制将程序的各个部分耦合起来，但在Go语言中我们找不到经典OO的语法元素、类型体系和继承机制，或者说Go语言本质上就不属于经典OO语言范畴。针对这种情况，很多人会问：那Go语言是如何将程序的各个部分有机地耦合在一起的呢？就像上面引述的Douglas McIlroy那句话中的浇水软管那样，<strong>Go语言遵从的设计哲学也是组合</strong>。</p><p>在<strong>语言设计层面</strong>，Go提供了正交的语法元素供后续组合使用，包括：</p><ul><li>Go语言无类型体系（type hierarchy），类型之间是独立的，没有子类型的概念；</li><li>每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；</li><li>接口（interface）与其实现之间隐式关联；</li><li>包（package）之间是相对独立的，没有子包的概念。</li></ul><p>我们看到无论是包、接口还是一个个具体的类型定义（包括类型的方法集合），Go语言为我们呈现了这样一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。现在摆在面前的工作就是以最适当的方式在这些孤岛之间建立关联（耦合），形成一个整体。<strong>Go采用了组合的方式，也是唯一的方式。</strong></p><p>Go语言提供的最为直观的组合的语法元素是<strong>类型嵌入（typeembedding）</strong>。通过类型嵌入，我们可以将已经实现的功能嵌入新类型中，以快速满足新类型的功能需求。这种方式有些类似经典 OO语言中的继承机制，但在原理上与其完全不同，这是一种Go设计者们精心设计的语法糖。<strong>被嵌入的类型和新类型之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典OO语言中的那种父类、子类的关系以及向上、向下转型（type casting）。</strong>在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为<strong>“垂直组合”</strong>，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。</p><p>通过在interface的定义中嵌入interface类型来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为Go语言的一种惯用法。</p><p><strong>interface 是 Go 语言中真正的“魔法”</strong>，是 Go 语言的一个创新设计，它只是方法集合，且与实现者之间的关系是隐式的，它让程序各个部分之间的耦合降至最低，同时是连接程序各个部分的“纽带”。隐式的 interface 实现会不经意间满足依赖抽象、里氏替换、接口隔离等设计原则，这在其他语言中是需要很刻意的设计谋划才能实现的，但在 Go interface 看来，一切却是自然而然的。通过 interface 将程序各个部分组合在一起的方法，笔者称之为“水平组合”。水平组合的模式有很多，一种常见的方法是通过接受 interface 类型参数的普通函数进行组合。</p><p>此外，Go 语言内置的并发能力也可以通过组合的方式实现对计算能力的串联，比如通过 <code>goroutine+channel</code> 的组合实现类似Unix Pipe的能力。</p><p>综上，组合原则的应用塑造了 Go 程序的骨架结构。类型嵌入为类型提供垂直扩展能力，interface 是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。组合也让遵循简单原则的 Go 语言在表现力上丝毫不逊色于复杂的主流编程语言。</p><h2 id="原生并发，轻量高效"><a href="#原生并发，轻量高效" class="headerlink" title="原生并发，轻量高效"></a>原生并发，轻量高效</h2><blockquote><p>并发是有关结构的，而并行是有关执行的。——Rob Pike（2012）</p></blockquote><p>将时钟回拨到 2007年，那时 Go语言的三位设计者 Rob Pike、Robert Griesemer 和 Ken Thompson 都在 Google 使用 C++ 语言编写服务端代码。当时 C++ 标准委员会正在讨论下一个 C++ 标准（C++0x，也就是后来的 C++11 标准），委员会在标准草案中继续增加大量语言特性的行为让 Go 的三位设计者十分不满，尤其是带有原子类型的新 C++ 内存模型，给本已负担过重的 C++ 类型系统又增加了额外负担。三位设计者认为 C++ 标准委员会在思路上是短视的，因为硬件很可能在未来十年内发生重大变化，将语言与当时的硬件紧密耦合起来是十分不明智的，是没法给开发人员在编写大规模并发程序时带去太多帮助的。</p><p>多年来，处理器生产厂商一直遵循着摩尔定律，在提高时钟频率这条跑道上竞争，各行业对计算能力的需求推动了处理器处理能力的提高。CPU 的功耗和节能问题成为人们越来越关注的焦点。CPU 仅靠提高主频来改进性能的做法遇到了瓶颈。主频提高导致CPU的功耗和发热量剧增，反过来制约了 CPU 性能的进一步提高。依靠主频的提高已无法实现性能提升，人们开始把研究重点转向把多个执行内核放进一个处理器，让每个内核在较低的频率下工作来降低功耗同时提高性能。2007年处理器领域已开始进入一个全新的多核时代，处理器厂商的竞争焦点从主频转向了多核，多核设计也为摩尔定律带来新的生命力。与传统的单核CPU相比，多核CPU带来了更强的并行处理能力、更高的计算密度和更低的时钟频率，并大大减少了散热和功耗。Go 的设计者敏锐地把握了 CPU 向多核方向发展的这一趋势，在决定不再使用C++而去创建一门新语言的时候，果断将面向多核、原生内置并发支持作为新语言的设计原则之一。</p><p>Go语言原生支持并发的设计哲学体现在以下几点。</p><ol><li><p>Go 语言采用轻量级协程并发模型，使用 Go 应用在面向多核硬件时更具可拓展性</p><p>传统编程语言（如C、C++等）的并发实现实际上就是基于操作系统调度的，即程序负责创建线程（一般通过pthread等函数库调用实现），操作系统负责调度。这种传统支持并发的方式主要有两大不足：复杂和难于扩展。</p><p>复杂主要体现在以下方面：</p><ul><li>创建容易，退出难：使用C语言的开发人员都知道，创建一个线程时（比如利用pthread库）虽然参数也不少，但还可以接受。而一旦涉及线程的退出，就要考虑线程是不是分离的（detached）？是否需要父线程去通知并等待子线程退出（join）？是否需要在线程中设置取消点（cancel point）以保证进行join操作时能顺利退出？</li><li>并发单元间通信困难，易错：多个线程之间的通信虽然有多种机制可选，但用起来相当复杂；并且一旦涉及共享内存（shared memory），就会用到各种锁（lock），死锁便成为家常便饭。</li><li>线程栈大小的设定：是直接使用默认的，还是设置得大一些或小一些呢？</li></ul><p>难于拓展主要体现在以下方面：</p><ul><li>虽然线程的代价比进程小了很多，但我们依然不能大量创建线程，因为不仅每个线程占用的资源不小，操作系统调度切换线程的代价也不小。</li><li>对于很多网络服务程序，由于不能大量创建线程，就要在少量线程里做网络的多路复用，即使用epoll/kqueue/IoCompletionPort 这套机制。即便有了libevent、libev这样的第三方库的帮忙，写起这样的程序也是很不容易的，存在大量回调（callback），会给程序员带来不小的心智负担。</li></ul><p>为了解决这些问题，Go果断放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程或者说是类协程（coroutine），Go将之称为 goroutine。goroutine 占用的资源非常少，Go运行时默认为每个 goroutine 分配的栈空间仅2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，在一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在 goroutine 中执行，哪怕是 Go 的运行时代码也不例外。</p><p>不过，一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现 Go 程序内 goroutine 之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些 goroutine 按照一定算法放到 CPU 上执行的程序就称为 goroutine 调度器（goroutine scheduler）。关于 goroutine 调度的原理，我们将在后面详细说明，这里就不赘述了。</p></li><li><p>Go 语言为开发者提供的支持并发的语法元素和机制</p><p>我们先来看看那些设计并诞生于单核年代的编程语言（如C、C++、Java）在语法元素和机制层面是如何支持并发的。</p><ul><li>执行单元：线程</li><li>创建和销毁的方式：调用库函数或调用对象方法</li><li>并发线程间的通信：多基于操作系统提供的 IPC机制（进程间通信），比如共享内存、Socket、Pipe等，当然也会使用有并发保护的全局变量。</li></ul><p>与上述传统语言相比，Go提供了语言层面内置的并发语法元素和机制。</p><ul><li>执行单元：goroutine</li><li>创建和销毁的方式：go+函数调用；函数退出即 goroutine 退出</li><li>并发线程间的通信：通过语言内置的channel传递消息或实现同步，并通过select实现多路channel的并发控制。</li></ul><p>对比来看，Go对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。</p></li><li><p>并发原则对 Go 开发者在程序结构设计层面的影响</p><p>由于 goroutine 的开销很小（相对线程），Go官方鼓励大家使用 goroutine 来充分利用多核资源。但并不是有了 goroutine 就一定能充分利用多核资源，或者说即便使用 Go 也不一定能写出好的并发程序。</p><p>为此Rob Pike曾做过一次关于“并发不是并行”的主题分享，图文并茂地讲解了并发（Concurrency）和并行（Parallelism）的区别。Rob Pike认为：</p><ul><li>并发是有关结构的，它是一种将一个程序分解成多个小片段并且每个小片段都可以独立执行的程序设计方法；并发程序的小片段之间一般存在通信联系并且通过通信相互协作。</li><li>并行是有关执行的，它表示同时进行一些计算任务。</li></ul><p>采用并发方案设计的程序在单核处理器上也是可以正常运行的（在单核上的处理性能可能不如非并发方案），并且随着处理器核数的增多，并发方案可以自然地提高处理性能，提升吞吐量。而非并发方案在处理器核数提升后，也仅能使用其中的一个核，无法自然扩展，这一切都是程序的结构所决定的。这告诉我们：<strong>并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。</strong></p></li></ol><p>除此之外，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计层面对程序进行拆解组合，再映射到程序执行层面：goroutine 各自执行特定的工作，通过 channel+select 将 goroutine 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go语言更适应现代计算环境。</p><h2 id="面向工程，自带电池"><a href="#面向工程，自带电池" class="headerlink" title="面向工程，自带电池"></a>面向工程，自带电池</h2><blockquote><p>软件工程指引着Go语言的设计。——Rob Pike（2012）</p></blockquote><p>要想理解这条设计哲学，我们依然需要回到三位Go语言之父在设计Go语言时的初衷：<strong>面向真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案</strong>。主要的问题包括：</p><ul><li>程序构建慢；</li><li>失控的依赖管理；</li><li>开发人员使用编程语言的不同子集（比如C++支持多范式，这样有些人用OO，有些人用泛型）；</li><li>代码可理解性差（代码可读性差、文档差等）；</li><li>功能重复实现；</li><li>升级更新消耗大；</li><li>实现自动化工具难度高；</li><li>版本问题；</li><li>跨语言构建问题。</li></ul><p>很多编程语言的设计者或拥趸认为这些问题并不是编程语言应该解决的，但Go语言的设计者并不这么看，他们以更高、更广阔的视角审视软件开发领域尤其是大规模软件开发过程中遇到的各种问题，并在Go语言最初设计阶段就将解决工程问题作为Go的设计原则之一去考虑Go语法、工具链与标准库的设计，这也是Go与那些偏学院派、偏研究性编程语言在设计思路上的一个重大差异。</p><blockquote><p>Go语言取得阶段性成功后，这种思路开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴Go的一些设计，比如越来越多的语言认可统一代码风格的优越之处，并开始提供官方统一的fmt工具（如Rust的rustfmt），又如Go创新提出的最小版本选择（Minimal Version Selection，MVS）被其他语言的包依赖工具所支持（比如Rust的cargo支持MVS）。</p></blockquote><p>Go设计者将所有工程问题浓缩为一个词：<strong>scale</strong>（笔者总觉得将scale这个词翻译为任何中文词都无法传神地表达其含义，暂译为“规模”吧）。从Go1开始，Go的设计目标就是帮助开发者更容易、更高效地管理两类规模。</p><ul><li>生产规模：用Go构建的软件系统的并发规模，比如这类系统并发关注点的数量、处理数据的量级、同时并发与之交互的服务的数量等。</li><li>开发规模：包括开发团队的代码库的大小，参与开发、相互协作的工程师的人数等。</li></ul><p>Go设计者期望 Go 可以游刃有余地应对生产规模和开发规模变大带来的各种复杂问题。Go语言的演进方向是优化甚至消除 Go语言自身面对规模化问题时应对不好的地方，比如：Go 1.9引入类型别名（type alias）以应对大型代码仓库代码重构，Go 1.11引入go module机制以解决不完善的包依赖问题等。这种设计哲学的落地让 Go语言具有广泛的规模适应性：既可以被仅有5人的初创团队用于开发终端工具，也能够满足像Google这样的巨型公司大规模团队开发大规模网络服务程序的需要。</p><p>那么Go是如何解决工程领域规模化所带来的问题的呢？我们从语言、标准库和工具链三个方面来看一下。</p><ol><li><p>语言</p><p>语法是编程语言的用户接口，它直接影响开发人员对于一门语言的使用体验。Go语言是一门简单的语言，简单意味着可读性好，容易理解，容易上手，容易修复错误，节省开发者时间，提升开发者间的沟通效率。但作为面向工程的编程语言，光有简单的设计哲学还不够，每个语言设计细节还都要经过“工程规模化”的考验和打磨，需要在细节上进行充分的思考和讨论。</p><ul><li>从工程的安全性和可靠性角度考虑，选择使用大括号代码块结构；</li><li>重新设计编译单元和目标文件格式，实现Go源码快速构建，将大工程的构建时间缩短到接近于动态语言的交互式解释的编译时间；</li><li>不能导入没有使用过的包，否则程序将无法编译。这既可以充分保证Go程序的依赖树是精确的，也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间。</li><li>去除包的循环依赖。循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建速度。</li><li>在处理依赖关系时，有时会通过允许一部分重复代码来避免引入较多依赖关系。</li><li>包路径是唯一的，而包名不必是唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者对如何引用其内容的约定。包名不必是唯一的约定大大降低了开发人员给包起唯一名字的心智负担。</li><li>故意不支持默认函数参数。因为在规模工程中会导致函数拥有太多的参数，降低清晰度和可读性。</li><li>首字母大小写定义标识符可见性，这是Go的一个创新。它让开发人员通过名称即可知晓其可见性，而无须回到标识符定义的位置查找并确定其可见性，这提升了开发人员阅读代码的效率。</li><li>在语义层面，相对于C，Go做了很多改动，提升了语言的健壮性，比如去除指针算术，去除隐式类型转换等。</li><li>内置垃圾收集。这对于大型工程项目来说，大大降低了程序员在内存管理方面的负担，程序员使用GC感受到的好处超过了付出的成本，并且这些成本主要由语言实现者来承担。</li><li>内置并发支持，为网络软件带来了简单性，而简单又带来了健壮，这是大型工程软件开发所需要的。增加类型别名，支持大规模代码库的重构。</li></ul></li><li><p>标准库</p><p>Go被称为“自带电池”（battery-included）的编程语言。“自带电池”原指购买了电子设备后，在包装盒中包含了电池，电子设备可以开箱即用，无须再单独购买电池。如果说一门编程语言“自带电池”，则说明这门语言标准库功能丰富，多数功能无须依赖第三方包或库，Go语言恰是这类编程语言。</p><p>由于诞生年代较晚，且目标较为明确，Go在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto/xx、encoding/xx等包充分迎合了云原生时代关于API/RPC Web服务的构建需求。Go开发者可以直接基于这些包实现满足生产要求的API服务，从而减轻对第三方包或库的依赖，降低工程代码依赖管理的复杂性，也降低开发人员学习第三方库的心智负担。</p><p>仅使用标准库来构建系统，这对于开发人员是很有吸引力的。在很多关于选用何种Go Web开发框架的调查中，选择标准库的依然占大多数，这也是Go社区显著区别于其他编程语言社区的一点。</p><p>Go语言目前在GUI、机器学习（Machine Learning）等开发领域占有的份额较低，这很可能与Go标准库没有内置这类包有关。</p></li><li><p>工具链</p><p>开发人员在做工程的过程中需要使用工具。而Go语言提供了十分全面、贴心的编程语言官方工具链，涵盖了编译、编辑、依赖获取、调试、测试、文档、性能剖析等的方方面面。</p><ul><li>构建和运行：go build/go run</li><li>依赖包查看与获取：go list/go get/go mod xx</li><li>编辑辅助格式化：go fmt/gofmt</li><li>文档查看：go doc/godoc</li><li>单元测试/基准测试/测试覆盖率：go test</li><li>代码静态分析：go vet</li><li>性能剖析与跟踪结果查看：go tool pprof/go tool trace</li><li>升级到新Go版本API的辅助工具：go tool fix</li><li>报告Go语言bug：go bug</li></ul><p>值得重点提及的是 gofmt 统一了 Go语言的编码风格，在其他语言开发者还在为代码风格争论不休的时候，Go开发者可以更加专注于领域业务。同时，相同的代码风格让以往困扰开发者的代码阅读、理解和评审工作变得容易了很多，至少Go开发者再也不会有那种因代码风格的不同而产生的陌生感。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这里做一个简单的总结：</p><p>简单是Go语言贯穿语言设计和应用的主旨设计哲学。德国建筑大师路德维希·密斯·凡德罗将“少即是多”这一哲学理念应用到建筑设计当中后取得了非凡的成功，而Go语言则是这一哲学在编程语言领域为数不多的践行者。“少”绝不是目的，“多”才是其内涵。Go在语言层面的简单让Go收获了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。</p><p>“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。Go在语言设计层面也将这一准则发挥到极致。Go崇尚通过组合的方式将正交的语法元素组织在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。</p><p>不同于C、C++、Java等诞生于20世纪后段的面向单机的编语言，<strong>Go语言是面向未来的</strong>。Go设计者对硬件发展趋势做出了敏锐且准确的判断——多核时代是未来主流趋势，于是将并发作为语言的“一等公民”，提供了内置于语言中的简单并发原语——go（goroutine）、channel 和 select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。Go 生来就肩负着解决面向软件工程领域问题的使命，我们看到的开箱即用的标准库、语言自带原生工具链以及开放的工具链生态的建立都是这一使命落地的结果，Go在面向工程领域的探索也引领着编程语言未来发展的潮流。</p><p>这篇博客是本系列博客的第一篇，主要内容来自于《Go 语言精进之路》一书中，希望通过阅读完上面的内容，让你我对 Go 语言有一个更加清晰的认知。在这里跟大家分享一下 Go语言之父的一些忠告。</p><blockquote><p>Rob Pike 今年已经 68 岁了，大部分时候在澳大利亚生活，现在居住在悉尼新南威尔士州。</p><p>在最近的一次采访中，他总结了自己 40 多年开发经验说：<code>避免倦怠的最好方法是在支持你的环境中做你真正喜欢的事情</code>。他认为自己是幸运的，在贝尔实验室和谷歌都是如此。</p><p>同时他也提醒我们：<code>如果对工作感到压力，应该随时休息或者改变方向</code>。</p></blockquote><p>希望每一个人都能找到自己喜欢做的事情！！！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/ikdl/p/18167778">【Go 语言入门专栏】Go语言的起源与发展</a></p><p><a href="https://weread.qq.com/web/reader/f343248072895ed9f34f408#outline?noScroll=1">Go 语言精进之路：从新手到高手的编程思想、方法和技巧1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;到今天，笔者学习 Go 语言也差不多有一年了，好像都没有认真地了解过 Go 语言的前世今生以及为什么要学习 Go 语言。不如趁着这个机会，好</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Go语言》</title>
    <link href="http://example.com/2024/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E3%80%8B/"/>
    <id>http://example.com/2024/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E3%80%8B/</id>
    <published>2024-10-19T06:34:30.000Z</published>
    <updated>2024-10-23T14:45:26.864Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，断更是因为找到了实习工作确实很忙，还有就是实在不知道要学什么了。好像进入了一种非常迷茫的状态，不过在经过几次新的面试之后，我发现现在自己对 Go 语言的理解还是局限在八股文中。最近也是看了好多关于 Go 语言底层原理的书，觉得可以整合一下，虽然之前也做过类似的整理，但是现在看来有点乱七八糟的，还是重新再来一遍吧。</p><p>所以，这是秋招特辑——《深入理解 Go 语言》，这个系列的博客不再仅仅是解释几个问题或者总结面试的时候常问的问题了，我对这个系列的博客的期望是能够真正的从浅到深地学习和理解Go语言。</p><p>整个系列分为三个部分——基础、并发和内存管理，每一部分会分别从使用方法和场景、实现原理、使用陷阱、历史发展和拓展五个部分来写。下面是目录链接：</p><ol><li>基础篇<ul><li><a href="https://zxh3032.github.io/2024/10/19/Go%E8%AF%AD%E8%A8%80%E5%88%9B%E4%B8%96%E7%BA%AA/">Go 语言创世纪</a></li><li>程序结构</li><li>基础数据结构</li><li>复合数据结构<ul><li>顺序存储两兄弟——数组和切片，到底有什么区别？</li><li>特殊的存在——只读的string</li><li>查询效率最高的数据结构——map</li><li>变量的合租公寓——结构体</li></ul></li><li>接口</li><li>函数</li><li>方法</li><li>反射</li><li>指针</li><li>defer 延迟调用</li></ul></li><li><p>错误处理</p><ul><li>panic 和 recover</li></ul></li><li><p>并发篇</p><ul><li>Goroutine 和 channel</li></ul></li><li>内存管理篇<ul><li>内存分配</li><li>垃圾回收</li></ul></li></ol><p>参考资料来源：</p><ol><li><p>书籍</p><ul><li><p>《Go 语言专家编程》</p></li><li><p>《Go 语言设计与实现》</p></li><li><p>《深入理解 Go 语言》</p></li><li><p>《Go 程序员面试笔试宝典》</p></li><li><p>《深入理解 Go 并发编程：从原理到实践，看这本就够了》</p></li></ul></li><li><p>AI</p><ul><li>豆包</li><li>ChatGPT</li></ul></li><li><p>博客</p><ul><li><a href="https://www.cnblogs.com/ikdl/p/18167778">【Go 语言入门专栏】Go语言的起源与发展</a></li></ul></li></ol><p>如果在写的过程中发现这么学习的效率不错的话，后面也会更新一些关于计算机网络、操作系统、MySQL、Redis 的相关内容，也会写一些关于面试和项目设计的东西。</p><p>《秋招特辑》系列博客只是用于帮助笔者学习和记忆知识点的内容，如果恰好你也在找工作，希望能够帮到你。希望大家都能找到一份好工作！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有更新博客了，断更是因为找到了实习工作确实很忙，还有就是实在不知道要学什么了。好像进入了一种非常迷茫的状态，不过在经过几次新的面试之后，我发现现在自己对 Go 语言的理解还是局限在八股文中。最近也是看了好多关于 Go 语言底层原理的书，觉得可以整合一下，虽然之前也做过</summary>
      
    
    
    
    <category term="秋招特辑" scheme="http://example.com/categories/%E7%A7%8B%E6%8B%9B%E7%89%B9%E8%BE%91/"/>
    
    
    <category term="求职必备" scheme="http://example.com/tags/%E6%B1%82%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    
    <category term="深入理解Go语言" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>gRPC入门</title>
    <link href="http://example.com/2024/07/05/gRPC%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2024/07/05/gRPC%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-05T13:12:05.000Z</published>
    <updated>2024-07-05T14:11:25.492Z</updated>
    
    <content type="html"><![CDATA[<p>RPC 和 gRPC 其实是笔者在几个月前就开始接触的东西，但是由于当时在 Windows 上配不好环境加上学起来确实有点难度，所以就放下没去做项目，就简单地了解了一下。最近几天实在是没什么想学的，在拿起来看看吧，环境已经在 WSL 上配置好了，回头可以直接开始做项目了。</p><p>那今天就先来学习总结一下基础概念吧。</p><h1 id="关于-RPC"><a href="#关于-RPC" class="headerlink" title="关于 RPC"></a>关于 RPC</h1><p>对 RPC 不了解地人，或许会纠结其与 TCP、HTTP 等的关系。后者是网络传输种的协议，而 RPC 是一种设计、实现框架。通讯协议只是其中一部分，RPC 不仅要解决协议通讯的问题，还有序列化与反序列化，以及消息通知。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>从本质上讲，它使一台机器上的程序能够调用另一台机器上的子程序，而不会意识到它是远程的。RPC 是一种软件通信协议，一个程序可以用来向位于网络上另一台计算机的程序请求服务，而不必了解网络的细节。</p><p>一个完整的 RPC 框架里面包含了四个核心的组件，分别是 <code>CLient</code>, <code>Server</code>, <code>ClientOptions</code> 以及 <code>ServerOptions</code>，这个 Options 就是 RPC 需要设计实现的东西。</p><ul><li>客户端（Client）：服务的调用方。</li><li>服务端（Server）：真正的服务提供方。</li><li>客户端存根（ClientOption）：socket 管理，网络收发包的序列化。</li><li>服务端存根（ServerOption）：socket 管理，提醒 server 层 rpc 方法调用，以及网络收发包的序列化。</li></ul><p>RPC 的逻辑示意图如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705212612357.png" alt="image-20240705212612357"></p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>为什么会有 RPC？RPC 和 HTTP 是什么关系？</p><blockquote><p>Socket 和 HTTP 编程使用消息传递范式。客户端向服务器发送一个消息，而服务器通常会发送一个消息回来。双方都负责以双方都能理解的格式创建消息，并从这些消息中读出数据。</p><p>然而，大多数独立的应用程序并没有那么多地使用消息传递技术。一般来说，首选的机制是函数（或方法或过程）的调用。在这种方式中，程序将调用一个带有参数列表的函数，并在完成函数调用后有一组返回值。这些值可能是函数值，或者如果地址被作为参数传递，那么这些地址的内容可能已经被改变。地址的内容可能已经被改变。</p><p>RPC 就是将这种编程方式引入网络世界的一种尝试。因此，客户端将进行在它看来是正常的过程调用。客户端会将其打包成网络消息并传送给服务器。服务器会将其解包，并在服务器端将其转回为过程调用。服务器端的过程调用。这个调用的结果将被打包，以便返回给客户端。</p></blockquote><p>上面的解释可谓是非常官方，看过之后也不是很清楚 RPC 到底是什么，有什么用，<a href="https://xiaolincoding.com/network/2_http/http_rpc.html">建议去看这篇博客</a>，解释的非常清楚，这里给一下结论：</p><ul><li>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 <strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP/2.0</strong> 在 <strong>HTTP/1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><h2 id="RPC-和-REST-的区别"><a href="#RPC-和-REST-的区别" class="headerlink" title="RPC 和 REST 的区别"></a>RPC 和 REST 的区别</h2><p>RPC 与 REST 最大的区别就在于 RPC 提供了更好的抽象，RPC 甚至将网络传输细节彻底隐藏了，而 REST 没有。具体来说，REST 至少要求用于提供 URL 以及请求参数，而 RPC 隐藏了与网络传输的相关实现细节。另一方面，RPC 可以基于任何网络通信协议，而 REST 通常基于 HTTP（或者 HTTPS）协议。RPC 调用者并不会关心具体的协议是：HTTP、TCP 还是其他任何自定义协议。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>以下是 RPC 为开发人员和应用程序管理员提供的一些优势：</p><ul><li>帮助客户端通过传统使用高级语言的过程调用与服务器进行通信。</li><li>可以在分布式环境以及本地环境中使用。</li><li>支持面向进程和面向线程的模型。</li><li>对用户隐藏内部消息传递机制。</li><li>只需极少的努力即可重写和重新开发代码。</li><li>提供抽象，即对用户隐藏网络通信的消息传递性质。</li><li>省略许多协议层以提高性能。</li></ul><p>另一方面，RPC 的一些缺点包括：</p><ul><li>客户端和服务器对各自的例程使用不同的执行环境，并且资源（例如，文件）的使用也更加复杂。因此，RPC 系统并不总是适合传输大量数据。</li><li>RPC 非常容易发生故障，因为它涉及通信系统，另一台计算机和另一个进程。</li><li>RPC 没有统一的标准;它可以通过多种方式实现。</li><li>RPC 只是基于交互的，因此，在硬件架构方面，它不提供任何灵活性。</li></ul><h1 id="关于-gRPC"><a href="#关于-gRPC" class="headerlink" title="关于 gRPC"></a>关于 gRPC</h1><p>gRPC 是 RPC 的一种，它使用 Protocol Buffer (简称 Protobuf) 作为序列化格式，Protocol Buffer 是来自 Google 的序列化框架，比 Json 更加轻便高效，同时基于 HTTP/2 标准设计，<strong>带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求</strong>等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。用 protoc 就能使用 proto 文件帮助我们生成上面的 option 层代码。</p><p>在 gRPC 中，客户端应用程序可以直接在另一台计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。</p><p>gRPC 的调用模型如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705215225298.png" alt="image-20240705215225298"></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><strong>分布式场景</strong> ：gRPC 设计为低延迟和高吞吐量通信，非常适用于效率至关重要的轻型微服务。</li><li><strong>点对点实时通信</strong>： gRPC 对双向流媒体提供出色的支持，可以实时推送消息而无需轮询。</li><li><strong>多语言混合开发</strong> ：支持主流的开发语言，使 gRPC 成为多语言开发环境的理想选择。</li><li><strong>网络受限环境</strong> ： 使用 Protobuf（一种轻量级消息格式）序列化 gRPC 消息。gRPC 消息始终小于等效的 JSON 消息。</li></ul><h2 id="四种调用方式"><a href="#四种调用方式" class="headerlink" title="四种调用方式"></a>四种调用方式</h2><p>学习 gRPC 使用之前，先介绍一下 RPC 中的客户端与服务端。在 RPC 中，服务端会开启服务供客户端调用，每一句 RPC 调用都是一次客户端发请求到服务器获得相应的过程，中间过程被封装了，看起来像本地的一次调用一样，一次 RPC 调用也就是一次通讯过程。</p><p>RPC 调用通常根据双端是否流式交互，分为了<code>单项 RPC (Simple RPC)</code>、<code>服务端流式（Server-side streaming RPC）</code>、<code>客户端流式（Client-side streaming RPC）</code>、和<code>双向流式（Bidirectional streaming RPC）</code>四种方式。</p><ul><li><code>单项 RPC(Simple RPC)</code>：客户端发起请求并等待服务端响应，就是普通的 Ping-Pong 模式。</li><li><code>服务端流式 RPC（Server-side streaming RPC）</code>：服务端发送数据，客户端接收数据。客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。</li><li><code>客户端流式 RPC（Client-side streaming RPC）</code>：与服务端数据流模式相反，这次是客户端源源不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。</li><li><code>双向流式 RPC（Bidirectional streaming RPC）</code>：双方使用读写流去发送一个消息序列，两个流独立操作，双方可以同时发送和同时接收。</li></ul><p>为了便于大家理解四种 gRPC 调用的应用场景，这里举一个例子，假设你是小超，有一个女朋友叫婷婷，婷婷的每种情绪代表一个微服务，你们之间的每一次对话可以理解为一次 PRC 调用，为了便于画流程图，RPC 请求被封装成 client.SayHello，请求包为 HelloRequest，响应为 HelloReply。</p><h3 id="单项-RPC"><a href="#单项-RPC" class="headerlink" title="单项 RPC"></a>单项 RPC</h3><p>当你在等婷婷回去吃饭，婷婷在加班时，你们之间的 rpc 调用可能是这样的：</p><p><em>小超：回来吃饭吗</em></p><p><em>婷婷：还在加班</em></p><p>这就是单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220032151.png" alt="image-20240705220032151"></p><ul><li>client 层调用 SayHello 接口，把 HelloRequest 包进行序列化</li><li>client option 将序列化的数据发送到 server 端</li><li>server option 接收到 rpc 请求</li><li>将 rpc 请求返回给 server 端，server 端进行处理，将结果给 server option</li><li>server option 将 HelloReply 进行序列化并发给 client</li><li>client option 做反序列化处理，并返回给 client 层</li></ul><h3 id="服务端流式-RPC"><a href="#服务端流式-RPC" class="headerlink" title="服务端流式 RPC"></a>服务端流式 RPC</h3><p>当你比赛输了给婷婷发消息时：</p><p><em>小超：今天比赛输了</em></p><p><em>婷婷：没事，一次比赛而已</em></p><p><em>婷婷：晚上带你去吃好吃的</em></p><p>这就是服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220316542.png" alt=""></p><ul><li>client 层调用 SayHello 接口，把 HelloRequest 包进行序列化</li><li>client option 将序列化的数据发送到 server 端</li><li>server option 接收到 rpc 请求</li><li>将 rpc 请求返回给 server 端，server 端进行处理，将将数据流给 server option</li><li>server option 将 HelloReply 进行序列化并发给 client</li><li>client option 做反序列化处理，并返回给 client 层</li></ul><h3 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h3><p>当你惹婷婷生气的时候：</p><p><em>小超：怎么了，宝贝</em></p><p><em>小超：别生气了，带你吃好吃的</em></p><p><em>婷婷：滚</em></p><p>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220455218.png" alt="image-20240705220455218"></p><ul><li>client 层调用 SayHello 接口，把 HelloRequest 包进行序列化</li><li>client option 将序列化的数据流发送到 server 端</li><li>server option 接收到 rpc 请求</li><li>将 rpc 请求返回给 server 端，server 端进行处理，将结果给 server option</li><li>server option 将 HelloReply 进行序列化并发给 client</li><li>client option 做反序列化处理，并返回给 client 层</li></ul><h3 id="双向流-RPC"><a href="#双向流-RPC" class="headerlink" title="双向流 RPC"></a>双向流 RPC</h3><p>当你哄好婷婷时：</p><p><em>小超：今天看了一个超好看的视频</em></p><p><em>婷婷：什么视频</em></p><p><em>小超：发给你看看</em></p><p><em>婷婷：这也叫好看？</em></p><p>双向流 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240705220534237.png" alt="image-20240705220534237"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实弄懂了单项 RPC、服务端流式 RPC、客户端流式 RPC、双向流 PRC 四种 grpc 应用场景，实现起来非常容易</p><ol><li>根据应用场景选择好哪种 gRPC 服务</li><li>写好 proto 文件，用 protoc 生成.pb.go 文件</li><li>服务端实现接口 -&gt;listen -&gt; grpc.NewServer () -&gt; pb.RegisterGreetsServer (server, &amp;Server {}) -&gt; s.Serve (lis)</li><li>客户端 grpc.Dial-&gt;pb.NewGreetsClient-&gt;context.WithTimeout-&gt;client.SayHello (调用接口)-&gt; 如果是流传输则循环读取数据</li></ol><p>代码实现这里就不实现了，因为就算写也不是我实现的，所以这里就我自己在下面理解了。</p><p>最近这两天什么都没干，做什么事都提不起来兴趣，有一种抽离感，好煎熬啊，快点出结果吧，祝我面试顺利！！！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learnku.com/articles/58641">https://learnku.com/articles/58641</a></p><p><a href="https://grpc.io/blog/principles/">https://grpc.io/blog/principles/</a></p><p><a href="https://www.cnblogs.com/rickiyang/p/14758485.html">https://www.cnblogs.com/rickiyang/p/14758485.html</a></p><p><a href="https://bbs.huaweicloud.com/blogs/337073#H21">https://bbs.huaweicloud.com/blogs/337073#H21</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RPC 和 gRPC 其实是笔者在几个月前就开始接触的东西，但是由于当时在 Windows 上配不好环境加上学起来确实有点难度，所以就放下没去做项目，就简单地了解了一下。最近几天实在是没什么想学的，在拿起来看看吧，环境已经在 WSL 上配置好了，回头可以直接开始做项目了。&lt;</summary>
      
    
    
    
    <category term="技术剖析" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90/"/>
    
    
    <category term="项目开发" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法——ZAB</title>
    <link href="http://example.com/2024/07/03/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94ZAB/"/>
    <id>http://example.com/2024/07/03/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94ZAB/</id>
    <published>2024-07-03T13:44:52.000Z</published>
    <updated>2024-07-03T15:39:53.746Z</updated>
    
    <content type="html"><![CDATA[<p>今天是分布式一致性算法的第三个——ZAB 算法。</p><h1 id="关于-ZAB-算法"><a href="#关于-ZAB-算法" class="headerlink" title="关于 ZAB 算法"></a>关于 ZAB 算法</h1><p>ZAB协议，全称 Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。它是专门为分布式协调服务——Zookeeper，设计的一种支持 <strong>崩溃恢复</strong> 和 <strong>原子广播</strong> 的协议。</p><p>从设计上看，ZAB协议和 Raft 很类似。ZooKeeper集群中，只有一个Leader节点，其余均为Follower节点。整个ZAB协议一共定义了四个阶段：<strong>选举（Leader Election）</strong>、 <strong>发现（Discovery）</strong> 、 <strong>同步（Synchronization）</strong> 、 <strong>广播（Broadcast）</strong> 。</p><p>ZAB借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。</p><p>在Zookeeper中主要依赖ZAB 协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。 这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后 Leader 客户端将数据同步到其他 Follower 节点。</p><p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；</p><p>如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>相比Paxos，Zab最大的特点是保证强一致性(strong consistency，或叫线性一致性linearizable consistency)。</p><ol><li><p>ZAB 协议需要确保那些已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交。</p></li><li><p>ZAB 协议需要确保丢弃那些只在 Leader 上被提出而没有被提交的事务。</p></li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1053629-d32b630b65a7a0b2.png" alt="zab 协议特性"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以事务 proposal （事务提议）的形式广播到所有的副本（Follower）进程上去。</p></li><li><p>保证一个全局的变更序列被顺序引用。</p><p>Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。</p><p>为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</p></li><li><p>当主进程出现异常的时候，整个zk集群依旧能正常工作。</p></li></ol><h1 id="直观理解：Zookeeper分布式一致性协议ZAB"><a href="#直观理解：Zookeeper分布式一致性协议ZAB" class="headerlink" title="直观理解：Zookeeper分布式一致性协议ZAB"></a>直观理解：Zookeeper分布式一致性协议ZAB</h1><p>基于ZAB协议，Zookeeper实现一种<strong>主备模式的系统架构来保持集群中主备副本之间数据的一致性</strong>。</p><p>ZAB算法分为两大块内容，<strong>消息广播 </strong>和 <strong>崩溃恢复</strong>。</p><ul><li>消息广播（boardcast）：Zab 协议中，所有的写请求都由 leader 来处理。正常工作状态下，leader 接收请求并通过广播协议来处理。 </li><li>崩溃恢复（recovery）：当服务初次启动，或者 leader 节点挂了，系统就会进入恢复模式，直到选出了有合法数量 follower 的新 leader，然后新 leader 负责将整个系统同步到最新状态。</li></ul><p>下面来详细介绍这两种基本模式的实现过程：</p><h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>消息广播是 Zookeeper 用来保证写入一致性的方法，在 Zookeeper 集群中，存在三种角色的节点：</p><ul><li>Leader：Zookeeper集群的核心角色，在集群启动或崩溃恢复中通过 Follower 参与选举产生，<strong>为客户端提供读写服务，并对事务请求进行处理</strong>。</li><li>Follower：Zookeeper 集群的核心角色，在集群启动或崩溃恢复中参加选举，没有被选上就是这个角色，<strong>为客户端提供读取服务</strong>，也就是处理非事务请求，Follower 不能处理事务请求，对于收到的事务请求会转发给Leader。</li><li>Observer：观察者角色，<strong>不参加选举，为客户端提供读取服务，处理非事务请求</strong>，对于收到的事务请求会转发给 Leader。使用 Observer 的目的是为了扩展系统，提高读取性能。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1.png" alt="img"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>下面通过几张图对ZAB的消息广播过程进行简单的介绍：</p><ol><li><p>Zookeeper各节点会接收来自客户端的请求，如果是非事务请求，各节点自行进行相应的处理。若接收到的是客户端的事务请求，如果当前节点是Follower则将该请求<strong>转发给当前集群中的Leader节点</strong>进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-4f5e54ed3eaa3ffc.png" alt="处理"></p></li><li><p>Leader接收到事务处理的请求后，将向所有的Follower节点发出Proposal提议，并等待各Follower的Ack反馈。</p><p>在广播事务之前Leader服务器会先给这个事务分配一个<strong>全局单调递增的唯一ID</strong>，也就是<strong>事务ID（zxid）</strong>，每一个事务必须按照zxid的先后顺序进行处理。</p><p>而且Leader服务器会为每一个Follower分配一个单独的队列，然后将需要广播的事务放到队列中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-5c507cccac9af7bd.png" alt="广播"></p></li><li><p>各Follower节点对Leader节点的Proposal进行Ack反馈，Leader对接收到的Ack进行统计，如果<strong>超多半数Follower进行了Ack，此时进行下一步操作</strong>，否则之间向客户端进行事务请求失败的Response。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-87240c31b1eea272.png" alt="超过一半"></p></li><li><p>如果Leader节点接收到了超过半数的Ack响应，此时Leader会向所有的Follower发出事务Commit的指令，同时自己也执行一次Commit，并向客户端进行事务请求成功的Response。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/53727-2d0f4e7526b50878.png" alt="成功"></p></li></ol><p>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。</p><p>这也是 CAP/BASE 实现最终一致性的一个体现。</p><p>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO 消息队列进行收发消息，使用队列消息可以做到异步解耦。</p><p>Leader 和 Follower 之间只需要往队列中发消息即可。</p><p>如果使用同步的方式会引起阻塞，性能要下降很多。</p><h3 id="丢弃的事务proposal处理过程："><a href="#丢弃的事务proposal处理过程：" class="headerlink" title="丢弃的事务proposal处理过程："></a>丢弃的事务proposal处理过程：</h3><p>ZAB协议中使用ZXID作为事务编号，ZXID为64位数字，低32位为一个递增的计数器，每一个客户端的一个事务请求时Leader产生新的事务后该计数器都会加1， 高32位为Leader周期epoch编号，当新选举出一个Leader节点时Leader会取出本地日志中最大事务Proposal的ZXID解析出对应的epoch把该值加1作为新的epoch，将低32位从0开始生成新的ZXID；</p><p>ZAB使用epoch来区分不同的Leader周期，能有效避免了不同的leader服务器错误的使用相同的ZXID编号提出不同的事务proposal的异常情况，大大简化了提升了数据恢复流程；</p><p>所以这个崩溃的机器启动时，也无法成为新一轮的Leader，因为当前集群中的机器一定包含了更高的epoch的事务proposal。</p><hr><p>Zookeeper的消息广播过程类似 2PC（Two Phase Commit），ZAB <strong>仅需要超过一半以上的Follower返回 Ack 信息就可以执行提交，大大减小了同步阻塞，提高了可用性</strong>。</p><p>ZAB协议简化了2PC事务提交：</p><ol><li>去除中断逻辑移除，follower要么ack，要么抛弃Leader；</li><li>leader不需要所有的Follower都响应成功，只要一个多数派ACK即可。</li></ol><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>在 Zookeeper 集群启动、运行过程中，如果 Leader 出现崩溃、网络断开、服务停止或重启等异常情况，或集群中有新服务器加入时，ZAB 会让当前集群快速进入崩溃恢复模式并选举出新的 Leader 节点，在此期间，整个集群<strong>不对外提供任何读取服务</strong>。</p><p>当产生新的 Leader 后，并且集群中有过半的 Follower 完成了与 Leader 的状态同步，那么 ZAB 协议就会让 Zookeeper 集群从崩溃恢复模式转换成消息广播模式。</p><p>崩溃恢复的<strong>目的</strong>就是保证当前Zookeeper集群快速选举出一个新的Leader并完成与其他Follower的状态同步，以便尽快进入消息广播模式对外提供服务。</p><p>Zookeeper崩溃恢复的主要任务就是选举Leader（Leader Election），Leader选举分两个场景：一个是Zookeeper服务器启动时Leader选举，另一个是Zookeeper集群运行过程中Leader崩溃后的Leader选举。</p><p><strong>参数</strong></p><p>在详细介绍Leader选举过程之前，需要先介绍几个参数：</p><ul><li><p>myid: 服务器ID，这个是在安装 Zookeeper 时配置的，myid 越大，该服务器在选举中被选为 Leader 的优先级会越大。</p></li><li><p>zxid: 事务ID，这个是由 Zookeeper 集群中的 Leader 节点进行 Proposal 时生成的全局唯一的事务ID，由于只有 Leader 才能进行Proposal，所以这个zxid很容易做到全局唯一且自增。因为 Follower 没有生成zxid的权限。zxid越大，表示当前节点上提交成功了最新的事务，这也是为什么在崩溃恢复的时候，需要优先考虑zxid的原因。</p></li><li><p>epoch: 投票轮次，每完成一次Leader选举的投票，当前Leader节点的epoch会增加一次。在没有Leader时，本轮此的epoch会保持不变。</p></li></ul><p><strong>优先选择 myid + zxid 最大的数据。</strong></p><p>另外在选举的过程中，每个节点的当前状态会在以下几种状态之中进行转变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOOKING: 竞选状态。 </span><br><span class="line"></span><br><span class="line">FOLLOWING: 随从状态，同步Leader 状态，参与Leader选举的投票过程。 </span><br><span class="line"></span><br><span class="line">OBSERVING: 观察状态，同步Leader 状态，不参与Leader选举的投票过程。 </span><br><span class="line"></span><br><span class="line">LEADING: 领导者状态。</span><br></pre></td></tr></table></figure><h3 id="集群启动时的-Leader-选举"><a href="#集群启动时的-Leader-选举" class="headerlink" title="集群启动时的 Leader 选举"></a>集群启动时的 Leader 选举</h3><p>假设现在存在一个由5个Zookeeper服务器组成的集群Sever1，Sever2，Sever3，Sever4和Sever5，集群的myid分别为：1， 2，3，4，5。</p><p>依次按照myid递增的顺序进行启动。</p><p>由于<strong>刚启动时zxid和epoch都为0，因此Leader选举的关键因素成了myid</strong>。</p><ol><li>启动Sever1，此时整个集群中只有Sever1启动，Sever1无法与其他任何服务建立通信，立即进入LOOKING状态，此时Server1给自己投1票（上来都觉得自己可以做Leader），由于1不大于集群总数的一半，即2，此时Sever1保持LOOKING状态。</li><li>启动Sever2，此时Sever2与Server1建立通信，Sever1和Sever2互相交换投票信息，Server1投票的myid为1，Server2投票的myid为2，此时选取myid最大的，因此Sever1的投票会变成2，但是由于目前投票Server2的服务器数量为2台，小于集群总数的一半2，因此Sever1和Sever2继续保持LOOKING状态。</li><li>启动Sever3，此时三台服务器之间建立了通信，Server3进入LOOKING状态，并与前两台服务器交换投票信息，Server1和Server2的投票信息为2，Server3投票自己，即myid为3，这个时候选择myid最大的作为Leader。此时集群中投票3的服务器数量变成了3台，此时3&gt;2，Sever3立刻变成LEADING状态，Sever1和Sever2变成FOLLOWING状态。</li><li>启动Sever4，Sever4进入LOOKING状态并与前三台服务器建立通信，由于集群中已经存在LEADING状态的节点，因此，Sever4立刻变为FOLLOWING状态，此时Sever3依旧处于LEADING状态。</li><li>启动动Sever5，Sever5与Sever4一样，在与其他服务器建立通信后会立刻变为FOLLOWING状态，此时Sever3依旧处于LEADING状态。</li></ol><p>最终整个Zookeeper集群中，Server3成为Leader，Server1，Server2，Server4和Server5成为Follower，最终Server3的epoch加一。</p><p>ps: 启动时，都给自己投一票，选举时，优先按照 myid 对比。超过一半的数量，则成为 leader。</p><h3 id="Leader-崩溃时的-Leader-选举"><a href="#Leader-崩溃时的-Leader-选举" class="headerlink" title="Leader 崩溃时的 Leader 选举"></a>Leader 崩溃时的 Leader 选举</h3><p>在Zookeeper集群刚启动的时候，zxid和epoch并不参与群首选举。</p><p>但是如果Zookeeper集群在运行了一段时间之后崩溃了，那么epoch和zxid在Leader选举中的重要性将大于myid。</p><p>重要性的排序为：<code>epoch &gt; zxid &gt; myid</code>。</p><p>当某一个Follower与Leader失去通信的时候，就会进入Leader选举，此时Follower会跟集群中的其他节点进行通信，但此时会存在两种情况：</p><p>1) Follower与Leader失去通信，但此时集群中的Follower并未崩溃，且与其他Follower保持正常通信。此时当该Follower与其他Follower进行通信时，其他Follower会告诉他，老大还活着，这个时候，Follower仅需要与Leader建立通信即可。<br>2) Leader真的崩溃了，此时集群中所有节点之间会进行通信，当得知老大挂了之后，每个节点都会开启争老大模式，各自会将当前节点最新的epoch，zxid和myid发送出来，参与投票，此时各节点之间会参照 <code>epoch &gt; zxid &gt; myid</code> 进行Leader选举，最后投票数超过集群数量一般的节点会成为新的Leader。</p><p>这种崩溃后的Leader选举机制也很好理解，如果Leader挂了，优先选择集群中最后做过（epoch）Leader的节点为新的Leader节点，其次选取有最新事务提交的节点（zxid）为Leader，最后才按默认的最大机器编号（myid）进行投票。</p><h1 id="保持数据一致性"><a href="#保持数据一致性" class="headerlink" title="保持数据一致性"></a>保持数据一致性</h1><p>ZooKeeper从以下几点保证了数据的一致性</p><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>来自任意特定客户端的更新都会按其发送顺序被提交。</p><p>也就是说，如果一个客户端将Znode z的值更新为a，在之后的操作中，它又将z的值更新为b，则没有客户端能够在看到z的值是b之后再看到值a（如果没有其他对z的更新）。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果。</p><h2 id="单一系统映像"><a href="#单一系统映像" class="headerlink" title="单一系统映像"></a>单一系统映像</h2><p>一个客户端无论连接到哪一台服务器，它看到的都是同样的系统视图。</p><p>这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比在之前服务器上所看到的更老。</p><p>当一台服务器出现故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有滞后于故障服务器的服务器都不会接受该连接请求，除非这些服务器赶上故障服务器。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一个更新一旦成功，其结果就会持久存在并且不会被撤销。</p><p>这表明更新不会受到服务器故障的影响。</p><h1 id="Zab特殊情况下需要解决的两个问题"><a href="#Zab特殊情况下需要解决的两个问题" class="headerlink" title="Zab特殊情况下需要解决的两个问题"></a>Zab特殊情况下需要解决的两个问题</h1><p>崩溃恢复过程中，为了保证数据一致性需要处理特殊情况：</p><ol><li><p>已经被Leader提交的proposal确保最终被所有的服务器follower提交</p></li><li><p>确保那些只在Leader被提出的proposal被丢弃</p></li></ol><p>针对这个要求,如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高的ZXID事务proposal，就可以保证这个新选举出来的Leader一定具有所有已经提交的提案，也可以省去Leader服务器检查proposal的提交与丢弃的工作。</p><h2 id="已经被处理的事务请求（proposal）不能丢（commit的）"><a href="#已经被处理的事务请求（proposal）不能丢（commit的）" class="headerlink" title="已经被处理的事务请求（proposal）不能丢（commit的）"></a>已经被处理的事务请求（proposal）不能丢（commit的）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 收到合法数量 follower 的 ACKs 后，就向各个 follower 广播 COMMIT 命令，同时也会在本地执行 COMMIT 并向连接的客户端返回「成功」。但是如果在各个 follower 在收到COMMIT 命令前 leader 就挂了，导致剩下的服务器并没有执行都这条消息。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol><li><p>选举拥有 proposal 最大值（即 zxid 最大） 的节点作为新的 leader。</p><blockquote><p>由于所有提案被 COMMIT 之前必须有合法数量的 follower ACK，即必须有合法数量的服务器的事务日志上有该提案的 proposal，因此，zxid最大也就是数据最新的节点保存了所有被 COMMIT 消息的 proposal 状态。</p></blockquote></li><li><p>新的 leader 将自己事务日志中 proposal 但未 COMMIT 的消息处理。</p></li><li><p>新的 leader 与 follower 建立先进先出的队列， 先将自身有而 follower 没有的 proposal 发送给 follower，再将这些 proposal 的 COMMIT 命令发送给 follower，以保证所有的 follower 都保存了所有的 proposal、所有的 follower 都处理了所有的消息</p></li></ol><h2 id="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"><a href="#没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？" class="headerlink" title="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"></a>没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 接收到消息请求生成 proposal 后就挂了，其他 follower 并没有收到此 proposal，因此经过恢复模式重新选了 leader 后，这条消息是被跳过的。 此时，之前挂了的 leader 重新启动并注册成了 follower，他保留了被跳过消息的 proposal 状态，与整个系统的状态是不一致的，需要将其删除。</p><h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>Zab 通过巧妙的设计 zxid 来实现这一目的。</strong></p><p>一个 zxid 是64位，高 32 是纪元（epoch）编号，每经过一次 leader 选举产生一个新的 leader，新 leader 会将 epoch 号 +1。低 32 位是消息计数器，每接收到一条消息这个值 +1，新 leader 选举后这个值重置为 0。</p><p>这样设计的好处是旧的 leader 挂了后重启，它不会被选举为 leader，因为此时它的 zxid 肯定小于当前的新 leader。当旧的 leader 作为 follower 接入新的 leader 后，新的 leader 会让它将所有的拥有旧的 epoch 号的未被 COMMIT 的 proposal 清除。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近的几篇文章都是围绕着分布式系统来开展的，学习了一些一致性算法和 ID 生成算法，每次开始学习这种新的知识的时候我都会感慨他们简直就是天才，十分神奇。有机会的话还会去更加全面的学习，现在还是只停留在纸面上，还没找到合适的机会去实战。</p><p>今天上午面试结束了，准备了很长时间也确实收获了很多东西，应该算是找到了比较正确的学习方法。除了学习方面的问题，通过昨天准备 HR 面的时候好好反思了自己的一些问题，还是觉得做事急于求成和功利心这方面的问题要及时纠正，最近两周也有在做一些调整，还是需要改掉这些毛病的，最起码要保证做一些事情的时候不要老是想成功了之后怎样怎样、失败了怎样怎样。</p><p>昨天晚上紧张的整晚都没睡好觉，今天早上六点多就起来了，准备了一下面试的东西，虽然面试的时候没有问，但是我确实有了不小的底气。至于结果怎么样，我非常希望会是一个好的结果，估计要到一周之后见分晓了。在北京、字节的王牌部门，如果能进去实习当然会往转正的方向努力。祝我面试成功！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是分布式一致性算法的第三个——ZAB 算法。&lt;/p&gt;
&lt;h1 id=&quot;关于-ZAB-算法&quot;&gt;&lt;a href=&quot;#关于-ZAB-算法&quot; class=&quot;headerlink&quot; title=&quot;关于 ZAB 算法&quot;&gt;&lt;/a&gt;关于 ZAB 算法&lt;/h1&gt;&lt;p&gt;ZAB协议，全称 Z</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法——Raft</title>
    <link href="http://example.com/2024/07/01/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Raft/"/>
    <id>http://example.com/2024/07/01/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Raft/</id>
    <published>2024-07-01T13:04:35.000Z</published>
    <updated>2024-07-01T14:03:21.600Z</updated>
    
    <content type="html"><![CDATA[<p>几天前更新的文章里降到了一致性算法，也详细地写了 Paxos 算法的内部原理，今天我们继续学习分布式一致性算法的其他两种，由于篇幅有限，所以一篇博客写一个算法。</p><h1 id="关于-Raft-算法"><a href="#关于-Raft-算法" class="headerlink" title="关于 Raft 算法"></a>关于 Raft 算法</h1><p>Raft 是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的 Paxos。</p><p>Paxos 算法是分布式系统领域最重要的一致性算法，同时也是公认的极为艰深难懂的算法。为了解决这个晦涩难懂的问题，斯坦福大学的Diego Ongaro、John Ousterhout教授以容易理解（Understandability）为目标设计了这个新的一致性算法：Raft，并在2013年发布了论文：《In Search of an Understandable Consensus Algorithm》。为了验证这个容易理解的特性，他们分别在斯坦福大学和加州大学伯克利分校的分布式计算课程上，使用了Raft和Paxos两种算法，采用视频教学的方式来传授给学生，之后采用小测验的方式来验证。结果表明 Raft 比 Paxos 容易理解很多。</p><p>Raft 和 Paxos 一样只要保证 n/2+1 节点（即超过半数节点）正常工作就能够提供服务。在设计层面，Raft 把算法流程分为三个子问题：领导选举（Leader election）、日志复制（Log replication）、安全性（Safety）。 Raft 开始时在集群中选举出 Leader 负责日志复制的管理，Leader 接受来自客户端的事务请求（日志），并将它们复制给集群的其他节点，然后负责通知集群中其他节点提交日志，Leader 负责保证其他节点与他的日志同步，当 Leader 宕机后集群其他节点会发起选举选出新的 Leader。</p><h2 id="Raft-算法使用场景"><a href="#Raft-算法使用场景" class="headerlink" title="Raft 算法使用场景"></a>Raft 算法使用场景</h2><p>一般用作两种场景：<strong>元数据管理</strong>：比如 etcd，特点是数据规模小，主要保证<strong>数据一致性</strong>和<strong>集群的高可用（Raft选主）</strong>，所以一套 Raft 集群就够了，<strong>分布式数据库</strong>：这种会用 parttion group，每个 group 有一个 Raft 集群，当数据变大的时候会做拓展。</p><blockquote><p>Raft只是个共识算法来保证数据的一致性，与数据库客户端、事务没有关系</p></blockquote><h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><p>Reft 算法流程分为三个子问题：领导选举（Leader election）、日志复制（Log replication）、安全性（Safety）。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li>领导者 Leader：接收处理客户端请求、向 Follower 进行日志同步、同一时刻最多只能有一个可行的 Leader。</li><li>追随者 Follower：接受并持久化 Leader 同步的日志，在 Leader 告之日志可以提交之后，提交日志，处在完全被动状态。</li><li>候选人 Candidate：临时角色，处于 Leader 和 Follower 之间的暂时状态。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/39ba62045eb5c0f8cbbc2b8aa99badad.png" alt="img"></p><p>Raft算法中在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a7531168a16a5b7cb5091b2fe06eb8ca.png" alt="img"></p><p><strong>状态切换流程：</strong></p><ol><li>Raft 刚启动的时候，所有节点初始状态都是 Follower</li><li>超时时间内如果没有收到 Leader 的请求，则转换为 Candidate 角色并发起 Leader 选举</li><li>如果 Candidate 收到了多数节点的选票则转换为 Leader</li><li>如果在发起选举期间发现已经有 Leader 了，或者收到更高任期的请求则转换为 Follower</li><li>Leader 在收到更高任期的请求后转换为 Follower</li></ol><h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><p>可以理解为是节点担任 Leader 职务的时间期限。</p><p>Raft 将时间划分为一个一个的任期（term），每个任期由单调递增的数字（人气编号）标识，工作期可长可短可能不存在。</p><blockquote><p>任期时间 = 选举时间 + 正常运行时间</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7fc521859d0fb400f01877953d410b96.png" alt="img"></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>Raft 中服务器节点之间通信通过两个 RPC 调用：</p><ul><li>请求投票 RequestVote：候选人(Candidate) 选举期间发起</li><li>日志复制 AppendEntries：领导人(Leader)发起，用于复制 log 和发送心跳</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7ccfe7004ee130b435c7f808be0839f8.png" alt="img"></p><h1 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h1><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>初始状态时，每个节点的角色都是 Follower (跟随者)，Term 任期编号为 1 (假设任期编号从1开始)</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/26963445b747cd52f7534d03d3cfe213.png" alt="img"></p><p>不过这两种情况会触发选举：</p><ul><li>Raft 初次启动时，不存在 Leader，这时候会触发 Leader 选举</li><li>Follower 在自己的超时时间内没有接收到 Leader 的心跳 heartBeat，触发选举超时，从而 Follower 的角色切换成 Candidate，Candidate 会发起选举</li></ul><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>既然有两种情况下会触发选举，一个是初次启动，一个是Leader故障未发送心跳给Follower，那么我们假设有五个节点，然后分别用图来看下是如何选举的！</p><p><strong>初始启动时：</strong></p><p>初次启动节点都是正常流程如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d01d252e6630b2a6594f5cc3a2cf2516.png" alt="img"></p><p><strong>Leader 故障时：</strong></p><p>Node2此时是Leader 节点，结果故障了，剩下四个节点参与选举：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/175a55e163fb0e173eb3cf8971dec5ad.png" alt="img"></p><h2 id="当选条件"><a href="#当选条件" class="headerlink" title="当选条件"></a>当选条件</h2><p>在一个任期（Term）内只可以投票给一个结点，得到超过半数的投票才可成为 Leader，从而保证了一个任期内只会有一个 Leader 产生。</p><h1 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h1><p>概括成一句话就是：<strong>保证Leader上日志能完全相同地复制到多台Follower服务器上。</strong></p><p>OK！我们看下是如何进行同步的。</p><h2 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h2><p>Raft算法中，每个节点维护着一份日志，其中包含了系统中所有状态变更的记录，每一次状态变更被称为一个日志条目。</p><p>我们先看日志结构和右侧说明：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/213828ecfbb19cea31428ec6a8cd6cc9.png" alt="img"></p><p>图中每个节点存储自己的日志副本(log[])，每条日志记录包含：</p><ul><li>索引 (log index)：记录在日志中的位置，是一个连续单调递增整数</li><li>任期号 (term)：日志记录被创建时Leader的任期号，上图中有三个任期</li><li>命令 (command)：客户端请求指定的、状态机需要执行的指令</li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>了解完日志结构后，我们来看日志是如何发起同步的。</p><p><strong>日志持久化存储的条件</strong></p><p>Follower节点必须先将记录安全写到磁盘，才能向Leader节点返回写入成功响应。</p><p>如果一条日志记录被存储在超过半数的节点上，我们认为该记录已提交(committed)——这是 Raft 非常重要的特性！如果一条记录已提交，意味着状态机可以安全地执行该记录</p><p><strong>流程如下图：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7a78999c1896181c3ca0eb79f03a8acf.png" alt="img"></p><ol><li>客户端向 Leader 发送命令，希望该命令被所有状态机执行；</li><li>Leader 先将该命令追加到自己的日志中；</li><li>Leader 并行地向其它节点发送AppendEntries RPC，等待响应；</li><li>收到超过半数节点的响应，则认为新的日志记录是被提交的：</li><li>Leader 将命令传给自己的状态机，然后向客户端返回响应</li><li>此外，一旦 Leader 知道一条记录被提交了，将在后续的AppendEntries RPC中通知已经提交记录的 Followers</li><li>Follower 将已提交的命令传给自己的状态机</li><li>如果 Follower 宕机/超时：Leader 将反复尝试发送 RPC；</li></ol><blockquote><p>Leader 不必等待每个 Follower 做出响应，只需要超过半数的成功响应（确保日志记录已经存储在超过半数的节点上），一个很慢的节点不会使系统变慢，因为 Leader 不必等待。</p></blockquote><h2 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h2><p>Raft 通过 AppendEntries RPC 消息来检测。</p><ul><li>每个AppendEntries RPC包含新日志记录之前那条记录的索引 (prevLogIndex) 和任期 (prevTerm)；</li><li>Follower接收到消息后检查自己的 log index 、 term 与 prevLogIndex 、 prevTerm 进行匹配</li><li>匹配成功则接收该记录，添加最新log，匹配失败则拒绝该消息</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0f1b62539e3fbb42d6b1effd2bedf236.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f3966f5f1a26d6a30aef6c55b6c02e4b.png" alt="img"></p><h2 id="日志一致性"><a href="#日志一致性" class="headerlink" title="日志一致性"></a>日志一致性</h2><p>Raft算法的目的是保证所有节点的一致性，即一个日志条目在某个节点被提交，那么这个日志条目也必须在所有节点上被提交。</p><blockquote><p>通过【<strong>一致性检查</strong>】就保证了日志一致性的这两点内容。</p></blockquote><ul><li>如果两个节点的日志在相同的索引位置上的任期号相同，则认为他们具有一样的命令，从头到这个索引位置之间的日志完全相同</li><li>如果给定的记录已提交，那么所有前面的记录也已提交</li></ul><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>Raft增加了如下两条限制以保证安全性:</p><ul><li><p>拥有最新的已提交的 log entry 的 Follower才有资格成为Leader。</p><p>这个保证是在 RequestVote RPC中做的，Candidate 在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新。</p></li><li><p>Leader只能推进commit index来提交当前 term 的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交(log index 小于 commit index的日志被间接提交)。</p></li></ul><p>之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-8.jpg" alt="img"></p><p>在阶段a，term为2，S1是Leader，且S1写入日志(term, index)为(2, 2)，并且日志被同步写入了S2；</p><p>在阶段b，S1离线，触发一次新的选主，此时S5被选为新的 Leader，此时系统 term 为3，且写入了日志(term, index)为(3， 2);</p><p>S5尚未将日志推送到 Followers 就离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志(2， 2)同步到了S3，而此时由于该日志已经被同步到了多数节点(S1, S2, S3)，因此，此时日志(2，2)可以被提交了。；</p><p>在阶段d，S1又下线了，触发一次选主，而S5有可能被选为新的Leader(这是因为S5可以满足作为主的一切条件: 1. term = 5 &gt; 4，2. 最新的日志为(3，2)，比大多数节点(如S2/S3/S4的日志都新)，然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志(2，2)被截断了。</p><p>增加上述限制后，即使日志(2，2)已经被大多数节点(S1、S2、S3)确认了，但是它不能被提交，因为它是来自之前term(2)的日志，直到S1在当前term(4)产生的日志(4， 4)被大多数Followers确认，S1方可提交日志(4，4)这条日志，当然，根据Raft定义，(4，4)之前的所有日志也会被提交。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志(4，4)。</p><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p><p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p><p>Snapshot中包含以下内容:</p><ul><li>日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。</li><li>系统当前状态。</li></ul><p>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC。</p><p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p><p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p><h2 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h2><p>成员变更是在集群运行过程中副本发生变化，如增加/减少副本数、节点替换等。</p><p>成员变更也是一个分布式一致性问题，既所有服务器对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的一致性达成的过程中，参与投票的进程会发生变化。</p><p>如果将成员变更当成一般的一致性问题，直接向Leader发送成员变更请求，Leader复制成员变更日志，达成多数派之后提交，各服务器提交成员变更日志后从旧成员配置(Cold)切换到新成员配置(Cnew)。</p><p>因为各个服务器提交成员变更日志的时刻可能不同，造成各个服务器从旧成员配置(Cold)切换到新成员配置(Cnew)的时刻不同。</p><p>成员变更不能影响服务的可用性，但是成员变更过程的某一时刻，可能出现在Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-9.jpg" alt="img"></p><p>由于成员变更的这一特殊性，成员变更不能当成一般的一致性问题去解决。</p><p>为了解决这一问题，Raft提出了两阶段的成员变更方法。集群先从旧成员配置Cold切换到一个过渡成员配置，称为共同一致(joint consensus)，共同一致是旧成员配置Cold和新成员配置Cnew的组合Cold U Cnew，一旦共同一致Cold U Cnew被提交，系统再切换到新成员配置Cnew。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-10.jpg" alt="img"></p><p>Raft两阶段成员变更过程如下:</p><ul><li>Leader收到成员变更请求从Cold切成Cnew；</li><li>eader在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧成员配置共存，写入本地日志，同时将该log entry复制至Cold∪Cnew中的所有副本。在此之后新的日志同步需要保证得到Cold和Cnew两个多数派的确认；</li><li>Follower收到Cold∪Cnew的log entry后更新本地日志，并且此时就以该配置作为自己的成员配置；</li><li>如果Cold和Cnew中的两个多数派确认了Cold U Cnew这条日志，Leader就提交这条log entry；</li><li>接下来Leader生成一条新的log entry，其内容是新成员配置Cnew，同样将该log entry写入本地日志，同时复制到Follower上；</li><li>Follower收到新成员配置Cnew后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在Cnew这个成员配置中会自动退出；</li><li>Leader收到Cnew的多数派确认后，表示成员变更成功，后续的日志只要得到Cnew多数派确认即可。Leader给客户端回复成员变更执行成功。</li></ul><p>异常分析:</p><ul><li>如果Leader的Cold U Cnew尚未推送到Follower，Leader就挂了，此后选出的新Leader并不包含这条日志，此时新Leader依然使用Cold作为自己的成员配置。</li><li>如果Leader的Cold U Cnew推送到大部分的Follower后就挂了，此后选出的新Leader可能是Cold也可能是Cnew中的某个Follower。</li><li>如果Leader在推送Cnew配置的过程中挂了，那么同样，新选出来的Leader可能是Cold也可能是Cnew中的某一个，此后客户端继续执行一次改变配置的命令即可。</li><li>如果大多数的Follower确认了Cnew这个消息后，那么接下来即使Leader挂了，新选出来的Leader肯定位于Cnew中。</li><li>两阶段成员变更比较通用且容易理解，但是实现比较复杂，同时两阶段的变更协议也会在一定程度上影响变更过程中的服务可用性，因此我们期望增强成员变更的限制，以简化操作流程。</li></ul><p>两阶段成员变更，之所以分为两个阶段，是因为对Cold与Cnew的关系没有做任何假设，为了避免Cold和Cnew各自形成不相交的多数派选出两个Leader，才引入了两阶段方案。</p><p>如果增强成员变更的限制，假设Cold与Cnew任意的多数派交集不为空，这两个成员配置就无法各自形成多数派，那么成员变更方案就可能简化为一阶段。</p><p>那么如何限制Cold与Cnew，使之任意的多数派交集不为空呢? 方法就是每次成员变更只允许增加或删除一个成员。</p><p>可从数学上严格证明，只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派。</p><p>一阶段成员变更:</p><ul><li>成员变更限制每次只能增加或删除一个成员(如果要变更多个成员，连续变更多次)。</li><li>成员变更由Leader发起，Cnew得到多数派确认后，返回客户端成员变更成功。</li><li>一次成员变更成功前不允许开始下一次成员变更，因此新任Leader在开始提供服务前要将自己本地保存的最新成员配置重新投票形成多数派确认。</li><li>Leader只要开始同步新成员配置，即可开始使用新的成员配置进行日志同步。</li></ul><h1 id="Raft-和-Multi-Paxos对比"><a href="#Raft-和-Multi-Paxos对比" class="headerlink" title="Raft 和 Multi-Paxos对比"></a>Raft 和 Multi-Paxos对比</h1><p>Raft与Multi-Paxos都是基于领导者的一致性算法，乍一看有很多地方相同，下面总结一下Raft与Multi-Paxos的异同。</p><p>Raft与Multi-Paxos中相似的概念:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-11.jpg" alt="img"></p><p>Raft与Multi-Paxos的不同:</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/alg-dst-raft-12.jpg" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>没更新的几天去干嘛了，有在学习，只是没去学习全新的东西，回过头去看了看之前没注意的一些知识点，收获非常大。不过不打算写博客来记录了，学到最多的还是一些关于 Go 底层实现的一些东西，我也是在看别人写的书，没有什么实际收获，只是去理解了一下，所以觉得没有再写博客的必要。</p><p>学习使我快乐，学习使我快乐，学习是我快乐。幸亏最近几天有去做算法题，才不至于在做笔试的时候手忙脚乱的。老规矩，祝我面试顺利！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几天前更新的文章里降到了一致性算法，也详细地写了 Paxos 算法的内部原理，今天我们继续学习分布式一致性算法的其他两种，由于篇幅有限，所以一篇博客写一个算法。&lt;/p&gt;
&lt;h1 id=&quot;关于-Raft-算法&quot;&gt;&lt;a href=&quot;#关于-Raft-算法&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法——Paxos</title>
    <link href="http://example.com/2024/06/27/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Paxos/"/>
    <id>http://example.com/2024/06/27/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Paxos/</id>
    <published>2024-06-27T11:23:50.000Z</published>
    <updated>2024-06-28T04:59:10.935Z</updated>
    
    <content type="html"><![CDATA[<p>在正式学习一致性算法之前，先来看一个问题。</p><p>基于前面对分布式系统环境下一致性与共识算法的基础理论，在分布式系统中进行节点通信大部分采用基于消息传递通信模型，不可避免的会发生如进程可能会变慢、被杀死或者重启等问题，会对分布式系统中各节点对某一值达成一致性产生问题。</p><p>如何解决这一问题，这就要引出今天的主角——Paxos。</p><h1 id="关于-Paxos"><a href="#关于-Paxos" class="headerlink" title="关于 Paxos"></a>关于 Paxos</h1><p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/莱斯利·兰伯特">莱斯利·兰伯特open in new window</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p><p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p><p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p><p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p><p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">《The Part-Time Parliament》open in new window</a></p><p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">《Paxos Made Simple》open in new window</a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p><p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/paxos-made-simple-v2KTTWQx.png" alt="img"></p><blockquote><p>The Paxos algorithm, when presented in plain English, is very simple.</p></blockquote><p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p><p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p><hr><p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p><p>自Paxos问世以来就持续垄断了分布式一致性算法，Paxos 这个名词几乎等同于分布式一致性。</p><p>Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如<strong>Chubby</strong>、<strong>Megastore</strong>以及Spanner等。开源的<strong>ZooKeeper</strong>，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p><p>但是它也有两个明显的缺点：</p><ol><li>难以理解</li><li>在工程是实现上比较复杂。</li></ol><hr><p>回到上面的问题，在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序还有网络分区）等情况。</p><p>Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><blockquote><p>这里的<strong>某个数据</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令。根据场景的不同，<strong>某个数据的值</strong>有不同的含义。</p></blockquote><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308090054350-634944220.png" alt="img"></p><h2 id="Paxos-中的角色"><a href="#Paxos-中的角色" class="headerlink" title="Paxos 中的角色"></a>Paxos 中的角色</h2><p>在 Paxos 算法中，有三种角色：</p><ul><li>Proposer (提案者)</li><li>Acceptor (人大代表)</li><li>Learners (广大群众)</li></ul><p>需要注意的是，在具体的算法实现中，并不是一个进程只能担任一种角色，它有可能会同时充当多个。比如一个进程<strong>既是Proposer又是Acceptor还是Learner</strong>。</p><p>还有一个很重要的概念叫<strong>提案（Proposal）</strong>，最终要达成一致的 value 就在提案里。</p><p>这个提案到底是什么？是仅仅包含一个信息数值吗？目前咱们先认为仅仅是一个普普通通的 value。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308091709138-1381398784.png" alt="img"></p><p>Paxos 算法过程和我国的立法过程是极其相似的（法律案的提出、法律案的审议、法律案的表决、法律的公布四个阶段），所谓的提案就是新颁布法律。</p><p>Proposer (提案者)可以提出（propose）提案；Accoptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p><p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p><ul><li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li><li>Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。</li><li>Learner：作为一个学习者，Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li></ul><h2 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h2><p>假设有一组可以<strong>提出（propose）value</strong>的进程集合（提案者团队），一个一致性算法需要保证提出的这么多value中，仅仅<strong>只有一个相同的</strong>value被选定（chosen）。也就是说要么没有value被提出，只要提出了value并且被选定，那么大家最终学习到的value必须是一致的。对于一致性算法，<strong>安全性（safaty）</strong>要求如下：</p><ul><li>只有被提出的value才能被选定。</li><li>只有一个value被选定。</li><li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li></ul><blockquote><p>“Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>如果假设不同角色之间可以通过发送消息来进行通信，那么：</p><ul><li>每个角色以各自任意的速度进行通信执行，在这个过程中可能会因为各种原因出错而导致执行停止或重启。当一个value被选定之后，因为故障原因才恢复正常的角色因为失去了某些重要的信息，导致它们无法确定被选定的值。</li><li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li></ul><p>以上都是可能会遇到的问题，要怎么解决？？？</p><h1 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h1><h2 id="最简单的方案——只有一个-Acceptor"><a href="#最简单的方案——只有一个-Acceptor" class="headerlink" title="最简单的方案——只有一个 Acceptor"></a>最简单的方案——只有一个 Acceptor</h2><p>假设只有一个 Acceptor（可以有多个 Proposer），只要 Acceptor 接受它收到的第一提案，则该提案被选定，该提案中的 value 就是被选定的 value。这样就保证只有一个 value 会被选定。</p><p>但是，如果唯一的 Acceptor 宕机了，那么整个系统就<strong>无法工作</strong>了！</p><p>因此，一个 Acceptor 是不可行的，必须要有多个 Acceptor！</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308093407946-175720911.png" alt="img"></p><h2 id="多个-Acceptor"><a href="#多个-Acceptor" class="headerlink" title="多个 Acceptor"></a>多个 Acceptor</h2><p>当有多个 Acceptor 的时候，如何保证在多个 Proposal 和多个 Acceptor 的情况下选定一个 value。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308094655679-884014389.png" alt="img"></p><p>首先，我们的目标是无论有多少个 Proposal 提出天，有且仅有一个 value 被选定？</p><p>那么，我们可以先定义一个约束：</p><p><strong>“P1：一个 Acceptor 必须接受它受到的第一个提案。”</strong></p><p>但是，这样又会出现其他的问题：如果每个 Proposal 所提出的提案 value 是不同的，并且将提案发送给不同的 Acceptor。根据 P1 约束，每个 Acceptor 都接受它收到的第一个提案，就会出现不同的 value 被选定的情况不一样，出现了不一致。</p><p>为了解决新出现的问题，我们加入一个新的<strong>规定</strong>：</p><p><strong>“规定：一个提案被选定需要半数以上的 Acceptor 接受”</strong></p><p>一个提案被半数以上接受，说明『一个 Acceptor 必须能够接受不止一个提案！』，不然可能导致最终没有 value 被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个 Acceptor 的接受，并没有被超过半数以上的 Acceptor 接受。</p><p>最开始将【<strong>提案</strong> <strong>= value</strong>】已经无法满足现在的需求，因为当一个 Proposer 发送多个提案到一个 Acceptor 的时候，需要使用一个编号来区分被提出的顺序。现在【<strong>提案=提案编号+value</strong>】。</p><p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的 value 值，否则又会出现不一致。</p><p><strong>“P2：如果某个 value 为 v 的提案被选定了，那么每个编号更高的被选定提案的 value 必须也是 v”</strong></p><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><p><strong>“P2a：如果某个 value 为 v 的提案被选定了，那么每个编号更高的被 Acceptor 接受的提案的 value 必须也是 v。”</strong></p><p>只要满足了P2a，就能满足P2。</p><hr><p>但是，考虑如下的情况：以立法过程为背景，假设总的有5个人大代表（Acceptor）。</p><p><strong>人民法院</strong>（Proposer2）提出[M1,V1]的提案，<strong>人大代表2-5号</strong>（半数以上）均接受了该提案，于是对于人大代表2-5号和人民法院来讲，它们都认为V1提案是被选定的。此时，<strong>人大代表1</strong>在办完其它事务之后也参与到其中（之前人大代表1没有收到过任何提案），此时<strong>最高人民检察院</strong>（另一个提案者Proposer1）向人大代表1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于人大代表1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,人大代表1必须接受该提案！同时人大代表1认为V2被选定。这就出现了两个问题：</p><ol><li>人大代表1认为V2被选定，人大代表2-5和人民法院认为V1被选定。出现了不一致。</li><li>V1被选定了，但是编号更高的被人大代表1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308102821869-269261256.png" alt="img"></p><p>所以，我们要对 P2a 约束进行加强。</p><p>P2a 是对 Acceptor 接受的提案约束，但其实提案是 Proposer 提出来的，所有我们可以对 Proposer 提出的提案进行约束。得到 P2b：</p><p><strong>P2b：如果某个 value 为 v 的提案被选定了，那么之后任何 Proposer 提出的编号更高的提案的 value 必须也是 v。”</strong></p><p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p><p>只要满足P2c即可：</p><p><strong>“P2c：对于任意的 N 和 V，如果提案[N, V]被提出，那么存在一个半数以上的 Acceptor 组成的集合S，满足以下两个条件中的任意一个：</strong></p><ul><li><strong>S中每个 Acceptor 都没有接受过编号小于 N 的提案。</strong></li><li><strong>S中 Acceptor 接受过的最大编号的提案的 value 为 V。”</strong></li></ul><h2 id="Proposal-生成提案"><a href="#Proposal-生成提案" class="headerlink" title="Proposal 生成提案"></a>Proposal 生成提案</h2><p>为了满足 P2b，这里有个比较重要的思想：Proposal 生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的 value，然后以该 value 作为自己提出的提案的 value。如果没有 value 被选定，Proposal 才可以自己决定 value 的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p><p>于是我们得到了如下的<strong>提案生成算法：</strong></p><ul><li>Proposal 选择一个<strong>新的提案编号 N</strong>，然后向<strong>某个 Acceptor 集合</strong>（半数以上）发送请求，要求该集合中的每一个 Acceptor 做出以下响应（response）。<ul><li>向 Proposal 承诺保证<strong>不再接受</strong>任何编号<strong>小于 N 的提案</strong>。</li><li>如果 Acceptor 已经接受过提案，那么就向 Proposer 响应<strong>已经接受过</strong>的编号小于 N 的<strong>最大编号的提案</strong>。</li></ul></li></ul><p>我们将该请求成为<strong>编号 N </strong>的 <strong>Prepare 请求</strong>。 </p><ol><li>如果 Proposer 收到<strong>半数以上</strong>的 Acceptor 的响应，那么它就可以生成编号为 N， Value 为 V 的提案[N, V]。</li><li><strong>这里的 V 是所有的响应中编号最大的提案的 value</strong>。</li><li>如果所有的响应中<strong>都没有提案</strong>，那么此时 V 就可以由 Proposer <strong>自己选择</strong>(一般为当前提案)。</li><li>生成提案后，Proposer 将该<strong>提案</strong>发送给<strong>半数以上</strong>的 Acceptor 集合，并期望这些 Acceptor 能接受该提案。我们称该请求为<strong>Accept</strong>请求。（注意：此时接受 Accept 请求的 Acceptor 集合<strong>不一定</strong>是之前响应 Prepare 请求的 Acceptor 集合）。</li></ol><h2 id="Acceptor-接受提案"><a href="#Acceptor-接受提案" class="headerlink" title="Acceptor 接受提案"></a>Acceptor 接受提案</h2><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p><p>我们对Acceptor接受提案给出如下约束：</p><p><strong>“P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。”</strong></p><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p><p>因此，一个Acceptor<strong>只需记住</strong>：</p><ol><li>已接受的编号最大的提案</li><li>已响应的请求的最大编号。</li></ol><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>经过上面的推导，我们总结下Paxos算法的流程。</p><p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p><p><strong>阶段一：</strong></p><ol><li>Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</li><li>如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong> 作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</li></ol><p><strong>阶段二：</strong></p><ol><li>如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对[N,V]提案的Accept请求给<strong>半数以上</strong>的Acceptor（和之前的Acceptor不一定相同）。注意：V就是收到的响应中编号最大的提案的value，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</li><li>如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N的Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</li></ol><h2 id="算法实现流程"><a href="#算法实现流程" class="headerlink" title="算法实现流程"></a>算法实现流程</h2><ol><li>提议者发出提案，发起一次投票，发现者接收到投票请求，讲提案发给参与者；</li><li>参与者接收到投票请求后，会对提案进行投票，投票正确时发送投票确认消息；</li><li>发起者收到参与者发回的投票确认消息，如果收到确认消息超过半数，则发起者发出 accept 消息，将提案接受；</li><li>参与者接收到 accept 消息后，如果投票正确，则发送 accept 确认消息；</li><li>发起者收到 accept 确认消息后，如果收到的 accept 确认消息超过半数，则发起者发出 commit 消息，将提案接受，并执行操作；</li><li>参与者接收到 commit 消息后，如果投票正确，则发送 commit 确认消息；</li><li>发起者收到 commit 确认消息后，如果收到的 commit 确认消息超过半数，则发起者发出 ack 消息，将提案接受，并将操作结果返回给发起者；</li><li>参与者接收到 ack 消息后，如果投票正确，则发送 ack 确认消息；</li><li>发起者收到 ack 确认消息后，如果收到的 ack 确认消息超过半数，则发起者发出完成消息，将提案接受，并将操作结果返回给发起者，完成 Paxos 算法。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230308151245081-381992641.png" alt="img"></p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="Learner-如何学习被选定的-value？"><a href="#Learner-如何学习被选定的-value？" class="headerlink" title="Learner 如何学习被选定的 value？"></a>Learner 如何学习被选定的 value？</h2><p>Learner学习（获取）被选定的value有如下三种方案：</p><p><strong>方案一：</strong></p><p>Acceptor接受到一个提案，就将该提案发送给所有 Learners.</p><ul><li>优点：Learner 能够快速获取被选定的 value</li><li>缺点：通信次数为M*N（M为提案数，N为 Learner数）</li></ul><p><strong>方案二：</strong></p><p>Acceptor接受一个提案，就将提案发送给<strong>主Learner</strong>，主 Learner 再通知其它 Learner</p><ul><li>优点：通信次数减少（M+N-1）（M为提案数，N为Learner数，M个提案发送给主Learner，然后主Learner通知N-1个Learner）</li><li>缺点：单点故障问题（主Learner可能出现故障）</li></ul><p><strong>方案三：</strong></p><p>Acceptor接受一个提案，就将提案发送给<strong>Learner**</strong>团**,Learner团再通知其它Learner</p><ul><li>优点：解决了方案二单点故障问题，可靠性好</li><li>缺点：实现复杂，网络通信复杂度高</li></ul><h2 id="如何保证-Paxos-算法的活性？"><a href="#如何保证-Paxos-算法的活性？" class="headerlink" title="如何保证 Paxos 算法的活性？"></a>如何保证 Paxos 算法的活性？</h2><p>通过选取<strong>主Proposer</strong>，就可以保证Paxos算法的活性。通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/160088-20230310094013145-1967792588.png" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Paxos算法十分重要，现在很多一致性算法都是由其演变过来的，在互联网时代分布式环境应用非常广泛。但在查询资料时发现学习难度还是比较大的，主要是因为大家的文章写得都不太一样，加上大多都是抽象的描述，理解起来需要一点时间。</p><p>最近更新的频率明显变低了很多，其实是在转过头来学之前学过的东西，之前都是囫囵吞枣，重新看一遍会有很大的收获。</p><p>字节面试进三面了，这几天还是要好好把项目和基础知识搞明白，加油加油加油，祝我面试顺利！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在正式学习一致性算法之前，先来看一个问题。&lt;/p&gt;
&lt;p&gt;基于前面对分布式系统环境下一致性与共识算法的基础理论，在分布式系统中进行节点通信大部分采用基于消息传递通信模型，不可避免的会发生如进程可能会变慢、被杀死或者重启等问题，会对分布式系统中各节点对某一值达成一致性产生问题</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统——理论基础</title>
    <link href="http://example.com/2024/06/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/06/24/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2024-06-24T09:22:59.000Z</published>
    <updated>2024-06-25T15:04:36.569Z</updated>
    
    <content type="html"><![CDATA[<p>关于分布式系统相关的内容， 在之前的博客里面也提到过不少，主要包括一致性算法、分布式存储等相关的内容，但是对于分布式系统，并没有一个清晰的概念。今天主要来看一下分布式系统的基础概念和理论基础，分布式系统涉及很多的技术、理论和协议，很多人也说，分布式系统是“入门容易，深入难”，我之前的学习也只算是管中窥豹，只见得其中一斑。</p><p>在网上搜索“如何学习分布式系统”，看完之后还是觉得云里雾里，不进行记录不太容易理清楚这里边的内容。本系列的博客主要关注一些实际应用场景中的技术实现，偏向于算法方向，更多的还是作为了解的内容。</p><h1 id="什么是分布式系统？"><a href="#什么是分布式系统？" class="headerlink" title="什么是分布式系统？"></a>什么是分布式系统？</h1><blockquote><p>一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样。</p><p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。</p></blockquote><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。简单来说就是<strong>一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样</strong>。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p><p>从分布式系统的概念中我们知道，各个主机之间通信和协调主要通过网络进行，所以分布式系统中的计算机在空间上几乎没有任何限制，这些计算机可能被放在不同的机柜上，也可能被部署在不同的机房中，还可能在不同的城市中，对于大型的网站甚至可能分布在不同的国家和地区。</p><p>在很多文章中，主要讲分布式系统分为分布式计算（computation）与分布式存储（storage）。计算与存储是相辅相成的，计算需要数据，要么来自实时数据（流数据），要么来自存储的数据；而计算的结果也是需要存储的。在操作系统中，对计算与存储有非常详尽的讨论，分布式系统只不过将这些理论推广到多个节点罢了。</p><p>那么分布式系统怎么将任务分发到这些计算机节点呢，很简单的思想，分而治之，即分片（<strong>partition）</strong>。对于计算，那么就是对计算任务进行切换，每个节点算一些，最终汇总就行了，这就是MapReduce的思想；对于存储，更好理解一下，每个节点存一部分数据就行了。当数据规模变大的时候，Partition是唯一的选择，同时也会带来一些好处：</p><ol><li><p>提升性能和并发，操作被分发到不同的分片，相互独立</p></li><li><p>提升系统的可用性，即使部分分片不能用，其他分片不会受到影响</p></li></ol><p>理想的情况下，有分片就行了，但事实的情况却不大理想。原因在于，分布式系统中有大量的节点，且通过网络通信。单个节点的故障（进程crash、断电、磁盘损坏）是个小概率事件，但整个系统的故障率会随节点的增加而指数级增加，网络通信也可能出现断网、高延迟的情况。在这种一定会出现的“异常”情况下，分布式系统还是需要继续稳定的对外提供服务，即需要较强的容错性。最简单的办法，就是冗余或者复制集（<strong>Replication</strong>），即多个节点负责同一个任务，最为常见的就是分布式存储中，多个节点复杂存储同一份数据，以此增强可用性与可靠性。同时，Replication也会带来性能的提升，比如数据的locality可以减少用户的等待时间。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1089769-20171108093209200-1813701105.png" alt="img"></p><p>Partition和Replication是解决分布式系统问题的一记组合拳，很多具体的问题都可以用这个思路去解决。但这并不是银弹，往往是为了解决一个问题，会引入更多的问题，比如为了可用性与可靠性保证，引用了冗余（复制集）。有了冗余，各个副本间的一致性问题就变得很头疼，一致性在系统的角度和用户的角度又有不同的等级划分。如果要保证强一致性，那么会影响可用性与性能，在一些应用（比如电商、搜索）是难以接受的。如果是最终一致性，那么就需要处理数据冲突的情况。CAP、FLP这些理论告诉我们，在分布式系统中，没有最佳的选择，都是需要权衡，做出最合适的选择。</p><h2 id="分布式系统的主要特征"><a href="#分布式系统的主要特征" class="headerlink" title="分布式系统的主要特征"></a>分布式系统的主要特征</h2><blockquote><p>无论空间上如何分布，一个标准的分布式系统应该具有以下几个主要特征</p></blockquote><ul><li><strong>分布性</strong></li></ul><p>分布式系统中的多台计算机之间在空间位置上可以随意分布，同时，机器的分布情况也会随时变动。</p><ul><li><strong>对等性</strong></li></ul><p>分布式系统中的计算机没有主／从之分，即没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。数据副本是指在不同节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</p><ul><li><strong>自治性</strong></li></ul><p>分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。</p><ul><li><strong>并发性</strong></li></ul><p>在一个计算机网络中，程序运行过程的并发性操作是非常常见的行为。例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。</p><h2 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h2><ul><li><strong>缺乏全局时钟</strong></li></ul><p>在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。</p><ul><li><strong>机器宕机</strong></li></ul><p>机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</p><ul><li><strong>网络异常</strong></li></ul><p>消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</p><ul><li><strong>分布式三态</strong></li></ul><p>如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</p><ul><li><strong>存储数据丢失</strong></li></ul><p>对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。 <em>异常处理原则</em>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</p><h2 id="衡量分布式系统的指标"><a href="#衡量分布式系统的指标" class="headerlink" title="衡量分布式系统的指标"></a>衡量分布式系统的指标</h2><ul><li><strong>性能</strong></li></ul><p>系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</p><ul><li><strong>可用性</strong></li></ul><p>系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</p><ul><li><strong>可扩展性</strong></li></ul><p>系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</p><ul><li><strong>一致性</strong></li></ul><p>分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单。</p><h1 id="分布式基础理论"><a href="#分布式基础理论" class="headerlink" title="分布式基础理论"></a>分布式基础理论</h1><h2 id="同步-异步系统模型"><a href="#同步-异步系统模型" class="headerlink" title="同步/异步系统模型"></a>同步/异步系统模型</h2><p><strong>同步系统模型：</strong>指系统中的各个节点的时钟误差存在上限，并且消息传递必须在一定时间内完成，否则认为失败；同时各个节点完成处理消息的时间是一定的。因此同步系统中可以很容易地判断消息是否丢失。</p><p><strong>异步系统模型</strong>：系统中各个节点可能存在较大的时钟差异；同时消息传输时间是任意长的；各节点对消息进行处理的时间也可能是任意长的。这就造成无法判断某个消息迟迟没有被响应是哪里出了问题（节点故障还是传输故障）。现实生活中的系统往往都是异步系统。</p><h2 id="FLP-不可能原理"><a href="#FLP-不可能原理" class="headerlink" title="FLP 不可能原理"></a>FLP 不可能原理</h2><p>由 Fischer，Lynch 和 Patterson 三位科学家发表的《Impossibility of Distributed Consensus with One Faulty Process》论文中提出，<strong>在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法</strong>。</p><p><strong>描述</strong>：FLP不可能原理假定节点只能因崩溃而失败； 网络可靠，并且异步系统模型的典型时序假设成立：例如，消息延迟没有限制的情况下，假设有A、B、C三个节点进行投票，A投票0，B投票1，而C收到了A与B的投票却没办法响应，A与B就没办法在有限的时间内获知最终结果；如果进行重新投票，类似的情况重复发生，则永远无法达到共识。</p><p>FLP 不可能原理的意义在于，告诉我们不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。</p><h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><p><strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点，只能满足三项中的两项：</p><ul><li><strong>一致性（Consistency）</strong> : 任何事务都应该是原子的，所有副本上的状态都是事务成功提交后的结果，并保持强一致性。</li><li><strong>可用性（Availability）</strong> : 系统正常节点能在有限时间内完成对操作请求的应答。</li><li><strong>分区容错性（Partition tolerance）</strong> : 系统中的网络可能发生分区故障（成为多个子网、节点上线和下线），节点之间的通信无法保障，而网络故障不应该影响到系统正常服务。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/8311955763f46820c7886b8e69f4dbf8_MD5.png" alt="图片"></p><p><strong>CAP理论证明</strong>：</p><p>假设有两个通信中的节点出现了网络分区的情况，如果允许其中一个节点更新状态，则需要舍弃一致性（C）；如果为了保证数据一致性，将分区的节点设置为不可用，就需要舍弃可用性（A）；如果两个节点可以互相通信，才能既保证一致性又保证可用性，会丧失分区容错性（P）。</p><p><strong>三类系统模型</strong></p><ul><li>CA（一致性+可用性）：包括完全严格的仲裁协议，例如<strong>2PC（两阶段提交）</strong>。</li><li>CP（一致性+分区容错性）： 包括多数仲裁协议，其中少数分区不可用，<strong>例如Paxos</strong>。</li><li>AP（可用性+分区容错性）： 包括执行最终一致性的协议，<strong>例如Gossip</strong>。</li></ul><p><strong>CA\CP区别</strong>：CA和CP系统设计均提供相同的一致性模型：高度一致性。 唯一的区别是CA系统不能容忍任何节点故障。 CP系统可以容忍 <strong>f</strong> 在给定 <strong>2f+1</strong> 在非拜占庭式故障模型中。</p><p><strong>场景</strong></p><ul><li>CA：弱化了分区容错性，早期分布式关系数据库系统中使用的许多系统设计如两阶段提交，都没有考虑分区容错性。 分区容错性是现代系统的重要属性，因为如果系统在多个地理环境上分布，网络分区出现的概览就会加大。</li><li>CP：弱化了可用性，一些对结果一致性很敏感的应用会选择基于此模型设计，当系统出现故障时会拒绝服务；Paxos、Raft 等共识算法，以及HBase、MongoDB等基于此模型设计。</li><li>AP：弱化了一致性，一些对结果一致性不敏感的应用会选择基于此模型设计，可以允许在新版本上线后过一段时间才最终更新成功，期间不保证一致性；分布式同步协议如 Gossip，以及DynamoDB、 CouchDB、Cassandra 数据库等基于此模型设计。</li></ul><h2 id="ACID原则与BASE原则"><a href="#ACID原则与BASE原则" class="headerlink" title="ACID原则与BASE原则"></a>ACID原则与BASE原则</h2><p><strong>ACID原则</strong></p><p>ACID 即 Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）四种特性的缩写，一般出现在分布式数据库等基于事务过程的系统中；ACID 原则描述了分布式数据库需要满足的一致性需求，同时允许付出可用性的代价。</p><ul><li><strong>Atomicity</strong>: 每次事务是原子的，事务包含的所有操作要么全部成功，要么全部不执行。一旦有操作失败，则需要回退状态到执行事务之前；</li><li><strong>Consistency</strong>: 数据库的状态在事务执行前后的状态是一致的和完整的，无中间状态。即只能处于成功事务提交后的状态；</li><li><strong>Isolation</strong>: 各种事务可以并发执行，但彼此之间互相不影响。按照标准 SQL 规范，从弱到强可以分为未授权读取、授权读取、可重复读取和串行化四种隔离等级；</li><li><strong>Durability</strong>: 状态的改变是持久的，不会失效。一旦某个事务提交，则它造成的状态变更就是永久性的。</li></ul><p><strong>BASE原则</strong></p><p>BASE即 Basic Availability（基本可用），Soft-state（弱状态），Eventual Consistency（最终一致性），为 eBay 技术专家 Dan Pritchett 提出的与ACID相对的一个原则，主要面向大型高可用分布式系统，主张牺牲掉对强一致性的追求，而实现最终一致性，来换取一定的可用性。</p><ul><li>Basic Availability：系统在出现不可预知的故障时候，允许损失部分可用性，保证核心服务可用。</li><li>Soft-state：允许系统在不同节点的数据副本之间进行数据同步的过程中存在延时（允许系统中的数据存在中间状态，不会影响系统的整体可用性）。</li><li>Eventual Consistency：系统中所有的数据副本，在进过一段时间的同步后，最终能够达到一个一致的状态。</li></ul><h1 id="分布式系统下的一致性问题"><a href="#分布式系统下的一致性问题" class="headerlink" title="分布式系统下的一致性问题"></a>分布式系统下的一致性问题</h1><p>一致性为在分布式系统领域中对于多个服务节点，给定一系列操作，在约定协议的保障下，使得它们对处理结果达成某种程度的协同。</p><p>分布式系统中的节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：进程可能会响应慢、被杀死或者重启，消息可能会延迟、丢失、重复；发生上面任意一种异常都会对分布式系统中各个节点对某一个值达成一致性产生问题。</p><p><strong>一致性的要求</strong>：</p><ul><li>可终止性（Termination）：一致的结果在有限时间内能完成（可以保障提供服务的（Liveness））</li><li>约同性（Agreement）：不同节点最终完成决策的结果是相同的（意味着算法要么不给出结果，任何给出的结果必定是达成了共识的，即安全性（Safety））</li><li>合法性（Validity）：决策的结果必须是某个节点提出的提案（即达成的结果必须是节点执行操作的结果）</li></ul><p>解决一致性问题的核心在于对不同空间发生的事件进行全局唯一排序。</p><p><strong>一致性模型</strong>：</p><ul><li>强一致性模型<ul><li>顺序一致性：所有操作都以某种顺序原子执行，该顺序与各个节点上看到的顺序一致，并且在所有节点上都相等；可以基于<a href="https://en.wikipedia.org/wiki/Lamport_timestamp">Lamport timestamp</a> 即逻辑时钟进行实现。</li><li>线性一致性：所有操作都按照操作的全局实时顺序一致的顺序自动执行；在顺序一致性前提下加强了进程间的操作排序，形成唯一的全局顺序；依赖于全局的时钟或锁，有很强的原子性保证，但是比较难实现。</li></ul></li><li>弱一致性模型<ul><li>最终一致性：在未来的某个时间点进行冲突检测和修正，如DNS</li><li>客户端为中心型一致性：通过在client端库中建立额外的缓存来实现，如亚马逊Dynamo</li></ul></li></ul><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><h3 id="共识（Consensus）与一致性（Consistency）"><a href="#共识（Consensus）与一致性（Consistency）" class="headerlink" title="共识（Consensus）与一致性（Consistency）"></a>共识（Consensus）与一致性（Consistency）</h3><p>一致性：含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。在分布式系统场景下，一致性指的是多个副本对外呈现的状态。如之前提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。</p><p>共识：特指在分布式系统中多个节点之间对某个事情达成一致看法的过程。需注意达成某种共识并不意味着就保障了一致性。</p><h3 id="共识算法解决的问题"><a href="#共识算法解决的问题" class="headerlink" title="共识算法解决的问题"></a>共识算法解决的问题</h3><p>共识算法解决的是分布式系统对某个提案（Proposal），大部分节点达成一致意见的过程。提案泛指多个事件发生的顺序、某个键对应的值…对于分布式系而言，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。</p><p>这里共识算法需要解决两个基本问题：</p><ol><li>如何提出一个待共识的提案（令牌传递、随机选取…）</li><li>如何让多个节点对提案达成共识（投票、规则验证…）</li></ol><p>现实网络环境中存在各种各样的问题，在分布式环境下，共识算法还需要解决如通信问题（网络中断、分区）、节点故障、消息伪造…</p><h3 id="共识算法分类"><a href="#共识算法分类" class="headerlink" title="共识算法分类"></a>共识算法分类</h3><p>根据是否允许拜占庭错误（伪造信息恶意响应）的情况，共识算法分为 Crash Fault Tolerance 崩溃容错 (CFT) 和 Byzantine Fault Tolerance（BFT）两类。</p><p>Crash Fault Tolerance (CFT) 算法：Paxos、Raft、ZAB…</p><p>Byzantine Fault Tolerance(BFT) 算法：PBFT为代表的确定性系列算法、PoW为代表的概率算法…</p><h1 id="核心问题-复制"><a href="#核心问题-复制" class="headerlink" title="核心问题-复制"></a>核心问题-复制</h1><p><strong>为什么核心问题是复制</strong>：在文章开头我们说过，分布式系统采用分片来将任务分发到这些计算机节点，为了实现高可用，又引入了冗余。分布式存储相关的系统都必须用某种冗余的方式在廉价硬件的基础上搭建高可靠的存储，而冗余的基础就是复制（多副本策略）, 一份数据存多份. 多副本保证了可靠性, 而副本之间的一致, 就需要各种分布式共识算法来保证。</p><p>复制是一个组通信问题。需要考虑哪种通信方式可以为我们提供我们想要的性能和可用性特性？面对网络分区以及节点同时发生故障，我们如何确保容错性，持久性以及避免分歧。</p><h2 id="基本复制方式"><a href="#基本复制方式" class="headerlink" title="基本复制方式"></a>基本复制方式</h2><ul><li>同步复制：强持久化保证，系统响应慢，对网络延迟敏感</li><li>异步复制：弱持久化保证，性能高，对网络延迟更加宽容</li></ul><h2 id="基本复制算法"><a href="#基本复制算法" class="headerlink" title="基本复制算法"></a>基本复制算法</h2><p>基本复制算法大致可以分为两类：Replication methods that prevent divergence (single copy systems) 防止差异的复制方式（单拷贝系统）与Replication methods that risk divergence (multi-master systems) 有差异风险的复制方式（多主系统）</p><h3 id="Replication-Methods-that-Prevent-Divergence-single-Copy-systems"><a href="#Replication-Methods-that-Prevent-Divergence-single-Copy-systems" class="headerlink" title="Replication Methods that Prevent Divergence (single Copy systems)"></a>Replication Methods that Prevent Divergence (single Copy systems)</h3><blockquote><p>防止差异的复制方式（单拷贝系统）</p></blockquote><p>对外表现得像一个单独的系统；当部分故障发生时，系统确保只有一个系统副本处于活动状态；系统需要确保副本始终保持一致，基于某一种共识算法去实现，一般有如下几种方式：</p><h4 id="Master-Slave（主从复制）"><a href="#Master-Slave（主从复制）" class="headerlink" title="Master/Slave（主从复制）"></a>Master/Slave（主从复制）</h4><p>所有更新都在主服务器上执行，操作日志(或者更改)通过网络传送到备份副本；涉及两种相关的变体异步主/备份、同步主/备份、半同步主/备复制。</p><ol><li>同步复制: 直到数据真的安全的复制到全部的机器上之后, master才告知客户端数据已经完成同步</li></ol><p>   <img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/bbc18660dac576b06b99dc0fc13ded8f_MD5.png" alt="image"></p><p>   问题：强一致性持久化保证，但是系统响应慢，对网络延迟的变化非常敏感；并且系统的可用性随着副本数量指数降低，任何一个机器的宕机都会影响到整个系统的写入。</p><ol><li>异步复制: master将更新存储在本地后立即向客户端发回响应，master在之后才进行异步复制到全部的机器上。</li></ol><p>   <img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c5807e8ee0565c259a9d525df73c06c0_MD5.png" alt="image"></p><p>   问题：性能高，但是为弱一致性持久化保证，数据存在丢失风险，会造成数据不一致的情况。</p><ol><li>半同步复制：要求master在应答客户端之前必须把数据复制到足够多的机器上, 而非全部机器. 这样副本数够多可以提供比较高的可靠性; 1台机器宕机也不会让整个系统停止写入; 但系统中还是会存在数据不一致的情况。</li></ol><h4 id="2-phase-commit（两阶段提交）"><a href="#2-phase-commit（两阶段提交）" class="headerlink" title="2-phase commit（两阶段提交）"></a>2-phase commit（两阶段提交）</h4><p>阶段一：投票阶段，协调人向所有参与者发送更新信息。每个参与者处理更新，并投票决定是提交还是放弃。当投票决定提交时，参与者将更新存储到一个临时区域（write-ahead log）。</p><p>阶段二：协调程序决定结果并通知每个参与者。如果所有参与者投票提交，那么更新将从临时区域获得并永久化。</p><p>问题：强一致性持久化保证，但是系统响应慢，对网络延迟的变化非常敏感；系统的可用性随着副本数量指数降低</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ Coordinator ] -&gt; OK to commit?     [ Peers ]</span><br><span class="line">                &lt;- Yes / No</span><br><span class="line">[ Coordinator ] -&gt; Commit / Rollback [ Peers ]</span><br><span class="line">                &lt;- ACK</span><br></pre></td></tr></table></figure><h4 id="Quorum机制（多数派）"><a href="#Quorum机制（多数派）" class="headerlink" title="Quorum机制（多数派）"></a>Quorum机制（多数派）</h4><p><strong>Quorum</strong> 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理；在分布式系统中，Quorum常用于副本的读写控制，容忍最多 <code>(N-1)/2</code> 个节点损坏。</p><p>假设每份数据有V个副本，每个副本对应一票，读、写操作首先要请求副本以获取其票数，定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read quorum R（最小读票数）：读操作获取的票数必须大于该值才允许读；</span><br><span class="line">write quorum W（最小写票数）：写操作获取的票数必须大于该值才允许写；</span><br></pre></td></tr></table></figure><p>V、R、W必须满足：</p><ul><li><code>R + W &gt; V</code>：保证对于每份数据，不会 同时读和写（当一个写操作请求过来的时候，它必须要获得W个写票。而剩下的数量是V-W是不够R的，因此不能再有读请求过来了）。</li><li><code>W &gt; V / 2</code>：保证对于每份数据，不会同时出现 两个写，即写操作是串行的</li></ul><p><strong>其他</strong></p><ul><li>没有规定 <code>R &gt; V / 2</code>，quorum 机制允许 多个读同时发生，即允许 并发读；</li><li>考虑write -&gt; read序列，因为<code>R + W &gt; V</code>，因此 W 和 V 之间至少有一个重叠（鸽巢原理），从而保证 write 之后，read 操作至少会获取一个最新副本；</li><li>在做复制冗余的时候，借助 Quorum 机制，5 个副本只需要完成 3 个写即可响应成功，提升了写操作的响应速度，又没有减弱可靠性；Quorum 机制本质上是把写负载转移到了读负载的一种设计权衡。</li></ul><p><strong>问题</strong>：</p><ul><li>读取不一致状态情况：对于一条数据的更新时, 会产生不一致的状态问题：如第一次client update，nodeA、nodeB写入a=x；第二次client update，nodeB、nodeC写入a=y；如果读取a的客户端联系到nodeA和nodeB，会得到不一致的数据（解决：对每次的写入增加全局时间戳，以后写入的优先）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeA: a=x 1577851200000</span><br><span class="line">nodeB: a=y 1577851230000</span><br><span class="line">nodeC: a=y 1577851230000</span><br></pre></td></tr></table></figure><ul><li>多数派写异常情况：在完成一起完整的多数派写时，发生写入异常，会产生不一致的状态问题：如第一次client update，nodeA、nodeB写入a=x；第二次client update，nodeB、nodeC写入a=y；但是只有nodeC写入成功了，然后client abort了，这时候另一个client 读取到nodeA与nodeB得到的结果与读取到nodeB与nodeC的不一致。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeA: a=x 1577851200000</span><br><span class="line">nodeB: a=x 1577851200000</span><br><span class="line">nodeC: a=y 1577851230000</span><br></pre></td></tr></table></figure><ul><li>并发环境下，因为无法保证顺序执行，所以无法保证系统的正确性。</li></ul><p><strong>结论</strong></p><p>Quorum机制无法保证强一致性，即无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据；后续Paxos对Quorum机制进行了改进，通过2次多数派读写, 实现了严谨的强一致共识算法。</p><h3 id="Replication-Methods-that-risk-Divergence-multi-master-systems"><a href="#Replication-Methods-that-risk-Divergence-multi-master-systems" class="headerlink" title="Replication Methods that risk Divergence (multi-master systems)"></a>Replication Methods that risk Divergence (multi-master systems)</h3><blockquote><p>有差异风险的复制方式（多主系统）</p></blockquote><h4 id="Gossip算法"><a href="#Gossip算法" class="headerlink" title="Gossip算法"></a>Gossip算法</h4><p>Gossip算法Palo Alto研究中心在论文《Epidemic Algorithms for Replicated Database Maintenance》中提出的一种用于分布式数据库在多节点间复制同步数据的算法；特点是要同步的信息如同流言一般传播，最终一致性。</p><p>具体的工作过程如下：</p><ol><li>如果有某一项信息需要在整个网络中所有节点中传播，那从信息源开始，选择一个固定的传播周期（如1秒），随机选择它 相连接的k个节点（称为Fan-Out）进行消息传播。</li><li>每一个节点收到消息后，如果这个消息是它之前没有收到过的，将在下一个周期内，选择除了发送消息给它的那个节点外的 其他相邻k个节点发送相同的消息，理论上最终网络的所有节点都会拥有相同的消息。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/29c4dbf98502c1e297c1fe9c200c0ea3_MD5.png" alt="image"></p><p>上图从一致性、延迟、吞吐量、数据丢失和故障转移对比了各个类型共识算法实现。</p><h1 id="用一个请求串起来"><a href="#用一个请求串起来" class="headerlink" title="用一个请求串起来"></a>用一个请求串起来</h1><p>假设这是一个对外提供服务的大型分布式系统，用户连接到系统，做一些操作，产生一些需要存储的数据，那么在这个过程中，会遇到哪些组件、理论与协议呢？</p><p>用户使用Web、APP、SDK，通过HTTP、TCP连接到系统。在分布式系统中，为了高并发、高可用，一般都是多个节点提供相同的服务。那么，第一个问题就是具体选择哪个节点来提供服务，这个就是负载均衡（load balance）。负载均衡的思想很简单，但使用非常广泛，在分布式系统、大型网站的方方面面都有使用，或者说，只要涉及到多个节点提供同质的服务，就需要负载均衡。</p><p>通过负载均衡找到一个节点，接下来就是真正处理用户的请求，请求有可能简单，也有可能很复杂。简单的请求，比如读取数据，那么很可能是有缓存的，即分布式缓存，如果缓存没有命中，那么需要去数据库拉取数据。对于复杂的请求，可能会调用到系统中其他的服务。</p><p>承上，假设服务A需要调用服务B的服务，首先两个节点需要通信，网络通信都是建立在TCP/IP协议的基础上，但是，每个应用都手写socket是一件冗杂、低效的事情，因此需要应用层的封装，因此有了HTTP、FTP等各种应用层协议。当系统愈加复杂，提供大量的http接口也是一件困难的事情。因此，有了更进一步的抽象，那就是RPC（remote produce call），是的远程调用就跟本地过程调用一样方便，屏蔽了网络通信等诸多细节，增加新的接口也更加方便。</p><p>一个请求可能包含诸多操作，即在服务A上做一些操作，然后在服务B上做另一些操作。比如简化版的网络购物，在订单服务上发货，在账户服务上扣款。这两个操作需要保证原子性，要么都成功，要么都不操作。这就涉及到分布式事务的问题，分布式事务是从应用层面保证一致性：某种守恒关系。</p><p>上面说道一个请求包含多个操作，其实就是涉及到多个服务，分布式系统中有大量的服务，每个服务又是多个节点组成。那么一个服务怎么找到另一个服务（的某个节点呢）？通信是需要地址的，怎么获取这个地址，最简单的办法就是配置文件写死，或者写入到数据库，但这些方法在节点数据巨大、节点动态增删的时候都不大方便，这个时候就需要服务注册与发现：提供服务的节点向一个协调中心注册自己的地址，使用服务的节点去协调中心拉取地址。</p><p>从上可以看见，协调中心提供了中心化的服务：以一组节点提供类似单点的服务，使用非常广泛，比如命令服务、分布式锁。协调中心最出名的就是chubby，zookeeper。</p><p>回到用户请求这个点，请求操作会产生一些数据、日志，通常为信息，其他一些系统可能会对这些消息感兴趣，比如个性化推荐、监控等，这里就抽象出了两个概念，消息的生产者与消费者。那么生产者怎么讲消息发送给消费者呢，RPC并不是一个很好的选择，因为RPC肯定得指定消息发给谁，但实际的情况是生产者并不清楚、也不关心谁会消费这个消息，这个时候消息队列就出马了。简单来说，生产者只用往消息队列里面发就行了，队列会将消息按主题（topic）分发给关注这个主题的消费者。消息队列起到了异步处理、应用解耦的作用。</p><p>上面提到，用户操作会产生一些数据，这些数据忠实记录了用户的操作习惯、喜好，是各行各业最宝贵的财富。比如各种推荐、广告投放、自动识别。这就催生了分布式计算平台，比如Hadoop，Storm等，用来处理这些海量的数据。</p><p>最后，用户的操作完成之后，用户的数据需要持久化，但数据量很大，大到按个节点无法存储，那么这个时候就需要分布式存储：将数据进行划分放在不同的节点上，同时，为了防止数据的丢失，每一份数据会保存多分。传统的关系型数据库是单点存储，为了在应用层透明的情况下分库分表，会引用额外的代理层。而对于NoSql，一般天然支持分布式。</p><h2 id="一个简化的架构图"><a href="#一个简化的架构图" class="headerlink" title="一个简化的架构图"></a>一个简化的架构图</h2><p>　　下面用一个不大精确的架构图，尽量还原分布式系统的组成部分（不过只能体现出技术，不好体现出理论）</p><p> <img src="https://images2017.cnblogs.com/blog/1089769/201711/1089769-20171110170521606-1076859931.png" alt="img"></p><h2 id="概念与实现"><a href="#概念与实现" class="headerlink" title="概念与实现"></a>概念与实现</h2><p>那么对于上面的各种技术与理论，业界有哪些实现呢，下面进行简单罗列。</p><p>当然，下面的这些实现，小部分我用过，知其所以然；大部分听说过，知其然；还有一部分之前闻所未闻，分类也不一定正确，只是从其他文章抄过来的。罗列在这里，以便日后或深或浅的学习。</p><ul><li><p>负载均衡：</p><ul><li><p>Nginx：高性能、高并发的web服务器；功能包括负载均衡、反向代理、静态内容缓存、访问控制；工作在应用层</p></li><li><p>LVS： Linux virtual server，基于集群技术和Linux操作系统实现一个高性能、高可用的服务器；工作在网络层</p></li></ul></li><li><p>webserver：</p><ul><li>Java：Tomcat，Apache，Jboss</li><li>Python：gunicorn、uwsgi、twisted、webpy、tornado</li></ul></li><li><p>service：　　</p><ul><li>SOA、微服务、spring boot，django</li></ul></li><li><p>容器：</p><ul><li>docker，kubernetes</li></ul></li><li><p>cache：</p><ul><li>memcache、redis等</li></ul></li><li><p>协调中心：</p><ul><li>zookeeper、etcd等</li><li>zookeeper使用了Paxos协议Paxos是强一致性，高可用的去中心化分布式。zookeeper的使用场景非常广泛，之后细讲。</li></ul></li><li><p>rpc框架：</p><ul><li>grpc、dubbo、brpc</li><li>dubbo是阿里开源的Java语言开发的高性能RPC框架，在阿里系的诸多架构中，都使用了dubbo + spring boot</li></ul></li><li><p>消息队列：</p><ul><li>kafka、rabbitMQ、rocketMQ、QSP</li><li>消息队列的应用场景：异步处理、应用解耦、流量削锋和消息通讯</li></ul></li><li><p>实时数据平台：</p><ul><li>storm、akka</li></ul></li><li><p>离线数据平台：</p><ul><li>hadoop、spark</li><li>PS: apark、akka、kafka都是scala语言写的，看到这个语言还是很牛逼的</li></ul></li><li><p>dbproxy：</p><ul><li>cobar也是阿里开源的，在阿里系中使用也非常广泛，是关系型数据库的sharding + replica 代理</li></ul></li><li><p>db：</p><ul><li>mysql、oracle、MongoDB、HBase</li></ul></li><li><p>搜索：</p><ul><li>elasticsearch、solr</li></ul></li><li><p>日志：</p><ul><li>rsyslog、elk、flume</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习分布式系统还是比较困难的，资料少而且实战的机会也不多，多以更多还是停留在纸面上的一些东西，所以我们在开头也提到了，本系列的博客更多还是关注分布式系统在实际生产环境中的一些使用方式。</p><p>有了坏消息，就必然会有好消息。坏消息是腾讯的两个全都挂了，好消息是今天字节跳动约了二面，但是我心里没底，害怕又像腾讯二面一样，所以明天和后天上午还是好好看一下八股和项目。一直说已经把项目吃透了，其实并没有，下次面试的时候一定要详细地讲自己的项目，技术选型和数据结构都要说，不能再省略过去了。自信点、自信点、自信点，不要说着说着就没声音了，哪怕不会也不能没气势。进字节不就是一开始学 Go 的原因吗，好好珍惜这次机会。加油，祝我面试成功！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于分布式系统相关的内容， 在之前的博客里面也提到过不少，主要包括一致性算法、分布式存储等相关的内容，但是对于分布式系统，并没有一个清晰的概念。今天主要来看一下分布式系统的基础概念和理论基础，分布式系统涉及很多的技术、理论和协议，很多人也说，分布式系统是“入门容易，深入难”</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯面试(三)</title>
    <link href="http://example.com/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/"/>
    <id>http://example.com/2024/06/24/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95-%E4%B8%89/</id>
    <published>2024-06-24T07:44:25.000Z</published>
    <updated>2024-06-25T14:17:57.944Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯二面，没想到上次面试还有下文，隔了四天，周日晚上约今天的面试，那时我还躺在南昌酒店的床上享受着美好的假期生活。腾讯是真给机会啊，面完的感受，觉得还是差太多了，面试官问的问题我甚至都没听懂，不知道为什么，感觉很奇怪。面试时间不长，面试官也没开摄像头，没有自我介绍，直接开始拷打项目，但是也没有问什么深入的内容，就让自己介绍、有什么收获、重做一遍会有什么改进、做了多长时间等等，后面问一些八股，答得也不好，二十五分钟结束面试。反问项目组用什么语言、做什么内容，主要用 Go 和 C++，做一些关于大数据的内容（这不刚好吗，我可是千年学府、百年名校的湖南大学的第二届大数据学生）。</p><p>由于问题并不是很多，而且问题好像也不是很难，只是我没懂面试官的意思，脑子坏掉了，我就说我总是关键时刻掉链子。所以就简单记录一下都问了什么问题吧。</p><ol><li>挑一个项目介绍一下。<ul><li>传统项目了，果断挑选博客系统，巴拉巴拉介绍完。</li></ul></li><li>介绍一下项目里用到的数据结构和技术选型。<ul><li>太专业了，脑子没转过来也不知道怎么回答了，就讲了一下GET、POST请求，想继续讲登录操作，被打断了，可能是我太啰嗦了。</li></ul></li><li>项目里前端和后端是怎么通信的，用的是什么协议。<ul><li>这个问题我就更是一头雾水了，没明白什么意思，来回确认了三次我都没动要怎么回答。面试官问用的是 http 协议吗，我说是。中间还说到了 Ngnix，给面试官整笑了，反正这个问题从头到尾我都没明白是怎么回事，后面搜了一下，大概懂了。可能是要我说 http 协议和 RESTful 规范之类的吧。</li></ul></li><li>有没有考虑过项目中的架构问题。<ul><li>说实话，从来没有考虑过这些方面的内容，这个项目连部署我都没做。后面就说有学过秒杀系统的一些架构问题，不知道能不能用到这个上面。</li></ul></li><li>用户登录之后会看到什么？每个用户看到的都一样吗？在拉取文章列表的时候有看过性能方面的问题吗？<ul><li>用户登陆后会看到MySQL中存储的文章，每个用户看到的都一样，因为是直接从MySQL中拉取出来的。</li><li>性能方面的问题并没有去考量，脑子一抽说成了是一次性把所有数据拉去出来，其实在做的时候是设计了分页功能，先拉取一页的内容，后面再看的时候再拉取，我是傻逼，脑子跟不上嘴。</li></ul></li><li>为什么要用 MySQL 来做数据库存储？为什么不用其他的数据库？<ul><li>我知道这里面试官想要我去分析主流的数据库的优缺点，但是选择 MySQL 就是因为我当时只会 MySQL。</li><li>分析了 MongoDB 和 MySQL 的一些区别，就说为了学习效率考虑就选择已经学会的MySQL，而不是MongoDB。</li></ul></li><li>项目一共做了多久？有什么收获？如果重新做一遍会对那些地方进行改进？<ul><li>项目一共做了不到两个月，收获还是很多的，嘴瓢说的含糊不清。主要就是 Go 语言、常用库、数据库、学习能力的提升。</li><li>重做一遍会更多关注在性能上，也会结合实际情况加入更多的功能，补充前端的东西。</li></ul></li><li>八股就问了三个：Linux查看进程占用CPU情况的命令。进程有哪几种状态？端口在TCP/IP协议中的那一层？<ul><li>第一个问题，确实没怎么用过命令行，所以直接回答了不知道，实际是用 <code>top</code> 和 <code>ps</code> 命令。</li><li>三种状态，更扩展的就不记得了，阻塞不能直接到运行状态。</li><li>回答了四元组，说确定端口号和IP地址，脑子一抽胡说了个网络层和链路层，其实是传输层，一边回答着传输要用到四元组，一边回答另外的东西。</li></ul></li><li>了解C++吗？虚拟继承有什么用？<ul><li>这个确实不知道，一面的时候面试官问的都是Go相关的八股。这个确实不知道。</li></ul></li><li>反问：项目组主要用什么语言？主要是做什么的？需要学大数据相关的框架吗？<ul><li>主要用 Go 和 Java，处理大数据的时候会用到 C++。</li><li>主要做跟大数据有关的内容。</li><li>需要学。</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总是这样，在面试之前总是觉得好像已经没什么可学的了，面试完之后就觉得好像什么都没学过。拷打的体无完肤，还是知识储备不够。刚刚也去看了前后端通信的过程，还是不是很清楚要怎么回答面试官的那个问题。</p><p>不管结果如何，我都很感谢腾讯，每一次面试都能发现很多不足，自己确实还是有很多东西都没有考虑到。通过面试查漏补缺属实不是什么好方法，但是我自己在下面又不能全方面地排查问题，所以面试了一场又一场，发现了很多问题，却又被我一直拖着没做。</p><p>其他两个面试也没什么结果，字节都已经过了一周了，还没约二面，应该是没戏了。俊德内推地腾讯云智，我觉得面的还挺好的，也还没消息，可能是不缺人吧，也可能只是我觉得很好。</p><p>唉，总的来说，上一周好像到了巅峰，三场面试，这一周好像又要开始往下走了，祝我面试顺利。</p><p>6月25号更新，显然并没有什么好消息，复盘之后发现二面确实很差，腾讯云智的也被挂了，不太明白为什么，昨天晚上和朋友复盘的时候发现之前的学习方法有问题。在学基础知识的时候，我总是偏向于理解，在自己脑子里有个印象，几乎没有认真地背过，这也导致我在回答这方面问题的时候总是表述不清，因为并没有记住，知识浅显的理解了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;腾讯二面，没想到上次面试还有下文，隔了四天，周日晚上约今天的面试，那时我还躺在南昌酒店的床上享受着美好的假期生活。腾讯是真给机会啊，面完的感受，觉得还是差太多了，面试官问的问题我甚至都没听懂，不知道为什么，感觉很奇怪。面试时间不长，面试官也没开摄像头，没有自我介绍，直接开始</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用：select/poll/epoll</title>
    <link href="http://example.com/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/"/>
    <id>http://example.com/2024/06/21/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect-poll-epoll/</id>
    <published>2024-06-21T07:26:39.000Z</published>
    <updated>2024-06-21T08:23:48.484Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前（三天前），我被问到一个熟悉又陌生的问题，了解I/O多路复用吗？我回答，了解但是还没开始学？是的，我学习的领域就是这么广泛又浅显，名词我都了解，但是就是不知道具体是什么。</p><p>说到 I/O多路复用，我学习的博客都把他归到了操作系统一类里面，我也学过操作系统啊，为什么就不知道这是什么呢？我问了我周围的同学，好像都不知道，应该是当时老师没讲，也可能是讲了我们都没听。我知道这个算法是在学习 Redis 的时候，我们在 Redis 为什么这么快 那篇博客里提到了 多路复用 这个算法，今天我们就来看一看 I/O多路复用的前世今生。</p><h1 id="最基础的-Socket-模型"><a href="#最基础的-Socket-模型" class="headerlink" title="最基础的 Socket 模型"></a>最基础的 <code>Socket</code> 模型</h1><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p><p>Socket 的中文名叫做插口，乍一看还挺迷惑的。事实上，双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。</p><p>创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。</p><p>UDP 的 Socket 编程相对简单些，这里我们只介绍基于 TCP 的 Socket 编程。</p><p>服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。</p><p>服务端首先调用 <code>socket()</code> 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 <code>bind()</code> 函数，给这个 Socket 绑定一个 <strong>IP 地址和端口</strong>，绑定这两个的目的是什么？</p><ul><li>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</li></ul><p>绑定完 IP 地址和端口后，就可以调用 <code>listen()</code> 函数进行监听，此时对应 TCP 状态图中的 <code>listen</code>，如果我们要判定服务器中一个网络程序有没有启动，可以通过 <code>netstat</code> 命令查看对应的端口号是否有被监听。</p><p>服务端进入了监听状态后，通过调用 <code>accept()</code> 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 <code>connect()</code> 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p><p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p><ul><li>一个是「还没完全建立」连接的队列，称为 <strong>TCP 半连接队列</strong>，这个队列都是没有完成三次握手的连接，此时服务端处于 <code>syn_rcvd</code> 的状态；</li><li>一个是「已经建立」连接的队列，称为 <strong>TCP 全连接队列</strong>，这个队列都是完成了三次握手的连接，此时服务端处于 <code>established</code> 状态；</li></ul><p>当 TCP 全连接队列不为空后，服务端的 <code>accept()</code> 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。</p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作<strong>监听 Socket</strong>；</li><li>一个叫作<strong>已连接 Socket</strong>；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <code>read()</code> 和 <code>write()</code> 函数来读写数据。</p><p>至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tcp_socket.png" alt="img"></p><p>看到这，不知道你有没有觉得读写 Socket 的方式，好像读写文件一样。</p><p>是的，基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。</p><h1 id="如何服务更多的用户？"><a href="#如何服务更多的用户？" class="headerlink" title="如何服务更多的用户？"></a>如何服务更多的用户？</h1><p>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p><p>可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。</p><p>在改进网络 I/O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？</p><p>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：<strong>本机IP, 本机端口, 对端IP, 对端端口</strong>。</p><p>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以<strong>最大 TCP 连接数 = 客户端 IP 数×客户端端口数</strong>。</p><p>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是<strong>服务端单机最大 TCP 连接数约为 2 的 48 次方</strong>。</p><p>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p><ul><li><strong>文件描述符</strong>，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li><strong>系统内存</strong>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p><p>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。</p><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</p><p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p><h1 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h1><p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，</p><p>可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。</p><p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" alt="img"></p><p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="img"></p><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 <strong>I/O 多路复用</strong>技术。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="img"></p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p><p>select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><p>select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>Select 实现多路复用的方式是，将以连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 Select 函数将文件描述符<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查有事件产生后，将此 Socket 标记为可读或者可写，接着再把整个文件描述符集合<strong>拷贝</strong>回用户态，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p><p><strong>函数签名与参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">            fd_set *<span class="keyword">restrict</span> errorfds,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p><p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><h3 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p><p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p><p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p><p>每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。</p><h3 id="socket-与-fd-的关系"><a href="#socket-与-fd-的关系" class="headerlink" title="socket 与 fd 的关系"></a>socket 与 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br></pre></td></tr></table></figure><p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。</p><p>可以这样理解：socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。socket 与 fd 是一一对应的。通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件。这也符合 Unix“一切皆文件”的哲学。</p><p>后面可以将 socket 和 fd 视为同义词。</p><h3 id="fd-set-文件描述符集合"><a href="#fd-set-文件描述符集合" class="headerlink" title="fd_set 文件描述符集合"></a>fd_set 文件描述符集合</h3><p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p><p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;  <span class="comment">// 将 fd_set 所有位置 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;   <span class="comment">// 将 fd_set 某一位置 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fd_set)</span>;  <span class="comment">// 将 fd_set 某一位置 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">// 检测 fd_set 某一位是否为 1</span></span><br></pre></td></tr></table></figure><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><p>下图的代码说明：</p><ol><li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li><li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li><li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li><li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li><li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li><li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li></ol><p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p><p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p><p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/15732186159520.jpg" alt="15732186159520"></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 和 select 几乎没有区别。poll 在用户态通过<strong>数组</strong>方式<strong>传递</strong>文件描述符，在内核会转为<strong>链表</strong>方式<strong>存储</strong>，没有最大数量的限制。</p><p>poll 的函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>fds</code> 是一个 <code>pollfd</code> 结构体类型的数组，调用 <code>poll()</code> 时必须通过 <code>nfds</code> 指出数组 <code>fds</code> 的大小，即文件描述符的数量。</p><p>poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><p>如下的代码中，先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><p><strong>第一点</strong>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p><strong>第二点</strong>， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p>从下图你可以看到 epoll 相关的接口作用：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/epoll.png" alt="img"></p><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><blockquote><p>插个题外话，网上文章不少说，<code>epoll_wait</code> 返回时，对于就绪的事件，epoll 使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。</p><p>这是错的！看过 epoll 内核源码的都知道，<strong>压根就没有使用共享内存这个玩意</strong>。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 <code>__put_user</code> 函数，这个函数就是将数据从内核拷贝到用户空间。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/__put_user.png" alt="img"></p><p>好了，这个题外话就说到这了，我们继续</p></blockquote><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p><p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p><p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p><p><code>epoll</code> 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>fd</code> 表示要监听的目标文件描述符</li><li><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</li><li><code>op</code>表示要对 <code>fd</code> 执行的操作，有以下几种：<ul><li><code>EPOLL_CTL_ADD</code>：为 <code>fd</code> 添加一个监听事件 <code>event</code></li><li><code>EPOLL_CTL_MOD</code>：Change the event event associated with the target file descriptor fd（<code>event</code> 是一个结构体变量，这相当于变量 <code>event</code> 本身没变，但是更改了其内部字段的值）</li><li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code> 的所有监听事件，这种情况下 <code>event</code> 参数没用</li></ul></li></ul><p>返回值 0 或 -1，表示上述操作成功与否。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li><li><code>maxevents</code> 指定 <code>events</code> 的大小</li><li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li></ul><p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）</strong>和<strong>水平触发（level-triggered，LT）</strong>。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><blockquote><p>另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：</p><blockquote><p>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.</p></blockquote><p>我谷歌翻译的结果：</p><blockquote><p>在Linux下，select() 可能会将一个 socket 文件描述符报告为 “准备读取”，而后续的读取块却没有。例如，当数据已经到达，但经检查后发现有错误的校验和而被丢弃时，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 O_NONBLOCK 可能更安全。</p></blockquote><p>简单点理解，就是<strong>多路复用 API 返回的事件并不一定可读写的</strong>，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I/O？"></a>为什么边缘触发必须使用非阻塞 I/O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</li><li><code>select</code> 可以使用阻塞 I/O 通过 <code>select</code> 获取到所有可读的文件描述符后，遍历每个文件描述符，<code>read</code> 一次数据<ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul></li><li>在 <code>epoll</code> 的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知<ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li></ul></li></ul><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。</p><p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。</p><ul><li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li></ul><p>而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。</p><p>I/O 多路复用在一定程度上成就了 Redis，这是我的理解，没有 I/O多路复用，Redis 可能就没这么快了，也许吧。</p><p>说说面试，前两天有三次面试，这让我觉得机会又来了，这也过了两三天了，都还没挂，也是好消息了，这三场面试也是让我学到了不少的东西，之前一直闷着头学习总是觉得没有方向，东一榔头西一棒槌，面试找到了不足，最近这几天也都在去补，所以还没怎么开始学新的内容，不过明天应该就差不多了，不管是学习还是实习又或者是秋招，都祝我好运。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">https://imageslr.com/2020/02/27/select-poll-epoll.html</a></p><p><a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</a></p><p><a href="https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久很久以前（三天前），我被问到一个熟悉又陌生的问题，了解I/O多路复用吗？我回答，了解但是还没开始学？是的，我学习的领域就是这么广泛又浅显，名词我都了解，但是就是不知道具体是什么。&lt;/p&gt;
&lt;p&gt;说到 I/O多路复用，我学习的博客都把他归到了操作系统一类里面，我也学过操作</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法大揭秘</title>
    <link href="http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/"/>
    <id>http://example.com/2024/06/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%8F%AD%E7%A7%98/</id>
    <published>2024-06-20T08:17:28.000Z</published>
    <updated>2024-06-20T12:54:00.350Z</updated>
    
    <content type="html"><![CDATA[<p>从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。</p><p>学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之前一直拖着没总结的东西重新学习并总结一下。</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法（sorting algorithm）用于对一组数据按照特定的顺序进行排序。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。</p><p>排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620163619694.png" alt="image-20240620163619694"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p><p><strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p><p><strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。</p><p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure><p><strong>自适应性</strong>：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。</p><p>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。</p><p><strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $𝑂(𝑛 log⁡𝑛)$ 。而非比较排序不使用比较运算符，时间复杂度可达 $𝑂(𝑛)$ ，但其通用性相对较差。</p><h2 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h2><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</p><p>接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。先看看各种算法的比较：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="image"></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>选择排序（selection sort）</strong>的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p><p><strong>算法步骤</strong>：</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ol><p><strong>动画演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1c7e20f306ddc02eb4e3a50fa7817ff4.gif" alt="img"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// 外循环：未排序区间为[i, n-1]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="comment">// 内循环：找到未排序区间内最小（大）的元素</span></span><br><span class="line">k := i</span><br><span class="line"><span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[k] &#123;</span><br><span class="line"><span class="comment">// 记录最小元素的值</span></span><br><span class="line">k = j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛2)、非自适应排序</strong>：外循环共 𝑛−1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛−1、…、3、2 轮内循环，求和为 $(𝑛−1)(𝑛+2)/2$ 。</li><li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>非稳定排序</strong>：如图 11-3 所示，元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620170153391.png" alt="image-20240620170153391"></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>冒泡排序（bubble sort）</strong>通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p><p><strong>算法步骤：</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/33a947c71ad62b254cab62e5364d2813.gif" alt="img"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为[0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回。</p><p>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 $𝑂(𝑛^2) $；但当输入数组完全有序时，可达到最佳时间复杂度 $𝑂(𝑛) $。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortWithFlag</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        flag := <span class="literal">false</span> <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">false</span> &#123; <span class="comment">// 此轮“冒泡”未交换任何元素，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 $𝑂(n^2)$、自适应排序</strong>：各轮“冒泡”遍历的数组长度依次为 𝑛−1、𝑛−2、…、2、1 ，总和为$ (𝑛−1)𝑛/2 $。在引入 <code>flag</code> 优化后，最佳时间复杂度可达到 $𝑂(𝑛)$ 。</li><li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>稳定排序</strong>：由于在“冒泡”中遇到相等元素不交换。</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>插入排序（insertion sort）</strong>是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p><p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p><p><strong>算法步骤：</strong></p><p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/91b76e8e4dab9b0cad9a017d7dd431e2.gif" alt="img"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        base := nums[i]</span><br><span class="line">        j := i<span class="number">-1</span></span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 $𝑂(𝑛2)$、自适应排序</strong>：在最差情况下，每次插入操作分别需要循环 𝑛−1、𝑛−2、…、2、1 次，求和得到 $(𝑛−1)𝑛/2 $，因此时间复杂度为 $𝑂(𝑛2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 𝑂(𝑛) 。</li><li><strong>空间复杂度为 $𝑂(1)$、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li><li><strong>稳定排序</strong>：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>插入排序的时间复杂度为$ 𝑂(𝑛^2) $，而我们即将学习的快速排序的时间复杂度为$ 𝑂(𝑛log⁡𝑛) $。尽管插入排序的时间复杂度更高，<strong>但在数据量较小的情况下，插入排序通常更快</strong>。</p><p>这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 𝑂(𝑛log⁡𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，𝑛2 和 𝑛log⁡𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。</p><p>实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。</p><p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $𝑂(𝑛^2) $，但在实际情况中，<strong>插入排序的使用频率显著高于冒泡排序和选择排序</strong>，主要有以下原因。</p><ul><li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，<strong>冒泡排序的计算开销通常比插入排序更高</strong>。</li><li>选择排序在任何情况下的时间复杂度都为 $𝑂(𝑛^2)$ 。<strong>如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</strong>。</li><li>选择排序不稳定，无法应用于多级排序。</li></ul><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>希尔排序（Shell Sort）</strong>通过将待排序数组分割成若干子序列，使得每个子序列分别进行插入排序，随着算法的进行逐渐减小子序列的间隔，最终使整个数组变得有序。希尔排序在最后一步中使用一个间隔为 1 的插入排序，这一步能够高效地将几乎有序的数组进行完全排序。</p><p><strong>算法步骤：</strong></p><ol><li><strong>选择初始增量（gap）</strong>：选择一个初始的增量序列，可以是数组长度的一半或者其他一些预定义的序列。</li><li><strong>分割子序列</strong>：根据当前的增量将数组分割成若干子序列，每个子序列由相隔增量距离的元素组成。</li><li><strong>对子序列进行插入排序</strong>：对每个子序列分别进行插入排序。</li><li><strong>缩小增量</strong>：减少增量的值，通常减小为原来的一半或者按照其他规则减小。</li><li><strong>重复上述步骤</strong>：重复分割子序列和排序的过程，直到增量缩小到 1，此时对整个数组进行一次插入排序。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="image"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 初始增量，通常取数组长度的一半</span></span><br><span class="line">    <span class="keyword">for</span> gap := n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := gap; i &lt; n; i++ &#123;</span><br><span class="line">            temp := nums[i]</span><br><span class="line">            j := i</span><br><span class="line">            <span class="keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-3"><a href="#算法特性-3" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度</strong>：希尔排序的时间复杂度依赖于增量序列的选择，最坏情况下为 $O(n^2)$，但在实际应用中通常表现优于插入排序和冒泡排序。</li><li><strong>空间复杂度</strong>：希尔排序是原地排序算法，空间复杂度为$ O(1)$。</li><li><strong>稳定性</strong>：希尔排序不是稳定排序，因为相同元素在不同子序列中的相对位置可能会发生变化。</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。</p><ol><li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ol><p><strong>算法步骤：</strong></p><p><strong>“划分阶段”</strong>从顶至底递归地将数组从中点切分为两个子数组。</p><ol><li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li><li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时终止。</li></ol><p><strong>“合并阶段”</strong>从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。</p><p><strong>动图演示：</strong></p><p><img src="https://static001.geekbang.org/infoq/cd/cdda3f11c6efbc01577f5c29a9066772.gif" alt="img"></p><p>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。</p><ul><li><strong>后序遍历</strong>：先递归左子树，再递归右子树，最后处理根节点。</li><li><strong>归并排序</strong>：先递归左子数组，再递归右子数组，最后处理合并。</li></ul><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 合并左子树组和右子数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span></span><br><span class="line">    <span class="comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化左子树组和右子数组的起始索引</span></span><br><span class="line">    i, j, k := left, mid+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= right &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j] &#123;</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将左子树组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &#123;</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j &lt;= right &#123;</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j++</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(tmp); k++ &#123;</span><br><span class="line">        nums[left+k] = tmp[k]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 划分阶段</span></span><br><span class="line">    mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">    mergeSort(nums, left, mid)</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-4"><a href="#算法特性-4" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：划分产生高度为 log⁡𝑛 的递归树，每层合并的总操作数量为 𝑛 ，因此总体时间复杂度为 𝑂(𝑛log⁡𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛)、非原地排序</strong>：递归深度为 log⁡𝑛 ，使用 𝑂(log⁡𝑛) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 𝑂(𝑛) 大小的额外空间。</li><li><strong>稳定排序</strong>：在合并过程中，相等元素的次序保持不变。</li></ul><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>对于链表，归并排序相较于其他排序算法具有显著优势，<strong>可以将链表排序任务的空间复杂度优化至 𝑂(1)</strong> 。</p><ul><li><strong>划分阶段</strong>：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。</li><li><strong>合并阶段</strong>：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p><strong>快速排序（quick sort）</strong>是一种基于分治策略的排序算法，运行高效，应用广泛。</p><p>快速排序的核心操作是 “哨兵划分”，其目标是：选择数组中某个元素作为 “基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p><p><strong>算法步骤：</strong></p><ol><li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li><li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤 <code>2</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ol><p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/c411339b79f92499dcb7b5f304c826f4.gif" alt="img"></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>哨兵划分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSort)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哨兵划分</span></span><br><span class="line">    pivot := q.partition(nums, left, right)</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    q.quickSort(nums, left, pivot<span class="number">-1</span>)</span><br><span class="line">    q.quickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuickSort 非递归快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        high := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        low := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        p := Partition(arr, low, high)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p<span class="number">-1</span> &gt; low &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, low, p<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右侧子数组有更多元素，压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> p+<span class="number">1</span> &lt; high &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, p+<span class="number">1</span>, high)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-5"><a href="#算法特性-5" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、自适应排序</strong>：在平均情况下，哨兵划分的递归层数为 log⁡𝑛 ，每层中的总循环数为 𝑛 ，总体使用 𝑂(𝑛log⁡𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 $𝑂(𝑛^2) $时间。</li><li><strong>空间复杂度为 𝑂(𝑛)、原地排序</strong>：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。</li><li><strong>非稳定排序</strong>：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</li></ul><h2 id="快速排序为什么快？"><a href="#快速排序为什么快？" class="headerlink" title="快速排序为什么快？"></a>快速排序为什么快？</h2><p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。</p><ul><li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 $𝑂(𝑛^2) $，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛log⁡𝑛) 的时间复杂度下运行。</li><li><strong>缓存使用效率高</strong>：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。</li><li><strong>复杂度的常数系数小</strong>：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><h3 id="基准数优化"><a href="#基准数优化" class="headerlink" title="基准数优化"></a>基准数优化</h3><p><strong>快速排序在某些输入下的时间效率可能降低</strong>。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。</p><p>为了尽量避免这种情况发生，<strong>我们可以优化哨兵划分中的基准数的选取策略</strong>。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。</p><p>需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。</p><p>为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），<strong>并将这三个候选元素的中位数作为基准数</strong>。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 $𝑂(𝑛^2) $的概率大大降低。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选取三个候选元素的中位数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> medianThree(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    l, m, r := nums[left], nums[mid], nums[right]</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid <span class="comment">// m 在 l 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">return</span> left <span class="comment">// l 在 m 和 r 之间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哨兵划分（三数取中值）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortMedian)</span></span> partition(nums []<span class="type">int</span>, left, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    med := q.medianThree(nums, left, (left+right)/<span class="number">2</span>, right)</span><br><span class="line">    <span class="comment">// 将中位数交换至数组最左端</span></span><br><span class="line">    nums[left], nums[med] = nums[med], nums[left]</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    i, j := left, right</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= nums[left] &#123;</span><br><span class="line">            j-- <span class="comment">//从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= nums[left] &#123;</span><br><span class="line">            i++ <span class="comment">//从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i <span class="comment">//返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。</p><p>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过 𝑛/2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序（尾递归优化）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *quickSortTailCall)</span></span> quickSort(nums []<span class="type">int</span>, left, right <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        pivot := q.partition(nums, left, right)</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span></span><br><span class="line">        <span class="keyword">if</span> pivot-left &lt; right-pivot &#123;</span><br><span class="line">            q.quickSort(nums, left, pivot<span class="number">-1</span>) <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q.quickSort(nums, pivot+<span class="number">1</span>, right) <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>                 <span class="comment">// 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 𝑂(𝑛log⁡𝑛) 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</p><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。</p><ol><li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li><li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li></ol><p>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。</p><p><strong>算法步骤：</strong></p><p>设数组的长度为 𝑛 </p><ol><li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li><li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。</li><li>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。</li><li>循环执行第 <code>2.</code> 步和第 <code>3.</code> 步。循环 𝑛−1 轮后，即可完成数组排序。</li></ol><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/7073c729230e1a2c3c3c9207b25f6b43.gif" alt="img"></p><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(nums *[]<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        r := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">        ma := i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] &#123;</span><br><span class="line">            ma = r</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        siftDown(nums, <span class="built_in">len</span>(*nums), i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(*nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span></span><br><span class="line">        (*nums)[<span class="number">0</span>], (*nums)[i] = (*nums)[i], (*nums)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        siftDown(nums, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-6"><a href="#算法特性-6" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：建堆操作使用 𝑂(𝑛) 时间。从堆中提取最大元素的时间复杂度为 𝑂(log⁡𝑛) ，共循环 𝑛−1 轮。</li><li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：几个指针变量使用 𝑂(1) 空间。元素交换和堆化操作都是在原数组上进行的。</li><li><strong>非稳定排序</strong>：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li></ul><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>计数排序（counting sort）不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3c7ddb59df2d21b287e42a7b908409cb.gif" alt="img"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>给定一个长度为 𝑛 的数组 <code>nums</code> ，其中的元素都是“非负整数”。</p><p><strong>算法步骤：</strong></p><ol><li>遍历数组，找出其中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚+1 的辅助数组 <code>counter</code> 。</li><li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加 1 即可。</li><li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字出现次数从小到大的顺序填入 <code>nums</code> 即可。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620202353083.png" alt="image-20240620202353083"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 简单实现，无法用于排序对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortNaive</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="number">0</span>, <span class="number">0</span>; num &lt; m+<span class="number">1</span>; num++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; counter[num]; j++ &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计数排序与桶排序的联系</p><p>从桶排序的角度看，我们可以将计数排序中的计数数组 <code>counter</code> 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。</p></blockquote><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>细心的同学可能已经发现了，<strong>如果输入数据是对象，上述步骤 <code>3.</code> 就失效了</strong>。假设输入数据是商品对象，我们想按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。</p><p>那么如何才能得到原数据的排序结果呢？我们首先计算 <code>counter</code> 的“前缀和”。顾名思义，索引 <code>i</code> 处的前缀和 <code>prefix[i]</code> 等于数组前 <code>i</code> 个元素之和：</p><script type="math/tex; mode=display">prefix[𝑖]=∑_{𝑗=0}^𝑖counter[j]</script><p><strong>前缀和具有明确的意义，<code>prefix[num] - 1</code> 代表元素 <code>num</code> 在结果数组 <code>res</code> 中最后一次出现的索引</strong>。这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 <code>nums</code> 的每个元素 <code>num</code> ，在每轮迭代中执行以下两步。</p><ol><li>将 <code>num</code> 填入数组 <code>res</code> 的索引 <code>prefix[num] - 1</code> 处。</li><li>令前缀和 <code>prefix[num]</code> 减小 1 ，从而得到下次放置 <code>num</code> 的索引。</li></ol><p>遍历完成后，数组 <code>res</code> 中就是排序好的结果，最后使用 <code>res</code> 覆盖原数组 <code>nums</code> 即可。</p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    m := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; m &#123;</span><br><span class="line">            m = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        counter[i+<span class="number">1</span>] += counter[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment">// 初始化数组 res 用于记录结果</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        num := nums[i]</span><br><span class="line">        <span class="comment">// 将 num 放置到对应索引处</span></span><br><span class="line">        res[counter[num]<span class="number">-1</span>] = num</span><br><span class="line">        <span class="comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">        counter[num]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="built_in">copy</span>(nums, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-7"><a href="#算法特性-7" class="headerlink" title="算法特性"></a>算法特性</h2><ul><li><strong>时间复杂度为 𝑂(𝑛+𝑚)、非自适应排序</strong> ：涉及遍历 <code>nums</code> 和遍历 <code>counter</code> ，都使用线性时间。一般情况下 𝑛≫𝑚 ，时间复杂度趋于 𝑂(𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑚)、非原地排序</strong>：借助了长度分别为 𝑛 和 𝑚 的数组 <code>res</code> 和 <code>counter</code> 。</li><li><strong>稳定排序</strong>：由于向 <code>res</code> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <code>nums</code> 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <code>nums</code> 也可以得到正确的排序结果，但结果是非稳定的。</li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>看到这里，你也许会觉得计数排序非常巧妙，仅通过统计数量就可以实现高效的排序。然而，使用计数排序的前置条件相对较为严格。</p><p><strong>计数排序只适用于非负整数</strong>。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去。</p><p><strong>计数排序适用于数据量大但数据范围较小的情况</strong>。比如，在上述示例中 𝑚 不能太大，否则会占用过多空间。而当 𝑛≪𝑚 时，计数排序使用 𝑂(𝑚) 时间，可能比 𝑂(𝑛log⁡𝑛) 的排序算法还要慢。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p><strong>桶排序（bucket sort）</strong>是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p><p><strong>算法步骤：</strong></p><p>考虑一个长度为 𝑛 的数组，其元素是范围 [0,1) 内的浮点数。</p><ol><li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li><li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li><li>按照桶从小到大的顺序合并结果。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620203439496.png" alt="image-20240620203439496"></p><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b29c1a8ee42595e7992b6d2eb1030f76.gif" alt="img"></p><h2 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(nums []<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="type">float64</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        buckets[i] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i := <span class="type">int</span>(num * <span class="type">float64</span>(k))</span><br><span class="line">        <span class="comment">// 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i] = <span class="built_in">append</span>(buckets[i], num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="comment">// 使用内置切片排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        sort.Float64s(buckets[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-8"><a href="#算法特性-8" class="headerlink" title="算法特性"></a>算法特性</h2><p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p><ul><li><strong>时间复杂度为 𝑂(𝑛+𝑘)</strong> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 𝑛𝑘 。假设排序单个桶使用 𝑂(𝑛/𝑘<em>log⁡(𝑛/𝑘)) 时间，则排序所有桶使用 𝑂(𝑛log⁡(𝑛/𝑘)) 时间。<em>*当桶数量 𝑘 比较大时，时间复杂度则趋向于 𝑂(𝑛)</em></em> 。合并结果时需要遍历所有桶和元素，花费 𝑂(𝑛+𝑘) 时间。</li><li><strong>自适应排序</strong>：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 𝑂(𝑛2) 时间。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑘)、非原地排序</strong>：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ul><h2 id="如何实现平均分配"><a href="#如何实现平均分配" class="headerlink" title="如何实现平均分配"></a>如何实现平均分配</h2><p>桶排序的时间复杂度理论上可以达到 𝑂(𝑛) ，<strong>关键在于将元素均匀分配到各个桶中</strong>，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。</p><p>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong>。</p><p>如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204021017.png" alt="image-20240620204021017"></p><p>如果我们提前知道商品价格的概率分布，<strong>则可以根据数据概率分布设置每个桶的价格分界线</strong>。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p><p>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204045066.png" alt="image-20240620204045066"></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>上面介绍了计数排序，它适用于数据量 𝑛 较大但数据范围 𝑚 较小的情况。假设我们需要对 $𝑛=10^6$ 个学号进行排序，而学号是一个 8 位数字，这意味着数据范围 $𝑚=10^8 $非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。</p><h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p><strong>基数排序（radix sort）</strong>的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</p><p><strong>算法步骤：</strong></p><p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的流程如图所示。</p><ol><li>初始化位数 𝑘=1 。</li><li>对学号的第 𝑘 位执行“计数排序”。完成后，数据会根据第 𝑘 位从小到大排序。</li><li>将 𝑘 增加 1 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204242169.png" alt="image-20240620204242169"></p><p>对于一个 𝑑 进制的数字 𝑥 ，要获取其第 𝑘 位 $𝑥_𝑘 $，可以使用以下计算公式：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240620204349152.png" alt="image-20240620204349152"></p><p>其中 ⌊𝑎⌋ 表示对浮点数 𝑎 向下取整，而 <code>mod d</code> 表示对 𝑑 取模（取余）。对于学号数据，𝑑=10 且 𝑘∈[1,8] 。</p><p>此外，我们需要小幅改动计数排序代码，使之可以根据数字的第 𝑘 位进行排序：</p><blockquote><p>为什么从最低位开始排序？</p><p>在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 𝑎&lt;𝑏 ，而第二轮排序结果 𝑎&gt;𝑏 ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。</p></blockquote><p><strong>动图演示：</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3a6f1e5059386523ed941f0d6c3a136e.gif" alt="img"></p><h2 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digit</span><span class="params">(num, exp <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序（根据 nums 第 k 位排序） */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSortDigit</span><span class="params">(nums []<span class="type">int</span>, exp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        d := digit(nums[i], exp) <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++             <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        counter[i] += counter[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        d := digit(nums[i], exp)</span><br><span class="line">        j := counter[d] - <span class="number">1</span> <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]    <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--        <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    max := math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">            max = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; max &gt;= exp; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        countingSortDigit(nums, exp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法特性-9"><a href="#算法特性-9" class="headerlink" title="算法特性"></a>算法特性</h2><p>相较于计数排序，基数排序适用于数值范围较大的情况，<strong>但前提是数据必须可以表示为固定位数的格式，且位数不能过大</strong>。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 𝑂(𝑛𝑘)≫𝑂(𝑛2) 。</p><ul><li><strong>时间复杂度为 𝑂(𝑛𝑘)、非自适应排序</strong>：设数据量为 𝑛、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 𝑂(𝑛+𝑑) 时间，排序所有 𝑘 位使用 𝑂((𝑛+𝑑)𝑘) 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 𝑂(𝑛) 。</li><li><strong>空间复杂度为 𝑂(𝑛+𝑑)、非原地排序</strong>：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 <code>res</code> 和 <code>counter</code> 。</li><li><strong>稳定排序</strong>：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果。</li></ul><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>Q</strong>：排序算法稳定性在什么情况下是必需的？</p><p>在现实中，我们有可能基于对象的某个属性进行排序。例如，学生有姓名和身高两个属性，我们希望实现一个多级排序：先按照姓名进行排序，得到 <code>(A, 180) (B, 185) (C, 170) (D, 170)</code> ；再对身高进行排序。由于排序算法不稳定，因此可能得到 <code>(D, 170) (C, 170) (A, 180) (B, 185)</code> 。</p><p>可以发现，学生 D 和 C 的位置发生了交换，姓名的有序性被破坏了，而这是我们不希望看到的。</p><p><strong>Q</strong>：哨兵划分中“从右往左查找”与“从左往右查找”的顺序可以交换吗？</p><p>不行，当我们以最左端元素为基准数时，必须先“从右往左查找”再“从左往右查找”。这个结论有些反直觉，我们来剖析一下原因。</p><p>哨兵划分 <code>partition()</code> 的最后一步是交换 <code>nums[left]</code> 和 <code>nums[i]</code> 。完成交换后，基准数左边的元素都 <code>&lt;=</code> 基准数，<strong>这就要求最后一步交换前 <code>nums[left] &gt;= nums[i]</code> 必须成立</strong>。假设我们先“从左往右查找”，那么如果找不到比基准数更大的元素，<strong>则会在 <code>i == j</code> 时跳出循环，此时可能 <code>nums[j] == nums[i] &gt; nums[left]</code></strong>。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。</p><p>举个例子，给定数组 <code>[0, 0, 0, 0, 1]</code> ，如果先“从左向右查找”，哨兵划分后数组为 <code>[1, 0, 0, 0, 0]</code> ，这个结果是不正确的。</p><p>再深入思考一下，如果我们选择 <code>nums[right]</code> 为基准数，那么正好反过来，必须先“从左往右查找”。</p><p><strong>Q</strong>：关于尾递归优化，为什么选短的数组能保证递归深度不超过 log⁡𝑛 ？</p><p>递归深度就是当前未返回的递归方法的数量。每轮哨兵划分我们将原数组划分为两个子数组。在尾递归优化后，向下递归的子数组长度最大为原数组长度的一半。假设最差情况，一直为一半长度，那么最终的递归深度就是 log⁡𝑛 。</p><p>回顾原始的快速排序，我们有可能会连续地递归长度较大的数组，最差情况下为 𝑛、𝑛−1、…、2、1 ，递归深度为 𝑛 。尾递归优化可以避免这种情况出现。</p><p><strong>Q</strong>：当数组中所有元素都相等时，快速排序的时间复杂度是 $𝑂(𝑛^2) $吗？该如何处理这种退化情况？</p><p>是的。对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p><p><strong>Q</strong>：桶排序的最差时间复杂度为什么是$ 𝑂(𝑛^2) $？</p><p>最差情况下，所有元素被分至同一个桶中。如果我们采用一个 $𝑂(𝑛^2)$ 算法来排序这些元素，则时间复杂度为$ 𝑂(𝑛^2) $。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到 𝑂(𝑛) 。</li><li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为 𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li><li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至 𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到 𝑂(log⁡𝑛) 。</li><li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为 𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至 𝑂(1) 。</li><li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配。</li><li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并且要求数据能够转换为正整数。</li><li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li></ul><p>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及正向自适应性等优点。然而，正如其他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据数据的特性来选择合适的排序算法。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/sorting_algorithms_comparison.png" alt="排序算法对比"></p><p>OK了，今天的算法学习就先到这里，该作题了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.hello-algo.com/chapter_sorting/">https://www.hello-algo.com/chapter_sorting/</a></p><p><a href="https://github.com/MisterBooo/Article">https://github.com/MisterBooo/Article</a></p><p><a href="https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4">https://xie.infoq.cn/article/ee95dfe949d2464ae8bc809b4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从刚开始找实习，我就一直说要重学算法，还是老毛病，拖延症。每次面试到了算法环节就只能讲自己的思路，因为代码实现不出来，题倒也做了不少，可惜就是没什么收获，还是慢慢重新学习吧。&lt;/p&gt;
&lt;p&gt;学习算法的第一站，我选择排序算法，主要原因还是因为昨天晚上的面试打击到我了，要先把之</summary>
      
    
    
    
    <category term="Hello,算法！" scheme="http://example.com/categories/Hello-%E7%AE%97%E6%B3%95%EF%BC%81/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是一致性哈希算法？</title>
    <link href="http://example.com/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
    <id>http://example.com/2024/06/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F/</id>
    <published>2024-06-20T06:45:14.000Z</published>
    <updated>2024-06-20T08:26:14.122Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希算法，一个躺在我书签里两周的知识点，之前就一直说要看要看，结果一直拖，拖到昨天被面试官问了，只能回答说不会。</p><p>一致性哈希算法、一致性算法，这两个内容我一直以为是一样的，所以刚开始决定放在一起学，刚刚得知，两个不是一个东西。露出尴尬的笑容，那就先学一致性哈希算法吧。</p><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p><p>一致性哈希算法是一种常用的分布式算法，其主要用途是在分布式系统中，将数据根据其键（key）进行散列（hash），然后将散列结果映射到环上，再根据数据节点的数量，将环划分为多个区间，每个节点负责处理环上一定区间范围内的数据。</p><p>按照老传统，我们逐步进行学习。</p><h1 id="如何分配请求？"><a href="#如何分配请求？" class="headerlink" title="如何分配请求？"></a>如何分配请求？</h1><p>大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。</p><p>但是问题来了，现在有这么多个节点，要如何保证分配客户端的请求呢？</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b752a4f8dcaab8ed4d941ebcc6f606c5.png" alt="img"></p><p>其实这个问题就是负载均衡问题。解决负载均衡问题的算法有很多，不同的负载均衡算法对应的就是不同的分配策略，适应的业务场景也不同。</p><p>最简单的方式，引入一个中间的负载均衡层，让它将外界的请求「轮流」地转发给内部的集群。比如集群有三个节点，外界请求有三个，那么每个节点都会处理一个请求，达到了分配请求的目的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d3279ad754257977f98e702cb156e9cf.png" alt="img"></p><p>考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做加权轮询。</p><p>加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。</p><p>但是，加权轮询算法是无法应对「分布式系统（数据分片的系统）」的。因为分布式系统中，每个节点存储的数据是不相同的。</p><p>当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如<strong>一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的</strong>，不是说任意访问一个节点都可以得到缓存结果的。</p><p>因此，我们要想一个能应对分布式系统的负载均衡算法。</p><h1 id="使用普通哈希的问题"><a href="#使用普通哈希的问题" class="headerlink" title="使用普通哈希的问题"></a>使用普通哈希的问题</h1><p>小脑袋瓜机灵的同学很快就会想到 <strong>哈希算法</strong>。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 <code>key</code> 确定到一个节点了，可以满足系统的负载均衡需求。</p><p>哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 <code>hash(key) % 3</code> 公式对数据进行了映射。</p><p>如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key) % 3</span><br></pre></td></tr></table></figure><p>如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。</p><p>但是有一个很致命的问题，<strong>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</strong>，否则会出现查询不到数据的问题。</p><p>分布式集群中，对机器的添加、删除或者机器故障后自动脱离集群这些操作都是集群管理最基本的功能。如果采用那个常用的 <code>hash(object)%N</code> 取模的方式，在节点进行添加或删除后，需要重新进行迁移改变映射关系，否则可能导致原有的数据无法找到。</p><p><strong>举个例子：</strong></p><p>随着业务和流量的增加，假如我们的 Redis 查询服务节点扩展到了3个，为了将查询请求进行均衡，每次请求都在相同的Redis中，使用hv = hash(key) % 3的方式计算，对每次查询请求都通过hash值计算，得出来0、1 、2的值分别对应服务节点的编号，计算得到的hv的值就去对应的节点处理。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/462342823ffbc816c623152f48240598.png" alt="img"></p><p>但是这里有个问题，服务增减是需要对此时的key进行重新计算，比如减少一个服务的时候，此时需要按 hv = hash(key) % 2计算，而增加一个服务节点的时候需要按hv = hash(key) % 4计算，而这种取模基数的变化会改变大部分原来的映射关系。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/3555435d14a54a088513b8dcc1049521.png" alt="img"></p><p>这个时候只能进行数据迁移，非常麻烦，所以我们应该选择一个更加好用的方案。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法能够很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p><p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</p><p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>，如下图：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/0ea3960fef48d4cbaeb4bec4345301e7.png" alt="img"></p><p>一致性哈希要进行两步哈希：</p><ul><li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li><li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；</li></ul><p>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p><p>问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？</p><p>答案是，映射的结果值往<strong>顺时针的方向的找到第一个节点</strong>，就是存储该数据的节点。</p><p>举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/83d7f363643353c92d252e34f1d4f687.png" alt="img"></p><p>接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。</p><p>比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。</p><p>所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：</p><ul><li>首先，对 key 进行哈希计算，确定此 key 在环上的位置；</li><li>然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。</li></ul><p>知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？</p><p>假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/f8909edef2f3949f8945bb99380baab3.png" alt="img"></p><p>你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。</p><p>假设节点数量从 3 减少到了 2，比如将节点 A 移除：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/31485046f1303b57d8aaeaab103ea7ab.png" alt="img"></p><p>你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。</p><p>因此，<strong>在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</strong>。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。</p><p>但是<strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，这样就会带来一个问题，会有大量的请求集中在一个节点上。</p><p>比如，下图中 3 个节点的映射位置都在哈希环的右半边：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/d528bae6fcec2357ba2eb8f324ad9fd5.png" alt="img"></p><p>这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。</p><p>另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。</p><p>比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。</p><p>所以，<strong>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</strong>。</p><h1 id="如何通过虚拟节点提高均衡度？"><a href="#如何通过虚拟节点提高均衡度？" class="headerlink" title="如何通过虚拟节点提高均衡度？"></a>如何通过虚拟节点提高均衡度？</h1><p>要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。</p><p>但问题是，实际中我们没有那么多节点。所以这个时候我们就加入<strong>虚拟节点</strong>，也就是对一个真实节点做多个副本。</p><p>具体做法是，<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</strong></p><p>比如对每个节点分别设置 3 个虚拟节点：</p><ul><li>对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03</li><li>对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03</li><li>对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03</li></ul><p>引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/602393536805bc21c12db2ecff73d4ab.png" alt="img"></p><p>你可以看到，<strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</p><p>上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。</p><p>另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</p><p>比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p><p>而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</p><p>因此，<strong>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同的负载均衡算法适用的业务场景也不同的。</p><p>轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。</p><p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p><p>为了减少迁移的数据量，就出现了一致性哈希算法。</p><p>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><p>但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</p><p>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</p><p>在聊到这个问题之前，我们讨论的是哈希冲突的解决方案，然后面试官抛出了这个问题，幸亏我没有胡乱回答，这和解决哈希冲突好像没什么关系。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93</a></p><p><a href="https://cloud.tencent.com/developer/article/2373162">https://cloud.tencent.com/developer/article/2373162</a></p><p><a href="https://github.com/fupengfei058/blog/blob/master/%E4%BA%94%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(consistent%20hashing).md">https://github.com/fupengfei058/blog/blob/master/%E4%BA%94%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(consistent%20hashing).md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一致性哈希算法，一个躺在我书签里两周的知识点，之前就一直说要看要看，结果一直拖，拖到昨天被面试官问了，只能回答说不会。&lt;/p&gt;
&lt;p&gt;一致性哈希算法、一致性算法，这两个内容我一直以为是一样的，所以刚开始决定放在一起学，刚刚得知，两个不是一个东西。露出尴尬的笑容，那就先学一致</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang中的闭包，你真的了解吗？</title>
    <link href="http://example.com/2024/06/20/Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/"/>
    <id>http://example.com/2024/06/20/Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/</id>
    <published>2024-06-20T04:58:35.000Z</published>
    <updated>2024-06-20T06:20:49.595Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p><p>因为Go语言的函数本身可以作为值进行传递，既支持匿名函数和闭包，又能满足接口，所以 Go 语言的函数属于一等公民。</p><p>本文将由一道题引出 Go 中的闭包。这是 Go 语言爱好者周刊第 90 期的一道题目。以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">app</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">t := <span class="string">&quot;Hi&quot;</span></span><br><span class="line">c := <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">t = t + <span class="string">&quot; &quot;</span> + b</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := app()</span><br><span class="line">b := app()</span><br><span class="line">a(<span class="string">&quot;go&quot;</span>)</span><br><span class="line">fmt.Println(b(<span class="string">&quot;All&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下，这里会输出什么，如果再加上一行代码 <code>fmt.Println(a(&quot;All&quot;))</code> ，它又会输出什么内容？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//fmt.Println(b(&quot;All&quot;))</span><br><span class="line">Hi All</span><br><span class="line">//fmt.Println(a(&quot;All&quot;))</span><br><span class="line">Hi go All</span><br></pre></td></tr></table></figure><p>发现什么神奇的东西了吗，新加入的一行代码的输出结果竟然包含着第17行中输入的字符串，这和我们之前学过的东西都不太一样，别急，继续往下看吧。</p><h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p>维基百科对<a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学">闭包的定义</a>) ：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了<strong>一个函数</strong>（通常是其入口地址）和<strong>一个关联的环境</strong>（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如 C++）。</p></blockquote><p>关于（函数）闭包，有几个关键点：</p><ul><li>函数是一等公民；</li><li>闭包所处环境，可以引用环境里的值；</li></ul><p>问到什么是闭包时，网上一般这么回答的：</p><blockquote><p>在支持函数是一等公民的语言中，一个函数的返回值是另一个函数，被返回的函数可以访问父函数内的变量，当这个被返回的函数在外部执行时，就产生了闭包。</p></blockquote><p>所以，上面题目中，函数 app 的返回值是另一个函数，因此产生了闭包。</p><p>回到最开始的问题：什么是闭包？</p><p>go官方的解释是：Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。</p><p>简单来说，闭包是由函数和与其相关的引用环境组合而成的实体。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/UML.jpg" alt="img"></p><p><strong>函数</strong>指的是在闭包实际实现的时候，往往通过调用一个外部函数返回其内部函数来实现的。用户得到一个闭包，也等同于得到了这个内部函数，每次执行这个闭包就等同于执行内部函数。</p><p><strong>引用环境</strong>可以简单理解为在函数外部定义但在函数内被引用的变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的所引用的外部变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。</p><h1 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h1><p>闭包是包含自由变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。由于自由变量包含在代码块中，所以只要闭包还被使用，那么这些自由变量以及它们引用的对象就不会被释放，要执行的代码为自由变量提供绑定的计算环境。</p><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</p><p>Golang 中的闭包同样也会引用到函数外的变量，闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。从形式上看，匿名函数都是闭包。</p><p>其实我们可以将闭包函数看成一个类 (C++)，一个闭包函数调用就是实例化一个对象，闭包的自由变量就是类的成员变量，闭包函数的参数就是类的函数对象的参数。</p><p>这让我想起了一句名言：<strong>对象是附有行为的数据，而闭包是附有数据的行为</strong>。</p><h1 id="闭包的意义"><a href="#闭包的意义" class="headerlink" title="闭包的意义"></a>闭包的意义</h1><p>我们会发现，使用普通函数和全局变量完全可以实现和闭包相同的功能。</p><p><strong>为什么不用全局变量？</strong></p><ul><li>缩小变量作用域，减少对全局变量的污染。上面的问题如果用全局变量进行实现，全局变量容易被其他人污染。</li><li>同时，如果我要实现n个闭包，如果我使用全局变量，就需要维护n个函数对应的全局变量。</li></ul><h1 id="使用闭包的一些例子"><a href="#使用闭包的一些例子" class="headerlink" title="使用闭包的一些例子"></a>使用闭包的一些例子</h1><h2 id="隔离数据"><a href="#隔离数据" class="headerlink" title="隔离数据"></a>隔离数据</h2><p>假设你想要创建一个函数，该函数可以访问即使在函数退出后仍会保留的数据。例如，您想要计算该函数被调用的次数，或者您想要创建一个斐波那契数生成器，但您不希望其他人访问该数据（这样他们就不会意外更改它）。您可以使用闭包来实现这一点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  gen := makeFibGen()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(gen())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeFibGen</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  f1 := <span class="number">0</span></span><br><span class="line">  f2 := <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    f2, f1 = (f1 + f2), f2</span><br><span class="line">    <span class="keyword">return</span> f1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装函数并创建中间件"><a href="#包装函数并创建中间件" class="headerlink" title="包装函数并创建中间件"></a>包装函数并创建中间件</h2><p>Go 中的函数是<a href="https://en.wikipedia.org/wiki/First-class_citizen#Functions">一等公民</a>。这意味着你不仅可以动态创建匿名函数，还可以将函数作为参数传递给函数。例如，在创建 Web 服务器时，通常会提供一个处理特定路由的 Web 请求的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, <span class="string">&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，该函数<code>hello()</code>被传递给<code>http.HandleFunc()</code>函数，并在该路由匹配时被调用。</p><p>虽然此代码不需要闭包，但如果我们想用更多逻辑包装处理程序，闭包非常有用。一个完美的例子是当我们想要创建中间件来在处理程序执行之前或之后执行工作时。</p><p>让我们看看一个简单的计时器中间件在 Go 中是如何工作的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, timed(hello))</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timed</span><span class="params">(f <span class="keyword">func</span>(http.ResponseWriter, *http.Request)</span></span>) <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    f(w, r)</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The request took&quot;</span>, end.Sub(start))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, <span class="string">&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们的<code>timed()</code>函数接受一个可用作处理程序函数的函数，并返回相同类型的函数，但返回的函数与传递给它的函数不同。返回的闭包记录当前时间，调用原始函数，最后记录结束时间并打印出请求的持续时间。所有这些都与处理程序函数内部实际发生的事情无关。</p><p>现在我们需要对处理程序进行计时，将它们包装起来<code>timed(handler)</code>并将闭包传递给<code>http.HandleFunc()</code>函数调用。</p><h2 id="访问通常不可用的数据"><a href="#访问通常不可用的数据" class="headerlink" title="访问通常不可用的数据"></a>访问通常不可用的数据</h2><p>闭包还可用于将数据包装在函数内部，否则函数通常无法访问这些数据。例如，如果你想在不使用全局变量的情况下为处理程序提供对数据库的访问权限，则可以编写如下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line">  Url <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(url <span class="type">string</span>)</span></span> Database &#123;</span><br><span class="line">  <span class="keyword">return</span> Database&#123;url&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db := NewDatabase(<span class="string">&quot;localhost:5432&quot;</span>)</span><br><span class="line"></span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello(db))</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(db Database)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, db.Url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以编写处理函数，就好像它们可以访问对象一样，<code>Database</code>同时仍返回具有预期签名的函数。这使我们能够绕过不允许我们传递自定义变量而不诉诸全局变量或任何此类变量的<code>http.HandleFunc()</code>事实。</p><h2 id="使用闭包进行二分搜索"><a href="#使用闭包进行二分搜索" class="headerlink" title="使用闭包进行二分搜索"></a>使用闭包进行二分搜索</h2><p>闭包也经常需要使用标准库中的包，比如<a href="https://golang.org/pkg/sort/">sort</a>包。</p><p>此包为我们提供了大量有用的函数和代码，用于对已排序列表进行排序和搜索。例如，如果您想对整数切片进行排序，然后在切片中搜索数字 7，则可以<code>sort</code>像这样使用该包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span>&#125;</span><br><span class="line">  sort.Ints(numbers)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Sorted:&quot;</span>, numbers)</span><br><span class="line">  index := sort.SearchInts(numbers, <span class="number">7</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;7 is at index:&quot;</span>, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果你想要搜索每个元素都是自定义类型的切片，会发生什么情况？或者，如果你想要查找第一个大于或等于 7 的数字的索引，而不仅仅是第一个 7 的索引，会发生什么情况？</p><p>为此，您应该使用<a href="https://golang.org/pkg/sort/#Search">sort.Search()</a>函数，并且需要传入一个闭包，该闭包可用于确定特定索引处的数字是否符合您的条件。</p><blockquote><p><code>sort.Search</code>是二分查找</p><p>该<code>sort.Search</code>函数执行二分搜索，因此它期望一个闭包，该闭包将对满足条件之前的任何索引返回 false，对满足条件之后的任何索引返回 true。这意味着您不能使用它来“在列表中找到 7 的索引”，而是需要将您的逻辑改写为“第一个大于或等于 7 的数字的索引是什么？”，然后在获取索引后检查该数字是否为 7。</p></blockquote><p>让我们使用上面描述的例子来实际看一下这一点；我们将搜索列表中大于或等于 7 的第一个数字的索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">-5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span>&#125;</span><br><span class="line">  sort.Ints(numbers)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Sorted:&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">  index := sort.Search(<span class="built_in">len</span>(numbers), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers[i] &gt;= <span class="number">7</span></span><br><span class="line">  &#125;)</span><br><span class="line">  fmt.Println(<span class="string">&quot;The first number &gt;= 7 is at index:&quot;</span>, index)</span><br><span class="line">  fmt.Println(<span class="string">&quot;The first number &gt;= 7 is:&quot;</span>, numbers[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们的闭包是作为第二个参数传递的简单小函数<code>sort.Search()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> numbers[i] &gt;= <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>numbers</code>即使从未传入切片，此闭包也会访问切片，并对任何大于或等于 7 的数字返回 true。通过这样做，它<code>sort.Search()</code>允许在无需了解您正在使用的底层数据类型或您试图满足的条件的情况下工作。它只需要知道特定索引处的值是否符合您的条件。</p><h2 id="用闭包-defer-进行处理异常"><a href="#用闭包-defer-进行处理异常" class="headerlink" title="用闭包 + defer 进行处理异常"></a>用闭包 + defer 进行处理异常</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;some except had happend:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">    *a = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some except had happend: runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure><p>recover 函数用于终止错误处理流程。一般情况下，recover 应该在一个使用 defer 关键字的函数中执行以有效截取错误处理流程。如果没有在发生异常的 goroutine 中明确调用恢复过程（调用 recover 函数），会导致该 goroutine 所属的进程打印异常信息后直接退出<br>对于第三方库的调用，在不清楚是否有 panic 的情况下，最好在适配层统一加上 recover 过程，否则会导致当前进程的异常退出，而这并不是我们所期望的。</p><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>这么有趣的东西，肯定有着不少的坑，也是我们在实际开发时要注意的东西。</p><h2 id="for-range-中使用闭包"><a href="#for-range-中使用闭包" class="headerlink" title="for range 中使用闭包"></a>for range 中使用闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                </span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;                             </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; </span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()                 </span><br><span class="line">    &#125;                        </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;    <span class="comment">// 阻塞模式                                                         </span></span><br><span class="line">&#125;                          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 嗯，结果应该是 a,b,c 吧</span></span><br></pre></td></tr></table></figure><p>来看看结果：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1262158-72c0946193c5d8e2.png" alt="img"></p><p>输出的结果不期而然，大家的结果也不一定和我相同。</p><p>对比下面的改进：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                </span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;                             </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; </span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;(v)   <span class="comment">//每次将变量 v 的拷贝传进函数                 </span></span><br><span class="line">    &#125;                        </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;                                                      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>所以结果当然是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><p>由于使用了 <code>go</code> 协程，并非顺序输出。</p><blockquote><p><strong>解释</strong>：也不用多解释了吧，在没有将变量 <code>v</code> 的拷贝值传进匿名函数之前，只能获取最后一次循环的值,这是新手最容易遇到的坑。</p></blockquote><h2 id="循环闭包引用"><a href="#循环闭包引用" class="headerlink" title="循环闭包引用"></a>循环闭包引用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> funcSlice []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      funcSlice = <span class="built_in">append</span>(funcSlice, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">println</span>(i)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">      funcSlice[j]()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>会输出什么？</strong></p><p>每次 append 操作仅将匿名函数放入到列表中，但并未执行，并且引用的变量都是 i，随着 i 的改变匿名函数中的 i 也在改变，所以当执行这些函数时，他们读取的都是环境变量 i 最后一次的值。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>声明新的变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> funcSlice []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      i := i</span><br><span class="line">      funcSlice = <span class="built_in">append</span>(funcSlice, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">println</span>(i)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">      funcSlice[j]()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明新变量：j := i，且把之后对 i 的操作改为对 j 操作。</li><li>声明新同名变量：i := i。注意：这里短声明右边是外层作用域的 i，左边是新声明的作用域在这一层的 i。原理同上。</li></ul><p>这相当于为这三个函数各声明一个变量，一共三个，这三个变量初始值分别对应循环中的 i 并且之后不会再改变。</p><p><strong>声明新匿名函数并传参</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> funcSlice []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         funcSlice = <span class="built_in">append</span>(funcSlice, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(i)</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;(i)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">      funcSlice[j]() <span class="comment">// 0, 1, 2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 println(i)使用的 i是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。</p><p>现在相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p><h1 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h1><h2 id="定义后立即被调用"><a href="#定义后立即被调用" class="headerlink" title="定义后立即被调用"></a>定义后立即被调用</h2><p>因为只会被使用一次，所以应该力图避免闭包对象的内存分配操作，那怎么优化一下呢？一下面的示例代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(byval)</span><br><span class="line">    byref++</span><br><span class="line">&#125;(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>在文章开头我们提到过闭包跟函数最大的不同在于，当捕捉闭包的时候，它的所引用的外部变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。如果闭包在定义后立即被调用，那它不会存在脱离上下文的使用场景，这时候其实可以将它转为简单函数的调用形式。</p><p>上面的闭包将被转换为简单函数调用的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(byval <span class="type">int</span>, &amp;byref *<span class="type">int</span>, a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(byval)</span><br><span class="line">    (*&amp;byref)++</span><br><span class="line">&#125;(byval, &amp;byref, <span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>我们注意到byval是值捕获，byref是引用捕获，这其实是根据变量在函数内部会不会被修改来决定的。我们知道在闭包内部修改变量会影响到外部环境，如果变量在闭包中会被修改，使用值捕获显然是不太合适的。</p><h2 id="定义后没有立即调用"><a href="#定义后没有立即调用" class="headerlink" title="定义后没有立即调用"></a>定义后没有立即调用</h2><p>这种情况下同一个闭包可能调用多次，这就需要创建闭包对象了，如何实现呢？</p><ul><li>如果变量是在函数内部不会被修改，并且该变量占用存储空间小于<code>2*sizeof(int)</code>，那么就通过在函数体内创建局部变量的形式来捕获的变量，相比于直接捕获变量地址，这么做的好处应该是考虑到减少引用数量、减少逃逸分析相关的计算。</li><li>如果变量在函数内部会被修改，或者变量占用存储空间较大（拷贝到本地做局部变量代价太大），则在捕获变量的地址。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ttt.svg" alt="image-UML"></p><h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transformclosure</span><span class="params">(xfunc *Node)</span></span> &#123;</span><br><span class="line">   lno := lineno</span><br><span class="line">   lineno = xfunc.Pos</span><br><span class="line">   clo := xfunc.Func.Closure</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> clo.Func.Top&amp;ctxCallee != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// If the closure is directly called, we transform it to a plain function call</span></span><br><span class="line">      <span class="comment">// with variables passed as args. This avoids allocation of a closure object.</span></span><br><span class="line">      <span class="comment">// Here we do only a part of the transformation. Walk of OCALLFUNC(OCLOSURE)</span></span><br><span class="line">      <span class="comment">// will complete the transformation later.</span></span><br><span class="line">      <span class="comment">// For illustration, the following closure:</span></span><br><span class="line">      <span class="comment">// func(a int) &#123;</span></span><br><span class="line">      <span class="comment">//    println(byval)</span></span><br><span class="line">      <span class="comment">//    byref++</span></span><br><span class="line">      <span class="comment">// &#125;(42)</span></span><br><span class="line">      <span class="comment">// becomes:</span></span><br><span class="line">      <span class="comment">// func(byval int, &amp;byref *int, a int) &#123;</span></span><br><span class="line">      <span class="comment">//    println(byval)</span></span><br><span class="line">      <span class="comment">//    (*&amp;byref)++</span></span><br><span class="line">      <span class="comment">// &#125;(byval, &amp;byref, 42)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// f is ONAME of the actual function.</span></span><br><span class="line">      f := xfunc.Func.Nname</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// We are going to insert captured variables before input args.</span></span><br><span class="line">      <span class="keyword">var</span> params []*types.Field</span><br><span class="line">      <span class="keyword">var</span> decls []*Node</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> xfunc.Func.Cvars.Slice() &#123;</span><br><span class="line">         <span class="keyword">if</span> !v.Name.Byval() &#123;</span><br><span class="line">            <span class="comment">// If v of type T is captured by reference,</span></span><br><span class="line">            <span class="comment">// we introduce function param &amp;v *T</span></span><br><span class="line">            <span class="comment">// and v remains PAUTOHEAP with &amp;v heapaddr</span></span><br><span class="line">            <span class="comment">// (accesses will implicitly deref &amp;v).</span></span><br><span class="line">            addr := newname(lookup(<span class="string">&quot;&amp;&quot;</span> + v.Sym.Name))</span><br><span class="line">            addr.Type = types.NewPtr(v.Type)</span><br><span class="line">            v.Name.Param.Heapaddr = addr</span><br><span class="line">            v = addr</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">         v.SetClass(PPARAM)</span><br><span class="line">         decls = <span class="built_in">append</span>(decls, v)</span><br><span class="line">    </span><br><span class="line">         fld := types.NewField()</span><br><span class="line">         fld.Nname = asTypesNode(v)</span><br><span class="line">         fld.Type = v.Type</span><br><span class="line">         fld.Sym = v.Sym</span><br><span class="line">         params = <span class="built_in">append</span>(params, fld)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(params) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="comment">// Prepend params and decls.</span></span><br><span class="line">         f.Type.Params().SetFields(<span class="built_in">append</span>(params, f.Type.Params().FieldSlice()...))</span><br><span class="line">         xfunc.Func.Dcl = <span class="built_in">append</span>(decls, xfunc.Func.Dcl...)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      dowidth(f.Type)</span><br><span class="line">      xfunc.Type = f.Type <span class="comment">// update type of ODCLFUNC</span></span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// The closure is not called, so it is going to stay as closure.</span></span><br><span class="line">      <span class="keyword">var</span> body []*Node</span><br><span class="line">      offset := <span class="type">int64</span>(Widthptr)</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> xfunc.Func.Cvars.Slice() &#123;</span><br><span class="line">         <span class="comment">// cv refers to the field inside of closure OSTRUCTLIT.</span></span><br><span class="line">         cv := nod(OCLOSUREVAR, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">         cv.Type = v.Type</span><br><span class="line">         <span class="keyword">if</span> !v.Name.Byval() &#123;</span><br><span class="line">            cv.Type = types.NewPtr(v.Type)</span><br><span class="line">         &#125;</span><br><span class="line">         offset = Rnd(offset, <span class="type">int64</span>(cv.Type.Align))</span><br><span class="line">         cv.Xoffset = offset</span><br><span class="line">         offset += cv.Type.Width</span><br><span class="line">    </span><br><span class="line">         <span class="keyword">if</span> v.Name.Byval() &amp;&amp; v.Type.Width &lt;= <span class="type">int64</span>(<span class="number">2</span>*Widthptr) &#123;</span><br><span class="line">            <span class="comment">// If it is a small variable captured by value, downgrade it to PAUTO.</span></span><br><span class="line">            v.SetClass(PAUTO)</span><br><span class="line">            xfunc.Func.Dcl = <span class="built_in">append</span>(xfunc.Func.Dcl, v)</span><br><span class="line">            body = <span class="built_in">append</span>(body, nod(OAS, v, cv))</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Declare variable holding addresses taken from closure</span></span><br><span class="line">            <span class="comment">// and initialize in entry prologue.</span></span><br><span class="line">            addr := newname(lookup(<span class="string">&quot;&amp;&quot;</span> + v.Sym.Name))</span><br><span class="line">            addr.Type = types.NewPtr(v.Type)</span><br><span class="line">            addr.SetClass(PAUTO)</span><br><span class="line">            addr.Name.SetUsed(<span class="literal">true</span>)</span><br><span class="line">            addr.Name.Curfn = xfunc</span><br><span class="line">            xfunc.Func.Dcl = <span class="built_in">append</span>(xfunc.Func.Dcl, addr)</span><br><span class="line">            v.Name.Param.Heapaddr = addr</span><br><span class="line">            <span class="keyword">if</span> v.Name.Byval() &#123;</span><br><span class="line">               cv = nod(OADDR, cv, <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            body = <span class="built_in">append</span>(body, nod(OAS, addr, cv))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(body) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         typecheckslice(body, ctxStmt)</span><br><span class="line">         xfunc.Func.Enter.Set(body)</span><br><span class="line">         xfunc.Func.SetNeedctxt(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   lineno = lno</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>那么具体是怎么捕获的呢？</p><p>在Go 语言中函数也是一种变量，和普通变量一样可以通过参数传递，可以做函数返回值。Go 语言把这样的函数变量称为 function value，它本质上是一个指针，指向一个 <code>runtime.funcval</code> 结构体，这个结构体保存了函数的入口地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">   fn <span class="type">uintptr</span></span><br><span class="line">   <span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/t.png" alt="img"></p><p>举个例子：func A 的指令位于代码段的 addr1。由于 func A 对应的 function value 没有捕获列表，编译期间编译器会在只读数据段分配一个 function value 结构体，这个结构体本身的地址是 addr2 ，它保存了 func A 的地址 addr1，多次 func A 调用共享一个 funcval。执行阶段，addr2 会被赋予 f1 与 f2。执行 f1 就是通过 f1 找出对应的 funcval，进而拿到 func A 入口地址。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tt.png" alt="img"></p><p><strong>为什么不直接通过addr1调用函数，而要添加一层中间层function value呢？</strong></p><p>这其实是为了支持闭包的实现，function value这一中间层方便我们将同一个函数绑定到不同的引用环境上。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tttt.png" alt="img"></p><p>通常来讲，局部变量都是分配在栈的，上图也是这样。但是，如果捕获变量的值会发生改变，Go 编译器会在堆上分配局部变量，栈上只保存一个地址。这就是所谓的“局部变量堆分配”。function value 的捕获列表保存局部变量的地址，这样闭包函数和外层函数就指向同一个变量了。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/ttttt.png" alt="img"></p><p>来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      a, b = b, a+b</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f1, f2 := Fibonacci(), Fibonacci()</span><br><span class="line">   fmt.Println(f1, f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码会输出什么？</strong></p><p>我们会发现它们输出的地址是一样的，不可思议。按道理每次分配新的funcval，地址是不可能相等的。其实fmt.Printf识别出f1和f2是函数变量后，把<code>funcval.fn</code>给打印出来了，打印的是函数的真实地址，而不是funcval的地址。</p><p>如果要查看真实地址，可以采用下面这种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      a, b = b, a+b</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f1, f2 := Fibonacci(), Fibonacci()</span><br><span class="line">   a1 := *(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;f1))</span><br><span class="line">   a2 := *(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;f2))</span><br><span class="line">   fmt.Println(a1, a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>闭包实际上就是一种语法糖机制，这种语法糖机制可以简化编程，比如，有时候对外部的变量进行访问，没这种语法糖机制将会编写冗余的代码。而这正也是可以把这种闭包机制归结为一种设计模式。但是由于使用闭包会导致代码不够清晰，使用不当还会导致得到错误的结果。所以一般不建议使用闭包。</p><p>不知道为什么，在我的环境下运行坑这一部分的代码时，是不会出现任何问题的，可能是 go 的新版本把这些问题给改了吧，也可能是编译器的优化问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://llmxby.com/2022/08/27/%E6%8E%A2%E7%A9%B6Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/">https://llmxby.com/2022/08/27/%E6%8E%A2%E7%A9%B6Golang%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</a></p><p><a href="https://learnku.com/articles/59988">https://learnku.com/articles/59988</a></p><p><a href="https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/">https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/</a></p><p><a href="https://polarisxu.studygolang.com/posts/go/action/go-closure/">https://polarisxu.studygolang.com/posts/go/action/go-closure/</a></p><p><a href="https://www.51cto.com/article/715815.html">https://www.51cto.com/article/715815.html</a></p><p><a href="https://www.cnblogs.com/liujiacai/p/17093687.html">https://www.cnblogs.com/liujiacai/p/17093687.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言从设计上对函数进行了优化和改进，让函数使用起来更加方便。&lt;/p&gt;
&lt;p&gt;因为Go语言的函数本身可以作为值进行传递，既支持匿名函数和闭包，又能满足接口，所以 Go 语言的函数属于一等公民。&lt;/p&gt;
&lt;p&gt;本文将由一道题引出 Go 中的闭包。这是 Go 语言爱好者周刊</summary>
      
    
    
    
    <category term="Go语言" scheme="http://example.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>腾讯面试——血与泪的教训（二）</title>
    <link href="http://example.com/2024/06/19/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2024/06/19/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-06-19T13:47:32.000Z</published>
    <updated>2024-06-19T15:50:43.816Z</updated>
    
    <content type="html"><![CDATA[<p>没想到啊，这个标题下的内容还能成为连续剧。</p><p>我终于明白我为什么找不到实习了，给我机会我不中用，我哭死，腾讯不愧是大公司，还给了我第四次面试机会，结果我还是没有把握住。有三分之一的问题没有回答出来，结果几乎全是之前就已经看过但是只是扫了一眼或者压根就只是躺在我的收藏夹里没动过。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a620f4b75df9a2cda1f0776b0d06015.jpg" alt="a620f4b75df9a2cda1f0776b0d06015"></p><p>还是借此机会，拾起来重新学吧。</p><p>今天的面试问题主要集中在两个方向，Go 语言基础的知识和数据库的一些底层内容。</p><h1 id="Golang中哪些不能作为map类型的key？"><a href="#Golang中哪些不能作为map类型的key？" class="headerlink" title="Golang中哪些不能作为map类型的key？"></a>Golang中哪些不能作为map类型的key？</h1><p>在 Go 语言中，<code>map</code> 的 <code>key</code> 可以是任意使用 <code>==</code> 或 <code>!=</code> 运算符进行比较的类型。这意味着一下类型可以作为 <code>map</code> 的键：</p><ul><li>基本类型：<code>int</code>、<code>float</code>、<code>bool</code>、<code>string</code></li><li>接口类型</li><li>指针类型</li><li>数组类型（数组中的元素必须是能作为键的类型）</li></ul><p>然而，以下类型<strong>不能</strong>作为 <code>map</code> 的键：</p><ul><li><code>slice</code></li><li><code>map</code></li><li><code>function</code></li><li>包含上述类型的结构体</li></ul><p>这是因为 <code>slice</code>、<code>map</code> 和 <code>function</code> 等类型的值不是固定的（它们在内存中的表示可能会改变），因此不能用于比较。例如，两个包含相同元素的 <code>slice</code> 在使用 <code>==</code> 运算符进行比较时会产生编译错误，因此 <code>slice</code> 不能作为 <code>map</code> 的键。</p><p>这就是我被问得满头大汗的起始点，从这个问题开始，我从语无伦次变得胡言乱语。</p><h1 id="Golang如何实现继承？"><a href="#Golang如何实现继承？" class="headerlink" title="Golang如何实现继承？"></a>Golang如何实现继承？</h1><p>我们在学习 Go 语言的时候就知道，它并不是一个常规的面向对象的编程的语言，所以在学习 Go 语言以及看一些底层实现的时候，我都没有认真地看过任何相关的内容。就在前两天我还看到了一个相关的内容，但是就扫了一眼，没有任何意外，我没记住，然后开始胡言乱语。</p><p>对于 go 语言的继承，之前总是模模糊糊的分不清是什么。不知道如何通过何种方式来继承的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/dPoVSPtWE3.png!large" alt="秒懂 go 语言的继承"></p><p>那我们就先看看 Java 是怎么实现继承的吧，然后使用 Go 来完成同样的继承操作。</p><h2 id="Java-操作"><a href="#Java-操作" class="headerlink" title="Java 操作"></a>Java 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>   String name;</span><br><span class="line">    <span class="keyword">public</span> String subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喜欢吃：&quot;</span> + food + <span class="string">&quot;,它属于：&quot;</span> + subject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类。 猫类继承动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">// 猫自己的属性和方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;今年&quot;</span> + age + <span class="string">&quot;岁了，特别喜欢睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个动物实例</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        a.name = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">        a.subject = <span class="string">&quot;动物科&quot;</span>;</span><br><span class="line">        a.eat(<span class="string">&quot;肉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个猫实例</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.name = <span class="string">&quot;咪咪&quot;</span>;</span><br><span class="line">        cat.subject = <span class="string">&quot;猫科&quot;</span>;</span><br><span class="line">        cat.age = <span class="number">1</span>;</span><br><span class="line">        cat.eat(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">        cat.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果入下：</span><br><span class="line">    动物喜欢吃：肉,它属于：动物科</span><br><span class="line">    咪咪喜欢吃：鱼,它属于：猫科</span><br><span class="line">    咪咪今年1岁了，特别喜欢睡觉</span><br></pre></td></tr></table></figure><h2 id="Go-语言实现继承"><a href="#Go-语言实现继承" class="headerlink" title="Go 语言实现继承"></a>Go 语言实现继承</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  subject <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物的公共方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> eat(food <span class="type">string</span>) &#123;</span><br><span class="line">  fmt.Println(a.name + <span class="string">&quot;喜欢吃：&quot;</span> + food +<span class="string">&quot;,它属于:&quot;</span> + a.subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类，继承动物类</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 继承动物的属性和方法</span></span><br><span class="line">  Animal</span><br><span class="line">  <span class="comment">// 猫自己的属性</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类独有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> sleep() &#123;</span><br><span class="line">  fmt.Println(c.name + <span class="string">&quot; 今年&quot;</span> + strconv.Itoa(c.age) + <span class="string">&quot;岁了,特别喜欢睡觉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个动物类</span></span><br><span class="line">  animal := Animal&#123;name:<span class="string">&quot;动物&quot;</span>, subject:<span class="string">&quot;动物科&quot;</span>&#125;</span><br><span class="line">  animal.eat(<span class="string">&quot;肉&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个猫类</span></span><br><span class="line">  cat := Cat&#123;Animal: Animal&#123;name:<span class="string">&quot;咪咪&quot;</span>, subject:<span class="string">&quot;猫科&quot;</span>&#125;,age:<span class="number">1</span>&#125;</span><br><span class="line">  cat.eat(<span class="string">&quot;鱼&quot;</span>)</span><br><span class="line">  cat.sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">    动物喜欢吃：肉,它属于:动物科</span><br><span class="line">    咪咪喜欢吃：鱼,它属于:猫科</span><br><span class="line">    咪咪 今年1岁了,特别喜欢睡觉</span><br></pre></td></tr></table></figure><p>是不是有点懂了，但是这只是最基础的封装，现在，在其他语言中，我们都知道，大多数都是以 interface 的方式来进行封装的。那么我们用 interface ，以一种高级的方式改造上面的例子如下：</p><h2 id="使用接口的方式进行封装一个方法"><a href="#使用接口的方式进行封装一个方法" class="headerlink" title="使用接口的方式进行封装一个方法"></a>使用接口的方式进行封装一个方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animaler <span class="keyword">interface</span> &#123;</span><br><span class="line">    eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    food <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 eat() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(animal Animal)</span></span> eat() &#123;</span><br><span class="line">    fmt.Println(animal.name + <span class="string">&quot;今年&quot;</span>+ strconv.Itoa(animal.age) +<span class="string">&quot;岁了，&quot;</span> + <span class="string">&quot;喜欢吃&quot;</span> + animal.food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Animal</span><br><span class="line">    time <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Animal</span><br><span class="line">    plays <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫独有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> sleep() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我叫&quot;</span> + cat.name + <span class="string">&quot;， 我能睡&quot;</span> + strconv.Itoa(cat.time) + <span class="string">&quot;分钟&quot;</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 狗独有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span></span> play() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我叫&quot;</span> + dog.name + <span class="string">&quot;我喜欢玩&quot;</span> + dog.plays)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInterface</span><span class="params">(animaler Animaler)</span></span>  &#123;</span><br><span class="line">    animaler.eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    cat := Cat&#123;Animal:Animal&#123;name:<span class="string">&quot;咪咪&quot;</span>, age:<span class="number">2</span>, food:<span class="string">&quot;鱼&quot;</span>&#125;, time: <span class="number">8</span>&#125;</span><br><span class="line">    cat.sleep()</span><br><span class="line">    testInterface(cat)</span><br><span class="line"></span><br><span class="line">    dog := Dog&#123;Animal:Animal&#123;name:<span class="string">&quot;大黄&quot;</span>, age:<span class="number">2</span>, food:<span class="string">&quot;骨头&quot;</span>&#125;, plays:<span class="string">&quot;球球&quot;</span>&#125;</span><br><span class="line">    dog.play()</span><br><span class="line">    testInterface(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我叫咪咪， 我能睡8分钟</span><br><span class="line">咪咪今年2岁了，喜欢吃鱼</span><br><span class="line">我叫大黄我喜欢玩球球</span><br><span class="line">大黄今年2岁了，喜欢吃骨头</span><br></pre></td></tr></table></figure><p>通过如上的代码可以看到，</p><ul><li>在 go 语言中， <code>type name struct&#123;&#125;</code> 结构体 就相当于其他语言中的 <code>class</code> 类的概念。</li><li>在其他语言中，方法是直接写在在 类 里面的，而在 go 语言中，我们对于该结构体，如果存在方法，比如猫咪存在睡觉的方法那么是以 <code>func (结构体名) 方法名&#123;&#125;</code>，即 <code>func(c Cat) sleep&#123;&#125;</code> 的方式来声明方法。</li><li>在 java 中， string + int = string，int 类型的值不需要类型转换，而在 go 语言中，string + int，如果想要一个字符串，则需要对 int 类型的值转换为 string 类型，然后才能拼接。</li></ul><h3 id="下面着这两句话一定要熟记："><a href="#下面着这两句话一定要熟记：" class="headerlink" title="下面着这两句话一定要熟记："></a>下面着这两句话一定要熟记：</h3><ul><li>结构体解决的是基本数据类型不能满足我们日常需要的问题。再简单点理解就是一个结构体就是一个 json 类型的 object。</li><li>接口是一种类型。是一种特殊的类型，它规定了不同结构体有哪些相同的行为，只是制定标准，而不实现标准。就好比自来水厂只规定水龙头的半径大小，而不去考虑谁生产水龙头，生产水龙头的厂家不管用什么材料，只需要按照自来水厂的标准制定就好。</li></ul><p>其实我并不觉得这是继承相关的内容，在语法上我们没有显示地去声明某个类要去继承另外一个类，也不能使用该类去调用父类的函数，Go 语言继承说白了就是结构体内嵌，而且设计者的想法也是通过组合来代替掉复杂的继承机制。</p><h1 id="Golang中两个变量值的交换方式"><a href="#Golang中两个变量值的交换方式" class="headerlink" title="Golang中两个变量值的交换方式?"></a>Golang中两个变量值的交换方式?</h1><p>先来看看各种方式的实现吧。</p><p>在 Go 语言中，可以使用以下四种方法来交换两个变量的值：</p><ol><li><p><strong>使用临时变量</strong>：这是最传统的方法，我们创建一个临时变量来保存一个变量的值，然后将另一个变量的值赋给第一个变量，最后将临时变量的值赋给第二个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure></li><li><p><strong>使用多重赋值</strong>：Go 语言支持多重赋值，这使得我们可以在一行代码中交换两个变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure></li><li><p><strong>使用指针</strong>：我们也可以使用指针来交换两个变量的值。在这种方法中，我们创建两个指针，分别指向两个变量，然后通过这两个指针来交换两个变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line">a := <span class="number">100</span></span><br><span class="line">b := <span class="number">200</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用算术运算</strong>：我们还可以使用加法和减法（或者异或运算）来交换两个变量的值。但是这种方法可能会因为数值过大而导致溢出，所以在实际应用中并不常用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b <span class="comment">// b = (a+b) - b = a</span></span><br><span class="line">a = a - b <span class="comment">// a = (a+b) - a = b</span></span><br></pre></td></tr></table></figure></li></ol><p>上面的四种方法虽然都能是实现我们想要的功能，但是我们实际上会经常应用的就是第二种方法。下面我们来看一下<strong>多重赋值</strong>的底层实现。</p><h2 id="如何实现多重赋值？"><a href="#如何实现多重赋值？" class="headerlink" title="如何实现多重赋值？"></a>如何实现多重赋值？</h2><p>我们来做一个小实验，看看四值交换的 golang 代码的汇编代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line">c := <span class="number">3</span></span><br><span class="line">d := <span class="number">4</span></span><br><span class="line">a, b, c, d = b, c, d, a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$&gt;dlv debug main.go</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b main.main</span><br><span class="line">Breakpoint 1 set at 0x454b6a for main.main() ~/pathToProject/main.go:3</span><br><span class="line">(dlv) r</span><br><span class="line">Process restarted with PID 26528</span><br><span class="line">(dlv) c</span><br><span class="line">&gt; main.main() ~/pathToProject/main.go:3 (hits goroutine(1):1 total:1) (PC: 0x454b6a)</span><br><span class="line">     1: package main</span><br><span class="line">     2:</span><br><span class="line">=&gt;   3: func main() &#123;</span><br><span class="line">     4:         a := 1</span><br><span class="line">     5:         b := 2</span><br><span class="line">     6:         c := 3</span><br><span class="line">     7:         d := 4</span><br><span class="line">(dlv) disassemble</span><br><span class="line">TEXT main.main(SB) D:/Users/polar/go/src/mylab/main.go</span><br><span class="line">        main.go:3       0x454b50        65488b0c2528000000      mov rcx, qword ptr gs:[0x28]</span><br><span class="line">        main.go:3       0x454b59        488b8900000000          mov rcx, qword ptr [rcx]</span><br><span class="line">        main.go:3       0x454b60        483b6110                cmp rsp, qword ptr [rcx+0x10]</span><br><span class="line">        main.go:3       0x454b64        0f8619020000            jbe 0x454d83</span><br><span class="line">=&gt;      main.go:3       0x454b6a*       4883ec50                sub rsp, 0x50</span><br><span class="line">        main.go:3       0x454b6e        48896c2448              mov qword ptr [rsp+0x48], rbp</span><br><span class="line">        main.go:3       0x454b73        488d6c2448              lea rbp, ptr [rsp+0x48]</span><br><span class="line">        main.go:4       0x454b78        48c744242801000000      mov qword ptr [rsp+0x28], 0x1  // a := 1</span><br><span class="line">        main.go:5       0x454b81        48c744242002000000      mov qword ptr [rsp+0x20], 0x2  // b := 2</span><br><span class="line">        main.go:6       0x454b8a        48c744241803000000      mov qword ptr [rsp+0x18], 0x3  // c := 3</span><br><span class="line">        main.go:7       0x454b93        48c744241004000000      mov qword ptr [rsp+0x10], 0x4  // d := 4</span><br><span class="line">        main.go:9       0x454b9c        488b442428              mov rax, qword ptr [rsp+0x28]</span><br><span class="line">        main.go:9       0x454ba1        4889442440              mov qword ptr [rsp+0x40], rax  // temp = a</span><br><span class="line">        main.go:9       0x454ba6        488b442420              mov rax, qword ptr [rsp+0x20]</span><br><span class="line">        main.go:9       0x454bab        4889442428              mov qword ptr [rsp+0x28], rax  // a = b</span><br><span class="line">        main.go:9       0x454bb0        488b442418              mov rax, qword ptr [rsp+0x18]</span><br><span class="line">        main.go:9       0x454bb5        4889442420              mov qword ptr [rsp+0x20], rax  // b = c</span><br><span class="line">        main.go:9       0x454bba        488b442410              mov rax, qword ptr [rsp+0x10]</span><br><span class="line">        main.go:9       0x454bbf        4889442418              mov qword ptr [rsp+0x18], rax  // c = d</span><br><span class="line">        main.go:9       0x454bc4        488b442440              mov rax, qword ptr [rsp+0x40]</span><br><span class="line">        main.go:9       0x454bc9        4889442410              mov qword ptr [rsp+0x10], rax  // d = temp</span><br></pre></td></tr></table></figure><p>很好理解了，就是编译器帮我们在栈上创建了一个临时变量 temp, 然后按顺序交换其他各个变量的值。</p><p>那么下面这种情况，会发生什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := 1</span><br><span class="line">b := 2</span><br><span class="line">a, b, a = b, a, b</span><br></pre></td></tr></table></figure><p>a 和 b 最终的值是多少？</p><p>看一下汇编代码就清楚了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main.go:5   0x454b9b 48c744241801000000   mov qword ptr [rsp+0x18], 0x1  // a:=1</span><br><span class="line">main.go:6   0x454ba4 48c744241002000000   mov qword ptr [rsp+0x10], 0x2  // b:=2</span><br><span class="line">main.go:7   0x454bad 488b442418           mov rax, qword ptr [rsp+0x18]</span><br><span class="line">main.go:7   0x454bb2 4889442428           mov qword ptr [rsp+0x28], rax  // aTemp := a</span><br><span class="line">main.go:7   0x454bb7 488b442410           mov rax, qword ptr [rsp+0x10]</span><br><span class="line">main.go:7   0x454bbc 4889442420           mov qword ptr [rsp+0x20], rax  // bTemp := b</span><br><span class="line">main.go:7   0x454bc1 488b442410           mov rax, qword ptr [rsp+0x10]</span><br><span class="line">main.go:7   0x454bc6 4889442418           mov qword ptr [rsp+0x18], rax  // a = b</span><br><span class="line">main.go:7   0x454bcb 488b442428           mov rax, qword ptr [rsp+0x28]</span><br><span class="line">main.go:7   0x454bd0 4889442410           mov qword ptr [rsp+0x10], rax  // b = aTemp</span><br><span class="line">main.go:7   0x454bd5 488b442420           mov rax, qword ptr [rsp+0x20]</span><br><span class="line">main.go:7   0x454bda 4889442418           mov qword ptr [rsp+0x18], rax  // a = bTemp</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aTemp = a</span><br><span class="line">bTemp = b</span><br><span class="line">a, b, a = bTemp, aTemp, bTemp</span><br></pre></td></tr></table></figure><p>这里两个值交换的操作的原理是将两个被赋值的变量的值，都存储在临时变量里，然后再用临时变量去赋值。所以这个例子赋值顺序对结果是无影响的，其结果仍然是 a = 2, b = 1。</p><p>不用再像 C 语言那样写交换函数再内联了，相当于把脏活丢给编译器干了。</p><p>这个问题我好像不是很明白面试官的意图，他说要问我这种赋值方式的实现原理，但是实现原理其实就是我写出的代码，难道是我想复杂了？</p><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><blockquote><p>MySQL 中最常见的存储引擎有：InnoDB、MyISAM 和 MEMORY，其中 InnoDB 是 MySQL 5.1 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列，它的特点是稳定（能保证业务的完整性），但数据的读写效率一般。</p></blockquote><p>MySQL 有很多存储引擎（也叫数据引擎），所谓的存储引擎是指用于存储、处理和保护数据的核心服务。也就是存储引擎是数据库的底层软件组织。在 MySQL 中可以使用“show engines”来查询数据库的所有存储引擎，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240619230440251.png" alt="image-20240619230440251"></p><p>在上述列表中，我们最常用的存储引擎有以下 3 种：</p><ul><li>InnoDB</li><li>MyISAM</li><li>MEMORY</li></ul><p>下面我们分别来看。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><blockquote><p>InnoDB 是事务型数据库的首选引擎，支持事务安全表 (ACID)，支持行锁定和外键。MySQL5.5.5 之后，InnoDB 作为默认存储引擎，InnoDB 主要特性有：</p></blockquote><ol><li>InnoDB 给 MySQL 提供了具有<strong>提交</strong>、<strong>回滚</strong>和<strong>崩溃恢复能力的事务安全(ACID 兼容)</strong>存储引擎。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表与其他 MySQL 的表的类型混合起来，甚至在同一个查询中也可以混合。</li><li>InnoDB 是为<strong>处理巨大数据量</strong>的最大性能设计。它的 CPU 的效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。</li><li>InnoDB 存储引擎完全与 MySQL 服务器整合，InnoDB 存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB 将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被艰制为 2GB 的操作系统上。</li><li>InnoDB 支持<strong>外键完整性约束（FOREIGN KEY)</strong>。 存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会被每一行生成一个 6B 的 ROWID，并以此作为主健。</li><li>InnoDB 被用在众多需要高性能的大型数据库站点上。 InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MYSQL 数据目录下创建一个名为 ibdata1 的 10MB 大小的自动扩展数据文件，以及两个名为ib_logfile() 和 ib_logfile1 的 5MB 大小的日志文件。</li></ol><p>InnoDB 的优势是支持事务、支持外键、支持崩溃修复和自增列；它的缺点是读写效率较差、占用的数据空间较大。</p><h2 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h2><blockquote><p>MyISAM 基于 ISAM 的存储引擎，并对其进行扩展。它是在 Web、数据存储和其他应用环境下最常用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。不支持行级锁，因此在添加和修改操作时，会执行锁表操作，所以它的写入效率较低。在 MySQL5.5.5 之前的版本中，MyISAM 是默认存储引擎。MyISAM 主要特性有：</p></blockquote><ol><li>大文件（达 63 位文件长度）在支持大文件系统和操作系统上被支持。</li><li>当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少的碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。</li><li>每个 MyISAM 表最大索引数是 64，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。</li><li>BLOB 和 TEXT 列可以被索引。</li><li>NULL 值被允许在索引的列中。这个值占每个键的 0~1 个字节。</li><li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩。</li><li>每表一个 AUTO_INCREMENT 列的内部处理。MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列。使得 AUTO_INCREMENT 列更快（至少 10%）。在序列顶的值被删除除之后就不能再利用。</li><li>可以把数据文件和索引文件放在不同目录。</li><li>每个字符列可以有不同的字符集。</li><li>有 VARCHAR 的表可以固定或动态记录长度。</li><li>VARCHAR 和 CHAR 列可以多达 64KB</li></ol><blockquote><p>使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以表的名字开始，扩展名指出文件类型：frm 文件存储表定义，数据文件的扩展名为 .MYD(MYData)，索引文件的扩展名是 .MYI（MYIndex)。</p></blockquote><p>MyISAM 引擎保存了单独的索引文件 .myi，且它的索引是直接定位到 OFFSET 的，而 InnoDB 没有单独的物理索引存储文件，且 <strong>InnoDB 索引寻址是先定位到块数据，再定位到行数据，所以 MyISAM 的查询效率是比 InnoDB 的查询效率要高。</strong>但它不支持事务、不支持外键，所以它的适用场景是<strong>读多写少</strong>，且<strong>对完整性要求不高</strong>的业务场景。</p><h2 id="MEMORY-存储引擎"><a href="#MEMORY-存储引擎" class="headerlink" title="MEMORY 存储引擎"></a>MEMORY 存储引擎</h2><blockquote><p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。同样不支持事务、不支持外键。MEMORY 支持 Hash 索引或 B 树索引，其中 Hash 索引是基于 key 查询的，因此查询效率特别高，但如果是基于范围查询的效率就比较低了。MEMORY 主要特性有：</p></blockquote><ol><li>MEMORY 表的每个表可以多达 32 个索引，每个索引 16 列，以及 500B 的最大键长度。</li><li>MEMORY 存储引擎引擎执行 HASH 和 BTREE 索引。</li><li>可以在一个 MEMORY 表中有非唯一键。</li><li>MEMORY 不支持 BLOB 或 TEXT 列。</li><li>MEMORY 表使用一个固定的记录长度格式。</li><li>MEMORY 支持 AUTO_INCREMENT 列和对包含 NULL 值的列索引。</li><li>MEMORY 表内容被存在内存中，内存是 MEMORY 表和服务器在查询处理时的空闲中创建的内部表共享。</li><li>MEMORY 表在所有客户端之间共享（就像其他任何非 TEMPORARY 表）。</li><li>当不再需要 MEMORY 表的内容时，要释放被 MEMORY 表使用的内存，应该执行 DELETE FROM 或 TRUNCATE TABLE，或者删除整个表（使用 DROP TABLE)。</li></ol><p>MEMORY 读写性能很高，但 MySQL 服务重启之后数据会丢失，它不支持事务和外键。适用场景是读写效率要求高，但对数据丢失不敏感的业务场景。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">MyISAM</th><th style="text-align:left">Memory</th><th style="text-align:left">InnoDB</th></tr></thead><tbody><tr><td style="text-align:left">存储限制</td><td style="text-align:left">265TB</td><td style="text-align:left">RAM</td><td style="text-align:left">65TB</td></tr><tr><td style="text-align:left">支持事务</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">支持全文索引</td><td style="text-align:left">Yes</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">支持数索引</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">支持哈希索引</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">支持数据缓存</td><td style="text-align:left">No</td><td style="text-align:left">N/A</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">支持外键</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr></tbody></table></div><p>MyISAM 和 InnoDB 更详细的区别：</p><div class="table-container"><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">事务</td><td style="text-align:center">不支持</td><td>支持</td></tr><tr><td style="text-align:center">存储结构</td><td style="text-align:center">每个MyISAM在磁盘上存储成三个文件</td><td>所有的表都保存在同一个数据文件中</td></tr><tr><td style="text-align:center">存储空间</td><td style="text-align:center">可被压缩，存储空间较小</td><td>会在主内存中建立其专用的缓冲池（需要更多内存和存储）</td></tr><tr><td style="text-align:center">可移植性</td><td style="text-align:center">跨平台的数据转移中会很方便，在备份和恢复时可单独针对某个表进行操作</td><td>拷贝数据文件、备份 binlog，或者用 mysqldump</td></tr><tr><td style="text-align:center">事务支持</td><td style="text-align:center">每次查询具有原子性，但不支持事务</td><td>提供事务支持事务</td></tr><tr><td style="text-align:center">表锁差异</td><td style="text-align:center">只支持表级锁</td><td>支持行级锁</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持</td><td>不支持</td></tr><tr><td style="text-align:center">表主键</td><td style="text-align:center">允许没有任何索引和主键的表存在</td><td>如果未设置主键，会自动生成</td></tr><tr><td style="text-align:center">表总行数</td><td style="text-align:center">保存有</td><td>没有保存</td></tr><tr><td style="text-align:center">CURD</td><td style="text-align:center">对于select支持更好</td><td>INSERT/DELETE支持更好</td></tr><tr><td style="text-align:center">外键</td><td style="text-align:center">不支持</td><td>支持</td></tr><tr><td style="text-align:center">查询效率</td><td style="text-align:center">小型应用可以考虑使用</td><td>高并发、复杂情况表现更优</td></tr></tbody></table></div><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。</p><p>InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</p><h1 id="MySQL索引有哪些？"><a href="#MySQL索引有哪些？" class="headerlink" title="MySQL索引有哪些？"></a>MySQL索引有哪些？</h1><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<br>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。<br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。<br>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><h2 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h2><p>MySQL索引按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102315.73077093610994059043569245969116%253A50001231000000%253A2800%253A0811D2FDEE3B45B77393B5BF0FEC352D34506ADE23D6B11EF6A4AF3E0422E8DF.png" alt="img"></p><blockquote><p>InnoDB实际上也支持Hash索引，但是InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。</p></blockquote><p>又聊到了这个问题，B+ 树，先前有文章去分析过它，这里简单写一些当时没在意的内容。</p><p><strong>B+tree</strong> 是MySQL中被存储引擎采用最多的索引类型。<strong>B+tree</strong> 中的 <code>B</code> 代表平衡（balance），而不是二叉（binary），因为 <strong>B+tree</strong> 是从最早的平衡二叉树演化而来的。下面展示B+tree数据结构与其他数据结构的对比。</p><h3 id="B-树-和-B树的对比"><a href="#B-树-和-B树的对比" class="headerlink" title="B+树 和 B树的对比"></a>B+树 和 B树的对比</h3><p><strong>B-tree</strong> 中的每个节点根据实际情况可以包含多条数据信息和子节点，如下图所示为一个3阶的B-tree：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102331.30999891407256149613718451179943%253A50001231000000%253A2800%253A80D5E61F978DBBE67A0F8B41CB7F5D2B54CF2F344D3FD5A6AD9E97181B268771.png" alt="img"></p><p><strong>相对于B-tree，B+tree有以下三点不同：</strong></p><ul><li>B+tree 非叶子节点只存储键值信息， 数据记录都存放在叶子节点中。而B-tree的非叶子节点也存储数据。所以B+tree单个节点的数据量更小，在相同的磁盘I/O次数下，能查询更多的节点。</li><li>B+tree 所有叶子节点之间都采用单链表连接。适合MySQL中常见的基于范围的顺序检索场景，而B-tree无法做到这一点。</li><li>B+tree 的子树数量等于它的关键字的数量，而 B-tree是关键字数量 + 1.</li></ul><h3 id="B-树-和-Hash-的对比"><a href="#B-树-和-Hash-的对比" class="headerlink" title="B+树 和 Hash 的对比"></a>B+树 和 Hash 的对比</h3><p>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：</p><ul><li><p><strong>Hash 索引仅仅能满足 <code>=</code> , <code>IN</code> 和 <code>&lt;=&gt;</code>(表示NULL安全的等价) 查询，不能使用范围查询。</strong></p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p></li><li><p><strong>Hash 索引无法适用数据的排序操作。</strong></p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash值，而且Hash值的大小关系并不一定和 Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p></li><li><p><strong>Hash 索引不能利用部分索引键查询。</strong></p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p></li><li><p><strong>Hash 索引依然需要回表扫描。</strong></p><p>Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键可能存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p></li><li><p><strong>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</strong></p><p>选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</p></li></ul><p><strong>由于范围查询是MySQL数据库查询中常见的场景，Hash表不适合做范围查询，它更适合做等值查询。另外Hash表还存在Hash函数选择和Hash值冲突等问题。因此，B+tree索引要比Hash表索引有更广的适用场景。</strong></p><p>在这里又要挖一个坑，后面肯定学习一致性算法。</p><h2 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h2><p>MySQL索引按叶子节点存储的是否为完整表数据分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102427.53515137275530572272513487545890%253A50001231000000%253A2800%253A4882A822A534BD6DA268CFCAE86B5E86B8CD748C4C7D57A43454012D9F3F64D2.png" alt="img"></p><p>InnoDB表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个隐式的自增id列，并在此列上建立聚簇索引。</p><p><strong>以MyISAM为存储引擎的表不存在聚簇索引。</strong></p><p>MyISAM表中的主键索引和非主键索引的结构是一样的，索引的叶子节点不存储表数据，存放的是表数据的地址。所以，MyISAM表可以没有主键。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102441.88414806560933869728435063808011%253A50001231000000%253A2800%253ACC3375B7FDAD49A1CBBD4F38968D563DF92C374A3C9FCBF427126AA644A75848.png" alt="img"></p><p>MyISAM表的数据和索引是分开存储的。MyISAM表的主键索引和非主键索引的区别仅在于主键索引的B+tree上的key必须符合主键的限制，非主键索引B+tree上的key只要符合相应字段的特性就可以了。</p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102454.45282045827004763457106217296461%253A50001231000000%253A2800%253A0511EA1E0E6F9C254C9D44002CC031237E63DE0D2D2AB133B09C0B583B45BC9F.png" alt="img"></p><p><strong>回表查询</strong></p><p>由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/2850086000437053095.20201112102506.85588670262453085996806072422996%253A50001231000000%253A2800%253AAF69C7F57EA4B0651E3387A2E813AEFA88A5C9EDA2F510FB1C07C4FF79CC7C73.png" alt="img"></p><p>回表查询 需要额外的 <strong>B+tree</strong> 搜索过程，必然增大查询耗时。</p><p>需要注意的是，<strong>通过二级索引查询时，回表不是必须的过程</strong>，当<strong>SELECT的所有字段在单个二级索引中都能够找到</strong>时，就不需要回表，MySQL称此时的二级索引为<strong>覆盖索引</strong>或触发了<strong>索引覆盖</strong>。<br>可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现<strong>Using index</strong>，表示查询触发了<strong>索引覆盖</strong>。</p><h2 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h2><p>MySQL索引按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>建立在主键上的索引被称为<strong>主键索引</strong>，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>建立在UNIQUE字段上的索引被称为<strong>唯一索引</strong>，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>建立在普通字段上的索引被称为<strong>普通索引</strong>。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p><strong>前缀索引</strong>是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p><h2 id="按索引字段个数分类"><a href="#按索引字段个数分类" class="headerlink" title="按索引字段个数分类"></a>按索引字段个数分类</h2><p>MySQL索引按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>建立在单个列上的索引被称为单列索引。</p><h3 id="联合索引（复合索引、组合索引）"><a href="#联合索引（复合索引、组合索引）" class="headerlink" title="联合索引（复合索引、组合索引）"></a>联合索引（复合索引、组合索引）</h3><p>建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是今天晚上的面试中我学习到的内容，并不是全部，还有关于算法和分布式系统的内容，我觉得内容会比较多，所以还是后面的博客里见吧，这次绝对不会再拖沓了，我要在考试周结束之前把所有之前欠下的东西补完。</p><p>我是个大**（自动消音：哔~），之前一直说的要沉淀沉淀，现在看来好像全是笑话。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.iamshuaidi.com/23129.html">问题一</a></p><p><a href="https://learnku.com/articles/32295">问题二</a></p><p>问题三</p><ul><li><p><a href="https://www.iamshuaidi.com/23169.html">https://www.iamshuaidi.com/23169.html</a></p></li><li><p><a href="https://studygolang.com/articles/20485">https://studygolang.com/articles/20485</a></p></li></ul><p>问题四</p><ul><li><a href="https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html">https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1076553">https://cloud.tencent.com/developer/article/1076553</a></li><li><a href="https://blog.csdn.net/qq_30108237/article/details/106672303">https://blog.csdn.net/qq_30108237/article/details/106672303</a></li><li><a href="https://www.runoob.com/note/28228">https://www.runoob.com/note/28228</a></li><li><a href="https://www.51cto.com/article/710761.html">https://www.51cto.com/article/710761.html</a></li></ul><p><a href="https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236">问题五</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没想到啊，这个标题下的内容还能成为连续剧。&lt;/p&gt;
&lt;p&gt;我终于明白我为什么找不到实习了，给我机会我不中用，我哭死，腾讯不愧是大公司，还给了我第四次面试机会，结果我还是没有把握住。有三分之一的问题没有回答出来，结果几乎全是之前就已经看过但是只是扫了一眼或者压根就只是躺在我的</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文——基础篇（三）</title>
    <link href="http://example.com/2024/06/19/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2024/06/19/Java%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2024-06-19T10:07:33.000Z</published>
    <updated>2024-06-20T16:13:46.620Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 Java 基础八股文的第三篇，本文内容包括异常、泛型、反射、注解、SPI、I/O等，内容很杂也是一些重要内容，一两个问题讲不清的后面还是要单独来学习吧。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图"></p><h2 id="Exception-和-Error-有什么区别"><a href="#Exception-和-Error-有什么区别" class="headerlink" title="Exception 和 Error 有什么区别"></a>Exception 和 Error 有什么区别</h2><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。 <code>Throwable</code> 有两个重要的子类：</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h2 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h2><p><strong><code>Checked Exception</code></strong> 即<strong>受检查异常</strong>，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>比如下面这段 I/O 操作的代码：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/checked-exception.png" alt="img"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h2 id="Throwable类常用方法有哪些？"><a href="#Throwable类常用方法有哪些？" class="headerlink" title="Throwable类常用方法有哪些？"></a><code>Throwable</code>类常用方法有哪些？</h2><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h2 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a><code>try-catch-finally</code> 如何使用？</h2><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块：用于处理 try 捕获到的异常。</li><li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a><code>finally</code> 中的代码一定会执行吗？</h2><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h2><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = null;</span><br><span class="line">try &#123;</span><br><span class="line">    scanner = <span class="built_in">new</span> Scanner(<span class="built_in">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    while (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != null) &#123;</span><br><span class="line">        scanner.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li><li>……</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型？有什么作用？泛型的使用方式有哪几种？"><a href="#什么是泛型？有什么作用？泛型的使用方式有哪几种？" class="headerlink" title="什么是泛型？有什么作用？泛型的使用方式有哪几种？"></a>什么是泛型？有什么作用？泛型的使用方式有哪几种？</h2><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><hr><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-32.png" alt="泛型类、泛型接口、泛型方法"></p><p><strong>泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>泛型常用的通配符有哪些？</p></blockquote><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt; 无限制通配符</span><br><span class="line">&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br><span class="line">&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br></pre></td></tr></table></figure><blockquote><p>使用原则《Effictive Java》<br>为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</p><ol><li>如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</li><li>如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；</li><li>如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ol></blockquote><h2 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h2><p>所谓的泛型擦除，官方名叫“类型擦除”。</p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。</p><p>也就是说，在运行的时候是没有泛型的。</p><p>例如这段代码，往一群猫里放条狗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Cat&gt; cats = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Cat&gt;();</span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;  <span class="comment">// 注意我在这里把范型去掉了，但是list和cats是同一个链表！</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 完全没问题！</span></span><br></pre></td></tr></table></figure><p>因为 Java 的范型只存在于源码里，编译的时候给你静态地检查一下范型类型是否正确，而到了运行时就不检查了。上面这段代码在 JRE（Java<strong>运行</strong>环境）看来和下面这段没区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">cats</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  <span class="comment">// 注意：没有范型！</span></span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br></pre></td></tr></table></figure><p><strong>泛型的类型擦除原则</strong>是：</p><ul><li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><p>为什么要类型擦除呢？</p><p>主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p><h2 id="如何理解泛型的多态？泛型的桥接方法"><a href="#如何理解泛型的多态？泛型的桥接方法" class="headerlink" title="如何理解泛型的多态？泛型的桥接方法"></a>如何理解泛型的多态？泛型的桥接方法</h2><blockquote><p>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p></blockquote><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们想要一个子类继承它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p><p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>再看子类的两个重写的方法的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">DateInter</span> <span class="variable">dateInter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInter</span>();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());                  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。</p><p><strong>为什么会这样呢</strong>？</p><p>原因是这样的，我们传入父类的泛型类型是Date，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p><p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p><blockquote><p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p></blockquote><p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.tao.test.DateInter <span class="keyword">extends</span> <span class="title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.util.Date)</span>;  <span class="comment">//我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: invokespecial #<span class="number">16</span>                 <span class="comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Date <span class="title function_">getValue</span><span class="params">()</span>;    <span class="comment">//我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">23</span>                 <span class="comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span></span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">getValue</span><span class="params">()</span>;     <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokevirtual #<span class="number">28</span>                 <span class="comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span></span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">30</span>                 <span class="comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p><p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p><p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p><p>setValue方法是为了解决类型擦除与多态之间的冲突。</p><p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p><p>那么父类的getValue方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p><p>并且，还有一点也许会有疑问，子类中的桥方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p><h2 id="如何理解基本类型不能作为泛型类型？"><a href="#如何理解基本类型不能作为泛型类型？" class="headerlink" title="如何理解基本类型不能作为泛型类型？"></a>如何理解基本类型不能作为泛型类型？</h2><blockquote><p>比如，我们没有<code>ArrayList&lt;int&gt;</code>，只有<code>ArrayList&lt;Integer&gt;</code>, 为何？</p></blockquote><p>因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><p>另外需要注意，我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解？注解的生命周期？注解的解析方式？"><a href="#什么是注解？注解的生命周期？注解的解析方式？" class="headerlink" title="什么是注解？注解的生命周期？注解的解析方式？"></a>什么是注解？注解的生命周期？注解的解析方式？</h2><p><strong>Java 注解本质上是一个标记</strong>，可以理解成生活中的一个人的一些小装扮，比如戴什么什么帽子，戴什么眼镜。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-33.png" alt="Java注解和帽子"></p><p>注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值，比如帽子颜色是绿色。</p><p>有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处。</p><p>例如我们常见的 AOP，使用注解作为切点就是运行期注解的应用；比如 lombok，就是注解在编译期的运行。</p><p>注解<strong>生命周期</strong>有三大类，分别是：</p><ul><li><code>RetentionPolicy.SOURCE</code>：给编译器用的，不会写入 class 文件</li><li><code>RetentionPolicy.CLASS</code>：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了</li><li><code>RetentionPolicy.RUNTIME</code>：会写入 class 文件，永久保存，可以通过反射获取注解信息</li></ul><p>所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。</p><p>像常见的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-34.png" alt="Override注解"></p><p>就是给编译器用的，编译器编译的时候检查没问题就 over 了，class 文件里面不会有 Override 这个标记。</p><p>再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以<strong>在运行的时候可以通过反射得到注解的信息</strong>，还能拿到标记的值 required 。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-35.png" alt="Autowired注解"></p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射是什么？应用？原理？"><a href="#反射是什么？应用？原理？" class="headerlink" title="反射是什么？应用？原理？"></a>反射是什么？应用？原理？</h2><p>创建一个对象是通过 new 关键字来实现的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>Person 类的信息在编译时就确定了，那假如在编译期无法确定类的信息，但又想在运行时获取类的信息、创建类的实例、调用类的方法，这时候就要用到反射。</p><p>反射功能主要通过 <code>java.lang.Class</code> 类及 <code>java.lang.reflect</code> 包中的类如 Method, Field, Constructor 等来实现。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-36.png" alt="三分恶面渣逆袭：Java反射相关类"></p><p>比如说我们可以装来动态加载类并创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure><p>比如说我们可以这样来访问字段和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载并实例化类</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;getTime&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj);</span><br><span class="line">System.out.println(<span class="string">&quot;Time: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;fastTime&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 对于私有字段需要这样做</span></span><br><span class="line">System.out.println(<span class="string">&quot;fastTime: &quot;</span> + field.getLong(obj));</span><br></pre></td></tr></table></figure><p><strong>反射有哪些应用场景</strong>？</p><p>一般我们平时都是在在写业务代码，很少会接触到直接使用反射机制的场景。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>像 Spring 里的很多 <strong>注解</strong> ，它真正的功能实现就是利用反射。</p><p>就像为什么我们使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为我们可以基于反射操作类，然后获取到类/属性/方法/方法的参数上的注解，注解这里就有两个作用，一是标记，我们对注解标记的类/属性/方法进行对应的处理；二是注解本身有一些信息，可以参与到处理的逻辑中。</p><p><strong>反射的原理是什么</strong>？</p><p>我们都知道 Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="什么是-SPI？它有什么用？"><a href="#什么是-SPI？它有什么用？" class="headerlink" title="什么是 SPI？它有什么用？"></a>什么是 SPI？它有什么用？</h2><p>SPI 即 <code>Service Provider Interface</code> ，字面意思就是：“<strong>服务提供者的接口</strong>”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg" alt="img"></p><h2 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h2><p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png" alt="img"></p><p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p><p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p><p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p><p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p><h2 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="SPI 的优缺点"></a>SPI 的优缺点</h2><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p><ul><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ul><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><h2 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h2><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>维基百科是如是介绍序列化的：</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/a478c74d-2c48-40ae-9374-87aacf05188c.png" alt="img"></p><p><strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？</strong></p><p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p><p>如上图所示，OSI 七层协议模型中，<strong>表示层</strong>做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议<strong>应用层</strong>的一部分。</p><h2 id="了解哪些序列化方式？"><a href="#了解哪些序列化方式？" class="headerlink" title="了解哪些序列化方式？"></a>了解哪些序列化方式？</h2><p>Java 序列化方式有很多，常见的有三种：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-31.png" alt="Java常见序列化方式"></p><ul><li>Java 对象序列化 ：Java 原生序列化方法即通过 Java 原生流(InputStream 和 OutputStream 之间的转化)的方式进行转化，一般是对象输出流 <code>ObjectOutputStream</code>和对象输入流<code>ObjectInputStream</code>。</li><li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。</li><li>ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul><h2 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h2><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h2 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h2><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为<strong>字节流</strong>和<strong>字符流</strong>。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h2 id="有什么分类？"><a href="#有什么分类？" class="headerlink" title="有什么分类？"></a>有什么分类？</h2><p>Java IO 流的划分可以根据多个维度进行，包括数据流的方向（输入或输出）、处理的数据单位（字节或字符）、流的功能以及流是否支持随机访问等。</p><p><strong>按照数据流方向如何划分</strong>？</p><ul><li>输入流（Input Stream）：从源（如文件、网络等）读取数据到程序。</li><li>输出流（Output Stream）：将数据从程序写出到目的地（如文件、网络、控制台等）。</li></ul><p><strong>按处理数据单位如何划分</strong>？</p><ul><li>字节流（Byte Streams）：以字节为单位读写数据，主要用于处理二进制数据，如音频、图像文件等。</li><li>字符流（Character Streams）：以字符为单位读写数据，主要用于处理文本数据。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/shangtou-01.png" alt="二哥的 Java 进阶之路"></p><p><strong>按功能如何划分</strong>？</p><ul><li>节点流（Node Streams）：直接与数据源或目的地相连，如 FileInputStream、FileOutputStream。</li><li>处理流（Processing Streams）：对一个已存在的流进行包装，如缓冲流 BufferedInputStream、BufferedOutputStream。</li><li>管道流（Piped Streams）：用于线程之间的数据传输，如 PipedInputStream、PipedOutputStream。</li></ul><h2 id="IO-流为什么要分为字节流和字符流？"><a href="#IO-流为什么要分为字节流和字符流？" class="headerlink" title="IO 流为什么要分为字节流和字符流？"></a>IO 流为什么要分为字节流和字符流？</h2><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 IO 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li><li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li></ul><p>所以， IO 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><p><strong>文本存储是字节流还是字符流，视频文件呢</strong>？</p><p>在计算机中，文本和视频都是按照字节存储的，只是如果是文本文件的话，我们可以通过字符流的形式去读取，这样更方便的我们进行直接处理。</p><p>比如说我们需要在一个大文本文件中查找某个字符串，可以直接通过字符流来读取判断。</p><p>处理视频文件时，通常使用字节流（如 Java 中的<code>FileInputStream</code>、<code>FileOutputStream</code>）来读取或写入数据，并且会尽量使用缓冲流（如<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>）来提高读写效率。</p><p>因此，无论是文本文件还是视频文件，它们在物理存储层面都是以字节流的形式存在。区别在于，我们如何通过 Java 代码来解释和处理这些字节流：作为编码后的字符还是作为二进制数据。</p><h2 id="IO流用到了什么设计模式？"><a href="#IO流用到了什么设计模式？" class="headerlink" title="IO流用到了什么设计模式？"></a>IO流用到了什么设计模式？</h2><p>其实，Java 的 IO 流体系还用到了一个设计模式——<strong>装饰器模式</strong>。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-25.png" alt="Java IO流用到装饰器模式"></p><h2 id="BIO、NIO、AIO-之间的区别？"><a href="#BIO、NIO、AIO-之间的区别？" class="headerlink" title="BIO、NIO、AIO 之间的区别？"></a>BIO、NIO、AIO 之间的区别？</h2><p>BIO（Blocking I/O）：采用阻塞式 I/O 模型，线程在执行 I/O 操作时被阻塞，无法处理其他任务，适用于连接数较少的场景。</p><p>NIO（New I/O 或 Non-blocking I/O）：采用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，适用于连接数多但连接时间短的场景。</p><p>AIO（Asynchronous I/O）：使用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-20240404103618.png" alt="二哥的 Java 进阶之路：IO 分类"></p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO，也就是传统的 IO，基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，基于 Socket 和 ServerSocket 进行网络通信。</p><p>对于每个连接，都需要创建一个独立的线程来处理读写操作。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-27.png" alt="三分恶面渣逆袭：BIO"></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO，JDK 1.4 时引入，放在 java.nio 包下，提供了 Channel、Buffer、Selector 等新的抽象，基于 RandomAccessFile、FileChannel、ByteBuffer 进行文件读写，基于 SocketChannel 和 ServerSocketChannel 进行网络通信。</p><p>实际上，“旧”的 I/O 包已经使用 NIO 重新实现过，所以在进行文件读写时，NIO 并无法体现出比 BIO 更可靠的性能。</p><p>NIO 的魅力主要体现在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，极大地提高了网络编程的性能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-28.png" alt="三分恶面渣逆袭：NIO"></p><p>缓冲区 Buffer 也能极大提升一次 IO 操作的效率。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/javase-29.png" alt="三分恶面渣逆袭：NIO完整示意图"></p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO 是 Java 7 引入的，放在 java.nio.channels 包下，提供了 AsynchronousFileChannel、AsynchronousSocketChannel 等异步 Channel。</p><p>它引入了异步通道的概念，使得 I/O 操作可以异步进行。这意味着线程发起一个读写操作后不必等待其完成，可以立即进行其他任务，并且当读写操作真正完成时，线程会被异步地通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;test.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">Future&lt;Integer&gt; result = fileChannel.read(buffer, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><h2 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h2><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>举个例子，Java 中的 <code>for-each</code> 就是一个常用的语法糖，其原理其实就是基于普通的 for 循环和迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;JavaGuide&quot;</span>, <span class="string">&quot;公众号：JavaGuide&quot;</span>, <span class="string">&quot;博客：https://javaguide.cn/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p><h2 id="Java-中有哪些常见的语法糖？"><a href="#Java-中有哪些常见的语法糖？" class="headerlink" title="Java 中有哪些常见的语法糖？"></a>Java 中有哪些常见的语法糖？</h2><p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，Java基础的常出现的八股文就已经结束了，只看一遍当然是不够的，有一些比较复杂的内容我也还没有完全理解，后面继续会看。</p><p>在写这种总结类型的博客时，我总会想这有什么用，我并不会一个字一个字地打出来，更多的还是把别人文章中的内容复制下来了，有的地方甚至会被我删掉，这也使得后面我再去看的时候可能会看不懂。所以我会在写博客和删博客的过程中浪费掉大量的时间，设置在开始写之前，我还会去浪费时间设计结构，美其名曰为了更好的知识组织，其实就是为了偷会懒。</p><p>但是写这些会省去我后面继续去查找资料的时间，而且如果不写下来的话，只看一遍基本上是什么都记不住的。</p><p>不管有没有意义，我都会一直坚持写写博客，这不只是为了秋招而做的准备，更是养成一种学习的习惯吧。</p><p>下一篇八股文就要在集合框架或者并发编程上见了。</p><p>让人惊讶的是，昨天晚上腾讯的面试竟然过了，如果有二面的机会，我一定会好好把握的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html">https://javaguide.cn/java/basis/java-basic-questions-03.html</a></p><p><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></p><p><a href="https://javabetter.cn/sidebar/sanfene/javase.html">https://javabetter.cn/sidebar/sanfene/javase.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是 Java 基础八股文的第三篇，本文内容包括异常、泛型、反射、注解、SPI、I/O等，内容很杂也是一些重要内容，一两个问题讲不清的后面还是要单独来学习吧。&lt;/p&gt;
&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="Java？Java！！！" scheme="http://example.com/categories/Java%EF%BC%9FJava%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    
    
    <category term="Java学习指北" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存那些坑：击穿、穿透、雪崩与数据一致性</title>
    <link href="http://example.com/2024/06/18/Redis%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E5%9D%91%EF%BC%9A%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://example.com/2024/06/18/Redis%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E5%9D%91%EF%BC%9A%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-06-18T13:33:50.000Z</published>
    <updated>2024-06-18T15:49:40.637Z</updated>
    
    <content type="html"><![CDATA[<p>又是这几个老生常谈的问题，在正式开始学习 Redis 之前，我就知道这几个问题，在无数个老哥的面试经验里面看到过这四个问题，让我一直觉得在简历上写熟悉 Redis 就只需要准备这几个问题就行了，但是实际上好像并没有面试官会问这几个问题，至少对我来说是这样的。</p><p>在之前的博客里面也大概讲过前三个问题，但是当时就是把别人写的八股文给复制下来了，今天还是想要在重新记录一下。</p><h1 id="Redis-三兄弟"><a href="#Redis-三兄弟" class="headerlink" title="Redis 三兄弟"></a>Redis 三兄弟</h1><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p><p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/37e4378d2edcb5e217b00e5f12973efd-20230309232858764.png" alt="图片"></p><p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p><p>这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e2b8d2eb5536aa71664772457792ec40-20230309232851699.png" alt="图片"></p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片"></p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li>大量数据同时过期；</li><li>Redis 故障宕机；</li></ul><p>不同的诱因，应对的策略也会不同。</p><h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>均匀设置过期时间；</li><li>互斥锁；</li><li>后台更新缓存；</li></ul><ol><li><p>均匀设置过期时间</p><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p></li><li><p>互斥锁</p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></li><li><p>后台更新缓存</p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p></li></ol><h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul><ol><li><p>服务熔断或请求限流机制</p><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p></li><li><p>构建 Redis 缓存高可靠集群</p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p></li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/acb5f4e7ef24a524a53c39eb016f63d4-20230309232840753.png" alt="图片"></p><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/b7031182f770a7a5b3c82eaf749f53b0-20230309232834574.png" alt="图片"></p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li>第一种方案，非法请求的限制；</li><li>第二种方案，缓存空值或者默认值；</li><li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li></ul><p><strong>第一种方案，非法请求的限制</strong></p><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p><p><strong>第二种方案，缓存空值或者默认值</strong></p><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p><p><strong>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</strong></p><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p><p>那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。</p><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/86b0046c2622b2c4bda697f9bc0f5b28.png" alt="图片"></p><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p><p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p><p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p><p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片"></p><h1 id="数据一致性：Redis和MySQL的“远距离恋爱”"><a href="#数据一致性：Redis和MySQL的“远距离恋爱”" class="headerlink" title="数据一致性：Redis和MySQL的“远距离恋爱”"></a>数据一致性：Redis和MySQL的“远距离恋爱”</h1><p>如何保证缓存和数据库一致性，这是一个老生常谈的话题了。</p><p>但很多人对这个问题，依旧有很多疑惑：</p><ul><li>到底是更新缓存还是删缓存？</li><li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li><li>为什么要引入消息队列保证一致性？</li><li>延迟双删会有什么问题？到底要不要用？</li><li>…</li></ul><p>为了解开上面的这些疑惑，我们一步一步来看。</p><h2 id="引入缓存提高性能"><a href="#引入缓存提高性能" class="headerlink" title="引入缓存提高性能"></a>引入缓存提高性能</h2><p>我们从最简单的场景开始讲起。</p><p>如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310437299742.jpg" alt="img"></p><p>但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。</p><p>这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074028.jpg" alt="img"></p><p>当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。</p><p>但引入缓存之后，你就会面临一个问题：<strong>之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？</strong></p><p>最简单直接的方案是「全量数据刷到缓存中」：</p><ul><li>数据库的数据，全量刷入缓存（不设置失效时间）</li><li>写请求只更新数据库，不更新缓存</li><li>启动一个定时任务，定时把数据库的数据，更新到缓存中</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074037.jpg" alt="img"></p><p>这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。</p><p>但缺点也很明显，有 2 个问题：</p><ol><li><strong>缓存利用率低</strong>：不经常访问的数据，还一直留在缓存中</li><li><strong>数据不一致</strong>：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）</li></ol><p>所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。</p><p>那如果我们的业务体量很大，怎么解决这 2 个问题呢？</p><h2 id="缓存利用率和一致性问题"><a href="#缓存利用率和一致性问题" class="headerlink" title="缓存利用率和一致性问题"></a>缓存利用率和一致性问题</h2><p>先来看第一个问题，如何提高<strong>缓存利用率</strong>？</p><p>想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？</p><p>我们可以这样优化：</p><ul><li>写请求依旧只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074043.jpg" alt="img"></p><p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。</p><hr><p>再来看<strong>数据一致性</strong>问题。</p><p>要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。</p><p>所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。</p><p>但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p><ol><li>先更新缓存，后更新数据库</li><li>先更新数据库，后更新缓存</li></ol><p>哪个方案更好呢？</p><p>先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。</p><p>因为操作分为两步，那么就很有可能存在<strong>「第一步成功、第二步失败」</strong>的情况发生。</p><h3 id="先更新缓存，后更新数据库"><a href="#先更新缓存，后更新数据库" class="headerlink" title="先更新缓存，后更新数据库"></a><strong>先更新缓存，后更新数据库</strong></h3><p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。</p><p>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。</p><p>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p><h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a><strong>先更新数据库，再更新缓存</strong></h3><p>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。</p><p>之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。</p><p>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。</p><hr><p>可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？</p><p>别急，后面我会详细给出对应的解决方案。</p><p>我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？</p><p>这里我们还需要重点关注：<strong>并发问题</strong>。</p><h2 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h2><p>在两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？</p><p>有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p><ol><li>线程 A 更新数据库（缓存）（X = 1）</li><li>线程 B 更新数据库（缓存）（X = 2）</li><li>线程 B 更新缓存（数据库）（X = 2）</li><li>线程 A 更新缓存（数据库）（X = 1）</li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/454a8228a6549176ad7e0484fba3c92b.png" alt="图片"></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/8febac10b14bed16cb96d1d944cd08da.png" alt="图片"></p><p>从上面的两张流程图也不难看出，即使两步都能成功执行，也无法保证数据库和缓存之间的一致性。</p><hr><p>那怎么解决这个问题呢？这里通常的解决方案是，加<strong>「分布式锁」</strong>。</p><p>两个线程要修改「同一条」数据，每个线程在改之前，先去申请分布式锁，拿到锁的线程才允许更新数据库和缓存，拿不到锁的线程，返回失败，等待下次重试。</p><p>这么做的目的，就是为了只允许一个线程去操作数据和缓存，避免并发问题。</p><p>除此之外，我们从<strong>「缓存利用率」</strong>的角度来评估这个方案，也是不太推荐的。</p><p>这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。</p><p>而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。</p><p>由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。</p><p>所以此时我们需要考虑另外一种方案：<strong>删除缓存</strong>。</p><h2 id="删除缓存能保证一致性吗？"><a href="#删除缓存能保证一致性吗？" class="headerlink" title="删除缓存能保证一致性吗？"></a>删除缓存能保证一致性吗？</h2><p>同样地，先来看「第二步」操作失败的情况。</p><p>先删除缓存，后更新数据库，第二步操作失败，数据库没有更新成功，那下次读缓存发现不存在，则从数据库中读取，并重建缓存，此时数据库和缓存依旧保持一致。</p><p>但如果是先更新数据库，后删除缓存，第二步操作失败，数据库是最新值，缓存中是旧值，发生不一致。所以，这个方案依旧存在问题。</p><p>总之，和前面提到的问题类似，第二步失败依旧有不一致的风险。</p><p>好，我们再来看<strong>「并发」</strong>问题，这个问题是我们需要关注的「重点」。</p><hr><h3 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a><strong>先删除缓存，后更新数据库</strong></h3><p>假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/cc208c2931b4e889d1a58cb655537767.png" alt="图片"></p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p><p>可以看到，<strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。</p><h3 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h3><p>继续用「读 + 写」请求的并发的场景来分析。</p><p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/1cc7401143e79383ead96582ac11b615.png" alt="图片"></p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</p><p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p><p>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p><p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p><p>为了确保万无一失，给缓存数据加上了「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p><p>好，解决了并发问题，我们继续来看前面遗留的，<strong>第二步执行「失败」导致数据不一致的问题</strong>。</p><h2 id="如何保证两部都执行成功？"><a href="#如何保证两部都执行成功？" class="headerlink" title="如何保证两部都执行成功？"></a>如何保证两部都执行成功？</h2><p>前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p><p><strong>保证第二步成功执行，就是解决问题的关键</strong>。</p><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>想一下，程序在执行过程中发生异常，最简单的解决办法是什么？</p><p>答案是：<strong>重试</strong>。</p><p>是的，其实这里我们也可以这样做。</p><p>无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。</p><p>那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？</p><p>答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p><ul><li>立即重试很大概率「还会失败」</li><li>「重试次数」设置多少才合理？</li><li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li></ul><p>看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。</p><p>那更好的方案应该怎么做？</p><p>答案是：<strong>异步重试</strong>。什么是异步重试？</p><p>其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。</p><p>或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</p><p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？</p><p>这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p><p>所以，这里我们必须把重试消息或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p><ul><li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li><li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的需求）</li></ul><p>至于写队列失败和消息队列的维护成本问题：</p><ul><li><strong>写队列失败</strong>：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li><li><strong>维护成本</strong>：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li></ul><p>所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074049.jpg" alt="img"></p><h3 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h3><p>那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？</p><p>方案还是有的，这就是近几年比较流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p><p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。</p><p>那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。</p><p>拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/16310431074053.jpg" alt="img"></p><p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p><ul><li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li><li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li></ul><p>当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。</p><blockquote><p>如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。</p></blockquote><p>至此，我们可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p><h2 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h2><p>到这里，还有 2 个问题，是我们没有重点分析过的。</p><p><strong>第一个问题</strong>，还记得前面讲到的「先删除缓存，再更新数据库」导致不一致的场景么？</p><p>这里我再把例子拿过来让你复习一下：</p><p>2 个线程要并发「读写」数据，可能会发生以下场景：</p><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p><strong>第二个问题</strong>：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。</p><p>如果使用「先更新数据库，再删除缓存」方案，其实也发生不一致：</p><ol><li>线程 A 更新主库 X = 2（原值 X = 1）</li><li>线程 A 删除缓存</li><li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li><li>从库「同步」完成（主从库 X = 2）</li><li>线程 B 将「旧值」写入缓存（X = 1）</li></ol><p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p><p>看到了么？这 2 个问题的核心在于：<strong>缓存都被回种了「旧值」</strong>。</p><p>那怎么解决这类问题呢？</p><p>最有效的办法就是，<strong>把缓存删掉</strong>。</p><p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。</p><p>按照延时双删策略，这 2 个问题的解决方案是这样的：</p><p><strong>解决第一个问题</strong>：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p><p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p><p>这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。</p><p>但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p><ul><li>问题1：延迟时间要大于「主从复制」的延迟时间</li><li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li></ul><p>但是，<strong>这个时间在分布式和高并发场景下，其实是很难评估的。</strong></p><p>很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。</p><p>所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p><p>所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p><h2 id="可以做到强一致吗？"><a href="#可以做到强一致吗？" class="headerlink" title="可以做到强一致吗？"></a>可以做到强一致吗？</h2><p>看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？</p><p>其实很难。</p><p>要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。</p><p>相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？</p><p>没错，<strong>性能</strong>。</p><p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。</p><p>所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。</p><p>虽然我们可以通过加「分布锁」的方式来实现，但我们也要付出相应的代价，甚至很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。</p><p>同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，第一部分内容已经被讲烂掉了，但是第二部分内容却是比较重要和新奇的，虽然之前有了解到这样的问题，但是以笔者这样的拖延症晚期，一般是不会马上学习的，写本文时也是笔者第一次学习这部分内容。明天继续面试，祝我面试顺利。</p><p>本以为这个老生常谈的话题，写起来很好写，没想到在写的过程中，还是挖到了很多之前没有深度思考过的细节。</p><p>好了，总结一下这篇文章的重点。</p><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况</p><p>4、采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估</p><p>5、采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致</p><p>6、采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/">http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/</a></p><p><a href="https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7">https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又是这几个老生常谈的问题，在正式开始学习 Redis 之前，我就知道这几个问题，在无数个老哥的面试经验里面看到过这四个问题，让我一直觉得在简历上写熟悉 Redis 就只需要准备这几个问题就行了，但是实际上好像并没有面试官会问这几个问题，至少对我来说是这样的。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
