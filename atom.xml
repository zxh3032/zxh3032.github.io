<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便寻个地方&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-23T12:37:40.254Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>随便寻个地方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GoBlog，启动！</title>
    <link href="http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/"/>
    <id>http://example.com/2024/03/23/Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/</id>
    <published>2024-03-23T12:52:50.000Z</published>
    <updated>2024-03-23T12:37:40.254Z</updated>
    
    <content type="html"><![CDATA[<p>喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直到需要找实习才发现自己简历上能写的东西寥寥无几。说来奇怪，上了几年大学发现自己好像什么都没学到，这应该就是一种清醒的堕落吧。</p><p>我对这个项目的了解就像我对Go语言的了解一样，来自我那个神奇的舍友。他花钱买了教程之后，我就可以蹭一下了，很难想象没有我亲爱的舍友，我的大学生活会变成什么样子。</p><h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p>废话少说，为什么要用Go来开发一个博客系统呢？答案很简单，Go语言本身就非常适用于开发Web应用程序，而且我们在学习的过程中也不难发现好像很多大佬都有自己的博客，那不如把这两个结合一下，这样在设计具体功能的时候也能找到一些可以借鉴的地方。</p><p>开发Web应用要涉及到的知识：</p><ul><li>表单验证</li><li>注册登录</li><li>授权验证</li><li>共享数据库连接</li><li>密码哈希</li><li>路由和中间件</li><li>代码组织（MVC/RESTful）</li><li>打包静态文件和模板文件</li><li>项目部署等</li></ul><p>这些内容会在后面的博客中一一介绍，这个项目并不是一个玩具项目，后续的文章中也会解决一些会在实际生产环境中出现的问题。</p><p>本书源码：<a href="https://github.com/summerblue/goblog">github.com/summerblue/goblog</a></p><p>本项目并不是笔者自己开发的，是跟着社区的教程完成的。</p><h1 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h1><p>作为实战项目，遇到程序报错是很正常的情况，多解决报错能帮助我们学到不少东西。</p><p>在遇到一些很抽象的报错时，不要怀疑机器有问题，99%的概率问题在自己，即使代码都是复制的。</p><p>当然如果实在是找不到，可以利用源码来排除错误。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>Windows11</li><li>Go1.21.1</li><li>编译器Visual studio code</li></ul><h1 id="通过本项目学到了什么"><a href="#通过本项目学到了什么" class="headerlink" title="通过本项目学到了什么"></a>通过本项目学到了什么</h1><ul><li>数据库使用</li><li>模板使用</li><li>基础测试</li><li>项目开发流程</li><li>Go 项目结构选择</li></ul><h1 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h1><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240323203506135.png" alt="image-20240323203506135"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;喜大普奔！！！GoBlog这个项目总算是写完了，严格来说这是笔者完成的第一个项目，也是笔者学习Go语言的主要途径。从开始那天算起到现在，完成这个项目用了差不多四个月，但真正用在学习这个项目的时间估计不到一个月。刚开始说为了学习Go语言开始写一个感兴趣的项目，结果就一直拖，直</summary>
      
    
    
    
    <category term="GoBlog" scheme="http://example.com/categories/GoBlog/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的Go Web程序</title>
    <link href="http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2024/03/22/Web%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-03-22T14:27:49.000Z</published>
    <updated>2024-03-22T14:38:08.780Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>腾讯面试——血与泪的教训</title>
    <link href="http://example.com/2024/03/21/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD/"/>
    <id>http://example.com/2024/03/21/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%A1%80%E4%B8%8E%E6%B3%AA%E7%9A%84%E6%95%99%E8%AE%AD/</id>
    <published>2024-03-21T13:39:57.000Z</published>
    <updated>2024-03-22T05:48:23.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又到了一周一度的学习总结了，本周可以算得上是非常神奇的一周了。从标题也不难看出，神奇之处就在于本周是笔者第一次参加一场面试，可谓是非常的紧张。经过一场面试也让我深刻地感受到闭门造车是行不通的，在面试之前总觉得自己把什么都准备好了，结果在两个小时的面试过程中，被面试官牵着鼻子走（狗头）。所以本周的总结主要集中在对面试的复盘方面，希望在完成这次周报之后能对我以后的学习有一定的帮助吧。</p><h1 id="面试复盘"><a href="#面试复盘" class="headerlink" title="面试复盘"></a>面试复盘</h1><h2 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h2><ol><li><p>首先就是面试官介绍自己的部门和我的自我介绍。</p><p>从舍友的评价来看，自我介绍环节就已经十分紧张了，说话也是结结巴巴，十分的不自信。</p></li><li><p>三道算法题。</p><p>题目倒不是很难，也不需要能够完全正确，只需要自己的思路对就OK了。</p></li><li><p>拷打项目，也是本次面试中笔者表现的最呆瓜的一个环节了。</p><p>面试官问我为什么要选择MySQL来作为数据库来存储信息。我竟然脑抽到回答说我只会MySQL。</p></li><li><p>除了拷打项目，就是一些比较简单的八股了，还是有待加强。</p></li></ol><h2 id="项目拷打总结"><a href="#项目拷打总结" class="headerlink" title="项目拷打总结"></a>项目拷打总结</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>是否支持上传图片？图片是怎样进行存储的？怎么把图片和对应的文章正确地显示出来？</p><p>显然，对于并没有完全准备好的我来说，这三个问题已经足够干掉我了。</p><ol><li>已经实现了上传和显示图片的功能。</li><li>应该将图片存储在对应的服务器中，现阶段的存储方式为把用户上传的图片放到一个专门的文件夹中。</li><li>由于图片存储为在固定的文件夹中，那么只需要将文件的路径放在文章的正确位置即可，这样在进行页面展示时，可以将图片进行正确的显示。</li></ol><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如果用户量太大，每个人都往其中存储文章，导致表中内容过多，该怎么解决？</p><p>在实际的应用开发中，数据量过大的MySQL表会导致查询的性能下降。解决方法如下：</p><ol><li>分表分库</li></ol><p>​    将单张数据量过大的表拆分成多个较小的表，每个表只存储一部分数据，以此来提高查询效率。</p><ol><li>垂直拆分</li></ol><p>​    如果单表的列比较多，但是并不是所有列都会频繁地使用，可以考虑将一些少用的列拆分到新的表中，从而减少单个表的数据量，减少磁盘空间的使用。</p><ol><li>建立合适的索引</li></ol><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>上一个问题提到，当数据量过大时可以采用分表策略，那要怎么进行文章的定位呢？</p><p>水平切分后同一张表会出现在多个数据库或表中，每个库和表的内容不同，对于水平分表后分库后，如何知道哪条数据在哪个库里或表里，则需要路由算法进行计算，这个算法会引入一定的复杂性。</p><ul><li>范围路由</li></ul><p>选取有序的数据列，如时间戳作为路由的条件，不同分段分散到不同的数据库表中，以最常见的用户ID为例，路由算法可以按照1000000的范围大小进行分段，1 ~ 9999999放到数据库1的表中，10000000~199999999放到数据库2的表中，以此累推。<br>  范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多增加维护复杂度，分段太大可能会导致单表依然存在性能问题，按一般大老们的经验，分段大小100W至2000W之间，具体需要根据业务选 取合适的分段大小。</p><ul><li>范围路由的优点<ul><li>可以随着数据的增加平滑地扩充新的表或库，原有的数据不需要动。</li><li>单表大小可控</li><li>使用分片字段进行范围查找时，连续分片可快速定位查询，有效避免分片查询的问题。</li></ul></li><li><p>热点数据成为性能瓶颈，连续分片可能存在数据热点，例如按时单字段分片，有些分片存储最近时间内的数据，可能会被频繁读写，而有些历史数据则很少被查询。</p></li><li><p>hash算法</p></li></ul><p>  选取某个列或几个列的值进行hash运算，然后根据hash的结果分散到不同的数据库表中，以用ID为例，假如我们一开始就规划10个数据库表，路由算法可以简单地用id % 10的值来表示数据所属的数据库编号，ID为985的用户放到编号为5的子表中。ID为10086编号放到编号为6的表中。<br>  Hash路由设计的复杂点主要体现 在初始表数量的选取上，表数量太多维护比较麻烦，表数量太小又可能导致单表性能存在问题。而用Hash路由后，增加字表数量是非常麻烦的，所有数据都要重新分布。<br>  Hash路由的优缺点与范围路由相反，Hash路由的优点是表分布比较均匀，缺点是扩容时很麻烦，所有数据均需要重新分布。</p><ul><li>路由配置</li></ul><p>  配置路由就是路由表，用一张独立的表来记录路由信息。同样以用户ID为例，我们新增一张ROUTER表，这个表包含table_Id两列，根据user_id就可以查询对应的修改路由表就可以了。<br>配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。<br>其缺点就是必须多查询一次，会影响整体性能，而且路由表本身如果太大，性能会成为瓶颈点，如果我们再将路由表分库分表，则又面临一个死循环。</p><h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>如果实行分表，如何确保自增的文章ID不出现重复。或者有什么其他解决方案。</p><p>在本人的测试过程中发现，给ID设置为自增并不会影响用户自己设置ID。</p><p>关于分表后ID自增又会从1开始，我的解决方案是在需要进行分表时可以先获取前一个表的最后一篇文章，在得到这个文章的ID后，将新建的文章ID设置为上一篇文章的ID+1。</p><p>其他解决方案：如果采用hash算法进行分表的话，可以将设置文章ID和插入表分为两步操作，先根据自增将wenzhangID设置出来，再进行插入表的操作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，经过此次面试还是返现了学习上的不少漏洞，本篇文章只解决了在项目拷打环节的一些提问，关于八股文和一些算法方面的内容我想还是要分开来写。最后面试官也有提醒到项目还是可以增加一些功能。可问的点有很多，还是得把项目吃透。</p><p>从面试官所问的问题也不难看出，有关到项目的内容他们更想听到的是在实际中的各种情况和解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;又到了一周一度的学习总结了，本周可以算得上是非常神奇的一周了。从标题也不难看出，神奇之处就在于本周是笔者第一次参加一场面试，可谓是非常的紧张</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="面试经验" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入Go语言——内存</title>
    <link href="http://example.com/2024/03/12/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2024/03/12/%E6%B7%B1%E5%85%A5Go%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</id>
    <published>2024-03-12T12:51:19.000Z</published>
    <updated>2024-03-15T05:54:16.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于内存部分的内容，是正在读的书中的第三部分，这一部分讲的是Go语言中的指针相关的知识，由于书中花费了一定篇幅去讲过于内存的问题，所以本周的总结报告命题为”内存“。</p><p>这并不是第三周全部学到的东西，只是开始，由于我现在还不能把学到的东西随手记录下来，所以选择先写一篇学习总结。我详细一篇应该是关于项目实战的。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>提到指针，我们并不陌生，从开始学习程序设计就已经接触到了指针。对我来说，指针是一个既熟悉又陌生的东西。熟悉是因为在最开始的学习时，我和同学不止一次地讨论过指针也进行了一定的学习。陌生是因为我确实不是很喜欢学习C语言，以至于其真正的核心内容我学的都不扎实，学了就忘。</p><hr><p>在Go语言中，由于变量分为<strong>值类型</strong>和<strong>引用类型</strong>，使得指针在函数传参的时候有了用处。对于<strong>值类型的变量</strong>而言，当函数的参数是指针类型时，函数对该参数的修改才会影响到该参数本身。</p><h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>对于是否使用指针类型作为接收者，有以下几点参考：</p><ol><li>如果接收者类型是 map、slice、channel 这类引用类型，不使用指针。</li><li>如果需要修改接收者，那么需要使用指针。</li><li>如果接收者是比较大的类型，可以考虑使用指针，因为内存拷员廉价，所以效率高。</li></ol><h3 id="什么情况下使用指针"><a href="#什么情况下使用指针" class="headerlink" title="什么情况下使用指针"></a>什么情况下使用指针</h3><p>从以上指针的详细分析中，我们可以总结出指针的两大好处：</p><ol><li>可以修改所指向数据的值。</li><li>在变量复制、参数传值的时候可以节省内存。</li></ol><p>不过.Go语言作为一种高级语言，在指针的使用上还是比较克制的。它在设计的时候就对指针进行了诸多限制，比如指针不支持运算，也不能取常量的指针。所以在思考是各使用时，我们也要保持克制的心态。<br>根据实战经验我总结了以下几点使用指针的建议，供你参考：</p><ol><li>不要对map、slice、channel 这类引用类型使用指针。</li><li>如果需要修改方法接收者内部的数据或者状态时，需要使用指针。</li><li>如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数。</li><li>如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针。</li><li>像 int、bool 这样的小数据类型没必要使用指针。</li><li>如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全。</li><li>指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然Go语言允许这么做，但是这会使你的代码变得异常复杂。</li></ol><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>指向接口的指针是否实现了该接口？为什么？</p><p>答：虽然指向具体类型的指针可以实现一个接口，但是指向接口的指针永远不可能实现该接口。</p><h2 id="值类型？指针类型？引用类型？"><a href="#值类型？指针类型？引用类型？" class="headerlink" title="值类型？指针类型？引用类型？"></a>值类型？指针类型？引用类型？</h2><p>初次看到这三个名词，我似懂非懂。值、指针、引用，为什么几个我认识的字放在一起，我就不太能分得清这些都是什么了。在上面的内容中有提到，Go语言中的变量分为两种，值类型和引用类型。那这个指针类型又是什么，和其他两种有什么关系呢。</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型包括：整型、浮点型、字符串、布尔、数组和 struct 。</p><p>认真观察过这些类型，我们不难发现，当这些类型作为函数参数时，在函数内部对其进行修改并不会影响到其原来的值。这就是值类型的特点。原因如下：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240312223328702.png" alt="image-20240312223328702"></p><p>观察上面的示意图不难得出，当 <code>main</code> 函数调用函数 <code>modifyPerson</code> 时，程序将变量 P 进行了一次复制，所以在函数 <code>modifyPerson</code> 试图修改变量 P 时，修改的是 P 的副本。值类型的变量在函数中均是如此。因此，在函数试图修改值类型的参数时，实际的参数并不会被修改。</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型保存的值就是数据对应的内存地址，所以在函数传参采用值传递的原则下，拷贝的值也是内存地址。因此当函数想要对参数进行修改时，即使修改的是参数的副本，其内容仍是需要修改变量的地址。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型包括：切片、map、函数、chan和接口</p><p>对于引用类型，在参数传递时仍然是<strong>值传递</strong>，但其传递的值为指针，并不是其他编程语言中所谓的引用传递。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20240312231609318.png" alt="image-20240312231609318"></p><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>在声明一个变量时，常常会使用到的是 <code>var</code> 关键字和 <code>:=</code> 这两种方法。当我们尝试着去指针类型的变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sp *<span class="type">string</span></span><br><span class="line">*sp = “内存地址”</span><br><span class="line">fmt.Println(*sp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行上面的代码时，编译器会报错。</p><p>这是因为指针类型的变量如果没有分配内存，其默认值为 <code>nil</code>，因为它没有指向的内存，所以无法使用，强行使用就会出现 <code>nil</code> 指针的报错。</p><p>一个变量必须要经过<strong>声明</strong>、<strong>内存分配</strong>才能赋值，才能进行初始化。对于值类型，Go语言会在声明时就为它分配内存，以便后续的赋值操作。对于指针类型，Go语言并没有自动分配内存，所以不能对其进行赋值操作。</p><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>正是因为上面情况，<code>new</code>函数派上了用场。</p><p><code>new</code> 函数的作用就是根据传入的类型申请一块内存，然后返回指向这块内存的指针，指针指向的数据就是该类型的<strong>零值</strong></p><h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><p>关于<code>make</code>函数，最常使用的场景就是 map、slice 和 chan 这三种类型的初始化。</p><p>make 函数就是上述三种类型的工厂函数，用于<strong>创建和初始化</strong>这几种类型。</p><h3 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h3><p><code>make</code> 和 <code>new</code> 是两个⽤于分配内存的内建函数, 在使⽤场景和返回值类型上有明显的区别。</p><ul><li><code>make</code> ⽤于创建并初始化切⽚、映射和通道等引⽤类型。它返回的是被初始化的⾮零值（⾮nil）的引⽤类型。</li><li><code>new</code> ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的零值的指针。</li></ul><p>总结：</p><ul><li><code>new</code>只⽤于分配内存，返回⼀个指向地址的<strong>指针</strong>。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li><li><code>make</code>只可⽤于 <strong>slice, map, channel</strong> 的初始化,返回的是<strong>引⽤</strong></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结一下，本周好像有一点懈怠了，做题和做项目的时候都有点心不在焉的。不过本周学到的东西还是不少的。</p><ul><li>算法题已经完成了数组、双指针、滑动窗口和区间四个部分了。</li><li>项目目前完成了一半左右，希望下一周能全部搞完，再完成一篇博客。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于内存部分的内容，是正在读的书中的第三部分，这一部分讲的是Go语言中的指针相关的知识，由于书中花费了一定篇幅去讲过于内存的问题，所以本周的</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语言进阶——并发</title>
    <link href="http://example.com/2024/03/08/Go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2024/03/08/Go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/</id>
    <published>2024-03-08T05:21:04.000Z</published>
    <updated>2024-03-08T06:40:09.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本周是正式系统性学习整理Go语言的第二周，上周把基础知识学过后，这周开始学习进阶知识。说到Go语言的特性，那就是高并发，所以进阶学习的第一部分只是就是关于并发的。总结内容和之前一样，并不会过多的记录书本里的东西，更多的是这一周学习的困难和解决的过程。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><p>本周学习内容主要有两个部分，并发基础和算法，学习这些的原因是因为最近开始找实习了，发现确实落下了太多东西。</p><h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>第一次了解并发是在学习计算机系统的时候，不再只让计算机做完一件事之后再开始做另外一件事，而是让计算机同时做多件事情，这就是并发。</p><p>说到并发就一定绕不开两个概念——进程和线程。</p><ul><li>在启动一个软件的时候，操作系统会为这个软件创建一个<strong>进程</strong>，这个进程就是该软件的工作空间，它包含了软件运行所需的所有资源。</li><li><strong>线程</strong>是进程的执行空间，一个进程可以有多个线程，线程被操作系统调度执行。</li></ul><p>一个程序启动就会有一个进程被创建，同时进程也会启动一个线程，这个线程被称为主线程，如果主线程结束，那么整个程序就退出了。有了主线程，就可以从主线程里启动很多其他线程，也就有了<strong>多线程的并发</strong>。</p><hr><p>在Go语言中并没有线程的概念，只有<strong>协程</strong>，也成为 <strong><code>goroutine</code></strong> 先比线程来说，协程更加轻量，一个程序可以随意启功成千上万个协程。</p><p><code>goroutine</code> 被 <code>Go routime</code>所调度，也就是说，Go语言的并发是由Go自己调度的，这对于开发者来说完全透明。</p><h2 id="如何通信"><a href="#如何通信" class="headerlink" title="如何通信"></a>如何通信</h2><p>当我们同时启动了多个 goroutine 时，它们之间要怎么通信？</p><p>Go语言提供了用于通信的<strong>管道</strong>—— <code>channel</code></p><ul><li>当需要从管道中接受值时，如果管道为空，那么会阻塞等待，知道管道中有值可以接受为之。</li></ul><p>管道分类：</p><ul><li><strong>无缓冲管道</strong>：容量为0，只起到传输数据的作用，又被称为<strong>同步管道</strong>；</li><li><strong>有缓冲管道</strong>：类似于一个可阻塞的对列，内部元素先进先出</li></ul><p>可以通过 <code>select + channel</code> 来实现多路复用的效果。</p><p>在Go语言中，提倡通过通信来共享内存，而不是通过共享内存来通信，所以在数据流动、传递的场景中要优先使用 channel，它是并发安全的。</p><hr><p>思考题：channel是如何实现并发安全的？</p><p>channel内部使用了互斥锁来保证并发的安全。</p><h2 id="并发中的Map是否安全"><a href="#并发中的Map是否安全" class="headerlink" title="并发中的Map是否安全"></a>并发中的Map是否安全</h2><p>Go 中的标准 <code>map</code> 类型是非并发安全的，这意味着在多个 <code>Goroutine</code> 中并发读写同一个 map 可能导致数据竞争和不确定的行为。为了在并发环境中使用  map，Go 提供了  <code>sync</code> 包中的 <code>sync.Map</code> 类型，它是一种并发安全的映射。</p><p>无须初始化，直接声明即可。<br>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。<br>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</p><p><strong>sync.Map提供的常用方法有如下七个</strong>:</p><ul><li>Load：通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</li><li>Store：该方法相当于对sync.Map的更新或新增，参数是键值对。</li><li>LoadOrStore：该方法的参数为key和value。该方法会先根据参数key查找对应的value，如果找到则不修改原来的值并通过actual返回，并且loaded为true；如果通过key无法查找到对应的value，则存储key-value并且将存储的value通过actual返回，loaded为false。</li><li>Delete：通过key删除键值对。</li><li>LoadAndDelete：通过key删除键的值，如果有，则返回上一个值。</li><li>Range：遍历sync.Map的元素，注意for…range map是对内置map类型的用法，sync.Map需要使用单独的Range方法。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明sync.Map</span></span><br><span class="line"><span class="keyword">var</span> syncmap sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store方法将键值对保存到sync.Map</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">97</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;lisi&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadOrStore key不存在</span></span><br><span class="line">    v, ok := syncmap.LoadOrStore(<span class="string">&quot;three&quot;</span>,<span class="number">3</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// 3 false</span></span><br><span class="line">    <span class="comment">// LoadOrStore key存在</span></span><br><span class="line">    v, ok = syncmap.LoadOrStore(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// 200 ture</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load方法获取sync.Map 键所对应的值</span></span><br><span class="line">    fmt.Println(syncmap.Load(<span class="string">&quot;lisi&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete方法键删除对应的键值对</span></span><br><span class="line">    syncmap.Delete(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> syncmap sync.Map</span><br><span class="line">    <span class="comment">// LoadAndDelete key不存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// &lt;nil&gt; false</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;xiaomi&quot;</span>, <span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    <span class="comment">// LoadAndDelete key存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// xiaomi true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Range遍历所有sync.Map中的键值对</span></span><br><span class="line">    syncmap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明 score，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</li><li>将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</li><li>Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</li><li>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</li></ul><h1 id="刷题思考"><a href="#刷题思考" class="headerlink" title="刷题思考"></a>刷题思考</h1><p>已经连续五天的刷题生活或许并没有给我带来什么真正有意义的思考，但还是想要记录一下。</p><p>毕竟从大一下学完数据结构之后就基本没怎么做过算法题了，所以刚开始这几天还是在找做题的感觉，有一种在高三备战高考的感觉，有时候也会觉得很折磨，看着别人想出来的完美算法，就会觉得自己和别人的差距太大了，只能一步一步来了。</p><p>这一周都只做了关于数组方面的题目，更多看到的题目标签是贪心、动态规划等等熟悉又陌生的字眼。</p><p>总之在做了几天题之后，发现自己的思维确实变慢了不少，还有就是把自然语言转换成代码语言的能力不行。</p><p>菜就多练喽！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本周学习内容主要是并发和算法，在Go语言项目上并没有投入什么精力，认真学习过并发之后就会正式开始学习做一些小项目来补充一下这方面的空白。</p><p>算法方面就希望下周能够找到做题的感觉，希望自己的小脑袋瓜赶紧转起来吧，继续积累经验。</p><p>关于Go语言八股文也确实应该腾出更多的时间来看了，希望下周能够完成计划吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本周是正式系统性学习整理Go语言的第二周，上周把基础知识学过后，这周开始学习进阶知识。说到Go语言的特性，那就是高并发，所以进阶学习的第一部</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言、并发" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80%E3%80%81%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>打开Go语言之门</title>
    <link href="http://example.com/2024/03/01/%E6%89%93%E5%BC%80GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%A8/"/>
    <id>http://example.com/2024/03/01/%E6%89%93%E5%BC%80GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%A8/</id>
    <published>2024-03-01T07:10:04.000Z</published>
    <updated>2024-03-08T05:21:27.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始学习Go语言已经差不多半年了，这是第一次正式写下一篇学习总结。又恰逢新学期开始，就把这篇当作新学期的第一篇周报吧。</p><p>本周主要是把半年来稀稀拉拉学到的Go语言基础知识有系统性地看了一遍。我对Go语言的了解更多还是从我的舍友，也正是受到他的影响我才会开始学习Go语言并进行记录。</p><p>这一周的学习内容就像本文的标签一样，Go语言基础。因为已经学习了很久，所以基础知识就不再本文中赘述。</p><h1 id="学习思考"><a href="#学习思考" class="headerlink" title="学习思考"></a>学习思考</h1><p>关于Go语言的学习，笔者已经看了四五本不同的基础书籍了，每本书的开头都是以Go语言的优点来开篇，那2024年的第一篇博客也从这个问题开始吧。</p><h2 id="Go语言好在哪？"><a href="#Go语言好在哪？" class="headerlink" title="Go语言好在哪？"></a>Go语言好在哪？</h2><p>说到Go语言的好处，想必都能想到什么简洁、高效等等。而真正吸引我开始学习Go语言的，还是我的舍友告诉我Go语言的代码有着严格的格式要求，不同人写的代码排版风格几乎一致，这一下就激起我学习Go语言的兴趣。因为笔者在刚开始学习编程的时候并没有养成良好的代码习惯，导致我的代码在很长一段时间里都只有我自己看得懂，于是迫切找到一个大家代码风格都差不多的语言重新开始学习。随着后来对Go的学习，我也了解到它更多的优点。接下来我们来看一下Go语言到底好在哪？</p><h3 id="语法简洁"><a href="#语法简洁" class="headerlink" title="语法简洁"></a>语法简洁</h3><p>Go语言相对于其他语言更容易上手，开发效率更高。这意味着Go易于学习、易于使用并且易于其他开发人员阅读。Go 没有大量的功能集，尤其是与 C++ 等语言相比。Go 的语法让人想起 C，这使得长期 C 开发人员学习起来相对容易。</p><p>从学术的角度讲Go语言其实非常平庸，不支持许多高级的语言特性；但从工程的角度讲，Go的设计是非常优秀的：规范足够简单灵活，有其他语言基础的程序员都能迅速上手。更重要的是Go自带完善的工具链，大大提高了团队协作的一致性。比如gofmt自动排版Go代码，很大程度上杜绝了不一致的问题。</p><h3 id="自带垃圾回收功能"><a href="#自带垃圾回收功能" class="headerlink" title="自带垃圾回收功能"></a>自带垃圾回收功能</h3><p>对比其他语言，Go语言的优势显著。比如Java虽然也具备垃圾回收功能，但它是解释型语言，需要安装JVM才能运行；C语言虽然不用解释，可以直接编译运行，但是它不具备垃圾回收功能，需要开发者自己管理内存的申请和释放，容易出问题。而Go语言具有两者的优势。</p><h3 id="并发性良好"><a href="#并发性良好" class="headerlink" title="并发性良好"></a>并发性良好</h3><p>Go语言就是为了并发而生的，其在设计时的创新就是 <strong>goroutines</strong> 和<strong>通道</strong>。</p><p><strong>Goroutines</strong> 是 Go 面向<strong>线程</strong>的轻量级方法，而通道是 goroutines 之间通信的优先方式。创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。</p><p>Goroutines的轻便主要体现在以下两个方面：</p><ul><li><strong>上下文切换代价小</strong>：Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；</li><li><strong>内存占用少</strong>：线程栈空间通常是 2M，Goroutine 栈空间最小 2K；</li></ul><p>关于Go语言的调度机制，可以看一下这篇文章——<a href="https://www.zhihu.com/question/21409296/answer/1040884859">https://www.zhihu.com/question/21409296/answer/1040884859</a></p><p>除了以上的三个优点以外，Go语言还有如强大的生态系统、支持跨平台操作以及拥有强大的标准库等优点。</p><h2 id="什么是静态语言"><a href="#什么是静态语言" class="headerlink" title="什么是静态语言"></a>什么是静态语言</h2><p>在打开任何一本关于Go语言基础的书籍时，首先映入眼帘的就是Go语言是一个静态语言，那么什么是静态语言，Go语言为什么会设计成静态语言，静态语言和动态语言又有什么区别。这些问题困扰了我很久，接下来将会解释以上问题。</p><p><strong>静态语言</strong>是一种编程语言，其特征是在编译时进行类型检查和绑定。在编写代码时，变量的类型需要明确指定，而且在编译阶段这些类型信息是固定的，不会在运行时发生变化。其特征如下：</p><ul><li><strong>类型检查：</strong> 在编译阶段进行，变量类型需要在声明时明确，并且编译器会检查变量的使用是否符合类型规定。</li><li><strong>编译时绑定：</strong> 函数调用和变量引用在编译时就已经确定，生成对应的机器代码。</li><li><strong>性能优化：</strong> 静态类型信息允许编译器进行更多的优化，生成更高效的代码。</li><li><strong>严格的错误检查：</strong> 由于类型信息在编译时就已知，因此静态语言通常有较为严格的类型检查，编译器可以在编译阶段捕获许多潜在的错误。</li></ul><p>静态语言主要有：Java、C、C++、C#、Swift 和 Go</p><hr><p><strong>动态语言</strong>是一种编程语言，其特征是在运行时进行类型检查和绑定。在编写代码时，变量的类型通常不需要显式指定，而是在运行时根据上下文动态确定。其特征如下：</p><ul><li><strong>类型检查：</strong> 在运行时进行，变量的类型可以在代码执行期间改变。</li><li><strong>运行时绑定：</strong> 函数调用和变量引用在运行时确定，这允许更大的灵活性和动态性。</li><li><strong>较少的编译时优化：</strong> 缺乏静态类型信息会减少编译器进行某些优化的能力。</li><li><strong>更灵活：</strong> 相对于静态语言，动态语言通常更灵活，适用于快速开发和迭代。</li></ul><p>动态语言主要有：Python、JavaScript、Ruby、PHP</p><hr><p>静态语言与动态语言的区别：</p><ul><li><strong>类型检查时机：</strong> 静态语言在编译时进行类型检查，而动态语言在运行时进行类型检查。</li><li><strong>类型灵活性：</strong> 静态语言要求在编写代码时明确指定变量的类型，而动态语言允许变量在运行时根据上下文动态确定类型。</li><li><strong>编译时绑定 vs. 运行时绑定：</strong> 静态语言的函数调用和变量引用在编译时绑定，而动态语言在运行时绑定，允许更大的灵活性。</li><li><strong>性能优化：</strong> 静态语言由于在编译阶段有更多的类型信息，通常可以进行更多的编译时优化，因此在一些性能方面具有优势。动态语言通常在运行时进行解释，因此可能在性能上略逊于静态语言。</li><li><strong>错误检查：</strong> 由于在编译时进行类型检查，静态语言通常能够在更早的阶段捕获潜在的错误，而动态语言在运行时才能发现。</li></ul><hr><p>Go语言被设计成静态语言的主要原因涉及到一系列的设计目标和哲学，其中一些因素包括：</p><ol><li><p><strong>性能优化：</strong> 静态语言通常在编译阶段进行类型检查，这使得编译器可以在生成机器代码时进行更多的优化。Go语言的设计目标之一是提供出色的性能，静态类型信息允许编译器在编译时对代码进行更多的优化，提高程序的执行效率。</p></li><li><p><strong>并发支持：</strong> Go语言的并发模型以及轻量级线程（goroutines）的概念需要在编译时对程序的结构有清晰的了解。静态类型信息使编译器能够更好地理解并发代码，减少在运行时发生竞争条件和死锁的可能性。</p></li><li><p><strong>简单性和可读性：</strong> Go语言的设计注重简单性和可读性，静态类型系统可以帮助开发者更容易理解代码。类型信息作为一种文档形式，使得代码更加自解释，减少了理解代码所需的认知负担。</p></li><li><p><strong>错误检查：</strong> 静态类型检查可以在编译时捕获潜在的类型错误，提高代码的可靠性。这有助于减少在运行时因为类型错误引起的 bug，提高了代码的稳定性。</p></li><li><p><strong>团队协作：</strong> 在大型项目和团队中，静态类型系统可以提供更好的协作支持。类型信息可以帮助开发者了解函数和变量的用法，使得团队成员之间更容易沟通和协作。</p></li><li><p><strong>编程工具的支持：</strong> 静态类型信息为IDE（集成开发环境）和其他编程工具提供了更多的信息，从而提供更强大的代码分析和自动补全功能，提高了开发效率。</p></li></ol><p>总的来说，Go语言之所以选择静态类型，是为了在性能、并发性、可读性和团队协作等方面达到一种平衡，使得开发者能够更容易地编写高性能、可维护和并发安全的代码。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，本周的学习总结也就完成了，内容较少，原因是还有一些更复杂的东西想留着专门来写。所以本文就只是写了在学了Go语言的基础语法，即打开了Go语言之门之后，我的疑问和相对应的解答。除了解语法之外，我也在尝试着跟着大佬来完成一些项目，详细的就等完成之后的总结吧。</p><p>下周的学习目标是更深层次地学习Go语言的进阶语法并推动项目进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开始学习Go语言已经差不多半年了，这是第一次正式写下一篇学习总结。又恰逢新学期开始，就把这篇当作新学期的第一篇周报吧。&lt;/p&gt;
&lt;p&gt;本周主</summary>
      
    
    
    
    <category term="学习周报" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="Go语言" scheme="http://example.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是命名空间（namespace）</title>
    <link href="http://example.com/2023/07/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89/"/>
    <id>http://example.com/2023/07/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89/</id>
    <published>2023-07-31T12:02:01.000Z</published>
    <updated>2024-03-01T09:04:47.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想必大家在初学C++时就已经发现了这样一个现象：一些代码前面要加上 <code>std::</code> 或者在头文件后用 <code>using namespce std;</code>来代替。已经学习C++两年的我在最开始发现这一问题时选择了最简单的方法来理解这一现象，那就是“记住就好了，就应该是这样的”。</p><p>直到最近在阅读《程序员的自我修养》这本书的时候又一次看到了 <code>namespace</code> 这一词，这次它以一个全新的名字出现在我的眼前——命名空间。在查询了资料过后，才解开了这个困惑。</p><h1 id="什么是命名空间"><a href="#什么是命名空间" class="headerlink" title="什么是命名空间"></a>什么是命名空间</h1><p>命名空间（Namespace）是编程语言中用于标识符（变量、函数、类、对象等）命名的一种机制，它可以防止命名冲突和提供更好的代码组织方式。在不同的上下文中，同一个名字可能会被用来表示不同的实体，这时候通过命名空间可以区分它们，避免混淆。</p><blockquote><p>我们假设一个C++文件是一个城市，在这个城市里有很多人都叫“张伟”，如果我们除了他们的名字以外对他们没有任何了解，那么当我们叫张伟这个名字时，编译器并不知道是哪一个张伟。更何况我们叫的这个名字，在别的城市（引入的其他头文件）也有。</p><p>为了更好分清楚他们，我们将收集更多关于这些人的个人信息，如家庭住址、年龄、身高、长相等。</p><p>由此引入命名空间这个概念，我们给每一个这样的人限定一定的空间范围，在每次使用时到提前声明他的空间范围是什么，这样编译器就可以分清楚我们要的是哪一个。本质上，命名空间就是定义了一个范围。</p></blockquote><h2 id="如何声明并使用命名空间"><a href="#如何声明并使用命名空间" class="headerlink" title="如何声明并使用命名空间"></a>如何声明并使用命名空间</h2><p>具体示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="comment">// 声明或定义变量、函数、类等实体</span></span><br><span class="line">    <span class="type">int</span> myVariable = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">        <span class="comment">// 类定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名空间中的实体</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyNamespace::<span class="built_in">myFunction</span>();</span><br><span class="line">    <span class="type">int</span> value = MyNamespace::myVariable;</span><br><span class="line">    MyNamespace::MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std;"></a>using namespace std;</h1><p>相信看到这里，一部分人就已经明白这一条代码是什么意思了。这是一个使用命名空间的声明，它的作用是告诉编译器在当前代码范围内使用标准 <strong>C++ 库（std）</strong>的所有实体，而无需在每个标识符前加上 <code>std::</code> 前缀。</p><p>在 C++ 中，<code>std</code> 是标准 C++ 库（Standard Library）的命名空间，它包含了许多有用的函数、类和对象，用于完成各种常见的任务，如输入输出、容器操作、算法处理、字符串处理等等。标准 C++ 库是 C++ 语言的一部分，提供了广泛的功能，使得开发者可以更加高效地编写 C++ 程序。</p><p><code>std</code> 是 C++ 标准库的命名空间，因此库中的所有实体（函数、类、对象等）都被放在这个命名空间下，以避免与用户代码中的其他实体发生命名冲突。</p><p>下面分别展示使用命名空间以及不使用命名空间的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用了std命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的名字：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的名字：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，在代码教程的情况下，使用 <code>using namespace std;</code> 可以少写很多代码。</p><h2 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a>using指令</h2><p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出结果为：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230731204222913.png" alt="image-20230731204222913"></p><p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p><h2 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h2><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p><p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h2><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123;   <span class="comment">// 代码声明   </span></span><br><span class="line"><span class="keyword">namespace</span> namespace_name2 &#123;      </span><br><span class="line"><span class="comment">// 代码声明   </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过使用 <strong>::</strong> 运算符来访问嵌套的命名空间中的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 namespace_name2 中的成员 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1::namespace_name2;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 namespace_name1 中的成员 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1;</span><br></pre></td></tr></table></figure><p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 第二个命名空间</span></span><br><span class="line">   <span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space::second_space;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>以上便是笔者解决自己疑惑所学到的内容，其中主要内容来自于<a href="https://www.runoob.com/cplusplus/cpp-namespaces.html">菜鸟教程</a>和ChatGPT的回答。本文仅作为笔者自己地思考笔记，希望对你有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想必大家在初学C++时就已经发现了这样一个现象：一些代码前面要加上 &lt;code&gt;std::&lt;/code&gt; 或者在头文件后用 &lt;code&gt;us</summary>
      
    
    
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Bomb Lab</title>
    <link href="http://example.com/2023/04/18/Bomb-Lab/"/>
    <id>http://example.com/2023/04/18/Bomb-Lab/</id>
    <published>2023-04-18T12:52:18.000Z</published>
    <updated>2024-03-01T09:04:59.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是HNU计算机系统课程的第三次实验，实验要求是给一个用C语言编写的可执行文件bomb，你可以看到它主函数的C语言代码，除此之外，一概不知，实验分为六个阶段，每个阶段需要输入一串字符，以此来破译炸弹的密码，如果六次输入的密码都是正确的，则炸弹拆除，否则炸弹爆炸（退出并打印爆炸信息）。为了防止学生互相借鉴，HNU采用了最传统的防作弊方式——让每个学生做不同的题目。这次实验好行并没有什么评分标准，所以可以不断测试自己的答案。</p><h2 id="C语言源代码"><a href="#C语言源代码" class="headerlink" title="C语言源代码"></a>C语言源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 邪恶博士公司(PerPETRATOR)在此授予您(受害者)明确的许可来使用这个炸弹(the BOMB)。</span></span><br><span class="line"><span class="comment"> * 这是一个有时间限制的许可，在受害者死亡后失效。</span></span><br><span class="line"><span class="comment"> * 对于受害者的损害、挫折、精神错乱、虫眼、腕管综合症、失眠或其他伤害，PerPETRATOR不承担任何责任。 </span></span><br><span class="line"><span class="comment"> * 除非 &quot;保护者 &quot;想邀功，也就是说。受害者不得将此炸弹的源代码分发给PERPETRATOR的任何敌人。</span></span><br><span class="line"><span class="comment"> * 受害者不得调试、逆向工程、运行 &quot;字符串&quot;、反编译、解密或使用任何其他技术来获得对炸弹的了解和拆除炸弹。 </span></span><br><span class="line"><span class="comment"> * 在处理本程序时，不得穿戴防弹衣。</span></span><br><span class="line"><span class="comment"> * PERPETRATOR不会为PERPETRATOR的不良幽默感道歉。</span></span><br><span class="line"><span class="comment"> * 在法律禁止使用BOMB的地方，本许可是无效的。</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> * 自我注意： 记得删除这个文件，这样我的受害者就不会知道发生了什么事，</span></span><br><span class="line"><span class="comment"> * 而且他们都会在一场可怕的魔鬼爆炸中被炸死。-- 邪恶博士</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. </span></span><br><span class="line"><span class="comment">     请注意：记得把这个炸弹移植到Windows上，并给它装上一个奇妙的GUI。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. </span></span><br><span class="line"><span class="comment">     当运行时没有参数，炸弹从标准输入中读取其输入行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. </span></span><br><span class="line"><span class="comment">     * 当运行时有一个参数&lt;file&gt;，炸弹从&lt;file&gt;读取，直到EOF，然后切换到标准输入。</span></span><br><span class="line"><span class="comment">     * 因此，当你拆除每个阶段的炸弹时，你可以将其拆除的字符串添加到&lt;file&gt;中，避免重新输入。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. </span></span><br><span class="line"><span class="comment">    你不能用1个以上的命令行参数调用炸弹。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. </span></span><br><span class="line"><span class="comment">    做各种秘密的事情，使炸弹更难拆除。*/</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! </span></span><br><span class="line"><span class="comment">    嗯...  六个阶段一定比一个阶段更安全！！*/</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input       获取输入            */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase        运行阶段      */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!糟了!  他们发现了!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. 让我知道他们是如何做到的。*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">    第二阶段更难。 没有人能够弄清楚</span></span><br><span class="line"><span class="comment">     * how to defuse this... </span></span><br><span class="line"><span class="comment">     如何化解这...*/</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. </span></span><br><span class="line"><span class="comment">     我想到目前为止这太容易了。 一些更复杂的代码会使人们感到困惑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! </span></span><br><span class="line"><span class="comment">    哦，是吗？ 那么，你的数学水平如何？ 试试这个俏皮的问题吧!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! </span></span><br><span class="line"><span class="comment">    我们在记忆中绕来绕去，我们在哪里停下来，炸弹就在哪里爆炸!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. </span></span><br><span class="line"><span class="comment">     这个阶段将永远不会被使用，因为没有人会通过前面的阶段。 </span></span><br><span class="line"><span class="comment">     但为了以防万一，要把这个阶段变得特别难。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! </span></span><br><span class="line"><span class="comment">     哇，他们得到了它!  但是不是有什么东西......不见了？ 也许他们忽略了什么？ Mua ha ha ha!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>本实验使用 WSL2 以及 Ubuntu 20.4 完成，编译器为 VS code。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于实验所给的文件中只有一个bomb.c 和一个可执行文件，而bomb.c 并不能直接编译，因此我们只能通过给出的可执行文件来进行分析。将可执行文件通过反汇编得到完整程序的汇编代码，操作如下：</p><p>建议创建一个文件，并将反汇编出的代码输入到该文件中，方便后续查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; objdump -d &gt; objdump.txt</span><br></pre></td></tr></table></figure><h2 id="实验解析"><a href="#实验解析" class="headerlink" title="实验解析"></a>实验解析</h2><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p><strong>密钥</strong>：The moon unit will be divided into two divisions.</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">08048b60 &lt;phase_1&gt;:</span><br><span class="line"> 8048b60:83 ec 1c             sub    $0x1c,%esp</span><br><span class="line"> 8048b63:c7 44 24 04 c4 a1 04 movl   $0x804a1c4,0x4(%esp)</span><br><span class="line"> 8048b6a:08 </span><br><span class="line"> 8048b6b:8b 44 24 20          mov    0x20(%esp),%eax</span><br><span class="line"> 8048b6f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048b72:e8 6d 04 00 00       call   8048fe4 &lt;strings_not_equal&gt; </span><br><span class="line"> 8048b77:85 c0                test   %eax,%eax</span><br><span class="line"> 8048b79:74 05                je     8048b80 &lt;phase_1+0x20&gt;</span><br><span class="line"> 8048b7b:e8 76 05 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048b80:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048b83:c3                   ret    </span><br></pre></td></tr></table></figure><p><strong>分析如下：</strong></p><p>结合源代码可以得出 <code>0x20(%esp)</code> 对应的是 bomb.c 中 <code>read_line</code>读入的字符串的首地址。</p><p>阅读phase_1的第 2 到第 6行 ，观察到数据 <code>$0x804a1c4</code> 和 <code>0x20(%esp)</code> 均被作为参数传入栈帧中，结合第 7 行的调用 <code>strings_not_equal</code> 函数，可以推测， <code>$0x804a1c4</code> 处存储的也是一个字符串的首地址，并且要与之前读入的字符串进行比较。</p><p>查看 <code>strings_not_equal</code> 函数的汇编代码，得知该函数是用于比较两个字符串是否相等的，若相等则返回0，不相等则返回1，返回值均保存在 <code>%eax</code> 中。</p><p>继续查看下面的汇编代码，其中第 8 到第 10 行可以得出：当 <code>%eax</code> 为 0 时，跳转到 <code>&lt;phase_1+0x20&gt;</code> 处（即跳过炸弹爆炸）；当 <code>%eax</code> 为 1 时，不会发生跳转，此时炸弹爆炸。</p><p>因此我们可以得出结论，当我们输入的字符串与 <code>$0x804a1c4</code> 处存储的字符串<strong>相等</strong>时，就能通过phase_1。</p><p>通过 gdb 调试查看 <code>$0x804a1c4</code> 处存储的字符串：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230417093216100.png" alt="image-20230417093216100"></p><p>通过 gdb 中的 print 命令，打印出来phase_1的通关密钥。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p><strong>密钥：</strong>1 2 4 8 16 32</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">08048b84 &lt;phase_2&gt;:</span><br><span class="line"> 8048b84:56                   push   %esi</span><br><span class="line"> 8048b85:53                   push   %ebx</span><br><span class="line"> 8048b86:83 ec 34             sub    $0x34,%esp</span><br><span class="line"> 8048b89:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048b8d:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048b91:8b 44 24 40          mov    0x40(%esp),%eax</span><br><span class="line"> 8048b95:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048b98:e8 8e 06 00 00       call   804922b &lt;read_six_numbers&gt;</span><br><span class="line"> 8048b9d:83 7c 24 18 01       cmpl   $0x1,0x18(%esp) //0x18(%esp)为第一个数字，且必须为1</span><br><span class="line"> 8048ba2:74 05                je     8048ba9 &lt;phase_2+0x25&gt;</span><br><span class="line"> 8048ba4:e8 4d 05 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ba9:8d 5c 24 1c          lea    0x1c(%esp),%ebx</span><br><span class="line"> 8048bad:8d 74 24 30          lea    0x30(%esp),%esi</span><br><span class="line"> 8048bb1:8b 43 fc             mov    -0x4(%ebx),%eax</span><br><span class="line"> 8048bb4:01 c0                add    %eax,%eax //上一个数字的两倍</span><br><span class="line"> 8048bb6:39 03                cmp    %eax,(%ebx) //第二个数字是第一个数字的两倍，2</span><br><span class="line"> 8048bb8:74 05                je     8048bbf &lt;phase_2+0x3b&gt;</span><br><span class="line"> 8048bba:e8 37 05 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048bbf:83 c3 04             add    $0x4,%ebx</span><br><span class="line"> 8048bc2:39 f3                cmp    %esi,%ebx</span><br><span class="line"> 8048bc4:75 eb                jne    8048bb1 &lt;phase_2+0x2d&gt; //如果当前这个数的下一个数是第6个输入的值，跳出循环</span><br><span class="line"> 8048bc6:83 c4 34             add    $0x34,%esp</span><br><span class="line"> 8048bc9:5b                   pop    %ebx</span><br><span class="line"> 8048bca:5e                   pop    %esi</span><br><span class="line"> 8048bcb:c3                   ret </span><br></pre></td></tr></table></figure><p>可以看到phase_2中调用了一个交 <code>read_six_numbers</code> 的函数，反汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0804922b &lt;read_six_numbers&gt;:</span><br><span class="line"> 804922b:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 804922e:8b 44 24 34          mov    0x34(%esp),%eax</span><br><span class="line"> 8049232:8d 50 14             lea    0x14(%eax),%edx</span><br><span class="line"> 8049235:89 54 24 1c          mov    %edx,0x1c(%esp)</span><br><span class="line"> 8049239:8d 50 10             lea    0x10(%eax),%edx</span><br><span class="line"> 804923c:89 54 24 18          mov    %edx,0x18(%esp)</span><br><span class="line"> 8049240:8d 50 0c             lea    0xc(%eax),%edx</span><br><span class="line"> 8049243:89 54 24 14          mov    %edx,0x14(%esp)</span><br><span class="line"> 8049247:8d 50 08             lea    0x8(%eax),%edx</span><br><span class="line"> 804924a:89 54 24 10          mov    %edx,0x10(%esp)</span><br><span class="line"> 804924e:8d 50 04             lea    0x4(%eax),%edx</span><br><span class="line"> 8049251:89 54 24 0c          mov    %edx,0xc(%esp)</span><br><span class="line"> 8049255:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8049259:c7 44 24 04 d7 a3 04 movl   $0x804a3d7,0x4(%esp)</span><br><span class="line"> 8049260:08 </span><br><span class="line"> 8049261:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8049265:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8049268:e8 03 f6 ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 804926d:83 f8 05             cmp    $0x5,%eax</span><br><span class="line"> 8049270:7f 05                jg     8049277 &lt;read_six_numbers+0x4c&gt;</span><br><span class="line"> 8049272:e8 7f fe ff ff       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8049277:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 804927a:c3                   ret    </span><br></pre></td></tr></table></figure><p>从函数的名字我们也不难猜出该函数的作用，读取 6 个数字。注意到 <code>8049259</code> 这一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8049259:c7 44 24 04 d7 a3 04 movl   $0x804a3d7,0x4(%esp)</span><br></pre></td></tr></table></figure><p>这里在 <code>0x4(%esp)</code> 里存了一个地址，输出一下看看是什么。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230417094147134.png" alt="image-20230417094147134"></p><p>想来这个就是输入函数 sscanf 的格式了，果不其然是输入6个数字。</p><p>已知 <code>read_six_numbers</code> 函数的作用，我们再次回到 phase_2的汇编代码中。第 10 行的 <code>cmpl   $0x1,0x18(%esp)</code>表明第一个数字必须为 1，否则炸弹直接爆炸。</p><p>由第 13 行到第 22 行，我们可以看出，每次将下一个数字的地址给到寄存器 <code>%ebx</code>，将当前数字给到寄存器 <code>%eax</code> ，再将 <code>%eax</code> 中的值做乘 2 处理，最后将  <code>%ebx</code> 地址处的值与 <code>%eax</code> 中的值作比较，相等则继续循环，不等则炸弹爆炸。循环结束的条件是 6 个数字全部比较结束。</p><p>因此输入的 6 个数字应该为：<code>1 2 4 8 16 32</code></p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p><strong>密钥：</strong>0 -418 或 1 -906 或 2 -536 或 3 -639 或 4 0 或 5 -639</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">08048bcc &lt;phase_3&gt;:</span><br><span class="line"> 8048bcc:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048bcf:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048bd3:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048bd7:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048bdb:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048bdf:c7 44 24 04 e3 a3 04 movl   $0x804a3e3,0x4(%esp) //该处地址内容为 &quot;%d %d&quot;，说明调用下一步的函数要输入两个整形</span><br><span class="line"> 8048be6:08 </span><br><span class="line"> 8048be7:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048beb:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048bee:e8 7d fc ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt; //返回值为输入参数的个数，小于2则炸弹爆炸</span><br><span class="line"> 8048bf3:83 f8 01             cmp    $0x1,%eax</span><br><span class="line"> 8048bf6:7f 05                jg     8048bfd &lt;phase_3+0x31&gt;</span><br><span class="line"> 8048bf8:e8 f9 04 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048bfd:83 7c 24 18 07       cmpl   $0x7,0x18(%esp) </span><br><span class="line"> 8048c02:77 64                ja     8048c68 &lt;phase_3+0x9c&gt; //如果第一个参数超过 7 ，则爆炸</span><br><span class="line"> 8048c04:8b 44 24 18          mov    0x18(%esp),%eax</span><br><span class="line"> 8048c08:ff 24 85 20 a2 04 08 jmp    *0x804a220(,%eax,4)</span><br><span class="line"> 8048c0f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c14:eb 05                jmp    8048c1b &lt;phase_3+0x4f&gt;</span><br><span class="line"> 8048c16:b8 e8 01 00 00       mov    $0x1e8,%eax</span><br><span class="line"> 8048c1b:2d 72 01 00 00       sub    $0x172,%eax减172</span><br><span class="line"> 8048c20:eb 05                jmp    8048c27 &lt;phase_3+0x5b&gt;</span><br><span class="line"> 8048c22:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c27:83 c0 67             add    $0x67,%eax加67</span><br><span class="line"> 8048c2a:eb 05                jmp    8048c31 &lt;phase_3+0x65&gt;</span><br><span class="line"> 8048c2c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c31:2d 7f 02 00 00       sub    $0x27f,%eax减27f</span><br><span class="line"> 8048c36:eb 05                jmp    8048c3d &lt;phase_3+0x71&gt;</span><br><span class="line"> 8048c38:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c3d:05 7f 02 00 00       add    $0x27f,%eax加27f</span><br><span class="line"> 8048c42:eb 05                jmp    8048c49 &lt;phase_3+0x7d&gt;</span><br><span class="line"> 8048c44:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c49:2d 7f 02 00 00       sub    $0x27f,%eax减27f</span><br><span class="line"> 8048c4e:eb 05                jmp    8048c55 &lt;phase_3+0x89&gt;</span><br><span class="line"> 8048c50:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c55:05 7f 02 00 00       add    $0x27f,%eax加27f</span><br><span class="line"> 8048c5a:eb 05                jmp    8048c61 &lt;phase_3+0x95&gt;</span><br><span class="line"> 8048c5c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c61:2d 7f 02 00 00       sub    $0x27f,%eax减27f</span><br><span class="line"> 8048c66:eb 0a                jmp    8048c72 &lt;phase_3+0xa6&gt;</span><br><span class="line"> 8048c68:e8 89 04 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c6d:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c72:83 7c 24 18 05       cmpl   $0x5,0x18(%esp) //第一个参数的取值范围为 【0， 5】</span><br><span class="line"> 8048c77:7f 06                jg     8048c7f &lt;phase_3+0xb3&gt;</span><br><span class="line"> 8048c79:3b 44 24 1c          cmp    0x1c(%esp),%eax //第二个参数与 eax作比较，</span><br><span class="line"> 8048c7d:74 05                je     8048c84 &lt;phase_3+0xb8&gt; //相等结束，否则爆炸</span><br><span class="line"> 8048c7f:e8 72 04 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c84:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048c87:c3                   ret    </span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>第 3 ~ 11 行是为scanf函数配置参数以及执行scanf函数的过程，用 print 查看<code>0x804a3e3</code> 中的内容，发现是 <code>&quot;%d %d&quot;</code> ，说明 scanf 读取的是两个整型数字，即密钥是由两个整数组成的。从第 12 行可以看出，当输入的参数个数小于 2 时，炸弹就会爆炸。</p><p>第15 ~ 16行，<code>0x18(%esp)</code>中存储的是输入的第一个数，<code>ja</code> 指令意味着无符号指令的大小比较，可以推断出第一个数的取值范围是[0,7]。</p><p>第 18 行代码是一个变址寻址的地址跳转，跳转的地址为<code>*(0x804a200+(%eax)*4)</code> ，使用 gdb 输出 <code>0x804a200</code> 地址处的 8 个值（因为输入的第一个参数为0~7，合理推测此处最多只有 8 个值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8wx 0x804a220</span><br><span class="line">0x804a220:      0x08048c16      0x08048c0f      0x08048c22      0x08048c2c</span><br><span class="line">0x804a230:      0x08048c38      0x08048c44      0x08048c50      0x08048c5c</span><br></pre></td></tr></table></figure><p>可以看出，<code>0x804a220</code>之后存储的 8 个值都是要跳转的地址。跳转后就会执行各种加或减的操作。一系列操作后，第44 ~ 45行代码又将第一个参数的取值范围缩小至[0,5]。第46 ~ 47行代码则是将操作后得到的数与我们输入的第二个参数相比较，相等则函数结束，不相等则炸弹爆炸。</p><p>因此要得出所有的答案，只需要在第18行跳转完成后计算出加减操作得到的最后的值，就是我们要输入的第二个数。</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p><strong>密钥：</strong>11 18</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">08048cf1 &lt;phase_4&gt;:</span><br><span class="line"> 8048cf1:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048cf4:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048cf8:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048cfc:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048d00:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d04:c7 44 24 04 e3 a3 04 movl   $0x804a3e3,0x4(%esp)</span><br><span class="line"> 8048d0b:08 </span><br><span class="line"> 8048d0c:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048d10:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048d13:e8 58 fb ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 8048d18:83 f8 02             cmp    $0x2,%eax</span><br><span class="line"> 8048d1b:75 0d                jne    8048d2a &lt;phase_4+0x39&gt; //输入参数不等于2时，炸弹爆炸</span><br><span class="line"> 8048d1d:8b 44 24 18          mov    0x18(%esp),%eax  //第一个参数</span><br><span class="line"> 8048d21:85 c0                test   %eax,%eax  //</span><br><span class="line"> 8048d23:78 05                js     8048d2a &lt;phase_4+0x39&gt; //第一个参数为负数时，炸弹爆炸</span><br><span class="line"> 8048d25:83 f8 0e             cmp    $0xe,%eax </span><br><span class="line"> 8048d28:7e 05                jle    8048d2f &lt;phase_4+0x3e&gt; //eax（第一个参数）应该小于等于 14，否则爆炸</span><br><span class="line"> 8048d2a:e8 c7 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d2f:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp) 调用函数func，第三个参数是 14，第二个参数是 0，第一个参数为输入的第一个值</span><br><span class="line"> 8048d36:00 </span><br><span class="line"> 8048d37:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp) </span><br><span class="line"> 8048d3e:00 </span><br><span class="line"> 8048d3f:8b 44 24 18          mov    0x18(%esp),%eax </span><br><span class="line"> 8048d43:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048d46:e8 3d ff ff ff       call   8048c88 &lt;func4&gt;</span><br><span class="line"> 8048d4b:83 f8 12             cmp    $0x12,%eax//比较返回值与18的大小，返回值不等于18，则炸弹爆炸</span><br><span class="line"> 8048d4e:75 07                jne    8048d57 &lt;phase_4+0x66&gt;</span><br><span class="line"> 8048d50:83 7c 24 1c 12       cmpl   $0x12,0x1c(%esp) //比较第二个输入值与18的大小，不等于则炸弹爆炸</span><br><span class="line"> 8048d55:74 05                je     8048d5c &lt;phase_4+0x6b&gt;</span><br><span class="line"> 8048d57:e8 9a 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d5c:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048d5f:c3                   ret </span><br></pre></td></tr></table></figure><p>有第 7 行的 <code>0x804a3e3</code>地址处所存的内容以及第 12 行将 scanf 函数的返回值与 2 作比较，可以得出输入的是两个参数，且参数类型为整形。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230422153859139.png" alt="image-20230422153859139"></p><p>由第 14 ~ 18 行分析可得，输入的第一个参数的取值范围应该是 [0, 14]。第 20 ~ 26 行，主函数调用 func4 函数，并将(x, 0, 14)作为函数的三个参数传入(x 表示我们输入的第一个参数)。以下是 <code>func4</code> 函数的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">08048c88 &lt;func4&gt;:A</span><br><span class="line"> 8048c88:83 ec 1c             sub    $0x1c,%esp</span><br><span class="line"> 8048c8b:89 5c 24 14          mov    %ebx,0x14(%esp)</span><br><span class="line"> 8048c8f:89 74 24 18          mov    %esi,0x18(%esp)</span><br><span class="line"> 8048c93:8b 44 24 20          mov    0x20(%esp),%eax//a = x</span><br><span class="line"> 8048c97:8b 54 24 24          mov    0x24(%esp),%edx//b = 0</span><br><span class="line"> 8048c9b:8b 74 24 28          mov    0x28(%esp),%esi//c = 14</span><br><span class="line"> 8048c9f:89 f1                mov    %esi,%ecx</span><br><span class="line"> 8048ca1:29 d1                sub    %edx,%ecx//d = c - b</span><br><span class="line"> 8048ca3:89 cb                mov    %ecx,%ebx</span><br><span class="line"> 8048ca5:c1 eb 1f             shr    $0x1f,%ebx//d进行逻辑右移31位，取出其符号位，e = d&gt;&gt;31</span><br><span class="line"> 8048ca8:01 d9                add    %ebx,%ecx//d = d + e </span><br><span class="line"> 8048caa:d1 f9                sar    %ecx//对d进行符号位拓展</span><br><span class="line"> 8048cac:8d 1c 11             lea    (%ecx,%edx,1),%ebx//f = (b + d)</span><br><span class="line"> 8048caf:39 c3                cmp    %eax,%ebx//比较f与a的大小</span><br><span class="line"> 8048cb1:7e 17                jle    8048cca &lt;func4+0x42&gt; //如果 f &lt;= a 则发生跳转</span><br><span class="line"> 8048cb3:8d 4b ff             lea    -0x1(%ebx),%ecx//f - 1 -&gt; ecx</span><br><span class="line"> 8048cb6:89 4c 24 08          mov    %ecx,0x8(%esp)//f-1 为第三个参数</span><br><span class="line"> 8048cba:89 54 24 04          mov    %edx,0x4(%esp)//b 为第二个参数</span><br><span class="line"> 8048cbe:89 04 24             mov    %eax,(%esp)//a 为第一个参数</span><br><span class="line"> 8048cc1:e8 c2 ff ff ff       call   8048c88 &lt;func4&gt;</span><br><span class="line"> 8048cc6:01 c3                add    %eax,%ebx//eax保存func4的返回值</span><br><span class="line"> 8048cc8:eb 19                jmp    8048ce3 &lt;func4+0x5b&gt;</span><br><span class="line"> 8048cca:39 c3                cmp    %eax,%ebx</span><br><span class="line"> 8048ccc:7d 15                jge    8048ce3 &lt;func4+0x5b&gt;//如果 f &gt;= a 发生跳转</span><br><span class="line"> 8048cce:89 74 24 08          mov    %esi,0x8(%esp)</span><br><span class="line"> 8048cd2:8d 53 01             lea    0x1(%ebx),%edx</span><br><span class="line"> 8048cd5:89 54 24 04          mov    %edx,0x4(%esp)</span><br><span class="line"> 8048cd9:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048cdc:e8 a7 ff ff ff       call   8048c88 &lt;func4&gt;</span><br><span class="line"> 8048ce1:01 c3                add    %eax,%ebx</span><br><span class="line"> 8048ce3:89 d8                mov    %ebx,%eax</span><br><span class="line"> 8048ce5:8b 5c 24 14          mov    0x14(%esp),%ebx</span><br><span class="line"> 8048ce9:8b 74 24 18          mov    0x18(%esp),%esi</span><br><span class="line"> 8048ced:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048cf0:c3                   ret</span><br></pre></td></tr></table></figure><p>这个函数有点绕，大概是做一个二分，具体的内容写在注释里，自己可以用笔模拟下这个函数在干嘛，可以推断出C语言代码大致如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line"><span class="type">int</span> d = c - b;</span><br><span class="line"><span class="type">int</span> e = (d &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">d = (d + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f = b + d;</span><br><span class="line"><span class="keyword">if</span>(a &lt; f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> g = func4(a, b, f<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> g = func4(a , f+<span class="number">1</span>, c);</span><br><span class="line"><span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>func4</code> 函数中返回后，第 27 行代码将函数的返回值与 <code>0x12</code> 作比较，不相等时炸弹直接爆炸，相等则继续下面的判断。第 29 行代码显示将输入的第二个值与 <code>0x12</code> 作比较，当不相等时发生爆炸，相等则安全退出函数。由推断出的 <code>func4</code> 的C语言代码可尝试在输入[0, 14]时，函数的不同返回值。只有当输入值为 11 时，返回值才是18，即与 <code>0x12</code> 相等。由此便可推出密钥为 <code>11 18</code>。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p><strong>密钥：</strong>bcejno 或 cdeijn 或 cejlmn（只列出了极少的情况，全部可能应该有几万种可能）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">08048d60 &lt;phase_5&gt;:</span><br><span class="line"> 8048d60:53                   push   %ebx</span><br><span class="line"> 8048d61:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048d64:8b 5c 24 20          mov    0x20(%esp),%ebx</span><br><span class="line"> 8048d68:89 1c 24             mov    %ebx,(%esp)</span><br><span class="line"> 8048d6b:e8 5b 02 00 00       call   8048fcb &lt;string_length&gt;//获取输入字符串的长度</span><br><span class="line"> 8048d70:83 f8 06             cmp    $0x6,%eax </span><br><span class="line"> 8048d73:74 05                je     8048d7a &lt;phase_5+0x1a&gt; //输入字符串的长度不等于 6 ，炸弹爆炸</span><br><span class="line"> 8048d75:e8 7c 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d7a:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line"> 8048d7f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048d84:0f be 0c 03          movsbl (%ebx,%eax,1),%ecx</span><br><span class="line"> 8048d88:83 e1 0f             and    $0xf,%ecx</span><br><span class="line"> 8048d8b:03 14 8d 40 a2 04 08 add    0x804a240(,%ecx,4),%edx</span><br><span class="line"> 8048d92:83 c0 01             add    $0x1,%eax</span><br><span class="line"> 8048d95:83 f8 06             cmp    $0x6,%eax</span><br><span class="line"> 8048d98:75 ea                jne    8048d84 &lt;phase_5+0x24&gt;</span><br><span class="line"> 8048d9a:83 fa 41             cmp    $0x41,%edx</span><br><span class="line"> 8048d9d:74 05                je     8048da4 &lt;phase_5+0x44&gt;</span><br><span class="line"> 8048d9f:e8 52 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048da4:83 c4 18             add    $0x18,%esp</span><br><span class="line"> 8048da7:5b                   pop    %ebx</span><br><span class="line"> 8048da8:c3                   ret</span><br></pre></td></tr></table></figure><p>分析前 8 行代码可知，输入值为一个字符串，且长度一定要是 6，否则炸弹直接爆炸。接下来就是一个循环结构，遍历输入的字符串，并将当前遍历的字节与 <code>oxf</code> 相与得到一个值，得到的值将作为首地址在 <code>0x804a240</code> 处的整数数组的下标，并将访问的值进行累加，若和为 <code>0x41</code> ，则该字符串就是密钥，否则炸弹爆炸。下面是该函数的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">6</span>] = 输入的字符串</span><br><span class="line"><span class="type">int</span> a[<span class="number">16</span>] = 首地址在<span class="number">0x804a220</span>处的数组，由于和<span class="number">0xf</span>相与，故下标最大值为<span class="number">15</span>，数组长度为<span class="number">16</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//累加和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos = (<span class="type">int</span>)s[i] &amp; <span class="number">0xf</span>;</span><br><span class="line">    sum += a[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum != <span class="number">0x41</span>)</span><br><span class="line">    explode_bomb();</span><br></pre></td></tr></table></figure><p>查看 <code>0x804a240</code> 地址处的长度为 16 的整数数组的全部值：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230409222538168.png" alt="image-20230409222538168"></p><p>每个整数值对应的字母大小写如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x804a240 &lt;array.2999&gt;: 2-p\P       10-a\q\A\Q      6-b\r\B\Q       1-c\s\C\S</span><br><span class="line">0x804a250 &lt;array.2999+16&gt;:      12-d\t\D\T      16-E\U\e\u      9-F\V\f\v       3-g\w\G\W</span><br><span class="line">0x804a260 &lt;array.2999+32&gt;:      4-H\X\h\x       7-I\Y\i\y       14-j\z\J\Z      5-k\K</span><br><span class="line">0x804a270 &lt;array.2999+48&gt;:      11-L\l      8-M\m       15-N\n      13-o\O</span><br></pre></td></tr></table></figure><p>全部不重复的情况如下（没有任何参考价值，尽量不要尝试算出所有的情况）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">[1, 6, 13, 14, 15, 16], </span><br><span class="line">[1, 7, 12, 14, 15, 16],</span><br><span class="line">[1, 8, 11, 14, 15, 16],</span><br><span class="line">[1, 8, 12, 13, 15, 16], </span><br><span class="line">[1, 9, 10, 14, 15, 16], </span><br><span class="line">[1, 9, 11, 13, 15, 16], </span><br><span class="line">[1, 9, 12, 13, 14, 16], </span><br><span class="line">[1, 10, 11, 12, 15, 16], </span><br><span class="line">[1, 10, 11, 13, 14, 16],</span><br><span class="line">[1, 10, 12, 13, 14, 15], </span><br><span class="line">[2, 5, 13, 14, 15, 16], </span><br><span class="line">[2, 6, 12, 14, 15, 16], </span><br><span class="line">[2, 7, 11, 14, 15, 16], </span><br><span class="line">[2, 7, 12, 13, 15, 16], </span><br><span class="line">[2, 8, 10, 14, 15, 16], </span><br><span class="line">[2, 8, 11, 13, 15, 16], </span><br><span class="line">[2, 8, 12, 13, 14, 16], </span><br><span class="line">[2, 9, 10, 13, 15, 16], </span><br><span class="line">[2, 9, 11, 12, 15, 16], </span><br><span class="line">[2, 9, 11, 13, 14, 16], </span><br><span class="line">[2, 9, 12, 13, 14, 15], </span><br><span class="line">[2, 10, 11, 12, 14, 16],</span><br><span class="line">[2, 10, 11, 13, 14, 15],</span><br><span class="line">[3, 4, 13, 14, 15, 16], </span><br><span class="line">[3, 5, 12, 14, 15, 16], </span><br><span class="line">[3, 6, 11, 14, 15, 16], </span><br><span class="line">[3, 6, 12, 13, 15, 16], </span><br><span class="line">[3, 7, 10, 14, 15, 16], </span><br><span class="line">[3, 7, 11, 13, 15, 16], </span><br><span class="line">[3, 7, 12, 13, 14, 16], </span><br><span class="line">[3, 8, 9, 14, 15, 16], </span><br><span class="line">[3, 8, 10, 13, 15, 16],</span><br><span class="line">[3, 8, 11, 12, 15, 16],</span><br><span class="line">[3, 8, 11, 13, 14, 16],</span><br><span class="line">[3, 8, 12, 13, 14, 15], </span><br><span class="line">[3, 9, 10, 12, 15, 16], </span><br><span class="line">[3, 9, 10, 13, 14, 16], </span><br><span class="line">[3, 9, 11, 12, 14, 16],</span><br><span class="line">[3, 9, 11, 13, 14, 15], </span><br><span class="line">[3, 10, 11, 12, 13, 16],</span><br><span class="line">[3, 10, 11, 12, 14, 15],</span><br><span class="line">[4, 5, 11, 14, 15, 16], </span><br><span class="line">[4, 5, 12, 13, 15, 16],</span><br><span class="line">[4, 6, 10, 14, 15, 16],</span><br><span class="line">[4, 6, 11, 13, 15, 16],</span><br><span class="line">[4, 6, 12, 13, 14, 16], </span><br><span class="line">[4, 7, 9, 14, 15, 16], </span><br><span class="line">[4, 7, 10, 13, 15, 16],</span><br><span class="line">[4, 7, 11, 12, 15, 16], </span><br><span class="line">[4, 7, 11, 13, 14, 16],</span><br><span class="line">[4, 7, 12, 13, 14, 15], </span><br><span class="line">[4, 8, 9, 13, 15, 16], </span><br><span class="line">[4, 8, 10, 12, 15, 16],</span><br><span class="line">[4, 8, 10, 13, 14, 16],</span><br><span class="line">[4, 8, 11, 12, 14, 16], </span><br><span class="line">[4, 8, 11, 13, 14, 15],</span><br><span class="line">[4, 9, 10, 11, 15, 16], </span><br><span class="line">[4, 9, 10, 12, 14, 16], </span><br><span class="line">[4, 9, 10, 13, 14, 15],</span><br><span class="line">[4, 9, 11, 12, 13, 16],</span><br><span class="line">[4, 9, 11, 12, 14, 15], </span><br><span class="line">[4, 10, 11, 12, 13, 15],</span><br><span class="line">[5, 6, 9, 14, 15, 16], </span><br><span class="line">[5, 6, 10, 13, 15, 16],</span><br><span class="line">[5, 6, 11, 12, 15, 16], </span><br><span class="line">[5, 6, 11, 13, 14, 16], </span><br><span class="line">[5, 6, 12, 13, 14, 15], </span><br><span class="line">[5, 7, 8, 14, 15, 16], </span><br><span class="line">[5, 7, 9, 13, 15, 16], </span><br><span class="line">[5, 7, 10, 12, 15, 16], </span><br><span class="line">[5, 7, 10, 13, 14, 16], </span><br><span class="line">[5, 7, 11, 12, 14, 16], </span><br><span class="line">[5, 7, 11, 13, 14, 15], </span><br><span class="line">[5, 8, 9, 12, 15, 16], </span><br><span class="line">[5, 8, 9, 13, 14, 16],</span><br><span class="line">[5, 8, 10, 11, 15, 16],</span><br><span class="line">[5, 8, 10, 12, 14, 16],</span><br><span class="line">[5, 8, 10, 13, 14, 15],</span><br><span class="line">[5, 8, 11, 12, 13, 16], </span><br><span class="line">[5, 8, 11, 12, 14, 15],</span><br><span class="line">[5, 9, 10, 11, 14, 16], </span><br><span class="line">[5, 9, 10, 12, 13, 16],</span><br><span class="line">[5, 9, 10, 12, 14, 15],</span><br><span class="line">[5, 9, 11, 12, 13, 15], </span><br><span class="line">[5, 10, 11, 12, 13, 14],</span><br><span class="line">[6, 7, 8, 13, 15, 16], </span><br><span class="line">[6, 7, 9, 12, 15, 16], </span><br><span class="line">[6, 7, 9, 13, 14, 16],</span><br><span class="line">[6, 7, 10, 11, 15, 16],</span><br><span class="line">[6, 7, 10, 12, 14, 16],</span><br><span class="line">[6, 7, 10, 13, 14, 15],</span><br><span class="line">[6, 7, 11, 12, 13, 16], </span><br><span class="line">[6, 7, 11, 12, 14, 15],</span><br><span class="line">[6, 8, 9, 11, 15, 16], </span><br><span class="line">[6, 8, 9, 12, 14, 16],</span><br><span class="line">[6, 8, 9, 13, 14, 15], </span><br><span class="line">[6, 8, 10, 11, 14, 16], </span><br><span class="line">[6, 8, 10, 12, 13, 16], </span><br><span class="line">[6, 8, 10, 12, 14, 15], </span><br><span class="line">[6, 8, 11, 12, 13, 15],</span><br><span class="line">[6, 9, 10, 11, 13, 16], </span><br><span class="line">[6, 9, 10, 11, 14, 15], </span><br><span class="line">[6, 9, 10, 12, 13, 15], </span><br><span class="line">[6, 9, 11, 12, 13, 14], </span><br><span class="line">[7, 8, 9, 10, 15, 16], </span><br><span class="line">[7, 8, 9, 11, 14, 16],</span><br><span class="line">[7, 8, 9, 12, 13, 16], </span><br><span class="line">[7, 8, 9, 12, 14, 15], </span><br><span class="line">[7, 8, 10, 11, 13, 16],</span><br><span class="line">[7, 8, 10, 11, 14, 15], </span><br><span class="line">[7, 8, 10, 12, 13, 15], </span><br><span class="line">[7, 8, 11, 12, 13, 14], </span><br><span class="line">[7, 9, 10, 11, 12, 16], </span><br><span class="line">[7, 9, 10, 11, 13, 15], </span><br><span class="line">[7, 9, 10, 12, 13, 14], </span><br><span class="line">[8, 9, 10, 11, 12, 15], </span><br><span class="line">[8, 9, 10, 11, 13, 14]</span><br><span class="line"></span><br><span class="line">一共有117种可能</span><br></pre></td></tr></table></figure><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p><strong>密钥：</strong>4 2 3 6 5 1 或 4 2 6 3 5 1</p><p>反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">08048da9 &lt;phase_6&gt;:</span><br><span class="line"> 8048da9:56                   push   %esi</span><br><span class="line"> 8048daa:53                   push   %ebx</span><br><span class="line"> 8048dab:83 ec 44             sub    $0x44,%esp</span><br><span class="line"> 8048dae:8d 44 24 10          lea    0x10(%esp),%eax</span><br><span class="line"> 8048db2:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048db6:8b 44 24 50          mov    0x50(%esp),%eax</span><br><span class="line"> 8048dba:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048dbd:e8 69 04 00 00       call   804922b &lt;read_six_numbers&gt;</span><br><span class="line"> 8048dc2:be 00 00 00 00       mov    $0x0,%esi/* </span><br><span class="line"> 8048dc7:8b 44 b4 10          mov    0x10(%esp,%esi,4),%eax</span><br><span class="line"> 8048dcb:83 e8 01             sub    $0x1,%eax</span><br><span class="line"> 8048dce:83 f8 05             cmp    $0x5,%eax </span><br><span class="line"> 8048dd1:76 05                jbe    8048dd8 &lt;phase_6+0x2f&gt;</span><br><span class="line"> 8048dd3:e8 1e 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd8:83 c6 01             add    $0x1,%esi</span><br><span class="line"> 8048ddb:83 fe 06             cmp    $0x6,%esi</span><br><span class="line"> 8048dde:74 33                je     8048e13 &lt;phase_6+0x6a&gt; </span><br><span class="line"> 8048de0:89 f3                mov    %esi,%ebx</span><br><span class="line"> 8048de2:8b 44 9c 10          mov    0x10(%esp,%ebx,4),%eax6个数字都要小于等于6，并且大于等于1</span><br><span class="line"> 8048de6:39 44 b4 0c          cmp    %eax,0xc(%esp,%esi,4) 且不能两两相等</span><br><span class="line"> 8048dea:75 05                jne    8048df1 &lt;phase_6+0x48&gt;否则炸弹爆炸</span><br><span class="line"> 8048dec:e8 05 03 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048df1:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8048df4:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line"> 8048df7:7e e9                jle    8048de2 &lt;phase_6+0x39&gt; </span><br><span class="line"> 8048df9:eb cc                jmp    8048dc7 &lt;phase_6+0x1e&gt;*/</span><br><span class="line"> 8048dfb:8b 52 08             mov    0x8(%edx),%edx</span><br><span class="line"> 8048dfe:83 c0 01             add    $0x1,%eax</span><br><span class="line"> 8048e01:39 c8                cmp    %ecx,%eax//使ecx的值与输入值相等</span><br><span class="line"> 8048e03:75 f6                jne    8048dfb &lt;phase_6+0x52&gt;</span><br><span class="line"> 8048e05:89 54 b4 28          mov    %edx,0x28(%esp,%esi,4)</span><br><span class="line"> 8048e09:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8048e0c:83 fb 06             cmp    $0x6,%ebx</span><br><span class="line"> 8048e0f:75 07                jne    8048e18 &lt;phase_6+0x6f&gt;</span><br><span class="line"> 8048e11:eb 1c                jmp    8048e2f &lt;phase_6+0x86&gt;</span><br><span class="line"> 8048e13:bb 00 00 00 00       mov    $0x0,%ebx</span><br><span class="line"> 8048e18:89 de                mov    %ebx,%esi</span><br><span class="line"> 8048e1a:8b 4c 9c 10          mov    0x10(%esp,%ebx,4),%ecx</span><br><span class="line"> 8048e1e:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 8048e23:ba 3c c1 04 08       mov    $0x804c13c,%edx</span><br><span class="line"> 8048e28:83 f9 01             cmp    $0x1,%ecx //输入的数字大于 1 发生跳转</span><br><span class="line"> 8048e2b:7f ce                jg     8048dfb &lt;phase_6+0x52&gt;</span><br><span class="line"> 8048e2d:eb d6                jmp    8048e05 &lt;phase_6+0x5c&gt;</span><br><span class="line"> 8048e2f:8b 5c 24 28          mov    0x28(%esp),%ebx j0 -&gt; ebx</span><br><span class="line"> 8048e33:8b 44 24 2c          mov    0x2c(%esp),%eaxj1 -&gt; eax</span><br><span class="line"> 8048e37:89 43 08             mov    %eax,0x8(%ebx)j1 -&gt; ebx+8</span><br><span class="line"> 8048e3a:8b 54 24 30          mov    0x30(%esp),%edxj2 -&gt; edx</span><br><span class="line"> 8048e3e:89 50 08             mov    %edx,0x8(%eax)j2 -&gt; eax+8</span><br><span class="line"> 8048e41:8b 44 24 34          mov    0x34(%esp),%eaxj3 -&gt; eax</span><br><span class="line"> 8048e45:89 42 08             mov    %eax,0x8(%edx)j3 -&gt; edx+8</span><br><span class="line"> 8048e48:8b 54 24 38          mov    0x38(%esp),%edxj4 -&gt; edx</span><br><span class="line"> 8048e4c:89 50 08             mov    %edx,0x8(%eax)j4 -&gt; eax+8</span><br><span class="line"> 8048e4f:8b 44 24 3c          mov    0x3c(%esp),%eaxj5 -&gt; eax</span><br><span class="line"> 8048e53:89 42 08             mov    %eax,0x8(%edx)j5 -&gt; edx+8</span><br><span class="line"> 8048e56:c7 40 08 00 00 00 00 movl   $0x0,0x8(%eax)0 -&gt; eax+8</span><br><span class="line"> 8048e5d:be 05 00 00 00       mov    $0x5,%esiesi = 5</span><br><span class="line"> 8048e62:8b 43 08             mov    0x8(%ebx),%eaxeax = j1</span><br><span class="line"> 8048e65:8b 10                mov    (%eax),%edx </span><br><span class="line"> 8048e67:39 13                cmp    %edx,(%ebx)j1与j0比较 </span><br><span class="line"> 8048e69:7d 05                jge    8048e70 &lt;phase_6+0xc7&gt;</span><br><span class="line"> 8048e6b:e8 86 02 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e70:8b 5b 08             mov    0x8(%ebx),%ebx</span><br><span class="line"> 8048e73:83 ee 01             sub    $0x1,%esi</span><br><span class="line"> 8048e76:75 ea                jne    8048e62 &lt;phase_6+0xb9&gt;</span><br><span class="line"> 8048e78:83 c4 44             add    $0x44,%esp</span><br><span class="line"> 8048e7b:5b                   pop    %ebx</span><br><span class="line"> 8048e7c:5e                   pop    %esi</span><br><span class="line"> 8048e7d:c3                   ret </span><br></pre></td></tr></table></figure><p>由第 9 行代码可以得出我们一共输入 6 个整型数字。分析后面的代码可得，输入的 6 个值的取值范围为[1, 6]，且不能两两相等。第 28 ~ 44 行是一个循环结构，用于比较当前数字与后一个数字的大小，前一个数一定不能小于后一个数，否则炸弹直接爆炸。其中要进行比较的数组为以 <code>0x804c13c</code> 为首地址的数组。</p><p>但是在输出该地址的内容后，发现这并不是一个数组，而是一个结构体，每个结构体中有3个元素，一个记录数值、一个记录node编号，一个存放下一个node的地址（可以把node理解为链表），共占12个字节。</p><p>存储node的方式是：按照读入的6个数（假定为a[i]），将编号为a[i]的node存储到第i个位置。然后从栈帧中的存储的第一个node开始，每个node与其后一个node中的数值进行比较，若后大于前，则会引爆炸弹。以下是打印出的 6 个node的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x804c13c &lt;node1&gt;:    99      1       134529352       </span><br><span class="line">0x804c148 &lt;node2&gt;:    476  2       134529364       </span><br><span class="line">0x804c154 &lt;node3&gt;:    208     3  134529376       </span><br><span class="line">0x804c160 &lt;node4&gt;:    740     4       134529388  </span><br><span class="line">0x804c16c &lt;node5&gt;:  135     5       134529400       </span><br><span class="line">0x804c178 &lt;node6&gt;:    208  6                   </span><br></pre></td></tr></table></figure><p>由此可以的出密钥应该是 4 2 3 6 5 1 或 4 2 6 3 5 1（因为6 与 3中的值是相等的，所以可以调换顺序）。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>至此，我们以及得出了六个关卡的正确密钥，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The moon unit will be divided into two divisions.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">4 0</span><br><span class="line">11 18</span><br><span class="line">bcejno</span><br><span class="line">4 2 3 6 5 1</span><br></pre></td></tr></table></figure><p>输入以上六个密钥，便可拆除炸弹。</p><p>但是，不知道你有没有注意到在该程序的源代码中的结尾处有一行注释，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span><br><span class="line">     * something they overlooked?  Mua ha ha ha ha! </span><br><span class="line">     哇，他们得到了它!  但是不是有什么东西......不见了？ 也许他们忽略了什么？ Mua ha ha ha!</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><p>这就十分可疑，再结合源代码中每个关卡在输出正确答案提示之前都调用了同一个函数——<code>phase_defused();</code>，下面的这个部分就是探寻隐藏关卡的部分。</p><h3 id="隐藏关卡"><a href="#隐藏关卡" class="headerlink" title="隐藏关卡"></a>隐藏关卡</h3><p><strong>密钥：</strong> 107</p><p><code>phase_defused</code>函数的反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">0804927b &lt;phase_defused&gt;:</span><br><span class="line"> 804927b:81 ec 8c 00 00 00    sub    $0x8c,%esp</span><br><span class="line"> 8049281:65 a1 14 00 00 00    mov    %gs:0x14,%eax</span><br><span class="line"> 8049287:89 44 24 7c          mov    %eax,0x7c(%esp)</span><br><span class="line"> 804928b:31 c0                xor    %eax,%eax</span><br><span class="line"> 804928d:83 3d cc c3 04 08 06 cmpl   $0x6,0x804c3cc //该地址处存储的是通过的个数，如果没有全部通过，则不会进入隐藏关卡</span><br><span class="line"> 8049294:75 72                jne    8049308 &lt;phase_defused+0x8d&gt;</span><br><span class="line"> 8049296:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line"> 804929a:89 44 24 10          mov    %eax,0x10(%esp)//第一个参数</span><br><span class="line"> 804929e:8d 44 24 28          lea    0x28(%esp),%eax</span><br><span class="line"> 80492a2:89 44 24 0c          mov    %eax,0xc(%esp)//第二个参数</span><br><span class="line"> 80492a6:8d 44 24 24          lea    0x24(%esp),%eax</span><br><span class="line"> 80492aa:89 44 24 08          mov    %eax,0x8(%esp)//第三个参数</span><br><span class="line"> 80492ae:c7 44 24 04 e9 a3 04 movl   $0x804a3e9,0x4(%esp) //0x804a3e9 &quot;%d %d %s&quot;,输入参数为两个整形个一个字符串，只有第三关和第四关符合条件，测试后应该是在第四关输入特殊字符串，进入隐藏关卡</span><br><span class="line"> 80492b5:08 </span><br><span class="line"> 80492b6:c7 04 24 d0 c4 04 08 movl   $0x804c4d0,(%esp)</span><br><span class="line"> 80492bd:e8 ae f5 ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 80492c2:83 f8 03             cmp    $0x3,%eax//输入参数一定要是3个，否则退出函数</span><br><span class="line"> 80492c5:75 35                jne    80492fc &lt;phase_defused+0x81&gt;</span><br><span class="line"> 80492c7:c7 44 24 04 f2 a3 04 movl   $0x804a3f2,0x4(%esp) //0x804a3f2:      &quot;DrEvil&quot;</span><br><span class="line"> 80492ce:08 </span><br><span class="line"> 80492cf:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line"> 80492d3:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 80492d6:e8 09 fd ff ff       call   8048fe4 &lt;strings_not_equal&gt;//调用比较字符串的函数，说明该地址处的字符串有关键作用</span><br><span class="line"> 80492db:85 c0                test   %eax,%eax//eax为0表示两个字符串相等，否则不相等</span><br><span class="line"> 80492dd:75 1d                jne    80492fc &lt;phase_defused+0x81&gt;</span><br><span class="line"> 80492df:c7 04 24 b8 a2 04 08 movl   $0x804a2b8,(%esp) //0x804a2b8:      &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line"> 80492e6:e8 15 f5 ff ff       call   8048800 &lt;puts@plt&gt; //输出字符串</span><br><span class="line"> 80492eb:c7 04 24 e0 a2 04 08 movl   $0x804a2e0,(%esp) //0x804a2e0:      &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line"> 80492f2:e8 09 f5 ff ff       call   8048800 &lt;puts@plt&gt; //输出字符串</span><br><span class="line"> 80492f7:e8 d3 fb ff ff       call   8048ecf &lt;secret_phase&gt; //进入隐藏关卡</span><br><span class="line"> 80492fc:c7 04 24 18 a3 04 08 movl   $0x804a318,(%esp) //0x804a318:      &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line"> 8049303:e8 f8 f4 ff ff       call   8048800 &lt;puts@plt&gt;//输出字符串</span><br><span class="line"> 8049308:8b 44 24 7c          mov    0x7c(%esp),%eax</span><br><span class="line"> 804930c:65 33 05 14 00 00 00 xor    %gs:0x14,%eax</span><br><span class="line"> 8049313:74 05                je     804931a &lt;phase_defused+0x9f&gt;</span><br><span class="line"> 8049315:e8 b6 f4 ff ff       call   80487d0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> 804931a:81 c4 8c 00 00 00    add    $0x8c,%esp</span><br><span class="line"> 8049320:c3                   ret    </span><br><span class="line"> 8049321:90                   nop</span><br><span class="line"> 8049322:90                   nop</span><br><span class="line"> 8049323:90                   nop</span><br><span class="line"> 8049324:90                   nop</span><br><span class="line"> 8049325:90                   nop</span><br><span class="line"> 8049326:90                   nop</span><br><span class="line"> 8049327:90                   nop</span><br><span class="line"> 8049328:90                   nop</span><br><span class="line"> 8049329:90                   nop</span><br><span class="line"> 804932a:90                   nop</span><br><span class="line"> 804932b:90                   nop</span><br><span class="line"> 804932c:90                   nop</span><br><span class="line"> 804932d:90                   nop</span><br><span class="line"> 804932e:90                   nop</span><br><span class="line"> 804932f:90                   nop</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>在找到 <code>phase_defused</code> 函数的反汇编之后，不难找到几个有助于我们分析关键部分，如下：</p><ul><li>第 6 行将地址 <code>0x804c3cc</code> 处的值与 6 作比较；</li><li>第 8 ~ 18 行调用 <code>__isoc99_sscanf@plt</code> 函数，其中第 14 和第 18 行为分析的关键点；</li><li>第 20 行将 <code>0x804a3f2</code> 地址处的值传给寄存器；</li><li>第 24 行调用比较字符串函数；</li><li>第 27 ~ 30 行输出两次地址中的值；</li><li>第 31 行调用名为 <code>secret_phase</code> 的函数；</li><li>第 32 ~ 33 行输出地址 <code>0x804a318</code> 中的值。</li></ul><p>根据以上关键点，我们可以得出以下结论：</p><ul><li><p>第 6 行， 地址 <code>0x804c3cc</code> 中的值应该是当前通过的数目，只有通关数为 6 时才迈出了进入隐藏关卡的第一步；</p></li><li><p>第 8 ~ 18 行，调用输入函数，且由第 18 行得知输入的参数的个数应该是 3 个；由第 14 行可知，三个参数的类型为前两个是整形，第三个是字符串类型。</p><p>因为一共要输入两个整数和一个字符串，且每次在解决一个关卡后都会调用该函数。由此可得，前两个整数应该是某一个关卡的密钥。而在我们得出得答案中，只有第 3 关和第 4 关的密钥是两个整型数字，经过测试后，隐藏关卡的实际入口在第4关</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418194052316.png" alt="image-20230418194052316"></p></li><li><p>输出第 20 行地址处的值为：<code>DrEvil</code> ；</p></li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418194200376.png" alt="image-20230418194200376"></p><ul><li>比较函数用于将第 20 行地址处的字符串与输入的第三个参数作比较，根据后面两行的代码可以分析出当输入值与设置值不相等时，会直接打印祝贺信息并退出该函数，只有当两个字符串相等时，我们操迈出了进入隐藏关卡的第二步。</li><li>第 27 ~ 30 行，一共输出了两个地址存储的值，打印出来后发现并没有什么实质价值，只是成功输入字符串的隐藏值。</li></ul><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418195114104.png" alt="image-20230418195114104"></p><ul><li>第 31 行，被调用的函数就是隐藏关卡，反汇编代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">08048ecf &lt;secret_phase&gt;:</span><br><span class="line"> 8048ecf:53                   push   %ebx</span><br><span class="line"> 8048ed0:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048ed3:e8 45 02 00 00       call   804911d &lt;read_line&gt;</span><br><span class="line"> 8048ed8:c7 44 24 08 0a 00 00 movl   $0xa,0x8(%esp) //第一个参数10</span><br><span class="line"> 8048edf:00 </span><br><span class="line"> 8048ee0:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp) //第二个参数0</span><br><span class="line"> 8048ee7:00 </span><br><span class="line"> 8048ee8:89 04 24             mov    %eax,(%esp) //第三个参数为输入值</span><br><span class="line"> 8048eeb:e8 f0 f9 ff ff       call   80488e0 &lt;strtol@plt&gt;//转化为十进制数</span><br><span class="line"> 8048ef0:89 c3                mov    %eax,%ebx</span><br><span class="line"> 8048ef2:8d 40 ff             lea    -0x1(%eax),%eax</span><br><span class="line"> 8048ef5:3d e8 03 00 00       cmp    $0x3e8,%eax</span><br><span class="line"> 8048efa:76 05                jbe    8048f01 &lt;secret_phase+0x32&gt; //输入值-1 小于等于 0x3e8的话跳转，炸弹不爆炸</span><br><span class="line"> 8048efc:e8 f5 01 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f01:89 5c 24 04          mov    %ebx,0x4(%esp)</span><br><span class="line"> 8048f05:c7 04 24 88 c0 04 08 movl   $0x804c088,(%esp)</span><br><span class="line"> 8048f0c:e8 6d ff ff ff       call   8048e7e &lt;fun7&gt;</span><br><span class="line"> 8048f11:83 f8 03             cmp    $0x3,%eax //函数fun7的返回值与 3 作比较，等于 3 炸弹不爆炸</span><br><span class="line"> 8048f14:74 05                je     8048f1b &lt;secret_phase+0x4c&gt;</span><br><span class="line"> 8048f16:e8 db 01 00 00       call   80490f6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f1b:c7 04 24 f8 a1 04 08 movl   $0x804a1f8,(%esp) //0x804a1f8:      &quot;Wow! You&#x27;ve defused the secret stage!&quot;</span><br><span class="line"> 8048f22:e8 d9 f8 ff ff       call   8048800 &lt;puts@plt&gt;//输出字符串</span><br><span class="line"> 8048f27:e8 4f 03 00 00       call   804927b &lt;phase_defused&gt; //返回调用函数</span><br><span class="line"> 8048f2c:83 c4 18             add    $0x18,%esp</span><br><span class="line"> 8048f2f:5b                   pop    %ebx</span><br><span class="line"> 8048f30:c3                   ret    </span><br><span class="line"> 8048f31:90                   nop</span><br><span class="line"> 8048f32:90                   nop</span><br><span class="line"> 8048f33:90                   nop</span><br><span class="line"> 8048f34:90                   nop</span><br><span class="line"> 8048f35:90                   nop</span><br><span class="line"> 8048f36:90                   nop</span><br><span class="line"> 8048f37:90                   nop</span><br><span class="line"> 8048f38:90                   nop</span><br><span class="line"> 8048f39:90                   nop</span><br><span class="line"> 8048f3a:90                   nop</span><br><span class="line"> 8048f3b:90                   nop</span><br><span class="line"> 8048f3c:90                   nop</span><br><span class="line"> 8048f3d:90                   nop</span><br><span class="line"> 8048f3e:90                   nop</span><br><span class="line"> 8048f3f:90                   nop</span><br></pre></td></tr></table></figure><p>进入secret_phase，函数先读取我们输入的密钥，然后调用了c语言的strtol函数，这个函数将字符串转为长整型数，其中参数0xa意味着将其转为十进制。接下来函数会比较经转换后的数自减1后与0x3e8（十进制为1000）的无符号数大小，这意味着我们输入的数必须在[1, 1001]中。接着，函数会调用一个递归函数func7，参数为0x804c088和我们输入的数，func7的伪代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func7</span><span class="params">(<span class="type">int</span>* k, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="type">int</span> kn = *k;</span><br><span class="line">       <span class="keyword">if</span>(kn == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(kn &lt; n) <span class="keyword">return</span> <span class="number">2</span>*func7(k+<span class="number">2</span>, n) + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*func7(k+<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又由以下两个指令知，<code>func7(, 我们输入的数)</code>的返回值必须为3，否则将引爆炸弹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8048ef2: 83 f8 03              cmp    $0x3,%eax</span><br><span class="line">8048ef5: 74 05                 je     8048efc &lt;secret_phase+0x4c&gt;</span><br></pre></td></tr></table></figure><p>观察内存中地址为0x804c088的内容，是一棵二叉树：第一个地址存储数据，第二、三个地址存储下子结点的地址。于是我们只要分析func7的行为，并根据0x804c088中的内容，即可确定要输入的数。</p><p>首先，函数要求func7最终返回3。要构造一个3，根据func7的特性，可以这样构造$2\cdot(2\cdot(0+1))+1$ ，这意味着，最后一次要返回 0，倒数第二次（或第二次）要返回 $2 \cdot func7(k+2, n) + 1$，倒数第三次（或第一次）要返回 $2 \cdot func7(k+2, n) + 1$ 。或者说，要返回的值是二叉树查找时比较的次数。要满足这样的关系，假如我们把第1~3次比较的数设为k1、k2、k3，那么，我们输入的数n要满足的条件是n &gt; k1且n &gt; k2且n == k3。要找到k3，查找0x804c088处的内存即可，经查找，为0x6b，转换为十进制为107，即为密钥。</p><p>打印 <code>0x804c088</code> 地址处的值可得：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418201622434.png" alt="image-20230418201622434"></p><p>所以，隐藏关卡的密钥为 <code>107</code> 。</p><p>下图为实验结果：</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230418205634637.png" alt="image-20230418205634637"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写到此处，我们的炸弹也就拆完了。在拆除炸弹之后，有关于x86-64的汇编指令以及gdb的一些调试方法我们都已经有所了解。总的来说，这个实验还是十分有趣的，通过剧情让我们了解汇编指令，值得自己独立研究一下，会有不小的收获。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bomb-Lab&quot;&gt;&lt;a href=&quot;#Bomb-Lab&quot; class=&quot;headerlink&quot; title=&quot;Bomb Lab&quot;&gt;&lt;/a&gt;Bomb Lab&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="《深入理解计算机系统》课程实验" scheme="http://example.com/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>小孔成像模型——坐标系转换</title>
    <link href="http://example.com/2023/03/28/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/03/28/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-03-28T14:37:07.000Z</published>
    <updated>2024-03-01T09:04:51.689Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。</p><p>本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。</p><h1 id="一、小孔成像模型与坐标系"><a href="#一、小孔成像模型与坐标系" class="headerlink" title="一、小孔成像模型与坐标系"></a>一、小孔成像模型与坐标系</h1><p>相机的拍摄过程可以简化为小孔成像的一种形式，利用这种形式很容易就能得到相机模型中的数学表达式。通过相机的成像方式及其数学表达式，可以看出三维场景和图像中每一个像素之间的映射关系。</p><p>相机的模型结构如下图所示，为了使其简单化，把成像的平面置于小孔前面，并且拍摄出来的图像也应该是正立的。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230328224246218.png" alt="image-20230328224246218"></p><p>在小孔成像模型中，场景从三维空间投影到图片上的整个过程可以理解为<strong>三个步骤</strong>和<strong>四个坐标系</strong>。</p><p>具体流程如下：从世界坐标系转换到相机坐标系，再从相机坐标系转换到图像坐标系，最后从图像坐标系转换到像素坐标系。</p><p>四个坐标系的定义如下：</p><ul><li><strong>世界坐标系：</strong>一个客观的绝对存在，世界坐标系都需要<strong>预先确定</strong>，指定其<strong>原点</strong>和<strong>方向</strong>。在定义好的世界坐标系中可以放置任何物体。世界坐标系下的坐标通常用（Xw,Yw,Zw）来进行表示。</li><li><strong>相机坐标系：</strong>目前通用的定义方法是以一台<strong>相机的光心或者主点</strong>作为坐标系的<strong>原点。X轴和Y轴</strong>在拍摄画面时分别平行于图像的横轴和纵轴，<strong>Z轴</strong>为相机的焦距所指方向。相机坐标系下的坐标通常使用符号（Xc,Yc,Zc）来进行表示。</li><li><strong>图像坐标系：</strong>根据图像进行定义，以图象中心作为<strong>原点，</strong>X 轴和 Y 轴与相机的 X 轴和 Y 轴的方向保持一致。图像坐标是使用米、厘米等物理学单位来表示的坐标系。图像坐标系只有两个维度，没有Z轴。图像坐标系下通常使用符号（x, y）来表示。</li><li><strong>像素坐标系：</strong>以像素为单位的坐标系。像素坐标系也是二维坐标系，其 X 轴和 Y 轴的方向与图像坐标系一致。坐标原点位于二维图像的左上角。像素通用的表示形式为一个方块或者矩形，每个像素里面存放的信息为像素的强度和灰度值。</li></ul><h1 id="二、坐标系的转换"><a href="#二、坐标系的转换" class="headerlink" title="二、坐标系的转换"></a>二、坐标系的转换</h1><p>在第一小节中，已经定义了各个坐标系及其表示形式，在该小节中，将通过数学模型的形式，推导小孔成像的过程。整个过程分为三个步骤，其中<strong>世界坐标系</strong>到<strong>相机坐标系</strong>的变化过程涉及相机的<strong>外参</strong>，从<strong>相机的坐标系</strong>转换到<strong>图像坐标系</strong>再转换到像素坐标系的过程中都涉及到了相机的<strong>内参</strong>的使用。该小节通过相机内参以及外参的形式推导相机的投影过程。</p><h2 id="1-相机外参"><a href="#1-相机外参" class="headerlink" title="(1) 相机外参"></a>(1) 相机外参</h2><p>世界坐标系（Xw,Yw,Zw）与相机坐标系（Xc,Yc,Zc）的转换。</p><p>假设点 <strong>P </strong>是一个三维空间的点，其在相机坐标系下的位置为 <strong>Pc</strong> ，在世界坐标系下的位置为 <strong>Pw </strong>。Pw 和 Pc 可以通过一个变换矩阵相互转换，该变换矩阵可以细分为旋转矩阵(<strong>R</strong>)和平移矩阵(<strong>t</strong>).其数学表达式为：</p><script type="math/tex; mode=display">P_c=RP_w+t</script><p>其中 <strong>R</strong> 有三个自由度，是一个 3 * 3 的矩阵，表示相机在世界坐标系下的旋转。<strong>t</strong> 表示相机的原点（或者说相机开始时的坐标系的原点）相对于世界坐标系的变化，是一个 3 * 1的矩阵。上式可以展开为：</p><script type="math/tex; mode=display">\begin{bmatrix}X_c \\Y_c \\Z_c \\\end{bmatrix}=\begin{bmatrix}R_{11} & R_{12} & R_{13} \\R_{21} & R_{22} & R_{23} \\R_{31} & R_{32} & R_{33} \\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\\end{bmatrix}+\begin{bmatrix}t_1 \\t_2 \\t_3 \\\end{bmatrix}</script><p>其齐次方程表的形式可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}=\begin{bmatrix}R_{11} & R_{12} & R_{13} & t_1\\R_{21} & R_{22} & R_{23} & t_2\\R_{31} & R_{32} & R_{33} & t_3\\0 & 0 & 0 & 1 \\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\1 \\\end{bmatrix}</script><p>可以简化为：</p><script type="math/tex; mode=display">\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}=\begin{bmatrix}\mathbf{R} & \mathbf{t} \\\mathbf{0} & 1\\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\1 \\\end{bmatrix}</script><h2 id="2-相机内参"><a href="#2-相机内参" class="headerlink" title="(2) 相机内参"></a>(2) 相机内参</h2><p>相机坐标系(Xc, Yc, Zc)与图像坐标系(x, y)的转换：相机坐标系是一个三维坐标系，图像坐标系是二维坐标系，三维到二维有一个降维的过程，主要是丢掉了深度这一维度，坐标向量由三维转为二维。</p><p>如下图，相机坐标系下存在任一点<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933146776-b2fe3d6e-64aa-4cab-88f8-705b3a9fb774.png#averageHue=%23efeae5&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u5179f4c5&amp;originHeight=19&amp;originWidth=115&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua892299b-1bd1-4690-9d5d-c8a2f843b10&amp;title=" alt="">，图像上的坐标点<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933166386-71ef4c8e-e578-4f90-9760-798c4ac6f931.png#averageHue=%23f1ece6&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=ubed80338&amp;originHeight=19&amp;originWidth=74&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udd7cebd1-a63c-4dfb-8539-6a039ca807a&amp;title=" alt="">与该三维点对应。由于两个坐标系的 X轴、Y轴一致，因此可以增加一个维度 f，形成相机坐标系的坐标<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933257046-1968546c-8804-4c5b-9182-d7a23cf12a8a.png#averageHue=%23f1ece7&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u2cf93ccd&amp;originHeight=19&amp;originWidth=89&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf206efb3-1a8f-419a-bef2-00a905328c7&amp;title=" alt="">，其中 f 是相机的焦距。</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230329001037658.png" alt="image-20230329001037658"></p><p>由相似三角形，可得以下公式：</p><script type="math/tex; mode=display">\frac{z_c}{f} = \frac{x_c}{f} = \frac{y_c}{f}</script><p>整理可得：</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}         x=f\frac{x_c}{z_c} \\         y=f\frac{y_c}{z_c} \\         z=f \\\end{array}\right.</script><p>转化为齐次坐标系下为：</p><script type="math/tex; mode=display">Z_c·\begin{bmatrix}x \\y \\1 \\\end{bmatrix}=\begin{bmatrix}f & 0 & 0 & 0\\0 & f & 0 & 0\\0 & 0 & 1 & 0\\\end{bmatrix}·\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}</script><p>至此推导出了相机坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933429538-567a3c43-bd16-423e-bd02-3d9a88f21858.png#averageHue=%23f3ece5&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u96cfe4a3&amp;originHeight=19&amp;originWidth=71&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u367f2754-ae6e-4ec8-a638-698f9b3ee07&amp;title=" alt=""> 与图像坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933430100-c27dca7d-3b2a-44b2-84af-744283fec0d4.png#averageHue=%23f7f1e9&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u604cffd6&amp;originHeight=19&amp;originWidth=37&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2e0543dc-2fbe-4c79-b46d-0b928187d72&amp;title=" alt=""> 的转换数学模型。</p><p>图像坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933491062-13bc7d4f-29c6-4ab2-b6ee-ac3d3c4dd186.png#averageHue=%23f7f1e9&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u01d320a8&amp;originHeight=19&amp;originWidth=37&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9cbc0ff2-554b-4e91-8233-a1ae3e89184&amp;title=" alt=""> 与像素坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/29628887/1679933491053-986b9369-8da2-40be-aaa4-621c3a68362f.png#averageHue=%23f7f0e8&amp;clientId=ua7ff77f5-2502-4&amp;from=paste&amp;id=u12316738&amp;originHeight=19&amp;originWidth=38&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8a74610e-7426-4bbf-81be-b7036151baf&amp;title=" alt=""> 的转换：这两个坐标系最核心的区别在于其单位不一致。</p><p>如下图：O为像素坐标系原点，O1为图像坐标系原点</p><p><img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/e9026b387f404269b42096669b62dd56.png" alt="img"></p><p>假设<strong>(u~0~, v~0~)</strong>为像素坐标系下的坐标，表示整个图像的中心。像素的表示形式通常为矩形 或是长方形，设像素的长宽分别为dx 、dy 。有对应关系可得：</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}         u=\frac{x}{dx}+u_0\\         v=\frac{y}{dy}+v_0 \\\end{array}\right.</script><p>转换到齐次坐标系得：</p><script type="math/tex; mode=display">\begin{bmatrix}u \\v \\1 \\\end{bmatrix}=\begin{bmatrix}\frac{1}{dx} & 0 & u_0 \\0 & \frac{1}{dy} & v_0 \\0 & 0 & 0 \\\end{bmatrix}\begin{bmatrix}x \\y \\1 \\\end{bmatrix}</script><p>到此为之，得到了图像坐标系（x, y）到像素坐标系（u, v）的转换的数学模型。</p><p>结合（7）、（9）得到一个三维空间中的点从相机坐标系到像素坐标系的整个投影过程，其数学表达式如下：</p><script type="math/tex; mode=display">Z_c·\begin{bmatrix}u \\v \\1 \\\end{bmatrix}=\begin{bmatrix}f_x & 0 & u_0 & 0\\0 & f_y & v_0 & 0\\0 & 0 & 1 & 0\\\end{bmatrix}·\begin{bmatrix}X_c \\Y_c \\Z_c \\1 \\\end{bmatrix}</script><p>其中<img src="https://raw.githubusercontent.com/zxh3032/save-image/masin/image-20230329002607626.png" alt="image-20230329002607626">被称为相机的内参矩阵，用<strong>K</strong>表示。</p><p>内参矩阵 <strong>K</strong> 有4个未知的数据，这四个数据与相机的构造相关。$f_x, f_y$ 为 $\frac{f}{dx}$, $\frac{f}{dy}$ 的简写形式，<strong>f</strong> 表示相机的焦距，$dx,dy$ 是单位像素的长和宽。$u_0, v_o$ 是像素坐标系下图像中间未知的坐标。</p><h2 id="（3-内外参数组合"><a href="#（3-内外参数组合" class="headerlink" title="（3) 内外参数组合"></a>（3) 内外参数组合</h2><p>通过相机的内参和外参，可以将相机模型中的四个坐标系之间的变换全部联系起来，其数学形式为：</p><script type="math/tex; mode=display">Z_c·\begin{bmatrix}u \\v \\1 \\\end{bmatrix}=\begin{bmatrix}f_x & 0 & u_0 & 0\\0 & f_y & v_0 & 0\\0 & 0 & 1 & 0\\\end{bmatrix}\begin{bmatrix}\mathbf{R} & \mathbf{t} \\\mathbf{0} & 1\\\end{bmatrix}\begin{bmatrix}X_w \\Y_w \\Z_w \\1 \\\end{bmatrix}</script><h1 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h1><p>主要参考：<a href="https://blog.csdn.net/TFZ941214/article/details/121235284">https://blog.csdn.net/TFZ941214/article/details/121235284</a></p><p>关于计算摄影学：<a href="https://zhuanlan.zhihu.com/p/570452119">https://zhuanlan.zhihu.com/p/570452119</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。&lt;/p&gt;
&lt;p&gt;本文主要记录在三维空间的物体转换为二维图像的过程，即相机的投影过程。&lt;/p&gt;
&lt;h1 id=&quot;一、小孔成像模型与坐标系&quot;&gt;&lt;a href=&quot;#一、小孔成像模型与坐标系&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="数字图像处理" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
</feed>
